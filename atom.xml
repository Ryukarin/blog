<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
  <id>https://vuepress-theme-hope-demo.mrhope.site/blog/</id>
  <title>KARIN</title>
  <subtitle>KARIN的学习笔记</subtitle>
  <author>
    <name>karin</name>
  </author>
  <updated>2022-01-27T04:22:12.906Z</updated>
  <generator>@mr-hope/vuepress-plugin-feed</generator>
  <link rel="self" href="https://vuepress-theme-hope-demo.mrhope.site/blog/atom.xml"/>
  <link rel="alternate" href="https://vuepress-theme-hope-demo.mrhope.site/blog/"/>
  <category term="使用指南"/>
  <contributor>
    <name>karin</name>
  </contributor>
  <entry>
    <title type="html">FTP笔记</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/IT/FTP/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/IT/FTP/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="ftp-介绍"> FTP 介绍</h2>
<p>FTP（File Transfer Protocol，文件传输协议） 是 TCP/IP 协议组中的协议之一。FTP 协议包括两个组成部分，其一为 FTP 服务器，其二为 FTP 客户端。其中 FTP 服务器用来存储文件，用户可以使用 FTP 客户端通过 FTP 协议访问位于 FTP 服务器上的资源。在开发网站的时候，通常利用 FTP 协议把网页或程序传到 Web 服务器上。此外，由于 FTP 传输效率非常高，在网络上传输大的文件时，一般也采用该协议。</p>
<p>默认情况下 FTP 协议使用 TCP 端口中的 20 和 21 这两个端口，其中 20 用于传输数据，21 用于传输控制信息。但是，是否使用 20 作为传输数据的端口与 FTP 使用的传输模式有关，如果采用主动模式，那么数据传输端口就是 20；如果采用被动模式，则具体最终使用哪个端口要服务器端和客户端协商决定。</p>
<h2 id="如何登录-ftp"> 如何登录 FTP</h2>
<ol>
<li>在命令行下输入<code>ftp IP地址</code>，按照提示输入用户名和密码，完成登陆</li>
</ol>
<div><pre><code>C:<span>\</span>Users<span>\</span>liujialin<span>></span>ftp <span>192.168</span>.3.1	<span>#直接 ftp IP地址</span>
连接到 <span>192.168</span>.3.1。
<span>220</span> <span>(</span>vsFTPd <span>3.0</span>.3<span>)</span>
<span>200</span> Always <span>in</span> UTF8 mode.
用户<span>(</span><span>192.168</span>.3.1:<span>(</span>none<span>))</span>: root		<span>#输入用户名</span>
<span>331</span> Please specify the password.
密码:								<span>#输入密码</span>
<span>230</span> Login successful.				<span>#登录成功</span>
ftp<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ol start="2">
<li>直接输入 <code>ftp</code>，进入 ftp 服务后输入 <code>open IP地址</code>，按照提示输入用户名和密码，完成登陆</li>
</ol>
<div><pre><code>C:<span>\</span>Users<span>\</span>liujialin<span>></span>ftp				<span>#输入ftp进入ftp模式</span>
ftp<span>></span> <span>open</span> <span>192.168</span>.3.1				<span>#输入open IP地址</span>
连接到 <span>192.168</span>.3.1。        
<span>220</span> <span>(</span>vsFTPd <span>3.0</span>.3<span>)</span>  
<span>200</span> Always <span>in</span> UTF8 mode.
用户<span>(</span><span>192.168</span>.3.1:<span>(</span>none<span>))</span>: root		<span>#输入用户名</span>
<span>331</span> Please specify the password.
密码:								<span>#输入密码</span>
<span>230</span> Login successful.				<span>#登录成功</span>
ftp<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="ftp-基本命令"> FTP 基本命令</h2>
<p>其实只要说一个命令，常用的基本命令就可以知道了。这个命令就是十万个为什么--- <code>?</code>（没错，该命令就是一个问号，等同 <code>hlep</code> 命令）
直接输入一个 <code>?</code>，就会显示出这些命令；输入 <code>? 命令</code>，就会显示该命令的帮助信息</p>
<div><pre><code>ftp<span>></span> ?
命令可能是缩写的。  命令为:

<span>!</span>               delete          literal         prompt          send
?               debug           <span>ls</span>              put             status
append          <span>dir</span>             mdelete         <span>pwd</span>             trace
ascii           disconnect      mdir            quit            <span>type</span>
bell            get             mget            quote           user
binary          glob            <span>mkdir</span>           recv            verbose
bye             <span>hash</span>            mls             remotehelp
<span>cd</span>              <span>help</span>            mput            <span>rename</span>
close           lcd             <span>open</span>            <span>rmdir</span>
ftp<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>比如这里随便查看几个命令的帮助信息，如下</p>
<div><pre><code>ftp<span>></span> ? ?
?               打印本地帮助信息
ftp<span>></span> ? <span>dir</span>
<span>dir</span>             列出远程目录的内容
ftp<span>></span> ? <span>ls</span>
<span>ls</span>              列出远程目录的内容
ftp<span>></span> ? <span>open</span>
<span>open</span>            连接到远程 FTP
ftp<span>></span> ? lcd
lcd             更改本地工作目录
ftp<span>></span> <span>help</span> bye
bye             终止 <span>ftp</span> 会话并退出
ftp<span>></span> <span>help</span> <span>pwd</span>
<span>pwd</span>             在远程计算机上打印工作目录
ftp<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="常用命令"> 常用命令</h2>
<h3 id="文件或目录操作命令"> 文件或目录操作命令</h3>
<p>一般情况下用户都会被限制目录的访问权限，只可在当前目录下进行操作</p>
<p><code>dir</code>：显示服务器目录和文件列表</p>
<div><pre><code>ftp<span>></span> <span>cd</span> /home
<span>250</span> Directory successfully changed.
ftp<span>></span> <span>dir</span>
<span>200</span> PORT <span>command</span> successful. Consider using PASV.
<span>150</span> Here comes the directory listing.
-rw-r--r--    <span>1</span> <span>0</span>        <span>0</span>         <span>1019904</span> May <span>12</span> <span>12</span>:39 Installing_OMV5_on_Armbian.pdf
-rw-r--r--    <span>1</span> <span>0</span>        <span>0</span>          <span>106026</span> Aug 03  <span>2019</span> breed.bin
drwxr-xr-x    <span>2</span> <span>55</span>       <span>55</span>              <span>0</span> Apr <span>30</span> 03:31 <span>ftp</span>
-rw-r--r--    <span>1</span> <span>0</span>        <span>0</span>         <span>2159147</span> Sep 09  <span>2019</span> 昆仑.epub
-rw-r--r--    <span>1</span> <span>0</span>        <span>0</span>          <span>441798</span> Feb <span>12</span>  <span>2019</span> 流浪地球.epub
<span>226</span> Directory send OK.
ftp: 收到 <span>363</span> 字节，用时 <span>0.01</span>秒 <span>24.20</span>千字节/秒。
ftp<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><code>mkdir</code>：在服务器上创建目录</p>
<div><pre><code>ftp<span>></span> <span>mkdir</span> <span>test</span>
<span>257</span> <span>"/home/test"</span> created
ftp<span>></span> <span>ls</span>
<span>200</span> PORT <span>command</span> successful. Consider using PASV.
<span>150</span> Here comes the directory listing.
<span>ftp</span>
ss.txt
system.png
<span>test</span>                    <span>#新创建的文件夹</span>
<span>226</span> Directory send OK.
ftp: 收到 <span>34</span> 字节，用时 <span>0.01</span>秒 <span>6.80</span>千字节/秒。
ftp<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><code>rmdir</code>：在服务器上删除目录</p>
<div><pre><code>ftp<span>></span> <span>rmdir</span> <span>test</span>
<span>250</span> Remove directory operation successful.
ftp<span>></span> <span>ls</span>
<span>200</span> PORT <span>command</span> successful. Consider using PASV.
<span>150</span> Here comes the directory listing.
<span>ftp</span>
ss.txt
system.png
<span>226</span> Directory send OK.
ftp: 收到 <span>28</span> 字节，用时 <span>0.01</span>秒 <span>5.60</span>千字节/秒。
ftp<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><code>ls</code>：显示服务器简易的文件列表</p>
<div><pre><code>ftp<span>></span> <span>ls</span>
<span>200</span> PORT <span>command</span> successful. Consider using PASV.
<span>150</span> Here comes the directory listing.
Installing_OMV5_on_Armbian.pdf
breed.bin
<span>ftp</span>
昆仑.epub
流浪地球.epub
<span>226</span> Directory send OK.
ftp: 收到 <span>83</span> 字节，用时 <span>0.01</span>秒 <span>10.38</span>千字节/秒。
ftp<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><code>cd</code>：进入服务器指定的目录</p>
<div><pre><code>ftp<span>></span> <span>cd</span> /tmp
<span>250</span> Directory successfully changed.
ftp<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>pwd</code>：查看服务器上的当前工作目录</p>
<div><pre><code>ftp<span>></span> <span>pwd</span>
<span>257</span> <span>"/tmp"</span> is the current directory
ftp<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>rename filename [newfilename]</code>：重命名 FTP 服务器上的文件</p>
<p><code>delete filename</code>：删除 FTP 服务器上的文件</p>
<h3 id="传输方式设置命令"> 传输方式设置命令</h3>
<p>上传和下载文件时应该使用正确的传输类型，FTP 的传输类型分为 ASCII码方式和二进制方式两种，对 .txt、.htm 等文件应采用 ASCII码方式传输，对 .exe或图片、视频、音频等文件应采用二进制方式传输。在默认情况下，FTP 为 ASCII码传输方式。（以下 3 个命令都不带参数）</p>
<p><code>type</code>：查看当前的传输方式</p>
<p><code>ascii</code>：设定传输方式为 ASCII码方式</p>
<p><code>binary</code>：设定传输方式为二进制方式</p>
<div><pre><code>ftp<span>></span> <span>type</span>
使用 ascii 模式传送文件。
ftp<span>></span> binary
<span>200</span> Switching to Binary mode.
ftp<span>></span> <span>type</span>
使用 binary 模式传送文件。
ftp<span>></span> ascii
<span>200</span> Switching to ASCII mode.
ftp<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="上传命令"> 上传命令</h3>
<p><code>put filename [newname]</code></p>
<p><code>send filename [newname]</code></p>
<p>filename 为上传的本地文件名，newname 为上传至 FTP 服务器上时使用的名字，如果不指定 newname，文件将以原名上传。</p>
<p>上传文件前，应该根据文件的类型设置传输方式（见文章最后），本机的工作目录也应该设置为上传文件所在的目录。</p>
<div><pre><code>ftp<span>></span> put C:<span>\</span>Users<span>\</span>liujialin<span>\</span>Downloads<span>\</span>system.png
<span>200</span> PORT <span>command</span> successful. Consider using PASV.
<span>150</span> Ok to send data.
<span>226</span> Transfer complete.
ftp: 发送 <span>64878</span> 字节，用时 <span>0.01</span>秒 <span>9268.29</span>千字节/秒。
ftp<span>></span> send C:<span>\</span>Users<span>\</span>liujialin<span>\</span>Downloads<span>\</span>ss.txt
<span>200</span> PORT <span>command</span> successful. Consider using PASV.
<span>150</span> Ok to send data.
<span>226</span> Transfer complete.
ftp: 发送 <span>382</span> 字节，用时 <span>0.00</span>秒 <span>382000.00</span>千字节/秒。
ftp<span>></span> <span>ls</span>
<span>200</span> PORT <span>command</span> successful. Consider using PASV.
<span>150</span> Here comes the directory listing.
<span>ftp</span>
ss.txt
system.png
<span>226</span> Directory send OK.
ftp: 收到 <span>28</span> 字节，用时 <span>0.01</span>秒 <span>4.67</span>千字节/秒。
ftp<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h3 id="下载命令"> 下载命令</h3>
<p><code>get filename [newname]</code></p>
<p>filename 为 FTP 服务器上的文件名，newname 为保存在本都计算机上时使用的名字，如果不指定 newname，文件将以原名保存。</p>
<p><code>get</code> 命令下载的文件将保存在本地计算机的工作目录下。该目录是启动 FTP 时在盘符 C: 后显示的目录。如果想修改本地计算机的工作目录，可以使用 <code>lcd</code> 命令。比如：<code>lcd d:\</code> 表示将工作目录设定为 D 盘的根目录。</p>
<div><pre><code>ftp<span>></span> lcd D:<span>\</span>
目前的本地目录 D:<span>\</span>。
ftp<span>></span> <span>pwd</span>
<span>257</span> <span>"/home"</span> is the current directory
ftp<span>></span> get ss.txt ssss.txt
<span>200</span> PORT <span>command</span> successful. Consider using PASV.
<span>150</span> Opening ASCII mode data connection <span>for</span> ss.txt <span>(</span><span>382</span> bytes<span>)</span>.
<span>226</span> Transfer complete.
ftp: 收到 <span>417</span> 字节，用时 <span>0.00</span>秒 <span>417000.00</span>千字节/秒。
ftp<span>></span> get system.png
<span>200</span> PORT <span>command</span> successful. Consider using PASV.
<span>150</span> Opening ASCII mode data connection <span>for</span> system.png <span>(</span><span>64877</span> bytes<span>)</span>.
<span>226</span> Transfer complete.
ftp: 收到 <span>65193</span> 字节，用时 <span>0.00</span>秒 <span>65193.00</span>千字节/秒。
ftp<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="其他命令"> 其他命令</h3>
<p><code>mput filename1 filename2 ...</code>：上传多个文件</p>
<p><code>mget filename1 filename2 ...</code>：下载多个文件</p>
<p><code>close</code>：结束与服务器的 FTP 会话</p>
<p><code>quit</code>：结束与服务器的 FTP 会话并退出 FTP 环境</p>
<p><code>!</code>：转义到 shell，也就是结束与服务器的 FTP 会话并退出</p>
<div><pre><code>ftp<span>></span> ? <span>!</span>
<span>!</span>               转义到 shell
ftp<span>></span> ? close
close           终止 <span>ftp</span> 会话
ftp<span>></span> ? quit
quit            终止 <span>ftp</span> 会话并退出
ftp<span>></span> ? bye
bye             终止 <span>ftp</span> 会话并退出
ftp<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><hr>
<div><p>说明</p>
<p>以上所有示例都是再 Windows 10 系统下的 CMD 命令行操作。</p>
<p>Linux 同样操作方法，只是界面和盘符显示不同而已。</p>
</div>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-06-24T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">IT 基础</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/IT/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/IT/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="it-基础知识"> IT 基础知识</h2>
<p>就是平时遇到的最基本的知识，网罗到此处。包括各个方面：</p>
<ul>
<li>
<p>Linux</p>
</li>
<li>
<p>Windows</p>
</li>
<li>
<p>各种系统</p>
</li>
<li>
<p>网络</p>
</li>
<li>
<p>各种协议</p>
</li>
<li>
<p>等等......</p>
</li>
</ul>
<p>都是之前学习或临时用到的时候，记的一些学习笔记。长时间没怎么用，再想用就已经忘的差不多了。所以，整理起来，以便日后方便查阅。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-06-24T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">SFTP笔记</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/IT/SFTP/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/IT/SFTP/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="sftp-介绍"> SFTP 介绍</h2>
<p>SFTP 是 SSH File Transfer  Protocol 的缩写，安全文件传送协议。SFTP 与 FTP 有着几乎一样的语法和功能。SFTP 为 SSH 的其中一部分，是一种传输档案至 Blogger 伺服器的安全方式。</p>
<p>其实在 SSH 软件包中，已经包含了一个叫作 SFTP 的安全文件信息传输子系统，SFTP 本身没有单独的守护进程，它必须使用 sshd 守护进程（端口号默认是 22）来完成相应的连接和答复操作，所以从某种意义上来说，SFTP 并不像一个服务器程序，而更像是一个客户端程序。</p>
<h2 id="如何登录-sftp"> 如何登录 SFTP</h2>
<ol>
<li>
<p><code>sftp 服务器IP</code></p>
<p><code>sftp 服务器IP</code> 回车之后，会提示输入默认用户密码进行验证，验证成功后即登录成功。</p>
</li>
</ol>
<div><pre><code>kei@kei-KVM:~/Desktop$ <span>sftp</span> <span>9.200</span>.76.179
ryuu@9.200.76.179's password: 
Connected to <span>9.200</span>.76.179.
sftp<span>></span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ol start="2">
<li>
<p><code>sftp user@服务器IP</code></p>
<p><code>sftp user@服务器IP</code> 之后，会提示输入指定用户 user 的密码进行验证，验证成功后即登录成功。</p>
</li>
</ol>
<div><pre><code>kei@kei-KVM:~/Desktop$ <span>sftp</span> karin@9.200.76.179
karin@9.200.76.179's password: 
Connected to <span>9.200</span>.76.179.
sftp<span>></span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="sftp-的基本命令"> SFTP 的基本命令</h2>
<p>同 FTP 一样，命令 <code>?</code> 或者 <code>help</code> 可以查看所有命令帮助信息。如下：</p>
<div><pre><code>sftp<span>></span> ?
Available commands:
bye                                退出 <span>sftp</span>
<span>cd</span> path                            更改远程目录到 <span>'path'</span>
<span>chgrp</span> <span>[</span>-h<span>]</span> grp path                将文件 <span>'path'</span> 的组更改为 <span>'grp'</span>
<span>chmod</span> <span>[</span>-h<span>]</span> mode path               将文件 <span>'path'</span> 的权限更改为 <span>'mode'</span>
<span>chown</span> <span>[</span>-h<span>]</span> own path                将文件 <span>'path'</span> 的属主更改为 <span>'own'</span>
<span>df</span> <span>[</span>-hi<span>]</span> <span>[</span>path<span>]</span>                    显示当前目录的统计信息或包含 <span>'path'</span> 的文件系统
<span>exit</span>                               退出 <span>sftp</span>
get <span>[</span>-afpR<span>]</span> remote <span>[</span>local<span>]</span>         下载文件
<span>help</span>                               显示这个帮助文本
lcd path                           更改本地目录到 <span>'path'</span>
lls <span>[</span>ls-options <span>[</span>path<span>]</span><span>]</span>            显示本地目录列表
lmkdir path                        创建本地目录
<span>ln</span> <span>[</span>-s<span>]</span> oldpath newpath            符号链接远程文件
lpwd                               显示本地工作目录
<span>ls</span> <span>[</span>-1afhlnrSt<span>]</span> <span>[</span>path<span>]</span>             显示远程目录列表
lumask <span>umask</span>                       将本地umask设置为 <span>'umask'</span>
<span>mkdir</span> path                         创建远程目录
progress                           切换是否显示文件传输进度
put <span>[</span>-afpR<span>]</span> <span>local</span> <span>[</span>remote<span>]</span>         上传文件
<span>pwd</span>                                显示远程工作目录
quit                               退出 <span>sftp</span>
reget <span>[</span>-fpR<span>]</span> remote <span>[</span>local<span>]</span>        恢复下载文件
<span>rename</span> oldpath newpath             重命名远程文件
reput <span>[</span>-fpR<span>]</span> <span>local</span> <span>[</span>remote<span>]</span>        恢复上传文件
<span>rm</span> path                            删除远程文件
<span>rmdir</span> path                         删除远程目录
symlink oldpath newpath            符号链接远程文件
version                            显示 SFTP 版本信息
<span>!</span>command                           在本地shell中执行 <span>'command'</span>
<span>!</span>                                  启动本地shell
?                                  帮助信息
sftp<span>></span> ? lpwd
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><h2 id="常用命令"> 常用命令</h2>
<h3 id="文件或目录操作命令"> 文件或目录操作命令</h3>
<p><code>pwd</code>：是看 sftp 服务器当前工作目录</p>
<p><code>lpwd</code>：是看本地当前工作目录</p>
<p><code>ls</code> ：是看 sftp 服务器下当前目录下的文件列表</p>
<p><code>lls</code>：是看本地当前目录下的文件列表</p>
<p><code>cd path</code>：更改远程目录到 'path'</p>
<p><code>lcd path</code>：更改本地目录到 'path'</p>
<p><code>mkdir path</code>：创建远程目录</p>
<p><code>rmdir path</code>：删除远程目录</p>
<p><code>rm file</code>：删除远程文件</p>
<p><code>rename oldfile newfile</code>：重命名远程文件</p>
<h3 id="上传命令"> 上传命令</h3>
<p><code>put [-r] localfile [remotefile]</code></p>
<p>如果不指定 <code>remotefile</code>，将使用和本地文件相同的文件名。参数 -r 来上传整个目录。</p>
<p>这个是把本地的 <code>test.txt</code> 文件和 <code>/home/ryuu/newfolder/</code> 目录上传到 sftp 服务器上的当前目录下。（当然也可以上传到指定的服务器目录）</p>
<div><pre><code><span>#上传文件</span>
上传文件sftp<span>></span> put /home/kei/test.txt 
Uploading /home/kei/test.txt to /home/ryuu/test.txt
/home/kei/test.txt                           <span>100</span>%    <span>0</span>     <span>0</span>.0KB/s   00:00    
sftp<span>></span> <span>ls</span>
Desktop         Documents       Downloads       IOSAPP          Pictures        
Templates       config.json     derby.log       fontconfig      hello           
nohup.out       share           test.txt

<span>#上传文件夹</span>
sftp<span>></span> put -r /home/kei/newfolder/
Uploading /home/kei/newfolder/ to /home/ryuu/newfolder
sftp<span>></span> <span>ls</span>
Desktop         Documents       Downloads       IOSAPP          Pictures        
Templates       config.json     derby.log       fontconfig      hello           
newfolder		nohup.out       share           test.txt
sftp<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="下载命令"> 下载命令</h3>
<p><code>get [-r] remotefile [localfile]</code></p>
<p>如果不指定 <code>localfile</code>，将使用和服务器文件相同的文件名。参数 -r 来下载整个目录。</p>
<p>这个是把 sftp 服务器上的 <code>hello</code> 文件和 <code>/home/ryuu/Documents/</code>  文件夹下载到本地当前目录下。（当然也可以下载到指定的本地目录）</p>
<div><pre><code><span>#下载文件</span>
sftp<span>></span> get /home/ryuu/hello
Fetching /home/ryuu/hello to hello
/home/ryuu/hello                              <span>100</span>%  <span>174</span>    <span>45</span>.4KB/s   00:00

<span>#下载文件夹</span>
sftp<span>></span> get -r /home/ryuu/Documents/
/home/ryuu/Documents/md/deploy.sh             <span>100</span>%  <span>493</span>   <span>611</span>.1KB/s   00:00    
/home/ryuu/Documents/test.txt                 <span>100</span>%  <span>790</span>     <span>1</span>.0MB/s   00:00    
/home/ryuu/Documents/new                      <span>100</span>%   <span>37</span>   <span>100</span>.0KB/s   00:00    
/home/ryuu/Documents/old                      <span>100</span>%   <span>26</span>     <span>6</span>.0KB/s   00:00    
/home/ryuu/Documents/webmin-1.972.tar.gz      <span>100</span>%   40MB  <span>36</span>.9MB/s   00:01    
sftp<span>></span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="其他命令"> 其他命令</h3>
<p><code>exit</code>：退出 sftp</p>
<p><code>bye</code>：退出 sftp</p>
<p><code>quit</code>：退出 sftp</p>
<p><code>help</code>：显示这个帮助文本</p>
<p><code>!command</code>：在本地shell中执行 'command'</p>
<p><code>!</code>：启动本地shell</p>
<hr>
<div><p>说明</p>
<p>以上所有示例都是再 Ubuntu 系统下的命令行模式操作。</p>
<p>Windows 同样操作方法，只是界面和盘符显示不同而已。</p>
</div>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-06-24T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Git笔记</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/IT/git/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/IT/git/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="git-笔记"> Git 笔记</h2>
<h3 id="git-是什么"> Git 是什么</h3>
<p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p>
<p>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p>
<p>Git 与常用的版本控制工具 CVS，Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。</p>
<p>Git 不仅仅是个版本控制系统，它也是个内容管理系统（CMS），工作管理系统等。</p>
<p><img src="./assets/dvcs.png" alt="dvcs" loading="lazy"></p>
<h2 id="git-安装配置"> Git 安装配置</h2>
<p>在使用 Git 前我们需要先安装 Git。Git 目前支持 Linux/Unix、Solaris、Mac 和 Windows 平台上运行。</p>
<p>Git 各平台安装包下载地址为：http://git-scm.com/downloads</p>
<div><p>说明</p>
<p>本笔记主要以 Linux 平台为主</p>
<p>Git 的工作需要调用 curl，zlib，openssl，expat，libiconv 等库的代码，所以需要先安装这些依赖工具。</p>
</div>
<p>各 Linux 系统可以使用其安装包管理工具（apt-get、yum 等）进行安装：</p>
<h3 id="debian-ubuntu"> Debian/Ubuntu</h3>
<p>如果你使用的系统是 Debian/Ubuntu， Git 安装命令为：</p>
<div><pre><code>$ <span>apt-get</span> <span>install</span> libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-dev
$ <span>apt-get</span> <span>install</span> <span>git</span>
$ <span>git</span> --version
<span>git</span> version <span>1.8</span>.1.2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="centos-redhat"> Centos/RedHat</h3>
<p>如果你使用的系统是 Centos/RedHat， Git 安装命令为：</p>
<div><pre><code>$ yum <span>install</span> curl-devel expat-devel gettext-devel openssl-devel zlib-devel
$ yum -y <span>install</span> git-core
$ <span>git</span> --version
<span>git</span> version <span>1.7</span>.1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="源码安装"> 源码安装</h3>
<p>我们也可以在官网下载源码包来安装，最新源码包下载地址：<a href="https://git-scm.com/download" target="_blank" rel="noopener noreferrer">https://git-scm.com/download</a></p>
<p>安装指定系统的依赖包：</p>
<div><pre><code><span>########## Centos/RedHat ##########</span>
$ yum <span>install</span> curl-devel expat-devel gettext-devel openssl-devel zlib-devel

<span>########## Debian/Ubuntu ##########</span>
$ <span>apt-get</span> <span>install</span> libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-dev
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>解压安装下载的源码包：</p>
<div><pre><code>$ <span>wget</span> https://www.kernel.org/pub/software/scm/git/git-2.32.0.tar.gz
$ <span>tar</span> -zxf git-2.32.0.tar.gz
$ <span>cd</span> git-2.32.0
$ <span>make</span> <span>prefix</span><span>=</span>/usr/local all
$ <span>sudo</span> <span>make</span> <span>prefix</span><span>=</span>/usr/local <span>install</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="git-配置"> Git 配置</h2>
<p>Git 提供了一个叫做 <code>git config</code> 的工具，专门用来配置或读取相应的工作环境变量。</p>
<p>这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：</p>
<ul>
<li><code>/etc/gitconfig</code> 文件：系统中对所有用户都普遍适用的配置。若使用 <code>git config</code> 时用 --system 选项，读写的就是这个文件。</li>
<li><code>~/.gitconfig</code> 文件：用户目录下的配置文件只适用于该用户。若使用 <code>git config</code> 时用 --global 选项，读写的就是这个文件。</li>
<li>当前项目的 Git 目录中的配置文件（也就是工作目录中的 <code>.git/config</code> 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 <code>.git/config</code> 里的配置会覆盖 <code>/etc/gitconfig</code> 中的同名变量。</li>
</ul>
<p>此外，Git 还会尝试找寻 <code>/etc/gitconfig</code> 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。</p>
<h3 id="用户信息"> 用户信息</h3>
<p>配置个人的用户名称和电子邮件地址：</p>
<div><pre><code>$ <span>git</span> config --global user.name <span>"runoob"</span>
$ <span>git</span> config --global user.email test@runoob.com
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果用了 <strong>--global</strong> 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。</p>
<p>如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 --global 选项重新配置即可，新的设定保存在当前项目的 <code>.git/config</code> 文件里。</p>
<h3 id="文本编辑器"> 文本编辑器</h3>
<p>设置Git默认使用的文本编辑器，一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置：</p>
<div><pre><code>$ <span>git</span> config --global core.editor emacs
</code></pre>
<div><span>1</span><br></div></div><h3 id="差异分析工具"> 差异分析工具</h3>
<p>还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话：</p>
<div><pre><code>$ <span>git</span> config --global merge.tool vimdiff
</code></pre>
<div><span>1</span><br></div></div><p>Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。</p>
<p>当然，你也可以指定使用自己开发的工具。</p>
<h3 id="查看配置信息"> 查看配置信息</h3>
<p>要检查已有的配置信息，可以使用 <code>git config --list</code> 命令：</p>
<div><pre><code>$ <span>git</span> config --list
http.postbuffer<span>=</span>2M
user.name<span>=</span>runoob
user.email<span>=</span>test@runoob.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 <code>/etc/gitconfig</code> 和 <code>~/.gitconfig</code>），不过最终 Git 实际采用的是最后一个。</p>
<p>这些配置我们也可以在 <code>~/.gitconfig</code> 或 <code>/etc/gitconfig</code> 看到，如下所示：</p>
<div><pre><code><span>vim</span> ~/.gitconfig 
</code></pre>
<div><span>1</span><br></div></div><p>显示内容如下所示：</p>
<div><pre><code><span>[</span>http<span>]</span>
    postBuffer <span>=</span> 2M
<span>[</span>user<span>]</span>
    name <span>=</span> runoob
    email <span>=</span> test@runoob.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样：</p>
<div><pre><code>$ <span>git</span> config user.name
runoob
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="git-工作流程"> Git 工作流程</h2>
<p>一般工作流程如下：</p>
<ul>
<li>克隆 Git 资源作为工作目录。</li>
<li>在克隆的资源上添加或修改文件。</li>
<li>如果其他人修改了，你可以更新资源。</li>
<li>在提交前查看修改。</li>
<li>提交修改。</li>
<li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</li>
</ul>
<p>下图展示了 Git 的工作流程：</p>
<p><img src="./assets/git-process.png" alt="git-process" loading="lazy"></p>
<h2 id="git-工作区、暂存区和版本库"> Git 工作区、暂存区和版本库</h2>
<h3 id="基本概念"> 基本概念</h3>
<p>我们先来理解下 Git 工作区、暂存区和版本库概念：</p>
<ul>
<li>
<p>工作区：就是你在电脑里能看到的目录。</p>
</li>
<li>
<p>暂存区：英文叫 stage 或 index。一般存放在<code>.git</code> 目录下的 index 文件（<code>.git/index</code>）中，所以我们把暂存区有时也叫作索引（index）。</p>
</li>
<li>
<p>版本库：工作区有一个隐藏目录 <code>.git</code>，这个不算工作区，而是 Git 的版本库。</p>
</li>
</ul>
<p>下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系：</p>
<p><img src="./assets/git_wsb.jpg" alt="git_wsb" loading="lazy"></p>
<ul>
<li>图中左侧为工作区，右侧为版本库。在版本库中标记为 &quot;index&quot; 的区域是暂存区（stage/index），标记为 &quot;master&quot; 的是 master 分支所代表的目录树。</li>
<li>图中我们可以看出此时 &quot;HEAD&quot; 实际是指向 master 分支的一个&quot;游标&quot;。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。</li>
<li>图中的 objects 标识的区域为 Git 的对象库，实际位于 &quot;.git/objects&quot; 目录下，里面包含了创建的各种对象及内容。</li>
<li>当对工作区修改（或新增）的文件执行 <code>git add</code> 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的 ID 被记录在暂存区的文件索引中。</li>
<li>当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</li>
<li>当执行 <code>git reset HEAD</code> 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</li>
<li>当执行 <code>git rm --cached &lt;file&gt;</code> 命令时，会直接从暂存区删除文件，工作区则不做出改变。</li>
<li>当执行 <code>git checkout .</code> 或者 <code>git checkout -- &lt;file&gt;</code> 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</li>
<li>当执行 <code>git checkout HEAD .</code> 或者 <code>git checkout HEAD &lt;file&gt;</code> 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</li>
</ul>
<h2 id="git-创建仓库"> Git 创建仓库</h2>
<p>本章节我们将为大家介绍如何创建一个 Git 仓库。</p>
<p>你可以使用一个已经存在的目录作为Git仓库。</p>
<h3 id="git-init"> git init</h3>
<p>Git 使用 <code>git init</code> 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 <code>git init</code> 是使用 Git 的第一个命令。</p>
<p>在执行完成 <code>git init</code> 命令后，Git 仓库会生成一个 <code>.git</code> 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变。</p>
<ul>
<li>使用方法</li>
</ul>
<p>使用当前目录作为Git仓库，我们只需使它初始化。</p>
<div><pre><code><span>git</span> init
</code></pre>
<div><span>1</span><br></div></div><p>该命令执行完后会在当前目录生成一个 .git 目录。</p>
<p>使用我们指定目录作为Git仓库。</p>
<div><pre><code><span>git</span> init newrepo
</code></pre>
<div><span>1</span><br></div></div><p>初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。</p>
<p>如果当前目录下有几个文件想要纳入版本控制，需要先用 <code>git add</code> 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p>
<div><pre><code>$ <span>git</span> <span>add</span> *.c
$ <span>git</span> <span>add</span> README
$ <span>git</span> commit -m <span>'初始化项目版本'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>以上命令将目录下以 .c 结尾及 README 文件提交到仓库中。</p>
<div><p>注</p>
<p>在 Linux 系统中，commit 信息使用单引号 <strong>'</strong>，Windows 系统，commit 信息使用双引号 <strong>&quot;</strong>。</p>
<p>所以在 git bash 中 <code>git commit -m '提交说明'</code> 这样是可以的，在 Windows 命令行中就要使用双引号 <code>git commit -m &quot;提交说明&quot;</code>。</p>
</div>
<h3 id="git-clone"> git clone</h3>
<p>我们使用 <code>git clone</code> 从现有 Git 仓库中拷贝项目。</p>
<p>克隆仓库的命令格式为：</p>
<div><pre><code><span>git</span> clone <span>&lt;</span>repo<span>></span>
</code></pre>
<div><span>1</span><br></div></div><p>如果我们需要克隆到指定的目录，可以使用以下命令格式：</p>
<div><pre><code><span>git</span> clone <span>&lt;</span>repo<span>></span> <span>&lt;</span>directory<span>></span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>参数说明：</strong></p>
<ul>
<li>**repo：**Git 仓库。</li>
<li>**directory：**本地目录。</li>
</ul>
<p>比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：</p>
<div><pre><code>$ <span>git</span> clone git://github.com/schacon/grit.git
</code></pre>
<div><span>1</span><br></div></div><p>执行该命令后，会在当前目录下创建一个名为 <code>grit</code> 的目录，其中包含一个 <code>.git</code> 的目录，用于保存下载下来的所有版本记录。</p>
<p>如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：</p>
<div><pre><code>$ <span>git</span> clone git://github.com/schacon/grit.git mygrit
</code></pre>
<div><span>1</span><br></div></div><h3 id="配置"> 配置</h3>
<p>git 的设置使用 <code>git config</code> 命令。</p>
<p>显示当前的 git 配置信息：</p>
<div><pre><code>$ <span>git</span> config --list
credential.helper<span>=</span>osxkeychain
core.repositoryformatversion<span>=</span><span>0</span>
core.filemode<span>=</span>true
core.bare<span>=</span>false
core.logallrefupdates<span>=</span>true
core.ignorecase<span>=</span>true
core.precomposeunicode<span>=</span>true
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>编辑 git 配置文件:</p>
<div><pre><code>$ <span>git</span> config -e
<span># 针对当前仓库 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>或者：</p>
<div><pre><code>$ <span>git</span> config -e --global
<span># 针对系统上所有仓库</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>设置提交代码时的用户信息：</p>
<div><pre><code>$ <span>git</span> config --global user.name <span>"runoob"</span>
$ <span>git</span> config --global user.email test@runoob.com
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果去掉 <strong>--global</strong> 参数只对当前仓库有效。</p>
<h2 id="git-基本操作"> Git 基本操作</h2>
<p>Git 的工作就是创建和保存你项目的快照及与之后的快照进行对比。</p>
<p>本节将对有关创建与提交你的项目快照的命令作介绍。</p>
<p>Git 常用的是以下 6 个命令：<strong>git clone</strong>、<strong>git push</strong>、<strong>git add</strong> 、<strong>git commit</strong>、<strong>git checkout</strong>、<strong>git pull</strong>，后面我们会详细介绍。</p>
<p><img src="./assets/git-command.jpg" alt="git_command" loading="lazy"></p>
<div><p>说明</p>
<ul>
<li>workspace：工作区</li>
<li>staging area：暂存区/缓存区</li>
<li>local repository：版本库或本地仓库</li>
<li>remote repository：远程仓库</li>
</ul>
</div>
<p>一个简单的操作步骤：</p>
<div><pre><code>$ <span>git</span> init
$ <span>git</span> <span>add</span> <span>.</span>
$ <span>git</span> commit
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li><code>git init</code> ：初始化仓库。</li>
<li><code>git add .</code> ：添加文件到暂存区。</li>
<li><code>git commit</code> ：将暂存区内容添加到仓库中。</li>
</ul>
<h3 id="创建仓库命令"> 创建仓库命令</h3>
<p>下表列出了 git 创建仓库的命令：</p>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>git init</code></td>
<td style="text-align:left">初始化仓库</td>
</tr>
<tr>
<td style="text-align:left"><code>git clone</code></td>
<td style="text-align:left">拷贝一份远程仓库，也就是下载一个项目。</td>
</tr>
</tbody>
</table>
<h3 id="提交与修改"> 提交与修改</h3>
<p>Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。</p>
<p>下表列出了有关创建与提交你的项目的快照的命令：</p>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>git add</code></td>
<td style="text-align:left">添加文件到仓库</td>
</tr>
<tr>
<td style="text-align:left"><code>git status</code></td>
<td style="text-align:left">查看仓库当前的状态，显示有变更的文件。</td>
</tr>
<tr>
<td style="text-align:left"><code>git diff</code></td>
<td style="text-align:left">比较文件的不同，即暂存区和工作区的差异。</td>
</tr>
<tr>
<td style="text-align:left"><code>git commit</code></td>
<td style="text-align:left">提交暂存区到本地仓库。</td>
</tr>
<tr>
<td style="text-align:left"><code>git reset</code></td>
<td style="text-align:left">回退版本。</td>
</tr>
<tr>
<td style="text-align:left"><code>git rm</code></td>
<td style="text-align:left">删除工作区文件。</td>
</tr>
<tr>
<td style="text-align:left"><code>git mv</code></td>
<td style="text-align:left">移动或重命名工作区文件。</td>
</tr>
</tbody>
</table>
<h3 id="提交日志"> 提交日志</h3>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>git log</code></td>
<td style="text-align:left">查看历史提交记录</td>
</tr>
<tr>
<td style="text-align:left"><code>git blame &lt;file&gt;</code></td>
<td style="text-align:left">以列表形式查看指定文件的历史修改记录</td>
</tr>
</tbody>
</table>
<h3 id="远程操作"> 远程操作</h3>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>git remote</code></td>
<td style="text-align:left">远程仓库操作</td>
</tr>
<tr>
<td style="text-align:left"><code>git fetch</code></td>
<td style="text-align:left">从远程获取代码库</td>
</tr>
<tr>
<td style="text-align:left"><code>git pull</code></td>
<td style="text-align:left">下载远程代码并合并</td>
</tr>
<tr>
<td style="text-align:left"><code>git push</code></td>
<td style="text-align:left">上传远程代码并合并</td>
</tr>
</tbody>
</table>
<h2 id="git-分支管理"> Git 分支管理</h2>
<p>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。</p>
<p>有人把 Git 的分支模型称为<strong>必杀技特性</strong>，而正是因为它，将 <strong>Git</strong> 从版本控制系统家族里区分出来。</p>
<p>创建分支命令：</p>
<div><pre><code><span>git</span> branch <span>(</span>branchname<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>切换分支命令:</p>
<div><pre><code><span>git</span> checkout <span>(</span>branchname<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。</p>
<p>合并分支命令:</p>
<div><pre><code><span>git</span> merge 
</code></pre>
<div><span>1</span><br></div></div><p>你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。</p>
<p>开始前我们先创建一个测试目录：</p>
<div><pre><code>$ <span>mkdir</span> gitdemo
$ <span>cd</span> gitdemo/
$ <span>git</span> init
Initialized empty Git repository<span>..</span>.
$ <span>touch</span> README
$ <span>git</span> <span>add</span> README
$ <span>git</span> commit -m <span>'第一次版本提交'</span>
<span>[</span>master <span>(</span>root-commit<span>)</span> 3b58100<span>]</span> 第一次版本提交
 <span>1</span> <span>file</span> changed, <span>0</span> insertions<span>(</span>+<span>)</span>, <span>0</span> deletions<span>(</span>-<span>)</span>
 create mode <span>100644</span> README
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="列出分支"> 列出分支</h3>
<p>列出分支基本命令：</p>
<div><pre><code><span>git</span> branch
</code></pre>
<div><span>1</span><br></div></div><p>没有参数时，<code>git branch</code> 会列出你在本地的分支。</p>
<div><pre><code>$ <span>git</span> branch
* master
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>此例的意思就是，我们有一个叫做 <strong>master</strong> 的分支，并且该分支是当前分支。</p>
<p>当你执行 <code>git init</code> 的时候，默认情况下 Git 就会为你创建 <strong>master</strong> 分支。</p>
<p>如果我们要手动创建一个分支。执行 <code>git branch (branchname)</code> 即可。</p>
<div><pre><code>$ <span>git</span> branch testing
$ <span>git</span> branch
* master
  testing
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>现在我们可以看到，有了一个新分支 <strong>testing</strong>。</p>
<p>当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了 <strong>testing</strong> 分支，Git 将还原你的工作目录到你创建分支时候的样子。</p>
<p>接下来我们将演示如何切换分支，我们用 <code>git checkout (branch)</code> 切换到我们要修改的分支。</p>
<div><pre><code>$ <span>ls</span>
README
$ <span>echo</span> <span>'runoob.com'</span> <span>></span> test.txt
$ <span>git</span> <span>add</span> <span>.</span>
$ <span>git</span> commit -m <span>'add test.txt'</span>
<span>[</span>master 3e92c19<span>]</span> <span>add</span> test.txt
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
 create mode <span>100644</span> test.txt
$ <span>ls</span>
README        test.txt
$ <span>git</span> checkout testing
Switched to branch <span>'testing'</span>
$ <span>ls</span>
README
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>当我们切换到 <strong>testing</strong> 分支的时候，我们添加的新文件 test.txt 被移除了。切换回 <strong>master</strong> 分支的时候，它们有重新出现了。</p>
<div><pre><code>$ <span>git</span> checkout master
Switched to branch <span>'master'</span>
$ <span>ls</span>
README        test.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>我们也可以使用 <code>git checkout -b (branchname)</code> 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。</p>
<div><pre><code>$ <span>git</span> checkout -b newtest
Switched to a new branch <span>'newtest'</span>
$ <span>git</span> <span>rm</span> test.txt 
<span>rm</span> <span>'test.txt'</span>
$ <span>ls</span>
README
$ <span>touch</span> runoob.php
$ <span>git</span> <span>add</span> <span>.</span>
$ <span>git</span> commit -am <span>'removed test.txt、add runoob.php'</span>
<span>[</span>newtest c1501a2<span>]</span> removed test.txt、add runoob.php
 <span>2</span> files changed, <span>1</span> deletion<span>(</span>-<span>)</span>
 create mode <span>100644</span> runoob.php
 delete mode <span>100644</span> test.txt
$ <span>ls</span>
README        runoob.php
$ <span>git</span> checkout master
Switched to branch <span>'master'</span>
$ <span>ls</span>
README        test.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>如你所见，我们创建了一个分支，在该分支的上移除了一些文件 test.txt，并添加了 runoob.php 文件，然后切换回我们的主分支，删除的 test.txt 文件又回来了，且新增加的 runoob.php 不存在主分支中。</p>
<p>使用分支将工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换。</p>
<h3 id="删除分支"> 删除分支</h3>
<p>删除分支命令：</p>
<div><pre><code><span>git</span> branch -d <span>(</span>branchname<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>例如我们要删除 testing 分支：</p>
<div><pre><code>$ <span>git</span> branch
* master
  testing
$ <span>git</span> branch -d testing
Deleted branch testing <span>(</span>was 85fc7e7<span>)</span>.
$ <span>git</span> branch
* master
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="分支合并"> 分支合并</h3>
<p>一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去：</p>
<div><pre><code><span>git</span> merge
$ <span>git</span> branch
* master
  newtest
$ <span>ls</span>
README        test.txt
$ <span>git</span> merge newtest
Updating 3e92c19<span>..</span>c1501a2
Fast-forward
 runoob.php <span>|</span> <span>0</span>
 test.txt   <span>|</span> <span>1</span> -
 <span>2</span> files changed, <span>1</span> deletion<span>(</span>-<span>)</span>
 create mode <span>100644</span> runoob.php
 delete mode <span>100644</span> test.txt
$ <span>ls</span>
README        runoob.php
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>以上实例中我们将 newtest 分支合并到主分支去，test.txt 文件被删除。</p>
<p>合并完后就可以删除分支:</p>
<div><pre><code>$ <span>git</span> branch -d newtest
Deleted branch newtest <span>(</span>was c1501a2<span>)</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>删除后， 就只剩下 master 分支了：</p>
<div><pre><code>$ <span>git</span> branch
* master
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="合并冲突"> 合并冲突</h3>
<p>合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。</p>
<div><pre><code>$ <span>git</span> branch
* master
$ <span>cat</span> runoob.php
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>首先，我们创建一个叫做 change_site 的分支，切换过去，我们将 runoob.php 内容改为:</p>
<div><pre><code><span>&lt;</span>?php
<span>echo</span> <span>'runoob'</span><span>;</span>
?<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>创建 change_site 分支：</p>
<div><pre><code>$ <span>git</span> checkout -b change_site
Switched to a new branch <span>'change_site'</span>
$ <span>vim</span> runoob.php
$ <span>head</span> -3 runoob.php
<span>&lt;</span>?php
<span>echo</span> <span>'runoob'</span><span>;</span>
?<span>></span>
$ <span>git</span> commit -am <span>'changed the runoob.php'</span>
<span>[</span>change_site <span>7774248</span><span>]</span> changed the runoob.php
 <span>1</span> <span>file</span> changed, <span>3</span> insertions<span>(</span>+<span>)</span>
 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>将修改的内容提交到 change_site 分支中。 现在，假如切换回 master 分支我们可以看内容恢复到我们修改前的(空文件，没有代码)，我们再次修改 runoob.php 文件。</p>
<div><pre><code>$ <span>git</span> checkout master
Switched to branch <span>'master'</span>
$ <span>cat</span> runoob.php
$ <span>vim</span> runoob.php    <span># 修改内容如下</span>
$ <span>cat</span> runoob.php
<span>&lt;</span>?php
<span>echo</span> <span>1</span><span>;</span>
?<span>></span>
$ <span>git</span> <span>diff</span>
<span>diff</span> --git a/runoob.php b/runoob.php
index e69de29<span>..</span>ac60739 <span>100644</span>
--- a/runoob.php
+++ b/runoob.php
@@ -0,0 +1,3 @@
+<span>&lt;</span>?php
+echo <span>1</span><span>;</span>
+?<span>></span>
$ <span>git</span> commit -am <span>'修改代码'</span>
<span>[</span>master c68142b<span>]</span> 修改代码
 <span>1</span> <span>file</span> changed, <span>3</span> insertions<span>(</span>+<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>现在这些改变已经记录到我的 &quot;master&quot; 分支了。接下来我们将 &quot;change_site&quot; 分支合并过来。</p>
<div><pre><code>$ <span>git</span> merge change_site
Auto-merging runoob.php
CONFLICT <span>(</span>content<span>)</span>: Merge conflict <span>in</span> runoob.php
Automatic merge failed<span>;</span> fix conflicts and <span>then</span> commit the result.

$ <span>cat</span> runoob.php     <span># 代开文件，看到冲突内容</span>
<span>&lt;</span>?php
<span>&lt;&lt;&lt;</span><span>&lt;&lt;&lt;</span><span>&lt;</span> HEAD
<span>echo</span> <span>1</span><span>;</span>
<span>==</span><span>==</span><span>==</span><span>=</span>
<span>echo</span> <span>'runoob'</span><span>;</span>
<span>>></span><span>>></span><span>>></span><span>></span> change_site
?<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>我们将前一个分支合并到 master 分支，一个合并冲突就出现了，接下来我们需要手动去修改它。</p>
<div><pre><code>$ <span>vim</span> runoob.php 
$ <span>cat</span> runoob.php
<span>&lt;</span>?php
<span>echo</span> <span>1</span><span>;</span>
<span>echo</span> <span>'runoob'</span><span>;</span>
?<span>></span>
$ <span>git</span> <span>diff</span>
<span>diff</span> --cc runoob.php
index ac60739,b63d7d7<span>..</span>0000000
--- a/runoob.php
+++ b/runoob.php
@@@ -1,3 -1,3 +1,4 @@@
  <span>&lt;</span>?php
 +echo <span>1</span><span>;</span>
+ <span>echo</span> <span>'runoob'</span><span>;</span>
  ?<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决</p>
<div><pre><code>$ <span>git</span> status -s
UU runoob.php
$ <span>git</span> <span>add</span> runoob.php
$ <span>git</span> status -s
M  runoob.php
$ <span>git</span> commit
<span>[</span>master 88afe0e<span>]</span> Merge branch <span>'change_site'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>现在我们成功解决了合并中的冲突，并提交了结果。</p>
<h2 id="git-查看提交历史"> Git 查看提交历史</h2>
<p>Git 提交历史一般常用两个命令：</p>
<ul>
<li><code>git log</code>：查看历史提交记录。</li>
<li><code>git blame &lt;file&gt;</code>：以列表形式查看指定文件的历史修改记录。</li>
</ul>
<h3 id="git-log"> git log</h3>
<p>在使用 Git 提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用 <code>git log</code> 命令查看。</p>
<p>针对我们前一章节的操作，使用 <code>git log</code> 命令列出历史提交记录如下：</p>
<div><pre><code>$ <span>git</span> log
commit d5e9fc2c811e0ca2b2d28506ef7dc14171a207d9 <span>(</span>HEAD -<span>></span> master<span>)</span>
Merge: c68142b <span>7774248</span>
Author: runoob <span>&lt;</span>test@runoob.com<span>></span>
Date:   Fri May <span>3</span> <span>15</span>:55:58 <span>2019</span> +0800
  
    Merge branch <span>'change_site'</span>
  
commit c68142b562c260c3071754623b08e2657b4c6d5b
Author: runoob <span>&lt;</span>test@runoob.com<span>></span>
Date:   Fri May <span>3</span> <span>15</span>:52:12 <span>2019</span> +0800
  
    修改代码
  
commit 777424832e714cf65d3be79b50a4717aea51ab69 <span>(</span>change_site<span>)</span>
Author: runoob <span>&lt;</span>test@runoob.com<span>></span>
Date:   Fri May <span>3</span> <span>15</span>:49:26 <span>2019</span> +0800
  
    changed the runoob.php
  
commit c1501a244676ff55e7cccac1ecac0e18cbf6cb00
Author: runoob <span>&lt;</span>test@runoob.com<span>></span>
Date:   Fri May <span>3</span> <span>15</span>:35:32 <span>2019</span> +0800
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>我们可以用 <strong>--oneline</strong> 选项来查看历史记录的简洁的版本。</p>
<div><pre><code>$ <span>git</span> log --oneline
d5e9fc2 <span>(</span>HEAD -<span>></span> master<span>)</span> Merge branch <span>'change_site'</span>
c68142b 修改代码
<span>7774248</span> <span>(</span>change_site<span>)</span> changed the runoob.php
c1501a2 removed test.txt、add runoob.php
3e92c19 <span>add</span> test.txt
3b58100 第一次版本提交
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这告诉我们的是，此项目的开发历史。</p>
<p>我们还可以用 <strong>--graph</strong> 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项：</p>
<div><pre><code>$ <span>git</span> log --graph
*   d5e9fc2 <span>(</span>HEAD -<span>></span> master<span>)</span> Merge branch <span>'change_site'</span>
<span>|</span><span>\</span>  
<span>|</span> * <span>7774248</span> <span>(</span>change_site<span>)</span> changed the runoob.php
* <span>|</span> c68142b 修改代码
<span>|</span>/  
* c1501a2 removed test.txt、add runoob.php
* 3e92c19 <span>add</span> test.txt
* 3b58100 第一次版本提交
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>现在我们可以更清楚明了地看到何时工作分叉、又何时归并。</p>
<p>你也可以用 <strong>--reverse</strong> 参数来逆向显示所有日志。</p>
<div><pre><code>$ <span>git</span> log --reverse --oneline
3b58100 第一次版本提交
3e92c19 <span>add</span> test.txt
c1501a2 removed test.txt、add runoob.php
<span>7774248</span> <span>(</span>change_site<span>)</span> changed the runoob.php
c68142b 修改代码
d5e9fc2 <span>(</span>HEAD -<span>></span> master<span>)</span> Merge branch <span>'change_site'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>如果只想查找指定用户的提交日志可以使用命令：<code>git log --author</code> , 例如，比方说我们要找 Git 源码中 Linus 提交的部分：</p>
<div><pre><code>$ <span>git</span> log --author<span>=</span>Linus --oneline -5
81b50f3 Move <span>'builtin-*'</span> into a <span>'builtin/'</span> subdirectory
3bb7256 <span>make</span> <span>"index-pack"</span> a built-in
377d027 <span>make</span> <span>"git pack-redundant"</span> a built-in
b532581 <span>make</span> <span>"git unpack-file"</span> a built-in
112dd51 <span>make</span> <span>"mktag"</span> a built-in
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>如果你要指定日期，可以执行几个选项：<strong>--since</strong> 和 <strong>--before</strong>，但是你也可以用 <strong>--until</strong> 和 <strong>--after</strong>。</p>
<p>例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 <strong>--no-merges</strong> 选项以隐藏合并提交）：</p>
<div><pre><code>$ <span>git</span> log --oneline --before<span>=</span><span>{</span><span>3</span>.weeks.ago<span>}</span> --after<span>=</span><span>{</span><span>2010</span>-04-18<span>}</span> --no-merges
5469e2d Git <span>1.7</span>.1-rc2
d43427d Documentation/remote-helpers: Fix typos and improve language
272a36b Fixup: Second argument may be any arbitrary string
b6c8d2d Documentation/remote-helpers: Add invocation section
5ce4f4e Documentation/urls: Rewrite to accomodate transport::address
00b84e9 Documentation/remote-helpers: Rewrite description
03aa87e Documentation: Describe other situations where -z affects <span>git</span> <span>diff</span>
77bc694 rebase-interactive: silence warning when no commits rewritten
636db2c t3301: <span>add</span> tests to use --format<span>=</span><span>"%N"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>更多 git log 命令可查看：http://git-scm.com/docs/git-log</p>
<h3 id="git-blame"> git blame</h3>
<p>如果要查看指定文件的修改记录可以使用 <code>git blame</code> 命令，格式如下：</p>
<div><pre><code><span>git</span> blame <span>&lt;</span>file<span>></span>
</code></pre>
<div><span>1</span><br></div></div><p>git blame 命令是以列表形式显示修改记录，如下实例：</p>
<div><pre><code>$ <span>git</span> blame README 
^d2097aa <span>(</span>tianqixin <span>2020</span>-08-25 <span>14</span>:59:25 +0800 <span>1</span><span>)</span> <span># Runoob Git 测试</span>
db9315b0 <span>(</span>runoob    <span>2020</span>-08-25 <span>16</span>:00:23 +0800 <span>2</span><span>)</span> <span># 菜鸟教程 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="git-标签"> Git 标签</h2>
<p>如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 <code>git tag</code> 给它打上标签。</p>
<p>比如说，我们想为我们的 runoob 项目发布一个&quot;1.0&quot;版本。 我们可以用 <code>git tag -a v1.0</code> 命令给最新一次提交打上（HEAD）&quot;v1.0&quot;的标签。</p>
<p><strong>-a</strong> 选项意为&quot;创建一个带注解的标签&quot;。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。</p>
<div><pre><code>$ <span>git</span> tag -a v1.0 
</code></pre>
<div><span>1</span><br></div></div><p>当你执行 <code>git tag -a</code> 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。</p>
<p>现在，注意当我们执行 <code>git log --decorate</code> 时，我们可以看到我们的标签了：</p>
<div><pre><code>$ <span>git</span> log --decorate
*   d5e9fc2 <span>(</span>HEAD -<span>></span> master<span>)</span> Merge branch <span>'change_site'</span>
<span>|</span><span>\</span>  
<span>|</span> * <span>7774248</span> <span>(</span>change_site<span>)</span> changed the runoob.php
* <span>|</span> c68142b 修改代码
<span>|</span>/  
* c1501a2 removed test.txt、add runoob.php
* 3e92c19 <span>add</span> test.txt
* 3b58100 第一次版本提交
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。</p>
<p>例如，假设我们发布了提交 85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。 我们现在也可以：</p>
<div><pre><code>$ <span>git</span> tag -a v0.9 85fc7e7
$ <span>git</span> log --oneline --decorate --graph
*   d5e9fc2 <span>(</span>HEAD -<span>></span> master<span>)</span> Merge branch <span>'change_site'</span>
<span>|</span><span>\</span>  
<span>|</span> * <span>7774248</span> <span>(</span>change_site<span>)</span> changed the runoob.php
* <span>|</span> c68142b 修改代码
<span>|</span>/  
* c1501a2 removed test.txt、add runoob.php
* 3e92c19 <span>add</span> test.txt
* 3b58100 <span>(</span>tag: v0.9<span>)</span> 第一次版本提交
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>如果我们要查看所有标签可以使用以下命令：</p>
<div><pre><code>$ git tag
v0.9
v1.0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>指定标签信息命令：</p>
<div><pre><code>git tag -a &lt;tagname&gt; -m &quot;runoob.com标签&quot;
</code></pre>
<div><span>1</span><br></div></div><p>PGP签名标签命令：</p>
<div><pre><code>git tag -s &lt;tagname&gt; -m &quot;runoob.com标签&quot;
</code></pre>
<div><span>1</span><br></div></div><h2 id="git-远程仓库-github"> Git 远程仓库（GitHub）</h2>
<p>目前我们使用到的 Git 命令都是在本地执行，如果你想通过 Git 分享你的代码或者与其他开发人员合作。 你就需要将数据放到一台其他开发人员能够连接的服务器上。</p>
<p>本例使用了 Github 作为远程仓库，你可以先阅读我们的 <a href="https://www.runoob.com/w3cnote/git-guide.html" target="_blank" rel="noopener noreferrer">Github 简明教程。</a></p>
<p><img src="./assets/Git-push-command.jpg" alt="Git-push-command" loading="lazy"></p>
<h3 id="添加远程库"> 添加远程库</h3>
<p>要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用,命令格式如下：</p>
<div><pre><code><span>git</span> remote <span>add</span> <span>[</span>shortname<span>]</span> <span>[</span>url<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>本例以 Github 为例作为远程仓库，如果你没有 Github 可以在官网 https://github.com/ 注册。</p>
<p>由于你的本地 Git 仓库和 GitHub 仓库之间的传输是通过 SSH 加密的，所以我们需要配置验证信息：</p>
<p>使用以下命令生成 SSH Key：</p>
<div><pre><code>$ ssh-keygen -t rsa -C <span>"youremail@example.com"</span>
</code></pre>
<div><span>1</span><br></div></div><p>后面的 <em>your_email@youremail.com</em> 改为你在 Github 上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。</p>
<p>成功的话会在 <code>~/</code> 下生成 <code>.ssh</code> 文件夹，进去，打开 <strong>id_rsa.pub</strong>，复制里面的 <strong>key</strong>。</p>
<div><pre><code>$ ssh-keygen -t rsa -C <span>"429240967@qq.com"</span>
Generating public/private rsa key pair.
Enter <span>file</span> <span>in</span> <span>which</span> to save the key <span>(</span>/Users/tianqixin/.ssh/id_rsa<span>)</span>: 
Enter passphrase <span>(</span>empty <span>for</span> no passphrase<span>)</span>:    <span># 直接回车</span>
Enter same passphrase again:                   <span># 直接回车</span>
Your identification has been saved <span>in</span> /Users/tianqixin/.ssh/id_rsa.
Your public key has been saved <span>in</span> /Users/tianqixin/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:MDKVidPTDXIQoJwoqUmI4LBAsg5XByBlrOEzkxrwARI <span>429240967</span>@qq.com
The key's randomart image is:
+---<span>[</span>RSA <span>3072</span><span>]</span>----+
<span>|</span>E*+.<span>+=</span>**oo       <span>|</span>
<span>|</span>%Oo+oo<span>=</span>o. <span>.</span>      <span>|</span>
<span>|</span>%**.o.o.         <span>|</span>
<span>|</span>OO.  o o         <span>|</span>
<span>|</span>+o+     S        <span>|</span>
<span>|</span><span>.</span>                <span>|</span>
<span>|</span>                 <span>|</span>
<span>|</span>                 <span>|</span>
<span>|</span>                 <span>|</span>
+----<span>[</span>SHA256<span>]</span>-----+
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>回到 github 上，进入 <strong>Account =&gt; Settings</strong>（账户配置）。</p>
<p><img src="./assets/Account_settings.png" alt="Account_settings" loading="lazy"></p>
<p>左边选择 <strong>SSH and GPG keys</strong>，然后点击 <strong>New SSH key</strong> 按钮。</p>
<p>![SSH and GPG keys](./assets/SSH and GPG keys.png)</p>
<p><em>title</em> 设置标题，可以随便填，<em>key</em> 粘贴在你电脑上生成的 <strong>key</strong>（ 上面生成的<code>~/.ssh/id_rsa.pub</code>文件内容），最后点击<strong>Add SSH key</strong>按钮添加。</p>
<p><img src="./assets/add_key.png" alt="add_key" loading="lazy"></p>
<p>添加成功后界面如下所示</p>
<p>![SSH and GPG keys](./assets/SSH and GPG keys.png)</p>
<p>为了验证是否成功，输入以下命令：</p>
<div><pre><code>$ <span>ssh</span> -T git@github.com
The authenticity of <span>host</span> <span>'github.com (52.74.223.119)'</span> can<span>'t be established.
RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes                   # 输入 yes
Warning: Permanently added '</span>github.com,52.74.223.119<span>' (RSA) to the list of known hosts.
Hi tianqixin! You'</span>ve successfully authenticated, but GitHub does not provide shell access. <span># 成功信息</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>以上命令说明我们已成功连上 Github。</p>
<p>之后点击 <strong>New repository</strong> 如下图所示：</p>
<p><img src="./assets/New_repository.png" alt="New_repository" loading="lazy"></p>
<p>之后在在 <strong>Repository name</strong> 填入 myblog（远程仓库名） ，其他保持默认设置，点击<strong>Create repository</strong>按钮，就成功地创建了一个新的Git仓库：</p>
<p><img src="./assets/repository_name.png" alt="repository_name" loading="lazy"></p>
<p>创建成功后，显示如下信息：</p>
<p><img src="./assets/created_repository.png" alt="created_repository" loading="lazy"></p>
<p>以上信息告诉我们可以从这个仓库克隆出新的仓库，也可以把本地仓库的内容推送到 GitHub 仓库。</p>
<p>现在，我们根据 GitHub 的提示，在本地的仓库下运行命令：</p>
<div><pre><code>$ <span>mkdir</span> myblog		                        <span># 创建测试目录</span>
$ <span>cd</span> myblog/                    		    <span># 进入测试目录</span>
$ <span>echo</span> <span>"# Git 测试"</span> <span>>></span> README.md				<span># 创建 README.md 文件并写入内容</span>
$ <span>ls</span>                                        <span># 查看目录下的文件</span>
README
$ <span>git</span> init                                  <span># 初始化</span>
$ <span>git</span> <span>add</span> README.md                         <span># 添加文件</span>
$ <span>git</span> commit -m <span>"添加 README.md 文件"</span>        <span># 提交并备注信息</span>
<span>[</span>master <span>(</span>root-commit<span>)</span> 0205aab<span>]</span> 添加 README.md 文件
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
 create mode <span>100644</span> README.md

<span># 提交到 Github</span>
$ <span>git</span> remote <span>add</span> origin git@github.com:Ryukarin/myblog.git
$ <span>git</span> push -u origin master
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>以下命令请根据你在 Github 成功创建新仓库的地方复制，而不是根据我提供的命令，因为我们的 Github 用户名不一样，仓库名也不一样。</p>
<p>接下来我们返回 Github 创建的仓库，就可以看到文件已上传到 Github上：</p>
<p><img src="./assets/push.png" alt="push" loading="lazy"></p>
<h3 id="查看当前的远程库"> 查看当前的远程库</h3>
<p>要查看当前配置有哪些远程仓库，可以用命令：</p>
<div><pre><code><span>git</span> remote
</code></pre>
<div><span>1</span><br></div></div><p>实例</p>
<div><pre><code>$ <span>git</span> remote
origin
$ <span>git</span> remote -v
origin	git@github.com:Ryukarin/myblog.git <span>(</span>fetch<span>)</span>
origin	git@github.com:Ryukarin/myblog.git <span>(</span>push<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>执行时加上 <strong>-v</strong> 参数，你还可以看到每个别名的实际链接地址。</p>
<h3 id="提取远程仓库"> 提取远程仓库</h3>
<p>Git 有两个命令用来提取远程仓库的更新。</p>
<ol>
<li>从远程仓库下载新分支与数据：</li>
</ol>
<div><pre><code><span>git</span> fetch
</code></pre>
<div><span>1</span><br></div></div><p>该命令执行完后需要执行 <code>git merge</code> 远程分支到你所在的分支。</p>
<ol start="2">
<li>从远端仓库提取数据并尝试合并到当前分支：</li>
</ol>
<div><pre><code><span>git</span> merge
</code></pre>
<div><span>1</span><br></div></div><p>该命令就是在执行 <code>git fetch</code> 之后紧接着执行 <code>git merge</code> 远程分支到你所在的任意分支。</p>
<p>假设你配置好了一个远程仓库，并且你想要提取更新的数据，你可以首先执行 <code>git fetch [alias]</code> 告诉 Git 去获取它有你没有的数据，然后你可以执行 <code>git merge [alias]/[branch]</code> 以将服务器上的任何更新（假设有人这时候推送到服务器了）合并到你的当前分支。</p>
<p>接下来我们在 Github 上点击 <strong>README.md</strong> 并在线修改它:</p>
<p><img src="./assets/edit_readme.png" alt="edit readme" loading="lazy"></p>
<p>修改好 <strong>README.md</strong> 之后，点击底部的 <strong>Commit changes</strong> 按钮。</p>
<p><img src="./assets/Commit_changes.png" alt="Commit changes" loading="lazy"></p>
<p>然后我们在本地更新修改。</p>
<div><pre><code>$ <span>git</span> fetch origin
remote: Counting objects: <span>3</span>, done.
remote: Compressing objects: <span>100</span>% <span>(</span><span>2</span>/2<span>)</span>, done.
remote: Total <span>3</span> <span>(</span>delta <span>0</span><span>)</span>, reused <span>0</span> <span>(</span>delta <span>0</span><span>)</span>, pack-reused <span>0</span>
Unpacking objects: <span>100</span>% <span>(</span><span>3</span>/3<span>)</span>, done.
From github.com:Ryukarin/myblog
   0205aab<span>..</span>febd8ed  master     -<span>></span> origin/main
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>以上信息&quot;0205aab..febd8ed master -&gt; origin/master&quot; 说明 main 分支已被更新，我们可以使用以下命令将更新同步到本地：</p>
<div><pre><code>$ <span>git</span> merge origin/main
Updating 0205aab<span>..</span>febd8ed
Fast-forward
 README.md <span>|</span> <span>1</span> +
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>查看 README.md 文件内容：</p>
<div><pre><code>$ <span>cat</span> README.md 
<span># Git 测试</span>
---
<span>## 第一次修改内容（二级标题）</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="推送到远程仓库"> 推送到远程仓库</h3>
<p>推送你的新分支与数据到某个远端仓库命令：</p>
<div><pre><code><span>git</span> push <span>[</span>alias<span>]</span> <span>[</span>branch<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>以上命令将你的 [branch] 分支推送成为 [alias] 远程仓库上的 [branch] 分支，实例如下。</p>
<div><pre><code>$ <span>touch</span> test.txt      <span># 添加文件</span>
$ <span>git</span> <span>add</span> test.txt 
$ <span>git</span> commit -m <span>"添加到远程"</span>
master 69e702d<span>]</span> 添加到远程
 <span>1</span> <span>file</span> changed, <span>0</span> insertions<span>(</span>+<span>)</span>, <span>0</span> deletions<span>(</span>-<span>)</span>
 create mode <span>100644</span> test.txt

$ <span>git</span> push origin master    <span># 推送到 Github</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>重新回到我们的 Github 仓库，可以看到文件已经提交上来了：</p>
<p><img src="./assets/add_remote.png" alt="add remote" loading="lazy"></p>
<h3 id="删除远程仓库"> 删除远程仓库</h3>
<p>删除远程仓库你可以使用命令：</p>
<div><pre><code><span>git</span> remote <span>rm</span> <span>[</span>别名<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>实例</p>
<div><pre><code>$ <span>git</span> remote -v
origin    git@github.com:Ryukarin/myblog.git <span>(</span>fetch<span>)</span>
origin    git@github.com:Ryukarin/myblog.git <span>(</span>push<span>)</span>

<span># 添加仓库 origin2</span>
$ <span>git</span> remote <span>add</span> origin2 git@github.com:Ryukarin/myblog.git

$ <span>git</span> remote -v
origin    git@github.com:Ryukarin/myblog.git <span>(</span>fetch<span>)</span>
origin    git@github.com:Ryukarin/myblog.git <span>(</span>push<span>)</span>
origin2    git@github.com:Ryukarin/myblog.git <span>(</span>fetch<span>)</span>
origin2    git@github.com:Ryukarin/myblog.git <span>(</span>push<span>)</span>

<span># 删除仓库 origin2</span>
$ <span>git</span> remote <span>rm</span> origin2
$ <span>git</span> remote -v
origin    git@github.com:Ryukarin/myblog.git <span>(</span>fetch<span>)</span>
origin    git@github.com:Ryukarin/myblog.git <span>(</span>push<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><div><p>码云（Gitee）</p>
<p>大家都知道国内访问 Github 速度比较慢，很影响我们的使用。</p>
<p>如果你希望体验到 Git 飞一般的速度，可以使用国内的 Git 托管服务——<a href="https://gitee.com/?utm_source=remote_blog_cnjc" target="_blank" rel="noopener noreferrer">Gitee（gitee.com）</a>。</p>
<p>Gitee 提供免费的 Git 仓库，还集成了代码质量检测、项目演示等功能。对于团队协作开发，Gitee 还提供了项目管理、代码托管、文档管理的服务，5 人以下小团队免费。</p>
<p>使用方法和  Github 大同小异，具体就不展开说了。</p>
</div>
<h2 id="git-服务器搭建"> Git 服务器搭建</h2>
<p>前面我们远程仓库使用了 Github，Github 公开的项目是免费的，2019 年开始 Github 私有存储库也可以无限制使用。</p>
<p>这当然我们也可以自己搭建一台 Git 服务器作为私有仓库使用。</p>
<p>接下来我们将以 Centos 为例搭建 Git 服务器。</p>
<h3 id="安装git"> 安装Git</h3>
<div><pre><code>$ yum <span>install</span> curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel
$ yum <span>install</span> <span>git</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>接下来我们 创建一个git用户组和用户，用来运行git服务：</p>
<div><pre><code>$ <span>groupadd</span> <span>git</span>
$ <span>useradd</span> <span>git</span> -g <span>git</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="创建证书登录"> 创建证书登录</h3>
<p>收集所有需要登录的用户的公钥，公钥位于id_rsa.pub文件中，把我们的公钥导入到<code>/home/git/.ssh/authorized_keys</code>文件里，一行一个。</p>
<p>如果没有该文件创建它：</p>
<div><pre><code>$ <span>cd</span> /home/git/
$ <span>mkdir</span> .ssh
$ <span>chmod</span> <span>755</span> .ssh
$ <span>touch</span> .ssh/authorized_keys
$ <span>chmod</span> <span>644</span> .ssh/authorized_keys
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="初始化git仓库"> 初始化Git仓库</h3>
<p>首先我们选定一个目录作为 Git 仓库，假定是 <code>/home/gitrepo/runoob.git</code>，在 <code>/home/gitrepo</code> 目录下输入命令：</p>
<div><pre><code>$ <span>cd</span> /home
$ <span>mkdir</span> gitrepo
$ <span>chown</span> git:git gitrepo/
$ <span>cd</span> gitrepo

$ <span>git</span> init --bare runoob.git
Initialized empty Git repository <span>in</span> /home/gitrepo/runoob.git/
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>以上命令 Git 创建一个空仓库，服务器上的Git仓库通常都以 .git 结尾。然后，把仓库所属用户改为git：</p>
<div><pre><code>$ <span>chown</span> -R git:git runoob.git
</code></pre>
<div><span>1</span><br></div></div><h3 id="克隆仓库"> 克隆仓库</h3>
<div><pre><code>$ <span>git</span> clone git@192.168.45.4:/home/gitrepo/runoob.git
Cloning into <span>'runoob'</span><span>..</span>.
warning: You appear to have cloned an empty repository.
Checking connectivity<span>..</span>. done.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>192.168.45.4 为 Git 所在服务器 ip ，你需要将其修改为你自己的 Git 服务 ip。</p>
<p>这样我们的 Git 服务器安装就完成。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-06-24T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">常用网站</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/guide/link/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/guide/link/"/>
    <updated>2022-01-27T04:23:32.482Z</updated>
    <content type="html"><![CDATA[<h2 id="常用网站"> 常用网站</h2>
<table>
<thead>
<tr>
<th style="text-align:center">工具网站</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="http://www.toolzl.com/" target="_blank" rel="noopener noreferrer">工具资料箱</a></td>
<td>在线工具，你能找到的，基本都在</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://ps.gaoding.com/#/" target="_blank" rel="noopener noreferrer">稿定</a></td>
<td>免费在线PS网站</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://docsmall.com/" target="_blank" rel="noopener noreferrer">docsmall</a></td>
<td>在线压缩工具，图片压缩、gif压缩、PDF压缩、PDF合并、PDF分割</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://www.pdfpai.com/" target="_blank" rel="noopener noreferrer">PDF派</a></td>
<td>几十个强大的PDF在线工具，永久免费，没有注册入口，人人都是VIP！</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://xiaomark.com/" target="_blank" rel="noopener noreferrer">小码短链接</a></td>
<td>简单易用的渠道短链接统计工具</td>
</tr>
<tr>
<td style="text-align:center"><a href="http://z-sms.com/" target="_blank" rel="noopener noreferrer">云短信</a></td>
<td>临时手机号，在线云短信网页版 - 免费接码平台</td>
</tr>
<tr>
<td style="text-align:center"><a href="http://zhimo.yuanzhumuban.cc/music/" target="_blank" rel="noopener noreferrer">音乐下载</a></td>
<td>全网音乐解析下载</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener noreferrer">我告诉你</a></td>
<td>做一个安静的工具站，系统镜像，工具软件下载</td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-04-21T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Markdown语法</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/guide/markdown/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/guide/markdown/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h1 id="markdown-介绍"> Markdown 介绍</h1>
<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。<br>
Markdown 编写的文档后缀为 .md, .markdown。</p>
<h1 id="markdown-应用"> Markdown 应用</h1>
<p>Markdown 能被使用来撰写电子书，如：Gitbook。<br>
当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。</p>
<h1 id="markdown-编辑器"> Markdown 编辑器</h1>
<p>本教程将使用 Typora 编辑器来讲解 Markdown 的语法，Typora 支持 MacOS 、Windows、Linux 平台，且包含多种主题，编辑后直接渲染出效果。
支持导出HTML、PDF、Word、图片等多种类型文件。<br>
Typora 官网：https://typora.io/</p>
<h1 id="markdown-语法"> Markdown 语法</h1>
<h2 id="一、标题"> 一、标题</h2>
<p>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。<br>
注：标准语法一般在 # 后跟个空格再写文字</p>
<div><pre><code># 这是一级标题
## 这是二级标题
### 这是三级标题
#### 这是四级标题
##### 这是五级标题
###### 这是六级标题
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>效果如下：</p>
<h1 id="这是一级标题"> 这是一级标题</h1>
<h2 id="这是二级标题"> 这是二级标题</h2>
<h3 id="这是三级标题"> 这是三级标题</h3>
<h4 id="这是四级标题"> 这是四级标题</h4>
<h5 id="这是五级标题"> 这是五级标题</h5>
<h6 id="这是六级标题"> 这是六级标题</h6>
<h2 id="二、字体"> 二、字体</h2>
<blockquote>
<p>加粗：文字左右分别用两个<em>号包起来（或者_）<br>
倾斜：文字左右分别用一个</em>号包起来（或者_）<br>
倾斜并加粗：文字左右分别用三个*号包起来（或者_）<br>
删除线：文字左右分别用两个~~号包起来<br>
下划线：下划线可以通过 HTML 的 &lt;u&gt; 标签来实现</p>
</blockquote>
<div><pre><code>**这是加粗的文字**  
__粗体文本__  
*这是倾斜的文字*  
_斜体文本_  
***这是斜体加粗的文字***  
___斜体加粗文本___  
~~这是加删除线的文字~~  
&lt;u&gt;这是带下划线文本&lt;/u&gt;  
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>效果如下：</p>
<p><strong>这是加粗的文字</strong><br>
<strong>粗体文本</strong><br>
<em>这是倾斜的文字</em><br>
<em>斜体文本</em><br>
<em><strong>这是斜体加粗的文字</strong></em><br>
<em><strong>斜体加粗文本</strong></em><br>
<s>这是加删除线的文字</s><br>
<u>这是带下划线文本</u></p>
<h2 id="三、段落"> 三、段落</h2>
<p>Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。</p>
<div><pre><code>这是段落格式  
这也是段落格式
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>效果如下：</p>
<p>这是段落格式<br>
这也是段落格式</p>
<h2 id="四、分割线"> 四、分割线</h2>
<p>三个或者三个以上的 - 或者 * 都可以。显示效果是一样的。</p>
<div><pre><code>---
-----
***
*****
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>效果如下：</p>
<hr>
<hr>
<hr>
<hr>
<h2 id="五、列表"> 五、列表</h2>
<p>Markdown 支持有序列表和无序列表。</p>
<ul>
<li><strong>无序列表</strong></li>
</ul>
<p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容。
无序列表用 - + * 任何一种都可以。</p>
<div><pre><code>* 第一项
+ 第二项
- 第三项
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>效果如下：</p>
<blockquote>
<ul>
<li>第一项</li>
</ul>
<ul>
<li>第二项</li>
</ul>
<ul>
<li>第三项</li>
</ul>
</blockquote>
<ul>
<li><strong>有序列表</strong></li>
</ul>
<p>有序列表使用数字并加上 . 号来表示，如：</p>
<div><pre><code>1. 第一项
2. 第二项
3. 第三项
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>效果如下：</p>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
<ul>
<li><strong>列表嵌套</strong></li>
</ul>
<p>列表嵌套只需在子列表中的选项前面添加四个空格即可。</p>
<div><pre><code>1. 第一项：
    - 第一项嵌套的第一个元素
    - 第一项嵌套的第二个元素
2. 第二项：
    + 第二项嵌套的第一个元素
    + 第二项嵌套的第二个元素
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>效果如下：</p>
<ol>
<li>第一项：
<ul>
<li>第一项嵌套的第一个元素</li>
<li>第一项嵌套的第二个元素</li>
</ul>
</li>
<li>第二项：
<ul>
<li>第二项嵌套的第一个元素</li>
<li>第二项嵌套的第二个元素</li>
</ul>
</li>
</ol>
<h2 id="六、引用"> 六、引用</h2>
<p>Markdown 引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号。<br>
引用也可以嵌套，如加两个&gt;&gt;、三个&gt;&gt;&gt;、n个...<br>
引用和列表也可以嵌套使用，此处不举例说明。</p>
<div><pre><code>&gt; 最外层
&gt;&gt; 第一层嵌套
&gt;&gt;&gt; 第二层嵌套
&gt;&gt;&gt;&gt;&gt; 第五层嵌套
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>效果如下：</p>
<blockquote>
<p>最外层</p>
<blockquote>
<p>第一层嵌套</p>
<blockquote>
<p>第二层嵌套</p>
<blockquote>
<blockquote>
<p>第五层嵌套</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h2 id="七、代码"> 七、代码</h2>
<ul>
<li><strong>单行代码</strong></li>
</ul>
<p>代码之间分别用一对反引号 ` 包起来</p>
<blockquote>
<p>比如说这行的 `printf()` 函数</p>
</blockquote>
<p>效果如下：</p>
<p>比如说这行的 <code>printf()</code> 函数</p>
<ul>
<li><strong>代码区块</strong></li>
</ul>
<p>你也可以用一对 ``` 包裹一段代码，并指定一种语言（也可以不指定），且反引号单独占一行</p>
<blockquote>
<p>```javascript<br>
$(document).ready(function () {<br>
alert('RUNOOB');<br>
});<br>
```</p>
</blockquote>
<p>效果如下：</p>
<div><pre><code><span>$</span><span>(</span>document<span>)</span><span>.</span><span>ready</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>alert</span><span>(</span><span>'RUNOOB'</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="八、超链接"> 八、超链接</h2>
<p>链接使用方法如下：</p>
<blockquote>
<p><em><strong>[链接名称](链接地址)</strong></em><br>
或者<br>
<em><strong>&lt;链接地址&gt;</strong></em></p>
</blockquote>
<div><pre><code>这是一个Typora官网链接 [Typora](https://typora.io/)
这是Typora的官网地址链接&lt;https://typora.io/&gt;
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>效果如下：</p>
<p>这是一个Typora官网链接 <a href="https://typora.io/" target="_blank" rel="noopener noreferrer">Typora</a><br>
这是Typora的官网地址链接<a href="https://typora.io/" target="_blank" rel="noopener noreferrer">https://typora.io/</a></p>
<h2 id="九、图片"> 九、图片</h2>
<p>图片语法格式如下：</p>
<blockquote>
<p>![alt 属性文本](图片地址)<br>
![alt 属性文本](图片地址 &quot;可选标题&quot;)</p>
</blockquote>
<div><pre><code>![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png)
![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png &quot;RUNOOB&quot;)
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>效果如下：</p>
<p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标" loading="lazy"></p>
<p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标" title="RUNOOB" loading="lazy"></p>
<p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code> 标签。</p>
<div><pre><code>&lt;img src=&quot;http://static.runoob.com/images/runoob-logo.png&quot; width=&quot;50%&quot;&gt;
</code></pre>
<div><span>1</span><br></div></div><p>效果如下：</p>
<img src="http://static.runoob.com/images/runoob-logo.png" alt="图像的替代文本" width="50%" height="50%">
<h2 id="十、表格"> 十、表格</h2>
<p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。<br>
语法格式如下：</p>
<div><pre><code>|  表头   | 表头  |
|  ----  | ----  |
| 单元格  | 单元格 |
| 单元格  | 单元格 |
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>效果如下：</p>
<table>
<thead>
<tr>
<th>表头</th>
<th>表头</th>
</tr>
</thead>
<tbody>
<tr>
<td>单元格</td>
<td>单元格</td>
</tr>
<tr>
<td>单元格</td>
<td>单元格</td>
</tr>
</tbody>
</table>
<ul>
<li>对齐方式</li>
</ul>
<p><strong>我们可以设置表格的对齐方式：</strong></p>
<ul>
<li>--:   设置内容和标题栏居右对齐。</li>
<li>:--   设置内容和标题栏居左对齐。</li>
<li>:-:   设置内容和标题栏居中对齐。</li>
</ul>
<div><pre><code>| 左对齐 | 右对齐 | 居中对齐 |
| :-----| -----: | :-----: |
| 单元格 | 单元格 | 单元格 |
| 单元格 | 单元格 | 单元格 |
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>效果如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">左对齐</th>
<th style="text-align:right">右对齐</th>
<th style="text-align:center">居中对齐</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">单元格</td>
<td style="text-align:right">单元格</td>
<td style="text-align:center">单元格</td>
</tr>
<tr>
<td style="text-align:left">单元格</td>
<td style="text-align:right">单元格</td>
<td style="text-align:center">单元格</td>
</tr>
</tbody>
</table>
<h2 id="十一、高级用法"> 十一、高级用法</h2>
<ul>
<li><strong>支持的 HTML 元素</strong></li>
</ul>
<p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。
目前支持的 HTML 元素有：<code>&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code> 等 ，如：</p>
<div><pre><code>使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑
</code></pre>
<div><span>1</span><br></div></div><p>效果如下：</p>
<p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p>
<ul>
<li><strong>转义</strong></li>
</ul>
<p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠 \ 转义特殊字符：</p>
<div><pre><code>**文本加粗**  
\*\* 正常显示星号 \*\*
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>效果如下：</p>
<p><strong>文本加粗</strong><br>
** 正常显示星号 **</p>
<ul>
<li><strong>公式</strong></li>
</ul>
<p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。
有点复杂，网上有很多教程，此处不进行说明。</p>
<ul>
<li><strong>流程图</strong></li>
</ul>
<p>当然，还有流程图，时序图，甘特图。也有点复杂，此处不做详解，网上可以查找相关内容。</p>
<h1 id="markdown用后感"> Markdown用后感</h1>
<p>使用Markdown之后，总体感觉就是语法简单，格式清爽，是一个很好用的文本格式编辑语言。Markdown文件不支持内嵌图片，所有的图片都以外部链接的方式插入。</p>
<blockquote>
<p>markdown一时爽, 分享火葬场</p>
</blockquote>
<p>所以分享Markdown文件的时候就不得不和图片一起发送，同时还得注意设置图片路径，让强迫症患者难以接受。<br>
解决方法就是设置图床，此处就不展开说明了。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2022-01-26T06:11:29.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">主要功能与配置演示</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/guide/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/guide/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h1 id="主要功能与配置演示"> 主要功能与配置演示</h1>
<ul>
<li>
<p><a href="./page.html">页面展示</a></p>
</li>
<li>
<p><a href="./markdown.html">Markdown 展示</a></p>
</li>
<li>
<p><a href="./disable.html">禁用展示</a></p>
</li>
<li>
<p><a href="./encrypt.html">加密展示</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <category term="使用指南"/>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2022-01-26T06:11:29.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">幻灯片页</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/guide/slides/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/guide/slides/"/>
    <updated>2022-01-27T04:23:32.497Z</updated>
    <content type="html"><![CDATA[
<i>Not supported content</i>]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">【RM2100】刷机救转</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/operate/AC_RM2100/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/operate/AC_RM2100/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>红米的 RM2100（或者小米 AC2100）最近挺火的，因为价钱便宜，配置给力，信号不错，主要是可以刷机。</p>
<p>咸鱼上斐讯 K2P 已经炒上天了，虽然信号各方面没得说，但是价钱嘛。还是小米的这两款给力，官方价格，来个优惠券，真香。反观斐讯 K2P 只有二手的，还有可能翻车。于是在官网下手了红米的 RM2100。</p>
<p>收到货之后，稍微用了一会，主要测试原固件。其实还挺好用的，要不是喜欢折腾还有第三方固件有插件的加持，我才不会刷机呢。</p>
<p>下面是刷机的过程。</p>
<h2 id="环境准备"> 环境准备</h2>
<h3 id="_1、windows-系统"> 1、Windows 系统</h3>
<p>本文用的是 Windows 10 环境，其他 Windows 系统差不多一样的设置操作。</p>
<h3 id="_2、开启-telnet-客户端"> 2、开启 Telnet 客户端</h3>
<ul>
<li>
<p>打开 <u>控制面板</u></p>
</li>
<li>
<p>找到 <u>程序</u>---&gt;<u>程序和功能</u>---&gt;<u>启用和关闭Windows功能</u></p>
</li>
<li>
<p>勾选 <u>Telnet 客户端</u></p>
</li>
</ul>
<p><img src="./assets/ac2100_1.png" alt="" loading="lazy"></p>
<h3 id="_3、网卡配置"> 3、网卡配置</h3>
<ul>
<li>
<p>进入 <code>控制面板\网络和 Internet\网络和共享中心\网络连接（更改适配器设置）</code></p>
</li>
<li>
<p>把所有不相关的网络接口都禁掉（WLAN和虚拟机网络接口），只留下本地网线接口</p>
</li>
<li>
<p>修改本地网线接口</p>
<ul>
<li>IP地址：192.168.31.177</li>
<li>子网掩码：255.255.255.0</li>
<li>默认网关：192.168.31.1</li>
</ul>
</li>
</ul>
<p><img src="./assets/ac2100_2.png" alt="" loading="lazy"></p>
<p>3、关闭杀毒软件和防火墙</p>
<p>关闭所有杀毒软件，关闭防火墙（包括360，火戎等等）</p>
<p><img src="./assets/ac2100_3.png" alt="" loading="lazy"></p>
<h2 id="开启-telnet"> 开启 Telnet</h2>
<h3 id="_1、连接方式"> 1、连接方式</h3>
<p>把路由器按照如下图方式连接电脑</p>
<p><img src="./assets/ac2100_4.png" alt="" loading="lazy"></p>
<h3 id="_2、拨号"> 2、拨号</h3>
<p>浏览器进入路由器管理页面（192.168.31.1 或 miwifi.com），确保路由地址为192.168.31.1</p>
<ul>
<li>
<p>上网方式：PPPoE</p>
</li>
<li>
<p>账号：123</p>
</li>
<li>
<p>密码：123</p>
</li>
</ul>
<p><img src="./assets/ac2100_5.png" alt="" loading="lazy"></p>
<h3 id="_3、执行开启-telnet-脚本"> 3、执行开启 Telnet 脚本</h3>
<ul>
<li>下载并解压刷机工具【RM2100完整版.zip】， 打开 <code>/rm2100</code> 文件夹，双击 npcap-0.9991.exe 安装文件进行安装</li>
<li>打开 <code>开启telnet命令.txt</code> 文件， 并提前复制好 <code>开启telnet命令.txt</code> 里面的命令</li>
<li>打开执行 <code>一键开启telnet.bat</code>（不用管理员运行），按照提示操作（按回车键）</li>
</ul>
<p><img src="./assets/ac2100_6.png" alt="" loading="lazy"></p>
<p><img src="./assets/ac2100_7.png" alt="" loading="lazy"></p>
<ul>
<li>开启 PPPOE 服务器，跳出 Task_PPPOE 服务器窗口，看 Task_PPPOE 服务器窗口是否有数据包（下图红线内容）</li>
</ul>
<p><img src="./assets/ac2100_8.png" alt="" loading="lazy"></p>
<ul>
<li>再回到一键解锁工具窗口，根据提示输入 y 回车，开启文件服务器</li>
</ul>
<p><img src="./assets/ac2100_9.png" alt="" loading="lazy"></p>
<ul>
<li>
<p>直到 <u>Task_反弹shell</u> 窗口显示如下内容，则电脑和路由器连接成功了</p>
<blockquote>
<p>connect to [192.168.31.177] form (UNKNOWN) [192.168.31.1] ......</p>
</blockquote>
</li>
</ul>
<p><img src="./assets/ac2100_10.png" alt="" loading="lazy"></p>
<ul>
<li>把提前复制好 <code>开启telnet命令.txt</code> 里面的命令（不用提前也可以），粘贴到 <u>Task_反弹sheel</u> 窗口（右键为粘贴），回车运行</li>
</ul>
<p><img src="./assets/ac2100_11.png" alt="" loading="lazy"></p>
<ul>
<li>窗口显示蓝线内容，则路由器的 Telnet 开启成功</li>
</ul>
<div><p>注意</p>
<p>1、卡 <u>Task_反弹shell</u> 等问题大概率是电脑系统、防火墙、杀毒软件造成的，如果开启 Telnet 你这一步没有成功，就彻底关掉电脑防火墙和杀毒软件，再从头走一遍。</p>
<p>2、路由器 Telnet 开启成功后记得把 WAN-LAN 之间的网线（上面接线图棕色线）拔掉，否则刷入 breed 后易造成网络风暴。</p>
</div>
<h2 id="刷入-breed"> 刷入 Breed</h2>
<h3 id="_1、telnet-连接路由器"> 1、Telnet 连接路由器</h3>
<ul>
<li>打开 cmd 命令行窗口，输入下面命令并回车</li>
</ul>
<div><pre><code>telnet <span>192.168</span>.31.1		<span>#telnet连接到路由器</span>
</code></pre>
<div><span>1</span><br></div></div><p><img src="./assets/ac2100_12.png" alt="" loading="lazy"></p>
<h3 id="_2、下载-breed-并烧录"> 2、下载 Breed 并烧录</h3>
<p>依次输入以下三条命令。</p>
<p>出现下图篮框内容，表示 Breed 已经烧录好了，路由正在重启</p>
<div><pre><code><span>cd</span> /tmp
<span>#进入/tmp路径，注意此时“Task_文件服务器”进程是否还在运行，没运行的再执行一下/rm2100中的httpserver.bat，之后再执行下面命令</span>
<span>wget</span>  http://192.168.31.177:8081/breed-mt7621-xiaomi-r3g.bin<span>&amp;&amp;</span>nvram  <span>set</span> <span>uart_en</span><span>=</span><span>1</span><span>&amp;&amp;</span>nvram <span>set</span> <span>bootdelay</span><span>=</span><span>5</span><span>&amp;&amp;</span>nvram <span>set</span>  <span>flag_try_sys1_failed</span><span>=</span><span>1</span><span>&amp;&amp;</span>nvram commit
<span>#下载Breed.bin并设置环境参数</span>
mtd -r <span>write</span> breed-mt7621-xiaomi-r3g.bin Bootloader
<span>#烧写Breed到Bootloader分区</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><img src="./assets/ac2100_13.png" alt="" loading="lazy"></p>
<ul>
<li>更改 PC 端 IP</li>
</ul>
<p>将电脑有线网卡改为自动获取 IP，等待路由器重启（当电脑获取到 IP 或者路由只有一个蓝灯亮时，Breed 引导官方固件成功）。</p>
<p><img src="./assets/ac2100_14.png" alt="" loading="lazy"></p>
<h2 id="进入-breed"> 进入 Breed</h2>
<h3 id="_1、断电"> 1、断电</h3>
<p>建议等待 3 分钟后拔掉电源</p>
<h3 id="_2、进入-breed"> 2、进入 Breed</h3>
<ul>
<li>用牙签按住 reset 键不要松开，再通电</li>
<li>一直等到蓝灯闪烁再松开 reset 键</li>
<li>浏览器访问 192.168.1.1 即可进入 Breed Web 界面。</li>
<li>首次进入 Breed 记得先备份下编程器固件和 eeprom。</li>
</ul>
<p>至此，成功进入路由器 Breed。</p>
<p><img src="./assets/ac2100_15.png" alt="" loading="lazy"></p>
<h2 id="刷入第三方固件"> 刷入第三方固件</h2>
<p>在刷第三方固件之前，进入 Breed 控制台，固件备份，最好先一下备份编程器固件。</p>
<h3 id="_1、padavan-固件"> 1、Padavan 固件</h3>
<ul>
<li>进入 Breed 控制台，选择固件更新---固件---选择文件，选择老毛子 Padavan 固件后，点上传</li>
</ul>
<p><img src="./assets/ac2100_16.png" alt="" loading="lazy"></p>
<ul>
<li>上传完成后，更新确认，确认没问题后点击更新</li>
</ul>
<p><img src="./assets/ac2100_17.png" alt="" loading="lazy"></p>
<ul>
<li>正在更新，等待更新完成</li>
</ul>
<p><img src="./assets/ac2100_18.png" alt="" loading="lazy"></p>
<ul>
<li>更新完成后，等待 3 分钟，然后浏览器输入 Padavan 的管理 IP 地址（不同大佬编译的固件，管理 IP 地址可能不同），输入账号密码进入路由后台
<ul>
<li>账号：admin</li>
<li>密码：admin</li>
</ul>
</li>
</ul>
<p><img src="./assets/ac2100_19.png" alt="" loading="lazy"></p>
<ul>
<li>登陆成功，进入熟悉的老毛子后台界面，有你需要的插件</li>
</ul>
<h3 id="_2、openwrt-固件"> 2、OpenWRT 固件</h3>
<ul>
<li>进 Breed 的环境变量编缉菜单，新增字段 xiaomi.r3g.bootfw 值为 2， 然后点保存。</li>
</ul>
<p><img src="./assets/ac2100_20.png" alt="" loading="lazy"></p>
<ul>
<li>刷入临时固件（刷入方法同上）</li>
</ul>
<p><img src="./assets/ac2100_21.png" alt="" loading="lazy"></p>
<p><img src="./assets/ac2100_22.png" alt="" loading="lazy"></p>
<ul>
<li>重启后会进入这个临时的 openwrt，我们打算用它来刷我们真正想刷的 openwrt 固件。这个临时 openwrt 的地址是 192.168.1.1，用户名是 root，没有密码。</li>
</ul>
<p><img src="./assets/ac2100_23.png" alt="" loading="lazy"></p>
<ul>
<li>然后找到 System -&gt; Backup / Flash Firmware，点击 Flash image... 上传我们想刷的 openwrt 固件</li>
</ul>
<p><img src="./assets/ac2100_24.png" alt="" loading="lazy"></p>
<ul>
<li>然后浏览选择固件，点上传</li>
</ul>
<p><img src="./assets/ac2100_25.png" alt="" loading="lazy"></p>
<ul>
<li>不要勾选 Keep settings and retain the current configuration，最后点 Continue</li>
</ul>
<p><img src="./assets/ac2100_26.png" alt="" loading="lazy"></p>
<ul>
<li>等几分钟让路由器自己重启。进入新固件</li>
</ul>
<p><img src="./assets/ac2100_27.png" alt="" loading="lazy"></p>
<h3 id="_3、gecoos-固件"> 3、GECOOS 固件</h3>
<ul>
<li>进入 Breed 控制台，选择固件更新---固件---选择文件，选择集客 AP 固件后，点上传，进入更新面点更新，等在更新完成（从2020051200版本开始支持 breed 升级）</li>
</ul>
<p><img src="./assets/ac2100_28.png" alt="" loading="lazy"></p>
<ul>
<li>更新完成后，等5分钟，在浏览器输入集客 AP 的管理后台IP（6.6.6.6 或者在路由后台找到对应的 IP）
<ul>
<li>账号：admin</li>
<li>密码：admin</li>
</ul>
</li>
</ul>
<p><img src="./assets/ac2100_29.png" alt="" loading="lazy"></p>
<ul>
<li>进入熟悉的集客 AP 的后台，之后就是自己设置</li>
</ul>
<h2 id="刷回官方-bootloader-及固件"> 刷回官方 bootloader 及固件</h2>
<h3 id="_1、刷回官方-bootloader"> 1、刷回官方 bootloader</h3>
<ul>
<li>首先进入 Breed，固件更新---&gt;Bootloader---选择文件（选择官方 bootloader 文件）---&gt;上传</li>
</ul>
<p><img src="./assets/ac2100_30.png" alt="" loading="lazy"></p>
<ul>
<li>确认更新界面，点更新，官 bootloader 只有 512KB 大小，所以很快就更新完成并返回 Breed 界面</li>
</ul>
<p><img src="./assets/ac2100_31.png" alt="" loading="lazy"></p>
<ul>
<li>此时，已经刷回官 bootloader 了</li>
</ul>
<h3 id="_2、刷回官方固件"> 2、刷回官方固件</h3>
<p>上面已经恢复官方 boot 引导，再用官方救砖工具一键刷回。</p>
<ul>
<li>首先断开电源，用牙签按住重置键，再插上电源，持续大概10秒，直到出现<strong>橙色灯闪烁。</strong></li>
<li>使用小米路由修复工具，刷回固件，打开其中的 MIWIFIRepairTool.x86</li>
</ul>
<p><img src="./assets/ac2100_32.png" alt="" loading="lazy"></p>
<ul>
<li>点击浏览，选择下载文件中的官方 <strong>固件---&gt;红米---&gt;miwifi_rm2100_firmware_d517e_1.0.14.bin</strong>，点击下一步</li>
</ul>
<p><img src="./assets/ac2100_33.png" alt="" loading="lazy"></p>
<p>选择连接路由器 LAN口 的网卡，再点击下一步（开启本地服务器）</p>
<p><img src="./assets/ac2100_34.png" alt="" loading="lazy"></p>
<ul>
<li>然后就会自动开始刷机了（把官方固件传到路由器上并烧录）</li>
</ul>
<p><img src="./assets/ac2100_35.png" alt="" loading="lazy"></p>
<ul>
<li>进度条跑满，看到如下提示时，并且路由器出现蓝色灯闪烁，即可重启路由器完成刷机</li>
</ul>
<p><img src="./assets/ac2100_36.png" alt="" loading="lazy"></p>
<ul>
<li>路由重启完成后，登陆路由器后台手机 APP（或浏览器 192.168.31.1），顺利进入路由器后台</li>
</ul>
<p><img src="./assets/ac2100_37.png" alt="" loading="lazy"></p>
<ul>
<li>刷回官方固件就完成了</li>
</ul>
<h2 id="相关文件"> 相关文件</h2>
<p>链接: <a href="https://pan.baidu.com/s/1A5Z5DpOdlTVO-9lqS2crig" target="_blank" rel="noopener noreferrer">https://pan.baidu.com/s/1A5Z5DpOdlTVO-9lqS2crig</a></p>
<p>提取码: 7kmn</p>
<h2 id="本文参考"> 本文参考</h2>
<p><a href="https://www.right.com.cn/forum/forum.php?mod=viewthread&amp;tid=4023907&amp;extra=page%3D1&amp;page=1" target="_blank" rel="noopener noreferrer">Breed来自恩山ivybridgexeon的帖子</a></p>
<p><a href="https://www.right.com.cn/forum/forum.php?mod=viewthread&amp;tid=4022682&amp;extra=page%3D1%26filter%3Dtypeid%26typeid%3D43" target="_blank" rel="noopener noreferrer">Padavan来自恩山淮尚的帖子</a></p>
<p><a href="https://www.right.com.cn/forum/forum.php?mod=viewthread&amp;tid=4025861&amp;extra=page%3D1%26filter%3Dtypeid%26typeid%3D43" target="_blank" rel="noopener noreferrer">OpenWrt来自恩山pnq的帖子</a></p>
<p><a href="https://www.right.com.cn/forum/thread-4021056-1-1.html" target="_blank" rel="noopener noreferrer">GECOOS来自恩山sgwyj的帖子</a></p>
<p><a href="https://www.xiaomi.cn/post/5289432" target="_blank" rel="noopener noreferrer">小米路由官方救砖工具使用说明</a></p>
<p><a href="http://miwifi.com/miwifi_download.html" target="_blank" rel="noopener noreferrer">小米路由官方资源下载首页</a></p>
<p><a href="https://www.smyz.net/pc/7793.html" target="_blank" rel="noopener noreferrer">红米AC2100刷回官方固件</a></p>
<p>还有部分其他论坛帖子，有些忘记了，所以就不一一列出了。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2020-06-30T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">个人信息</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/intro/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/intro/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h1 id="个人信息页"> 个人信息页</h1>
<h2 id="基本信息"> 基本信息</h2>
<ul>
<li>姓名：刘家麟</li>
<li>生日：yyyy/mm/dd</li>
<li>年龄：xx</li>
<li>性别：男</li>
<li>现居地：江苏</li>
</ul>
<h2 id="娱乐爱好"> 娱乐爱好</h2>
<ul>
<li>看书（主要是小说）</li>
<li>看电影（小电影除外）</li>
<li>运动（主要为了减肥）</li>
<li>动手瞎折腾（有空无聊时）</li>
</ul>
<h2 id="梦想"> 梦想</h2>
<p>梦想还是要有的，万一彩票中奖了呢。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2022-01-26T06:11:29.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">【MSG1500】刷机</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/operate/MSG1500/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/operate/MSG1500/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>前几天在闲鱼上看到一款路由器瑞斯康达 SGM1500，网上查了一下相关配置，还不错，还可以刷机，于是搞了一台。</p>
<h2 id="配置参数"> 配置参数</h2>
<ul>
<li>CPU：MT7621</li>
<li>接口：1WAN+4LAN，USB2.0（全千兆网口）</li>
<li>无线：2.4G/5G（7615DN）</li>
<li>Flash：128M（NAND）</li>
<li>内存：256M</li>
</ul>
<h2 id="刷入-breed"> 刷入 Breed</h2>
<h3 id="确定breed"> 确定Breed</h3>
<p>CPU 和无线芯片是和 K2P 一样的，内存和 Flash 方案和小米R3G、极路由4一样（nand flash）。
根据相关配置信息，到 hackpascal 大佬的恩山帖子查找，MT7621 的 nand flash 方案的 Breed 有极路由4，小米R3G（网件R6220内存只有128M排除掉）</p>
<p><img src="./assets/msg1500_1.png" alt="img" loading="lazy"></p>
<p>然后先把这 2 个 breed 先下载下来备用，放在 tftpd32.exe 所在目录（提前下载好 tftpd32 并解压好）</p>
<p><img src="./assets/msg1500_2.png" alt="img" loading="lazy"></p>
<h3 id="telnet-进入路由"> Telnet 进入路由</h3>
<p>路由器通电，用网线连接路由器的 LAN 口和电脑的网口</p>
<p><img src="./assets/msg1500_3.png" alt="img" loading="lazy"></p>
<p>等待片刻打开 CMD 输入 ipconfig，查看有线网卡获取到IP地址（192.168.2.X）和网关（192.168.2.254）</p>
<p><img src="./assets/msg1500_4.png" alt="img" loading="lazy"></p>
<p>用 putty 工具 telnet 进入路由器</p>
<ul>
<li>host IP：192.168.2.254</li>
<li>connection type：telnet</li>
<li>用户名：root</li>
<li>密码：root</li>
</ul>
<p><img src="./assets/msg1500_5.png" alt="img" loading="lazy"></p>
<h3 id="备份原固件和-bootloader"> 备份原固件和 Bootloader</h3>
<ol>
<li>查看分区信息
<code>cat /proc/mtd</code></li>
</ol>
<div><pre><code>root@OpenWrt:~<span># cat /proc/mtd</span>
dev:    size   erasesize  name
mtd0: 07f80000 00020000 <span>"ALL"</span>
mtd1: 00080000 00020000 <span>"Bootloader"</span>    <span>#mtd1就是引导分区（Bootloader）</span>
mtd2: 00080000 00020000 <span>"Config"</span>
mtd3: 00040000 00020000 <span>"Factory"</span>
mtd4: 01ec0000 00020000 <span>"firmware"</span>      <span>#mtd4就是固件分区（firmware）</span>
mtd5: 01b94faf 00020000 <span>"rootfs"</span>
mtd6: 05f80000 00020000 <span>"rootfs_data"</span>
root@OpenWrt:~<span>#</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ol start="2">
<li>备份分区
<code>dd if=源文件(input file) of=目的文件(of=output file )</code>
备份启动分区和固件分区到 <code>/tmp</code> 目录下</li>
</ol>
<div><pre><code>root@OpenWrt:~<span># dd if=/dev/mtd4 of=/tmp/firmware_backup.bin</span>
<span>62976</span>+0 records <span>in</span>
<span>62976</span>+0 records out
root@OpenWrt:~<span># dd if=/dev/mtd1 of=/tmp/Bootloader_backup.bin</span>
<span>1024</span>+0 records <span>in</span>
<span>1024</span>+0 records out
root@OpenWrt:~<span>#</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ol start="3">
<li>查看备份</li>
</ol>
<div><pre><code>root@OpenWrt:~<span># cd /tmp/</span>
root@OpenWrt:/tmp<span># ls</span>
Bootloader_backup.bin		<span>#有此文件，说明上面的备份成功</span>
firmware_backup.bin				<span>#有此文件，说明上面的备份成功</span>
root@OpenWrt:/tmp<span>#</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ol start="4">
<li>
<p>导出备份</p>
<p>见<u><strong>文件传输</strong></u>内容</p>
</li>
</ol>
<h3 id="开启-tftp"> 开启 tftp</h3>
<p>打开tftpd32.exe之前，先关闭系统防火墙和杀毒软件，否则 tftp 命令不能传输文件</p>
<p><img src="./assets/msg1500_6.png" alt="img" loading="lazy"></p>
<p>打开 tftpd32.exe，就会自动开启 tftp 服务器，Server interfaces 选择电脑网口的 IP，就是上面 CMD 获取的IP（192.168.2.X）</p>
<p><img src="./assets/msg1500_7.png" alt="img" loading="lazy"></p>
<h3 id="文件传输"> 文件传输</h3>
<ol>
<li>导出备份</li>
</ol>
<p>下面两个命令是把备份固件导出到本地 tftpd32.exe 所在目录中</p>
<div><pre><code>root<span>@OpenWrt</span><span>:</span><span>/</span>tmp<span># tftp -pl Bootloader_backup.bin 192.168.2.192</span>
root<span>@OpenWrt</span><span>:</span><span>/</span>tmp<span># tftp -pl firmware_backup.bin 192.168.2.192</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><img src="./assets/msg1500_8.png" alt="img" loading="lazy"></p>
<ol start="2">
<li>上传 breed 文件到路由器</li>
</ol>
<p>把下载的 Breed 放到本地 tftpd32.exe 所在的目录下，先测试极路由4 的 <strong>breed-mt7621-hiwifi-hc5962.bin</strong>（如果此 Breed不可用，再测试小米R3G的 Breed）</p>
<ul>
<li>上传并确认 Breed 文件</li>
</ul>
<div><pre><code>root@OpenWrt:/tmp<span># tftp -gr breed-mt7621-hiwifi-hc5962.bin 192.168.2.192</span>
<span>#把本地tftpd32.exe所在目录中的breed-mt7621-hiwifi-hc5962.bin文件上传到路由的/tmp目录下</span>
root@OpenWrt:/tmp<span># ls</span>
breed-mt7621-hiwifi-hc5962.bin
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>
<p>刷入 Breed
把 Breed 刷入到 Bootloader 分区</p>
<p><code>mtd write /tmp/breed-mt7621-hiwifi-hc5962.bin Bootloader</code></p>
</li>
</ul>
<div><pre><code>root<span>@OpenWrt</span><span>:</span><span>/</span>tmp<span>#mtd write /tmp/breed-mt7621-hiwifi-hc5962 Bootloader</span>
Unlocking Bootloader <span>...</span>

Writing form <span>/</span>tmp<span>/</span>breed<span>-</span>mt7621<span>-</span>hiwifi<span>-</span>hc5962<span>.</span>bin to Bootloader <span>...</span>
root<span>@OpenWrt</span><span>:</span><span>/</span>tmp<span>#</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>以上，Breed 就刷入完成了，开机启动看看能否进入 Breed。</p>
<h2 id="进入-breed"> 进入 Breed</h2>
<ul>
<li>路由器断电</li>
<li>按住路由 WPS 键并通电（WPS键继续按住8秒左右）</li>
<li>浏览器输入192.168.1.1</li>
</ul>
<p><img src="./assets/msg1500_9.png" alt="img" loading="lazy"></p>
<p>成功进入 Breed，以防万一，继续备份一下。</p>
<p><img src="./assets/msg1500_10.png" alt="img" loading="lazy"></p>
<h2 id="刷第三方固件"> 刷第三方固件</h2>
<p>C 大的老毛子已增加此型号，编译一下即可，参考老毛子固件 Padavan 编译</p>
<ul>
<li>如图选择文件，这里选择的是 C 大的老毛子固件</li>
</ul>
<p><img src="./assets/msg1500_11.png" alt="img" loading="lazy"></p>
<ul>
<li>点击更新，开始刷机</li>
</ul>
<p><img src="./assets/msg1500_12.png" alt="img" loading="lazy"></p>
<ul>
<li>等到更新成功后重启路由器
<ul>
<li>浏览器输入192.168.2.1</li>
<li>用户名：admin</li>
<li>密码：admin</li>
</ul>
</li>
</ul>
<p>成功进入路由器后台界面</p>
<p><img src="./assets/msg1500_13.png" alt="img" loading="lazy"></p>
<p>编译时加入了一些插件</p>
<p><img src="./assets/msg1500_14.png" alt="img" loading="lazy"></p>
<p>USB 接口测试可用</p>
<p><img src="./assets/msg1500_15.png" alt="img" loading="lazy"></p>
<h2 id="无线测试"> 无线测试</h2>
<p>测试了一下无线效果，并不是很好（非专业测试，只是在家里几个地方测试了一下，仅供参考）</p>
<table>
<thead>
<tr>
<th>WiFi</th>
<th>2.4G Down</th>
<th>2.4G Up</th>
<th>5G Down</th>
<th>5GUp</th>
</tr>
</thead>
<tbody>
<tr>
<td>贴脸</td>
<td>70.9</td>
<td>55.5</td>
<td>135</td>
<td>92</td>
</tr>
<tr>
<td>一堵墙</td>
<td>38.2</td>
<td>30.6</td>
<td>119</td>
<td>118</td>
</tr>
<tr>
<td>两堵墙</td>
<td>2.6</td>
<td>7.2</td>
<td>28.4</td>
<td>41.6</td>
</tr>
</tbody>
</table>
<h2 id="个人感受"> 个人感受</h2>
<p>无线并不是很强，不如红米 AC2100，更不如 K2P，看他们的 2.4GWIFI 芯片对比，虽然价格还算便宜，效果真的不咋地。如果不考虑无线的话，当个主路由、旁路由或交换机，干些其他等，还是很值的。</p>
<h2 id="相关文件"> 相关文件</h2>
<p>待整理上传</p>
<h2 id="本文参考"> 本文参考</h2>
<p><a href="https://www.right.com.cn/forum/thread-161906-1-1.html" target="_blank" rel="noopener noreferrer">https://www.right.com.cn/forum/thread-161906-1-1.html</a></p>
<p><a href="https://post.smzdm.com/p/aoozem39/" target="_blank" rel="noopener noreferrer">https://post.smzdm.com/p/aoozem39/</a></p>
<p><a href="https://github.com/chongshengB/Padavan-build" target="_blank" rel="noopener noreferrer">https://github.com/chongshengB/Padavan-build</a></p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2020-11-06T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">【斐讯N1】Armbian</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/operate/N1_armbian/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/operate/N1_armbian/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="下载-armbian-镜像"> 下载 Armbian 镜像</h2>
<p>下载地址：https://users.armbian.com/balbes150/arm-64/
该地址为 armbian 官网 balbes150 大神专门为晶晨、全志、RK 芯片的盒子做的镜像，并且不断更新，更新后，原来的镜像都会被删除，所以如果觉得某个版本的镜像好，要自己备份。</p>
<h2 id="写入镜像到-u盘"> 写入镜像到 U盘</h2>
<ol>
<li>
<p>下载镜像写入工具，把镜像写入到U盘中。</p>
</li>
<li>
<p>烧录到优盘后，修改 <code>extlinux</code> 目录下的 <code>extlinux.conf</code> 文件。</p>
</li>
</ol>
<p>前三行不变之后全用 #注释，#aml s9xx 以下的行解除#注释，并修改对应 dtb 路径（只解除一个 FDT 行的注释并修改即可）</p>
<p>2018 年上半年以前的 S905L/M2 的机器（Q7、部分Q5、HM201、R3300L、MG101、M201S、M201D、部分E900V21C)，使用 p212；
新一代支持蓝牙和双频 WiFi 的 S905L 盒子，比如咪咕 MGV2000、创维 E900V21D/E 等机型由于没有适配的 dtb，使用 p212 有机会开机启动，但没有视频和网络，可以通过 TTL 输出，目前没有进一步适配 dtb；S905M的机器，比如江苏版 Q5、魔百盒 G2 40F、百事通 R3300-M 等，使用 gxbb_p200_1G_100M_RealtekWiFi
其他机器所用 dtb 见下：</p>
<ul>
<li>Amlogic S905 = p200/p201</li>
<li>Amlogic S905X = p212</li>
<li>Amlogic S905D = p230/231</li>
<li>Amlogic S905W = p281</li>
<li>Amlogic S912 = q200/q201</li>
</ul>
<ol start="3">
<li>重命名 U盘根目录的 u-boot-s905x-s912 为 u-boot.ext</li>
<li>插入盒子，U盘启动</li>
</ol>
<h2 id="进入-armbian-系统"> 进入 armbian 系统</h2>
<ol>
<li>插入 U盘，给N1通电，会默认进入 U盘的 armbian 系统</li>
</ol>
<ul>
<li>
<p>username：root</p>
</li>
<li>
<p>passeord：1234</p>
<p>首次登录，需要修改密码，密码修改后，提示新建账户，ctrl+C可以取消</p>
</li>
</ul>
<ol start="2">
<li>写入 emmc</li>
</ol>
<p>输入如下命令，执行脚本，会自动把 armbian 写入到 emmc 中</p>
<div><pre><code>./install-aml.sh
</code></pre>
<div><span>1</span><br></div></div><p>当出现 commpletd 表明写入完成</p>
<ol start="3">
<li>
<p>重启 N1</p>
<p>输入命令</p>
</li>
</ol>
<div><pre><code><span>shutdown</span> -r now
</code></pre>
<div><span>1</span><br></div></div><p>等到 N1 的灯灭掉之后，拔出U盘，在重新拔插电源，N1 会自动计入到 emmc 的 armbian 系统</p>
<hr>
<p>以上，N1 刷入 armbian 结束。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-03-18T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">【斐讯N1】开机第一屏logo替换</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/operate/N1_logo_PARTITION/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/operate/N1_logo_PARTITION/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>斐讯 N1 的刷机，网上的教程满天飞，随便找一个都可以。但是，刷完机之后，开启启动的第一屏 logo 我个人不是太喜欢。于是，就有了想替换的想法，在网上查询了半天，有两种方法：一个是用 Amlogic CustomizationTool 工具修改替换刷机包的 logo，这个需要重新刷机；另一个是直接命令行替换，无需刷机。</p>
<h3 id="方法一"> 方法一</h3>
<ol>
<li>
<p>首先到网上搜索 Amlogic CustomizationTool 工具并下载安装。</p>
</li>
<li>
<p>打开工具，点击【加载】会跳出新的选项窗口，勾选【设置Logo镜像（提换Logo图片）】，然后确定。</p>
</li>
</ol>
<p><img src="./assets/N1_logo_1.png" alt="" loading="lazy"></p>
<ol start="3">
<li>
<p>选择你要加载的固件 img 文件，等待加载完成。</p>
</li>
<li>
<p>然后点击【启动图片】，再点【打开】选择自己喜欢的图片，提示保存为 RGB16 格式选择【Yes】。</p>
</li>
</ol>
<p><img src="./assets/N1_logo_2.png" alt="" loading="lazy"></p>
<ol start="5">
<li>最后，点击【压缩】，等待打包成新的镜像。（建议打包成新的镜像包名，不要和原镜像重名）</li>
</ol>
<p>把上面新生成的镜像包重新刷机，N1的开机第一屏 Logo 就变成修改后的图片了。当然这个方法就是有点耗时麻烦，好在修改还是不需要什么技术，当然还可以更多的定制化，如开机动画的修改，添加 APK 软件等等。</p>
<h3 id="方法二"> 方法二</h3>
<p>此方法来自与恩山 Lilith 的帖子教程，很简单且不需要刷机。</p>
<ol>
<li>将 <code>logo.PARTITION</code> 置于设备存储中 /sdcrad（或其他位置，即参数 if 的位置）</li>
<li>键盘连接 N1，打开终端模拟器（Terminel）输入以下命令（或远程工具连接到 N1)</li>
</ol>
<div><pre><code><span>dd</span> <span>if</span><span>=</span>/sdcard/logo.PARTITION <span>of</span><span>=</span>/dev/block/logo
<span># 如果没权限执行的话，加上sudo执行</span>
<span># dd 可从标准输入或文件中读取数据，根据指定的格式来转换数据，再输出到文件、设备或标准输出。</span>
<span># if=文件名：输入文件名，默认为标准输入。即指定源文件。</span>
<span># of=文件名：输出文件名，默认为标准输出。即指定目的文件。 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ol start="3">
<li>重启设备生效</li>
</ol>
<div><pre><code><span>reboot</span>
</code></pre>
<div><span>1</span><br></div></div><p>原贴：<a href="https://www.right.com.cn/forum/thread-764098-1-1.html" target="_blank" rel="noopener noreferrer">https://www.right.com.cn/forum/thread-764098-1-1.html</a></p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-03-18T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">【魔百合Q5】改造计划</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/operate/Q5/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/operate/Q5/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>这次直接说说改造过程，首先是拆机测量，设计并画出图纸（比较浪费时间,各种修改），之后去马云家找个亚克力厂家定制外壳，直接把图纸发给客服，估价下单，一般也就十几块钱的样子。还有要买一些组装外壳需要的小零件，铜柱螺丝之类的。</p>
<p>魔百合 Q5（也叫数码视讯 Q5）在复古游戏圈曾是一代神器，刷上复古游戏系统（Sx05RE），可以模拟几千个游戏。当然也可以刷 armbian 系统，可作为家庭小型服务器，刷如破解的 Android TV 系统等。</p>
<h2 id="配置参数"> 配置参数</h2>
<ul>
<li>
<p>芯片：S905M 四核 1.5GHz</p>
</li>
<li>
<p>存储：1G+8G</p>
</li>
<li>
<p>接口：两个 USB，1 TF卡，1 百兆网口，1 HDMI</p>
</li>
<li>
<p>无线：有无线 WiFi，无蓝牙</p>
</li>
</ul>
<h2 id="图纸设计"> 图纸设计</h2>
<p>首先是拆机测量，设计并画出图纸（比较浪费时间，各种修改），之后去马云家找个亚克力厂家定制外壳，直接把图纸发给客服，估价下单，一般也就十几块钱的样子。</p>
<p>我的是魔百和 Q5 江苏版的，其它版本通不通用不清楚，具体对照一下主板。</p>
<p><img src="./assets/Q5_tz.png" alt="img" loading="lazy"></p>
<h2 id="所需材料"> 所需材料</h2>
<div>
<p><img src="./assets/Q5_cl.png" alt="img" loading="lazy"></p>
</div>
<div><p>补充</p>
<p>上图材料中再追加加一个 M2 螺母，用于连接一个<u>单通铜柱（M2*5+4）</u> 和 <u>双通铜柱（M2*25）</u>。</p>
</div>
<p>以下安装教程全是水，安装时忘了拍照，所以流程如下：</p>
<ol>
<li>
<p>首先你得这样，然后再这样</p>
</li>
<li>
<p>这样安装之后，再这样弄</p>
</li>
<li>
<p>这样弄完了后，最后再这样</p>
</li>
</ol>
<h2 id="完成效果"> 完成效果</h2>
<div>
<p><img src="./assets/Q5_xg1.jpg" alt="img" loading="lazy"></p>
<p><img src="./assets/Q5_xg2.jpg" alt="img" loading="lazy"></p>
<p><img src="./assets/Q5_xg3.jpg" alt="img" loading="lazy"></p>
<p><img src="./assets/Q5_xg4.jpg" alt="img" loading="lazy"></p>
<p><img src="./assets/Q5_xg5.jpg" alt="img" loading="lazy"></p>
<p><img src="./assets/Q5_xg6.jpg" alt="img" loading="lazy"></p>
<p><img src="./assets/Q5_xg7.jpg" alt="img" loading="lazy"></p>
</div>
<h2 id="相关文件"> 相关文件</h2>
<p>链接: <a href="https://pan.baidu.com/s/1kNk4wjLwczWU3ixMvXGedg" target="_blank" rel="noopener noreferrer">https://pan.baidu.com/s/1kNk4wjLwczWU3ixMvXGedg</a></p>
<p>提取码: 233t</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2020-04-29T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">瞎折腾</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/operate/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/operate/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="瞎折腾那些事儿"> 瞎折腾那些事儿</h2>
<p>你又在瞎搞什么东西啊。</p>
<p>就是把平时学到的一些技能，搞搞小玩意儿。基于一些矿渣产品上的，刷机、改造、测试、搭建服务器之类的折腾总结；也有一些其他方面的折腾，突然哪天对什么感兴趣了，那就安排！</p>
<h3 id="矿渣硬件方面的折腾"> 矿渣硬件方面的折腾：</h3>
<ul>
<li>玩客云</li>
<li>斐逊N1</li>
<li>斐逊K3</li>
<li>小娱C1</li>
<li>魔百合Q5</li>
<li>X86小主机</li>
<li>瑞斯康达SGM1500</li>
<li>红米AC2100</li>
<li>贝克云</li>
<li>......</li>
</ul>
<h3 id="系统软件层面的折腾"> 系统软件层面的折腾：</h3>
<ul>
<li>可道云KODBOX</li>
<li>open media vault</li>
<li>EmuELEC</li>
<li>Lakka</li>
<li>OpenWRT</li>
<li>老毛子Padavan</li>
<li>Armbian</li>
<li>......</li>
</ul>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-04-09T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">【小娱C1C5】改造计划</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/operate/XY_C1C5/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/operate/XY_C1C5/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="配置"> 配置</h2>
<ul>
<li>CPU：MT7621A</li>
<li>内存：512MB DDR3</li>
<li>Flash：32MB</li>
<li>WAN*1 + LAN*4（均为千兆）</li>
<li>USB 3.0*1</li>
<li>SATA*1（支持 SATA3）</li>
<li>DC：12V、1-2A</li>
<li><u>没有无线</u></li>
</ul>
<h2 id="材料准备"> 材料准备</h2>
<div>
<p><img src="./assets/XY_cl.png" alt="img" loading="lazy"></p>
</div>
<p>图纸来自于矿渣社区，有好几个版本，看上去有点乱，于是参考图纸重新画了，如下图所示。</p>
<div>
<p><img src="./assets/XY_tz.png" alt="img" loading="lazy"></p>
</div>
<p>以上物品，自行购买</p>
<p><em>淘宝定制亚克力：<u>金亿有机玻璃制品厂</u>，个人推荐非广告，找了好多家，只有他家最便宜，定制过好多次，人也爽快，服务也好</em></p>
<h2 id="组装前准备"> 组装前准备</h2>
<p>材料齐全之后，首先要对小娱的电路部分改装，主要分两块，一个是电源，一个是风扇，注意导线的长短适当。</p>
<h3 id="电源部分"> 电源部分</h3>
<p>把导线焊接到 DC 电源母座，短脚为正接红线，长脚为负接黑线。（主板端暂时不接，导线的另一端链接主板的 12V 端口上，主板 12V 电源端口有4个，上面有标正负，两个正两个负，只要正负接对了就没问题）</p>
<div>
<p><img src="./assets/XY_dc.png" alt="img" loading="lazy"></p>
<p>电源接口</p>
</div>
<h3 id="风扇部分"> 风扇部分</h3>
<p>主板 USB3.0 接口处的背面，有一排 4 个脚针的最外端的两个脚针，如图分别是 5V 的正负极，如下图，把散热风扇的红线接正极，黑线接负极。</p>
<div>
<p><img src="./assets/XY_fs.png" alt="img" loading="lazy"></p>
<p>风扇连接</p>
</div>
<h2 id="开始组装"> 开始组装</h2>
<ol>
<li>把焊接好的 DC 电源口安装到带网口的面板上（注意正反面）</li>
</ol>
<div>
<p><img src="./assets/XY_zz_1.png" alt="img" loading="lazy"></p>
</div>
<ol start="2">
<li>将 M3*5+4 单通铜柱固定在底板安装孔位置 （4 个）</li>
</ol>
<div>
<p><img src="./assets/XY_zz_2.png" alt="img" loading="lazy"></p>
</div>
<ol start="3">
<li>先卡好主板和网口面板，然后再把主板和底板固定好（固定前最好把所有导线理好），再固定风扇到风扇面板，将风扇面板卡到底板上（按装过程忘了拍这几步骤的照片）</li>
</ol>
<div>
<p><img src="./assets/XY_zz_3.png" alt="img" loading="lazy"></p>
</div>
<ol start="4">
<li>SATA 延长线接到主板 SATA 口上</li>
</ol>
<div>
<p><img src="./assets/XY_zz_4.png" alt="img" loading="lazy"></p>
</div>
<ol start="5">
<li>再将两个侧板卡上去</li>
</ol>
<div>
<p><img src="./assets/XY_zz_5.png" alt="img" loading="lazy"></p>
</div>
<ol start="6">
<li>把 2.5 寸硬盘固定到顶板上，注意硬盘和板之间用一个 M3 尼龙垫片垫着，一是为了让 SATA 线能够接上，不会卡住，二是利于散热。</li>
</ol>
<div>
<p><img src="./assets/XY_zz_6.png" alt="img" loading="lazy"></p>
</div>
<ol start="7">
<li>SATA 延长线有点硬，先折好弯度，方便顶板的固定</li>
</ol>
<div>
<p><img src="./assets/XY_zz_7.png" alt="img" loading="lazy"></p>
</div>
<ol start="8">
<li>连接上 SATA 线和硬盘</li>
</ol>
<div>
<p><img src="./assets/XY_zz_8.png" alt="img" loading="lazy"></p>
</div>
<ol start="9">
<li>固定顶板，完工</li>
</ol>
<div>
<p><img src="./assets/XY_zz_9.png" alt="img" loading="lazy"></p>
</div>
<p>下面几张是完工效果图</p>
<div>
<p><img src="./assets/XY_zz_10.png" alt="img" loading="lazy"></p>
<p><img src="./assets/XY_zz_11.png" alt="img" loading="lazy"></p>
<p><img src="./assets/XY_zz_12.png" alt="img" loading="lazy"></p>
</div>
<p>至此，小娱 C1 亚克力外壳改装结束</p>
<h2 id="相关文件"> 相关文件</h2>
<p>链接: <a href="https://pan.baidu.com/s/1-esHAm9bmaPJpx-TTSa4WQ" target="_blank" rel="noopener noreferrer">https://pan.baidu.com/s/1-esHAm9bmaPJpx-TTSa4WQ</a></p>
<p>提取码: d7cc</p>
<h2 id="本文参考"> 本文参考</h2>
<p><a href="https://post.smzdm.com/p/a07o89z9/" target="_blank" rel="noopener noreferrer">https://post.smzdm.com/p/a07o89z9/</a></p>
<p><a href="https://post.smzdm.com/p/alpo9wq0/" target="_blank" rel="noopener noreferrer">https://post.smzdm.com/p/alpo9wq0/</a></p>
<p><a href="http://bbs.nas66.com/thread-588-1-4.html?_dsign=06917c02" target="_blank" rel="noopener noreferrer">http://bbs.nas66.com/thread-588-1-4.html?_dsign=06917c02</a></p>
<p>以及参考于恩山论坛，矿渣社区（不记得具体是哪个帖子）</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2020-04-27T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">【小娱C1C5】刷机</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/operate/XY_C1C5_sj/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/operate/XY_C1C5_sj/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="外观配置"> 外观配置</h2>
<h3 id="外观图片"> 外观图片</h3>
<div>
<p><img src="./assets/XY_sj_wg1.png" alt="img" loading="lazy"></p>
<p><img src="./assets/XY_sj_wg2.png" alt="img" loading="lazy"></p>
<p><img src="./assets/XY_sj_wg3.png" alt="img" loading="lazy"></p>
<p><img src="./assets/XY_sj_wg4.png" alt="img" loading="lazy"></p>
<p><img src="./assets/XY_sj_wg5.png" alt="img" loading="lazy"></p>
</div>
<h3 id="配置参数"> 配置参数</h3>
<ul>
<li>
<p>CPU：MT7621A</p>
</li>
<li>
<p>网口：LAN * 4 + WAN * 1（全千兆）</p>
</li>
<li>
<p>USB 3.0 * 1</p>
</li>
<li>
<p>内置一个 SATA 接口（支持 SATA3）</p>
</li>
<li>
<p>电源 12V1A</p>
</li>
<li>
<p>内存：512MB</p>
</li>
<li>
<p>Flash：32MB</p>
</li>
</ul>
<h2 id="刷机过程"> 刷机过程</h2>
<h3 id="刷入-breed"> 刷入 breed</h3>
<p>首先给小娱通电，网线连接小娱 LAN口 和电脑网口，确认电脑网络已经正常连接到小娱，可看电脑 IP 是否为192.168.188.X（X为0-255之间但不为1，不是的话需要手动更改）</p>
<p>下载大佬的一键刷入 breed 工具并解压</p>
<div>
<p><img src="./assets/XY_sj1.png" alt="img" loading="lazy"></p>
</div>
<p>打开 <u>XiaoYu_C5_breed.exe</u> 刷机工具，点击 <kbd>刷入breed</kbd> 按钮，等待刷机完成</p>
<ul>
<li>小娱 IP 地址：192.168.188.1</li>
<li>小娱密码：admin</li>
</ul>
<div>
<p><img src="./assets/XY_sj2.png" alt="img" loading="lazy"></p>
</div>
<p>跳出下图说明刷入成功</p>
<div>
<p><img src="./assets/XY_sj3.png" alt="img" loading="lazy"></p>
</div>
<h3 id="进入-breed"> 进入 breed</h3>
<p>刷第三方固件首先要进入 breed，进入 breed 顺序如下</p>
<ol>
<li>
<p>拔掉电源</p>
</li>
<li>
<p>按住Reset键不放</p>
</li>
<li>
<p>接通电源</p>
</li>
<li>
<p>六秒左右松开 Reset 键</p>
</li>
<li>
<p>浏览器访问：192.168.1.1 进入 <u>Breed Web 恢复控制台</u></p>
</li>
</ol>
<div>
<p><img src="./assets/XY_sj4.png" alt="img" loading="lazy"></p>
</div>
<h3 id="刷第三方固件"> 刷第三方固件</h3>
<p>进入 <u>Breed Web 恢复控制台</u>后，按下图顺序进行刷入第三方固件（以H大老毛子固件为例）</p>
<p>选择文件 <u>MT7621_7603_7612_512M_3.4.3.9-099.trx</u></p>
<div>
<p><img src="./assets/XY_sj5.png" alt="img" loading="lazy"></p>
</div>
<p>点击上传后，提示正在更新，注意过程中不要断开电源，等待更新完成</p>
<div>
<p><img src="./assets/XY_sj6.png" alt="img" loading="lazy"></p>
</div>
<p>更新成功后，等待两分钟左右，路由会重启完成，此时再浏览器访问老毛子管理后台</p>
<ul>
<li>
<p>老毛子 IP：192.168.123.1</p>
</li>
<li>
<p>账号：admin</p>
</li>
<li>
<p>密码：admin</p>
</li>
</ul>
<p>至此，小娱小娱路由器刷机完成。</p>
<h2 id="补充"> 补充</h2>
<p>如果无法完成一键刷入 Breed</p>
<p>请参考 <a href="http://www.myzaker.com/article/5e6e2febb15ec077a83269c4" target="_blank" rel="noopener noreferrer">http://www.myzaker.com/article/5e6e2febb15ec077a83269c4</a></p>
<h2 id="相关文件"> 相关文件</h2>
<p>链接: <a href="https://pan.baidu.com/s/1-esHAm9bmaPJpx-TTSa4WQ" target="_blank" rel="noopener noreferrer">https://pan.baidu.com/s/1-esHAm9bmaPJpx-TTSa4WQ</a></p>
<p>提取码: d7cc</p>
<h2 id="本文参考"> 本文参考</h2>
<p><a href="https://www.acwifi.net/9335.html" target="_blank" rel="noopener noreferrer">https://www.acwifi.net/9335.html</a></p>
<p><a href="http://www.myzaker.com/article/5e6e2febb15ec077a83269c4" target="_blank" rel="noopener noreferrer">http://www.myzaker.com/article/5e6e2febb15ec077a83269c4</a></p>
<p><a href="https://post.smzdm.com/p/a07o89z9/" target="_blank" rel="noopener noreferrer">https://post.smzdm.com/p/a07o89z9/</a></p>
<p><a href="https://post.smzdm.com/p/aoowedwn/" target="_blank" rel="noopener noreferrer">https://post.smzdm.com/p/aoowedwn/</a></p>
<p>以及恩山论坛，矿渣社区</p>
<p>部分图片没来得及拍，借用以上参考文章或帖子的图片，如有侵权请联系删除。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2020-04-27T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">【贝壳云】改造计划</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/operate/bky_P1/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/operate/bky_P1/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>前段时间在网上看到了关于矿渣贝壳云的玩法，灯大的小钢炮固件以及亚克力外壳改造，心动了，手痒了。于是准备对它下手了。</p>
<h2 id="配置"> 配置</h2>
<p>贝壳云是一款矿难机，配置如下：</p>
<ul>
<li>RK3328 四核 A53 1.5Ghz</li>
<li>1G DDR3</li>
<li>8G emmc</li>
<li>USB3.0 x 4</li>
<li>千兆有线网口</li>
<li>HDMI 高清接口</li>
</ul>
<h2 id="刷机"> 刷机</h2>
<p>关于刷机，我就不多说了，网上好多教程</p>
<p><a href="https://www.jianshu.com/p/21d3954231dc" target="_blank" rel="noopener noreferrer">刷机教程</a></p>
<p><a href="http://www.wdmomo.fun:81/doc/web/#/5" target="_blank" rel="noopener noreferrer">各种固件</a></p>
<p><a href="http://rom.nanodm.net/beikeyun/" target="_blank" rel="noopener noreferrer">灯大的小钢炮固件</a></p>
<p>小钢炮用这个包：rk3328-beikeyun-linux-hacklog-20190506-0242-freq-limited.7z</p>
<h2 id="图纸"> 图纸</h2>
<p>网上找到相关图纸，加入了自己的一些想法修改图纸，然后开始定制亚克力盒子，买各种工具小部件，M3 铜柱，螺丝螺母，USB 母口，拨动开关等等，后面会详细整理一下所需的材料。（安装需要有一定的动手能力，我焊接几个触点用了好长时间，手抖，哈哈！）</p>
<div>
<p><img src="./assets/bky_tz.png" alt="img" loading="lazy"></p>
<p>贝壳云盒子图纸</p>
<p><img src="./assets/bky_tz_2.5.png" alt="img" loading="lazy"></p>
<p>2.5 寸硬盘支架图纸</p>
</div>
<h2 id="材料"> 材料</h2>
<div>
<p><img src="./assets/bky_cl.png" alt="img" loading="lazy"></p>
<p>材料</p>
<p><img src="./assets/bky_ykl.png" alt="img" loading="lazy"></p>
<p>根据图纸制作的亚克力板子</p>
</div>
<div><p>说明</p>
<p>安装盒子之前，先把贝壳云刷成第三方系统再安装，具体原因请看本文最后的关于刷机内容。</p>
<p>由于作文水平太低，只好用看图写话的方式描述安装过程。</p>
</div>
<h2 id="安装过程"> 安装过程</h2>
<h3 id="接线"> 接线</h3>
<div>
<p><img src="./assets/bky_usb.png" alt="img" loading="lazy"></p>
<p>USB 母口接线</p>
<p><img src="./assets/bky_fs.png" alt="img" loading="lazy"></p>
<p>主板风扇接线</p>
<p><img src="./assets/bky_fst.png" alt="img" loading="lazy"></p>
<p>风扇接线电路图（灵魂画手）</p>
</div>
<h3 id="组装"> 组装</h3>
<p>接线完成后，就开始组装盒子了。</p>
<div><p>说明</p>
<p>此顺序是我自己组装的顺序，建议大家按照图 3→ 4→ 5→ 1→ 2 顺序安装</p>
</div>
<ol>
<li>安装USB母口</li>
</ol>
<div>
<p><img src="./assets/bky_az_1.png" alt="img" loading="lazy"></p>
</div>
<ol start="2">
<li>安装开关</li>
</ol>
<div>
<p><img src="./assets/bky_az_2.png" alt="img" loading="lazy"></p>
</div>
<ol start="3">
<li>对准接口</li>
</ol>
<div>
<p><img src="./assets/bky_az_3.png" alt="img" loading="lazy"></p>
</div>
<ol start="4">
<li>底板准备工作</li>
</ol>
<div>
<p><img src="./assets/bky_az_4.png" alt="img" loading="lazy"></p>
</div>
<div><p>注意</p>
<p>如果你的主板固定孔和底板对不齐的话，请把底板翻过来，它并不是对称的，要分正反左右的</p>
</div>
<ol start="5">
<li>固定主板</li>
</ol>
<div>
<p><img src="./assets/bky_az_5.png" alt="img" loading="lazy"></p>
</div>
<ol start="6">
<li>安装两侧板</li>
</ol>
<div>
<p><img src="./assets/bky_az_6.png" alt="img" loading="lazy"></p>
</div>
<ol start="7">
<li>安装前面板</li>
</ol>
<div>
<p><img src="./assets/bky_az_7.png" alt="img" loading="lazy"></p>
</div>
<ol start="8">
<li>把灯板安装到顶板上</li>
</ol>
<div>
<p><img src="./assets/bky_az_8.png" alt="img" loading="lazy"></p>
</div>
<ol start="9">
<li>把风扇安装到顶板上</li>
</ol>
<div>
<p><img src="./assets/bky_az_9.png" alt="img" loading="lazy"></p>
</div>
<ol start="10">
<li>固定顶板</li>
</ol>
<div>
<p><img src="./assets/bky_az_10.png" alt="img" loading="lazy"></p>
</div>
<h2 id="关于刷机"> 关于刷机</h2>
<div>
<p><img src="./assets/bky_sj.png" alt="img" loading="lazy"></p>
</div>
<p>经过上面的看图写话，相信大家应该已经了然于胸了。</p>
<p>之后会测试 2.5 寸硬盘和贝壳云合体的支架，支架已定制，期待它的到来，我将尝试一下效果怎么样。</p>
<hr>
<h2 id="追加"> 追加</h2>
<p><u>更新于2020.3.21</u></p>
<p>贝壳云可合体 2.5寸 硬盘支架安装效果</p>
<div>
<p><img src="./assets/bky_hz+2.5disk_1.png" alt="img" loading="lazy"></p>
<p><img src="./assets/bky_hz+2.5disk_2.png" alt="img" loading="lazy"></p>
<p><img src="./assets/bky_hz+2.5disk_3.png" alt="img" loading="lazy"></p>
<p><img src="./assets/bky_hz+2.5disk_4.png" alt="img" loading="lazy"></p>
<p><img src="./assets/bky_hz+2.5disk_5.png" alt="img" loading="lazy"></p>
</div>
<h2 id="相关文件"> 相关文件</h2>
<p>最后给上相关文件链接</p>
<p>链接: <a href="https://pan.baidu.com/s/17Vz-wVCsXUd6HK8S81RtFw" target="_blank" rel="noopener noreferrer">https://pan.baidu.com/s/17Vz-wVCsXUd6HK8S81RtFw</a></p>
<p>提取码: m6ve</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2020-03-18T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">【openwrt】编译F大N1固件</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/operate/flippy_openWRT/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/operate/flippy_openWRT/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="所需文件"> 所需文件</h2>
<ul>
<li>
<p>Flippy预编译好的 Arm64 内核（3个文件 boot、dtb、modules）</p>
<p>下载地址：<a href="https://pan.baidu.com/s/19KNVcCQL57mvpiboFc-5rA" target="_blank" rel="noopener noreferrer">https://pan.baidu.com/s/19KNVcCQL57mvpiboFc-5rA</a> 提取码：hk6x</p>
</li>
<li>
<p>自己编译的 openwrt rootfs tar.gz 包</p>
<ul>
<li>openwrt-armvirt-64-default-rootfs.tar.gz</li>
</ul>
</li>
</ul>
<h2 id="准备环境"> 准备环境</h2>
<ul>
<li>
<p>linux 环境（这里以 Ubuntu 20.04 为工作环境）</p>
</li>
<li>
<p>预先安装软件包。</p>
<p>losetup、lsblk(版本&gt;=2.33)、blkid、uuidgen、fdisk、parted、mkfs.vfat、mkfs.ext4、mkfs.btrfs (列表不一定完整，打包过程中若发生错误，请自行检查输出结果并添加缺失的命令）</p>
</li>
</ul>
<h2 id="openwrt-编译"> OpenWRT 编译</h2>
<p>关于编译，请参考此篇文章：<a href="https://ryukarin.github.io/blog/operate/openwrt/" target="_blank" rel="noopener noreferrer">https://ryukarin.github.io/blog/operate/openwrt/</a></p>
<p><strong>编译注意事项：</strong></p>
<div><pre><code>Target System  -&gt;  QEMU ARM Virtual Machine 
Subtarget -&gt;  QEMU ARMv8 Virtual Machine (cortex-a53)
Target Profile  -&gt;  Default
Target Images  -&gt;   tar.gz
*** 必选软件包(基础依赖包，仅保证打出的包可以写入EMMC,可以在EMMC上在线升级，不包含具体的应用)： 
Languages -&gt; Perl               
             -&gt;  perl-http-date
             -&gt;  perlbase-getopt
             -&gt;  perlbase-time
             -&gt;  perlbase-unicode                              
             -&gt;  perlbase-utf8        
Utilities -&gt; Disc -&gt; blkid、fdisk、lsblk、parted            
          -&gt; Filesystem -&gt; attr、btrfs-progs(Build with zstd support)、chattr、dosfstools、
                           e2fsprogs、f2fs-tools、f2fsck、lsattr、mkf2fs、xfs-fsck、xfs-mkfs
          -&gt; Compression -&gt; bsdtar 或 p7zip(非官方源)、pigz
          -&gt; Shells  -&gt;  bash         
          -&gt; gawk、getopt、losetup、tar、uuidgen

 * (可选)Wifi基础包：
 *     打出的包可支持博通SDIO无线模块,Firmware不用选，
 *     因为打包源码中已经包含了来自Armbian的firmware，
 *     会自动覆盖openwrt rootfs中已有的firmware
 Kernel modules  -&gt;   Wireless Drivers -&gt; kmod-brcmfmac(SDIO) 
                                       -&gt; kmod-brcmutil
                                       -&gt; kmod-cfg80211
                                       -&gt; kmod-mac80211
 Network  -&gt;  WirelessAPD -&gt; hostpad-common
                          -&gt; wpa-cli
                          -&gt; wpad-basic
          -&gt;  iw
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p><strong>除上述必选项以外的软件包可以按需自主选择。</strong></p>
<ul>
<li>
<p>编译完成后输出路径：<code>lede/bin/targets/armvirt/64/</code></p>
</li>
<li>
<p>固件文件名：<code>openwrt-armvirt-64-default-rootfs.tar.gz</code></p>
</li>
</ul>
<h2 id="编译-phicomm-n1-固件"> 编译 Phicomm_N1 固件</h2>
<ol>
<li>
<p>新建工作目录</p>
<div><pre><code>$ <span>mkdir</span> openwrt_arm
$ <span>cd</span> openwrt_arm
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>放置内核文件</p>
<div><pre><code>$ <span>mkdir</span> kernel
<span>#在openwrt_arm下新建kernel目录，并放入Flippy预编译好的Arm64内核（3个相同版本号）</span>
<span># boot-5.4.159-flippy-67+o.tar.gz</span>
<span># dtb-amlogic-5.4.159-flippy-67+o.tar.gz</span>
<span># modules-5.4.159-flippy-67+o.tar.gz</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p>git clone 项目</p>
<div><pre><code>$ <span>git</span> clone https://github.com/unifreq/openwrt_packit
$ <span>ls</span> -l
总用量 <span>12</span>
drwxrwxr-x  <span>2</span> karin karin <span>4096</span> <span>11</span>月 <span>16</span> <span>14</span>:59 kernel
drwxrwxr-x <span>19</span> karin karin <span>4096</span> <span>11</span>月 <span>16</span> <span>14</span>:08 lede
drwxrwxr-x  <span>6</span> karin karin <span>4096</span> <span>11</span>月 <span>16</span> <span>14</span>:54 openwrt_packit
<span>#把编译好的openwrt-armvirt-64-default-rootfs.tar.gz上传至openwrt_arm/openwrt_packit/目录中</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>
<p>修改环境</p>
<div><pre><code>$ <span>cd</span> openwrt_packit
$ gedit make.env
<span>#根据提示，修改WHOAMI，KERNEL_VERSION，KERNEL_PKG_HOME</span>
<span># WHOAMI是打包者的名字</span>
<span># KERNEL_VERSION是Flippy预编译好的Arm64内核的版本，选择对应的版本，其他注释，没有对应版本则修改</span>
<span># KERNEL_PKG_HOME是Flippy预编译好的Arm64内核文件所在目录</span>
<span>#修改完成之后保存</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><img src="./assets/flippy_openwrt.png" alt="" loading="lazy"></p>
</li>
<li>
<p>执行打包脚本</p>
<div><pre><code>$ <span>sudo</span> ./mk_s905d_n1.sh 
<span># ./mk_xxx.sh</span>
<span># xxx指代你想要生成的固件对应的芯片型号或设备型号</span>
<span># 如下信息表示镜像固件已经生成</span>
镜像已生成<span>!</span> 存放在 /home/karin/openwrt_arm/openwrt_packit/output/ 下面<span>!</span>
<span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span> end ./mk_s905d_n1.sh <span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
</ol>
<p>参考：</p>
<p><a href="https://github.com/unifreq/openwrt_packit" target="_blank" rel="noopener noreferrer">https://github.com/unifreq/openwrt_packit</a></p>
<p>其他盒子固件的编译方法类似（如贝壳云等）</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2020-06-30T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">【bootimg】解包打包</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/operate/mkbootimg/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/operate/mkbootimg/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>关于 kernel.img 系统内核文件，我们该如何去修改呢？一般此类型文件是很难打开或挂载的，那么就没有办法修改了吗，经过几天的查资料，其实也不难。对安卓开发的大神来说，那是轻而易举的，但对于没有开发经验的来说就比较困难了。</p>
<p>好了，下面直接把我折腾的内容整理一下。</p>
<h2 id="解压-kernel-img-文件"> 解压 kernel.img 文件</h2>
<h3 id="查看文件类型"> 查看文件类型</h3>
<p>要想解压某个文件，首先要知道该文件是什么类型的。用 <code>file</code> 命令查看一下 <code>kernel.img</code> 文件的类型。</p>
<div><pre><code>img$ <span>file</span> kernel.img
kernel.img: Android bootimg, kernel <span>(</span>0x1080000<span>)</span>, ramdisk <span>(</span>0x1000000<span>)</span>, page size: <span>2048</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>由此可知，这是 Android bootimg 文件类型。那么，怎么解压呢？</p>
<h3 id="下载工具并解压"> 下载工具并解压</h3>
<p>在网上查找了相关资料，需要 <code>unpackbootimg</code> 解包命令，<code>mkbootimg</code> 打包命令。那这两个命令系统并没有，需要自行下载。</p>
<div><pre><code><span># 下载项目 android-unpackbootimg</span>
img$ <span>git</span> clone https://github.com/anestisb/android-unpackbootimg.git bootimg
img.git bootimg
正克隆到 <span>'bootimg'</span><span>..</span>.
remote: Enumerating objects: <span>50</span>, done.
remote: Total <span>50</span> <span>(</span>delta <span>0</span><span>)</span>, reused <span>0</span> <span>(</span>delta <span>0</span><span>)</span>, pack-reused <span>50</span>
展开对象中: <span>100</span>% <span>(</span><span>50</span>/50<span>)</span>, 完成.
img$ <span>cd</span> bootimg

<span># 编译此项目，会多出两个可执行文件 mkbootimg、unpackbootimg</span>
img/bootimg$ <span>make</span>
<span>..</span>.
cc -O2 -Wall -Werror -Wno-address-of-packed-member -Iinclude -o mkbootimg mkbootimg.c  -L. -lmincrypt
cc -O2 -Wall -Werror -Wno-address-of-packed-member -Iinclude -o unpackbootimg unpackbootimg.c  -L. -lmincrypt

<span># 返回上级目录并查看文件列表</span>
img/bootimg$ <span>cd</span> <span>..</span> <span>&amp;&amp;</span> <span>ls</span> -l
drwxrwxr-x <span>5</span> kei kei     <span>4096</span> <span>9</span>月  <span>15</span> <span>11</span>:01 bootimg
-rw-r--r-- <span>1</span> kei kei <span>16543744</span> <span>9</span>月  <span>15</span> <span>14</span>:15 kernel.img

<span>#新建boot目录，把 kernel.img 解压缩到 boot 目录</span>
img$ <span>mkdir</span> boot
img$ <span>cd</span> bootimg/
img/bootimg$ ./unpackbootimg -i <span>..</span>/kernel.img -o <span>..</span>/boot
BOARD_KERNEL_CMDLINE 
BOARD_KERNEL_BASE 01078000
BOARD_NAME 
BOARD_PAGE_SIZE <span>2048</span>
BOARD_HASH_TYPE sha1
BOARD_KERNEL_OFFSET 00008000
BOARD_RAMDISK_OFFSET fff88000
BOARD_SECOND_OFFSET ffe88000
BOARD_TAGS_OFFSET fef88100
<span># 解压缩完成</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><div><p>补充</p>
<p><code>mkbootimg</code>、<code>unpackbootimg</code> 命令工具使用方法</p>
<div><pre><code>$ ./unpackbootimg
usage: unpackbootimg
  -i|--input boot.img
  [ -o|--output output_directory]
  [ -p|--pagesize &lt;size-in-hexadecimal&gt; ]
$ ./mkbootimg
usage: mkbootimg
       --kernel &lt;filename&gt;
       [ --ramdisk &lt;filename&gt; ]
       [ --second &lt;2ndbootloader-filename&gt; ]
       [ --cmdline &lt;kernel-commandline&gt; ]
       [ --board &lt;boardname&gt; ]
       [ --base &lt;address&gt; ]
       [ --pagesize &lt;pagesize&gt; ]
       [ --dt &lt;filename&gt; ]
       [ --kernel_offset &lt;base offset&gt; ]
       [ --ramdisk_offset &lt;base offset&gt; ]
       [ --second_offset &lt;base offset&gt; ]
       [ --tags_offset &lt;base offset&gt; ]
       [ --os_version &lt;A.B.C version&gt; ]
       [ --os_patch_level &lt;YYYY-MM-DD date&gt; ]
       [ --hash &lt;sha1(default)|sha256&gt; ]
       [ --id ]
       -o|--output &lt;filename&gt;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div></div>
<h3 id="查看解压后的文件"> 查看解压后的文件</h3>
<div><pre><code>img/bootimg$ <span>cd</span> <span>..</span>/boot
img/boot$ <span>ls</span> -lh
总用量 17M
-rw-rw-r-- <span>1</span> kei kei    <span>9</span> <span>9</span>月  <span>15</span> 09:52 kernel.img-base
-rw-rw-r-- <span>1</span> kei kei    <span>1</span> <span>9</span>月  <span>15</span> 09:52 kernel.img-board
-rw-rw-r-- <span>1</span> kei kei    <span>1</span> <span>9</span>月  <span>15</span> 09:52 kernel.img-cmdline
-rw-rw-r-- <span>1</span> kei kei    <span>5</span> <span>9</span>月  <span>15</span> 09:52 kernel.img-hash
-rw-rw-r-- <span>1</span> kei kei    <span>9</span> <span>9</span>月  <span>15</span> 09:52 kernel.img-kerneloff
-rw-rw-r-- <span>1</span> kei kei    <span>5</span> <span>9</span>月  <span>15</span> 09:52 kernel.img-pagesize
-rw-rw-r-- <span>1</span> kei kei <span>5</span>.3M <span>9</span>月  <span>15</span> 09:52 kernel.img-ramdisk.gz
-rw-rw-r-- <span>1</span> kei kei    <span>9</span> <span>9</span>月  <span>15</span> 09:52 kernel.img-ramdiskoff
-rw-rw-r-- <span>1</span> kei kei    <span>9</span> <span>9</span>月  <span>15</span> 09:52 kernel.img-secondoff
-rw-rw-r-- <span>1</span> kei kei    <span>9</span> <span>9</span>月  <span>15</span> 09:52 kernel.img-tagsoff
-rw-rw-r-- <span>1</span> kei kei  12M <span>9</span>月  <span>15</span> 09:52 kernel.img-zImage

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>有两个文件比较大：</p>
<ul>
<li>kernel.img-ramdisk.gz：根文件系统</li>
<li>kernel.img-zImage：Linux 内核 zImage</li>
</ul>
<div><pre><code><span># 查看这两个文件类型</span>
img/boot$ <span>file</span> kernel.img-ramdisk.gz 
kernel.img-ramdisk.gz: ASCII cpio archive <span>(</span>SVR4 with no CRC<span>)</span>
<span>#cpio格式的文件</span>
img/boot$ <span>file</span> kernel.img-zImage 
kernel.img-zImage: lzop compressed data - version <span>1.030</span>, LZO1X-999, os: Unix
<span>#lzop压缩的文件</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><p>说明</p>
<p>zImage 内核文件，一般不建议修改；但是 ramdisk 根文件系统是可以根据需要适当的修改。</p>
</div>
<h2 id="修改-ramdisk"> 修改 ramdisk</h2>
<p>kernel.img-ramdisk.gz 映像是一个最基础的小型文件系统，它包括了初始化系统所需要的全部核心文件，例如：初始化 init 进程以及 init.rc（可以用于设置很多系统的参数）等文件。我们怎么去修改它呢？</p>
<h3 id="挂载修改"> 挂载修改</h3>
<p>上面查了它是 cpio 格式的文件，那么我们就用 <code>cpio</code> 进行挂载。</p>
<div><pre><code><span># 首先，新建一个目录，用于挂载 kernel.img-ramdisk.gz</span>
img/boot$ <span>mkdir</span> kernel.img-ramdisk
img/boot$ <span>cd</span> kernel.img-ramdisk/

<span># cpio 命令进行挂载</span>
img/boot/kernel.img-ramdisk$ <span>sudo</span> cpio -i -F <span>..</span>/kernel.img-ramdisk.gz
<span>10696</span> 块

<span># 挂载成功后，查看文件列表</span>
img/boot/kernel.img-ramdisk$ <span>ls</span> -l
总用量 <span>64</span>
lrwxrwxrwx <span>1</span> root root     <span>8</span> <span>9</span>月  <span>15</span> <span>10</span>:00 bin -<span>></span> /usr/bin
drwxrwxr-x <span>2</span> root root  <span>4096</span> <span>9</span>月  <span>15</span> <span>10</span>:00 dev
drwxrwxr-x <span>2</span> root root  <span>4096</span> <span>9</span>月  <span>15</span> <span>10</span>:00 etc
-rwxr-xr-x <span>1</span> root root  <span>3879</span> <span>9</span>月  <span>15</span> <span>10</span>:00 functions
-rwxr-xr-x <span>1</span> root root <span>38051</span> <span>9</span>月  <span>15</span> <span>10</span>:00 init
lrwxrwxrwx <span>1</span> root root     <span>8</span> <span>9</span>月  <span>15</span> <span>10</span>:00 lib -<span>></span> /usr/lib
-rwxr-xr-x <span>1</span> root root  <span>2411</span> <span>9</span>月  <span>15</span> <span>10</span>:00 platform_init
lrwxrwxrwx <span>1</span> root root     <span>9</span> <span>9</span>月  <span>15</span> <span>10</span>:00 sbin -<span>></span> /usr/sbin
drwxrwxr-x <span>2</span> root root  <span>4096</span> <span>9</span>月  <span>15</span> <span>10</span>:00 splash
drwxrwxr-x <span>6</span> root root  <span>4096</span> <span>9</span>月  <span>15</span> <span>10</span>:00 usr
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>然后，我们进入挂载的目录中，对需要改动的文件进行修改或替换等。（可能需要 sudo 权限）</p>
<h3 id="压缩还原"> 压缩还原</h3>
<div><pre><code><span># 先对原先的kernel.img-ramdisk.gz做个备份（改名）</span>
img/boot/kernel.img-ramdisk$ <span>mv</span> <span>..</span>/kernel.img-ramdisk.gz <span>..</span>/kernel.img-ramdisk.gz.bk

<span># 用 cpio 命令进行打包</span>
img/boot/kernel.img-ramdisk$ <span>find</span> <span>.</span> <span>|</span> cpio -o -H newc <span>></span> <span>..</span>/kernel.img-ramdisk.gz
<span>10696</span> 块

<span># 返回上一级目录，查看生成的文件</span>
img/boot/kernel.img-ramdisk$ <span>cd</span> <span>..</span> <span>&amp;&amp;</span> <span>ls</span> -l
总用量 <span>22116</span>
-rw-rw-r-- <span>1</span> kei kei        <span>9</span> <span>9</span>月  <span>15</span> 09:52 kernel.img-base
-rw-rw-r-- <span>1</span> kei kei        <span>1</span> <span>9</span>月  <span>15</span> 09:52 kernel.img-board
-rw-rw-r-- <span>1</span> kei kei        <span>1</span> <span>9</span>月  <span>15</span> 09:52 kernel.img-cmdline
-rw-rw-r-- <span>1</span> kei kei        <span>5</span> <span>9</span>月  <span>15</span> 09:52 kernel.img-hash
-rw-rw-r-- <span>1</span> kei kei        <span>9</span> <span>9</span>月  <span>15</span> 09:52 kernel.img-kerneloff
-rw-rw-r-- <span>1</span> kei kei        <span>5</span> <span>9</span>月  <span>15</span> 09:52 kernel.img-pagesize
drwxrwxr-x <span>6</span> kei kei     <span>4096</span> <span>9</span>月  <span>15</span> <span>10</span>:00 kernel.img-ramdisk
-rw-rw-r-- <span>1</span> kei kei  <span>5476352</span> <span>9</span>月  <span>15</span> <span>10</span>:05 kernel.img-ramdisk.gz
-rw-rw-r-- <span>1</span> kei kei  <span>5476352</span> <span>9</span>月  <span>15</span> 09:52 kernel.img-ramdisk.gz.bk
-rw-rw-r-- <span>1</span> kei kei        <span>9</span> <span>9</span>月  <span>15</span> 09:52 kernel.img-ramdiskoff
-rw-rw-r-- <span>1</span> kei kei        <span>9</span> <span>9</span>月  <span>15</span> 09:52 kernel.img-secondoff
-rw-rw-r-- <span>1</span> kei kei        <span>9</span> <span>9</span>月  <span>15</span> 09:52 kernel.img-tagsoff
-rw-rw-r-- <span>1</span> kei kei <span>11652817</span> <span>9</span>月  <span>15</span> 09:52 kernel.img-zImage
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id="打包还原-kernel-img"> 打包还原 kernel.img</h2>
<h3 id="查看解包信息"> 查看解包信息</h3>
<div><pre><code><span># 成功生成 kernel.img-ramdisk.gz，那么原先的备份就不需要了，可以删除或移到其他位置</span>
img/boot$ <span>rm</span> kernel.img-ramdisk.gz.bk
img/boot$ <span>ls</span> -l
总用量 <span>16192</span>
-rw-rw-r-- <span>1</span> kei kei        <span>9</span> <span>9</span>月  <span>15</span> 09:52 kernel.img-base
-rw-rw-r-- <span>1</span> kei kei        <span>1</span> <span>9</span>月  <span>15</span> 09:52 kernel.img-board
-rw-rw-r-- <span>1</span> kei kei        <span>1</span> <span>9</span>月  <span>15</span> 09:52 kernel.img-cmdline
-rw-rw-r-- <span>1</span> kei kei        <span>5</span> <span>9</span>月  <span>15</span> 09:52 kernel.img-hash
-rw-rw-r-- <span>1</span> kei kei        <span>9</span> <span>9</span>月  <span>15</span> 09:52 kernel.img-kerneloff
-rw-rw-r-- <span>1</span> kei kei        <span>5</span> <span>9</span>月  <span>15</span> 09:52 kernel.img-pagesize
-rw-rw-r-- <span>1</span> kei kei  <span>4887552</span> <span>9</span>月  <span>15</span> <span>10</span>:53 kernel.img-ramdisk.gz
-rw-rw-r-- <span>1</span> kei kei        <span>9</span> <span>9</span>月  <span>15</span> 09:52 kernel.img-ramdiskoff
-rw-rw-r-- <span>1</span> kei kei        <span>9</span> <span>9</span>月  <span>15</span> 09:52 kernel.img-secondoff
-rw-rw-r-- <span>1</span> kei kei        <span>9</span> <span>9</span>月  <span>15</span> 09:52 kernel.img-tagsoff
-rw-rw-r-- <span>1</span> kei kei <span>11652817</span> <span>9</span>月  <span>15</span> 09:52 kernel.img-zImage

<span># 查看解包 kernel.img 的信息</span>
img/boot$ <span>cat</span> kernel.img-base kernel.img-board kernel.img-cmdline kernel.img-hash kernel.img-kerneloff kernel.img-pagesize kernel.img-ramdiskoff kernel.img-secondoff kernel.img-tagsoff
01078000


sha1
00008000
<span>2048</span>
fff88000
ffe88000
fef88100
<span># 查看解包打包参数信息</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h3 id="打包封装"> 打包封装</h3>
<div><pre><code><span># 返回到 kernel.img 所在目录，修改原文件名称，以防原文件被覆盖导致混淆</span>
img/boot$ <span>cd</span> <span>..</span> <span>&amp;&amp;</span> <span>ls</span> -l
drwxrwxr-x <span>2</span> kei kei     <span>4096</span> <span>9</span>月  <span>15</span> <span>14</span>:10 boot
drwxrwxr-x <span>5</span> kei kei     <span>4096</span> <span>9</span>月  <span>15</span> <span>11</span>:01 bootimg
-rw-r--r-- <span>1</span> kei kei <span>16543744</span> <span>9</span>月  <span>15</span> <span>14</span>:15 kernel.img
img$ <span>mv</span> kernel.img kernel.img.bk

<span># 根据上面的参数信息，进行打包封装</span>
img/boot$ <span>..</span>/bootimg/mkbootimg --kernel kernel.img-zImage --ramdisk kernel.img-ramdisk.gz --base 01078000 --kernel_offset 00008000  --ramdisk_offset fff88000 --second_offset ffe88000 --tags_offset fef88100 -o <span>..</span>/kernel.img

<span># 打包封装完成后，返回上一级目录查看</span>
img/boot$ <span>cd</span> <span>..</span>
img$ <span>file</span> kernel.img
kernel.img: Android bootimg, kernel <span>(</span>0x1080000<span>)</span>, ramdisk <span>(</span>0x1000000<span>)</span>, page size: <span>2048</span>
img$ <span>file</span> kernel.img.bk
kernel.img: Android bootimg, kernel <span>(</span>0x1080000<span>)</span>, ramdisk <span>(</span>0x1000000<span>)</span>, page size: <span>2048</span>
<span># 和原版文件的信息对比，一样</span>
<span># kernel.img 为后打包封装的，kernel.img.bk 为原文件</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div>]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-09-15T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">【OpenWRT】固件编译</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/operate/openwrt/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/operate/openwrt/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>此文主要是以 Lean 的 Openwrt 源码编译：<a href="https://github.com/coolsnowwolf/lede" target="_blank" rel="noopener noreferrer">https://github.com/coolsnowwolf/lede</a></p>
<h2 id="固件说明"> 固件说明</h2>
<ul>
<li>
<p>默认登陆 IP：192.168.1.1</p>
</li>
<li>
<p>用户名/密码：root/password</p>
</li>
<li>
<p>插件可自行增加或删减</p>
</li>
</ul>
<div><p>说明</p>
<ul>
<li><strong>不要用 root 用户进行 <code>git</code> 和编译！！！</strong></li>
<li>国内用户编译前最好准备好梯子</li>
</ul>
</div>
<h2 id="环境准备"> 环境准备</h2>
<h3 id="_1、linux-系统"> 1、Linux 系统</h3>
<p>推荐 Ubuntu 18.04 LTS x64，当然其它也可以，本文是基于 Ubuntu 18.04 LTS。</p>
<h3 id="_2、环境搭建"> 2、环境搭建</h3>
<div><pre><code>$ <span>sudo</span> <span>apt-get</span> update
$ <span>sudo</span> <span>apt-get</span> -y <span>install</span> build-essential asciidoc binutils <span>bzip2</span> <span>gawk</span> gettext <span>git</span> libncurses5-dev libz-dev patch python3.5 python2.7 <span>unzip</span> zlib1g-dev lib32gcc1 libc6-dev-i386 subversion flex uglifyjs git-core gcc-multilib p7zip p7zip-full msmtp libssl-dev texinfo libglib2.0-dev xmlto qemu-utils upx libelf-dev autoconf automake libtool autopoint device-tree-compiler g++-multilib antlr3 gperf
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="_3、克隆项目"> 3、克隆项目</h3>
<p>使用下面命令下载好源代码，然后进入 lede 目录</p>
<div><pre><code>$ <span>git</span> clone https://github.com/coolsnowwolf/lede
$ <span>cd</span> lede
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="_4、插件配置"> 4、插件配置</h3>
<p>如果你需要那个什么乳酸菌+，在 lede 路径下，编辑 <code>feeds.conf.default</code> 文件，将里面最后一行开头的注释#删除保存，如果还想要 p@55w@11 插件，在此文件末尾追加下面一行内容。如下图所示。</p>
<div><pre><code>src-git kenzo https://github.com/kenzok8/openwrt-packages			<span>#passwall</span>
src-git small https://github.com/kenzok8/small			<span>#passwall依赖</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><img src="./assets/openwrt_1.png" alt="" loading="lazy"></p>
<h3 id="_5、更新配置"> 5、更新配置</h3>
<p>更新 <code>feeds.conf.default</code> 文件</p>
<div><pre><code>$ ./scripts/feeds update -a
$ ./scripts/feeds <span>install</span> -a
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="开始编译"> 开始编译</h2>
<h3 id="_1、编译配置"> 1、编译配置</h3>
<p>输入下面命令，跳出图形配置界面，根据自己的硬件以及需要的插件，进行配置，配置好选 save，会保存到在 lede 目录下，文件名默认为 <code>.config</code>。（以小娱C1 路由器为例，进行配置）</p>
<div><pre><code>$ <span>make</span> menuconfig
</code></pre>
<div><span>1</span><br></div></div><h3 id="_2、硬件型号选择"> 2、硬件型号选择</h3>
<p>CPU 型号可以参考这里的 <a href="https://openwrt.org/supported_devices" target="_blank" rel="noopener noreferrer">CSV文件</a>，去选择相应的硬件平台型号（小娱C1和C5硬件配置一样）</p>
<p><img src="./assets/openwrt_2.png" alt="" loading="lazy"></p>
<h3 id="_3、主题选择"> 3、主题选择</h3>
<p>进入 LuCI ---&gt; Themes ，选择你想要的主题</p>
<p><img src="./assets/openwrt_3.png" alt="" loading="lazy"></p>
<h3 id="_4、插件配置-2"> 4、插件配置</h3>
<p>进入 LuCI ---&gt; Applications，选择你想要的插件</p>
<p><img src="./assets/openwrt_4.png" alt="" loading="lazy"></p>
<div><p>注意</p>
<p>根据路由器硬件 Flash 的容量大小，插件不要选太多，保证编译出来的固件大小要小于 Flash 的容量，我一开始选了很多插件，编译就失败了，或者即使编译成功了，刷机的时候就会提示容量固件太大了，那么就在要编译的插件选 M，这样就可以让编译出来的固件没那么大了，之后刷机进入 openwrt 再手动安装编译成安装包的插件（当然，我编译小娱C1的 Flash 只有 32M，如果你的 Flash 有 128M，那就无所谓了）</p>
<p><strong>LuCI ---&gt; Applications 添加常用插件及应用说明</strong></p>
<div><pre><code>LuCI ---<span>></span> Applications ---<span>></span> luci-app-accesscontrol  <span>#访问时间控制</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-adbyby-plus  <span>#广告屏蔽大师Plus +</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-aria2 <span># Aria2下载工具</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-arpbind  <span>#IP/MAC绑定</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-autoreboot  <span>#支持计划重启</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-baidupcs-web  <span>#百度网盘管理</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-ddns   <span>#动态域名 DNS（集成阿里DDNS客户端）</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-diskman   <span>#磁盘管理工具</span>
    luci-app-diskman ---<span>></span> Include btrfs-progs   <span>#新型的写时复制 (COW)</span>
    luci-app-diskman ---<span>></span> Include lsblk   <span>#lsblk命令 用于列出所有可用块设备的信息</span>
    luci-app-diskman ---<span>></span> Include <span>mdadm</span>   <span>#mdadm命令 用于创建、管理、监控RAID设备的工具</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-dockerman  <span>#Docker容器 </span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-filetransfer  <span>#文件传输（可web安装ipk包）</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-firewall   <span>#添加防火墙</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-flowoffload  <span>#Turbo ACC网络加速（集成FLOW,BBR,NAT,DNS...</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-frpc   <span>#内网穿透Frp客户端</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-guest-wifi   <span>#WiFi访客网络</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-hd-idle  <span>#硬盘休眠</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-kodexplorer  <span>#KOD可道云私人网盘</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-mwan3   <span>#MWAN3负载均衡</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-mwan3helper   <span>#MWAN3分流助手</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-netdata  <span>#Netdata实时监控（图表）</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-nfs   <span>#NFS网络共享</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-nlbwmon   <span>#网络带宽监视器</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-nps   <span>#内网穿透nps</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-ntpc   <span>#NTP时间同步服务器</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-p910nd   <span>#打印服务器模块</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-passwall  <span>#不解释PassWall</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-qbittorrent  <span>#BT下载工具（qBittorrent）</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-qos   <span>#流量服务质量(QoS)流控</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-ramfree  <span>#释放内存</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-samba   <span>#网络共享（Samba）</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-sfe  <span>#Turbo ACC网络加速（flowoffload二选一）</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-sqm  <span>#流量智能队列管理（QOS）</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-乳酸菌饮料-plus   <span>#乳酸菌饮料低调上网Plus+</span>
    luci-app-乳酸菌饮料-plus ---<span>></span> Include s-s v贰瑞 Plugin  <span>#SS v贰瑞插件</span>
    luci-app-乳酸菌饮料-plus ---<span>></span> Include v贰瑞  <span>#v贰瑞代理</span>
    luci-app-乳酸菌饮料-plus ---<span>></span> Include Trojan  <span>#Trojan代理</span>
    luci-app-乳酸菌饮料-plus ---<span>></span> Include red---socks2  <span>#red---socks2代理 </span>
    luci-app-乳酸菌饮料-plus ---<span>></span> Include Kcptun  <span>#Kcptun加速</span>
    luci-app-乳酸菌饮料-plus ---<span>></span> Include 违禁软件 Server  <span>#乳酸菌饮料服务器</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-statistics  <span>#流量监控工具</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-syncdial  <span>#多拨虚拟网卡（原macvlan）</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-transmission   <span>#BT下载工具</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-ttyd   <span>#网页终端命令行</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-unblockmusic  <span>#解锁网易云灰色歌曲3合1新版本</span>
    UnblockNeteaseMusic Golang Version  <span>#Golang版本</span>
    UnblockNeteaseMusic NodeJS Version  <span>#NodeJS版本</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-upnp   <span>#通用即插即用UPnP（端口自动转发）</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-usb-printer   <span>#USB 打印服务器</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-verysync  <span>#微力同步 </span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-vlmcsd  <span>#KMS服务器设置</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-vnstat   <span>#vnStat网络监控（图表） </span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-vsftpd  <span>#FTP服务器</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-watchcat  <span>#断网检测功能与定时重启</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-webadmin  <span>#Web管理页面设置</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-wifischedule  <span>#WiFi 计划</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-wol   <span>#WOL网络唤醒</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-wrtbwmon  <span>#实时流量监测</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-xlnetacc  <span>#迅雷快鸟</span>
LuCI ---<span>></span> Applications ---<span>></span> luci-app-zerotier  <span>#ZeroTier内网穿透</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br></div></div></div>
<h3 id="_5、下载-dl-库"> 5、下载 dl 库</h3>
<p>下载dl库，国内请尽量全局科学上网</p>
<div><pre><code>$ <span>make</span> -j8 download <span>V</span><span>=</span>s
</code></pre>
<div><span>1</span><br></div></div><h3 id="_6、编译"> 6、编译</h3>
<p>输入编译命令，即可开始编译你要的固件了。</p>
<div><pre><code>$ <span>make</span> -j1 <span>V</span><span>=</span>s		<span>#-j1 后面是线程数。第一次编译推荐用单线程</span>
</code></pre>
<div><span>1</span><br></div></div><div><p>说明</p>
<p>本套代码保证肯定可以编译成功。里面包括了 R20 所有源代码，包括 IPK 的。</p>
</div>
<p>如果是二次编译</p>
<div><pre><code>$ <span>cd</span> lede
$ <span>git</span> pull
$ ./scripts/feeds update -a <span>&amp;&amp;</span> ./scripts/feeds <span>install</span> -a
$ <span>make</span> defconfig
$ <span>make</span> -j8 download
<span>$make</span> -j<span><span>$((</span>$<span>(</span>nproc<span>)</span><span>+</span><span>1</span><span>))</span></span> <span>V</span><span>=</span>s
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>如果需要重新配置：</p>
<div><pre><code>$ <span>rm</span> -rf ./tmp <span>&amp;&amp;</span> <span>rm</span> -rf .config
$ <span>make</span> menuconfig
$ <span>make</span> -j<span><span>$((</span>$<span>(</span>nproc<span>)</span><span>+</span><span>1</span><span>))</span></span> <span>V</span><span>=</span>s
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="_7、查看结果"> 7、查看结果</h3>
<p>编译完成后输出路径：<code>/lede/bin/targets</code></p>
<div><p>说明</p>
<p>如果 feeds update 出现一堆类似下面的警告：</p>
<blockquote>
<p>WARNING: Makefile 'package/lean/shadowsocksR-libev-full/Makefile' has a dependency on 'libpcre', which does not exist</p>
</blockquote>
<p>解决办法就是删掉 feeds 整个文件夹，在 lede 或 openwrt 目录下执行 <code>rm -rf ./feeds</code>，然后再 update。</p>
<h2 id="usb-sata-支持的-kmod-及挂载"> USB/SATA 支持的 Kmod 及挂载</h2>
<p>内核编译选项</p>
<div><pre><code><span>make</span> menuconfig
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>
<p><u>Base syste</u></p>
<ul>
<li>Block-mount ---Block device mounting and checking------支持设备挂载</li>
</ul>
</li>
<li>
<p><u>Utilities</u></p>
<ul>
<li>mount-utils</li>
</ul>
</li>
<li>
<p><u>Kernel modules &gt; Block Devices</u></p>
<ul>
<li>kmod-ata-core ------Sata接口核心&gt;&gt;支持的芯片组及传输协议 ID（支持设备类型 IDE AHCI SCSI）</li>
</ul>
</li>
<li>
<p><u>Kernel modules &gt; Filesystems</u></p>
<ul>
<li>Kmod-fs-ext4/vfat/ntfs------支持文系统类型 EXT3/4 /FAT/NTFS</li>
</ul>
</li>
<li>
<p><u>Extra packages</u></p>
<ul>
<li>
<p>automount------自动挂载磁盘</p>
</li>
<li>
<p>autosamba------自动smb共享</p>
</li>
<li>
<p>ipv6helper------支持IPv6</p>
</li>
</ul>
</li>
</ul>
<p><img src="./assets/openwrt_5.png" alt="" loading="lazy"></p>
<h2 id="参考文档"> 参考文档</h2>
<p><a href="https://blog.51cto.com/tiexcn/1700034" target="_blank" rel="noopener noreferrer">https://blog.51cto.com/tiexcn/1700034</a></p>
<p><a href="https://imgki.com/archives/openwrt-lean.html" target="_blank" rel="noopener noreferrer">https://imgki.com/archives/openwrt-lean.html</a></p>
<p><a href="https://github.com/coolsnowwolf/lede" target="_blank" rel="noopener noreferrer">https://github.com/coolsnowwolf/lede</a></p>
<p><a href="https://github.com/kenzok8/openwrt-packages" target="_blank" rel="noopener noreferrer">https://github.com/kenzok8/openwrt-packages</a></p>
<p><a href="https://www.mianao.info/2020/05/05/%E7%BC%96%E8%AF%91%E6%9B%B4%E6%96%B0OpenWrt-PassWall%E5%92%8CSSR-plus%E6%8F%92%E4%BB%B6" target="_blank" rel="noopener noreferrer">https://www.mianao.info/2020/05/05/编译更新OpenWrt-PassWall和SSR-plus插件</a></p>
<p><a href="https://www.right.com.cn/forum/thread-3682029-1-1.html" target="_blank" rel="noopener noreferrer">https://www.right.com.cn/forum/thread-3682029-1-1.html</a></p>
<p>以及恩山其它帖子</p>
</div>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-04-09T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">【Padavan】固件编译</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/operate/padavan/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/operate/padavan/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="固件说明"> 固件说明</h2>
<ul>
<li>默认登陆IP：192.168.2.1</li>
<li>默认用户名/密码：admin/admin</li>
<li>默认wifi密码：1234567890</li>
<li>集成/取消新增插件请修改此文件：<code>trunk/build_firmware_modify</code></li>
<li>已适配除官方适配外的以下机型
<ul>
<li>MI-R3P(感谢群里emmmm适配,可能led控制有点问题,其它功能正常)</li>
<li>京东云路由(文件来自Lintel) 编译代码: JDC-1</li>
<li>歌华链(感谢群里Heaven适配与测试）编译代码: GHL</li>
<li>NEWIFI-D1</li>
<li>B70(感谢Untitled提供荒野无灯的适配文件)</li>
<li>JCG-AC856M(感谢群里的旅途中的我适配和测试,gpio值还未完全适配，但不影响使用)</li>
<li>JCG-AC836M(感谢群里的碧霄客修改和测试)</li>
<li>YK-L1(L1、L1C、L1W通刷)</li>
<li>PSG712</li>
<li>PSG1208</li>
<li>PSG1218</li>
<li>5K-W20 (USB)</li>
<li>OYE-001 (USB)</li>
<li>NEWIFI-MINI (USB)</li>
<li>MI-MINI (USB)</li>
<li>MI-3 (USB)</li>
<li>MI-R3G (USB)</li>
<li>HC5661A</li>
<li>HC5761A (USB)</li>
<li>HC5861B</li>
<li>360P2 (USB)</li>
<li>MI-NANO</li>
<li>MZ-R13</li>
<li>MZ-R13P</li>
<li>RT-AC1200GU (USB)</li>
<li>XY-C1 (USB)</li>
<li>WR1200JS (USB)</li>
<li>NEWIFI3 (USB)</li>
<li>B70 (USB)</li>
<li>A3004NS (USB)</li>
<li>K2P</li>
<li>K2P-USB (USB)</li>
<li>JCG-836PRO (USB)</li>
<li>JCG-AC860M (USB)</li>
<li>DIR-882 (USB)</li>
<li>DIR-878</li>
<li>MR2600 (USB)</li>
<li>WDR7300</li>
<li>RM2100</li>
<li>R2100</li>
</ul>
</li>
</ul>
<h2 id="本地编译"> 本地编译</h2>
<h3 id="_1、安装依赖包"> 1、安装依赖包</h3>
<div><pre><code><span># Debian/Ubuntu</span>
<span>sudo</span> <span>apt</span> update
<span>sudo</span> <span>apt</span> <span>install</span> <span>unzip</span> libtool-bin <span>curl</span> cmake gperf <span>gawk</span> flex bison <span>nano</span> xxd fakeroot cpio <span>git</span> python-docutils gettext automake autopoint texinfo build-essential help2man pkg-config zlib1g-dev libgmp3-dev libmpc-dev libmpfr-dev libncurses5-dev libltdl-dev <span>wget</span>

<span># CentOS 7</span>
<span>sudo</span> yum update
<span>sudo</span> yum <span>install</span> ncurses-* flex byacc bison zlib-* texinfo gmp-* mpfr-* gettext libtool* libmpc-* gettext-* python-docutils <span>nano</span> help2man fakeroot
<span>sudo</span> yum groupinstall <span>"Development Tools"</span>

<span># CentOS 8</span>
<span>sudo</span> yum update
<span>sudo</span> yum <span>install</span> ncurses-* flex byacc bison zlib-* gmp-* mpfr-* gettext libtool* libmpc-* gettext-* <span>nano</span> fakeroot
<span>sudo</span> yum groupinstall <span>"Development Tools"</span>
<span># CentOS 8不能直接通过yum安装texinfo，help2man，python-docutils。请去官网下载发行的安装包编译安装</span>
<span># 以texinfo为例</span>
<span># cd /usr/local/src</span>
<span># sudo wget http://ftp.gnu.org/gnu/texinfo/texinfo-6.7.tar.gz</span>
<span># sudo tar zxvf texinfo-6.7.tar.gz</span>
<span># cd texinfo-6.7</span>
<span># sudo ./configure</span>
<span># sudo make</span>
<span># sudo make install</span>

<span># Archlinux/Manjaro</span>
<span>sudo</span> pacman -Syu --needed <span>git</span> base-devel cmake gperf ncurses libmpc gmp python-docutils <span>vim</span> rpcsvc-proto fakeroot
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h3 id="_2、克隆源码"> 2、克隆源码</h3>
<div><pre><code><span>sudo</span> <span>git</span> clone --depth<span>=</span><span>1</span> https://github.com/chongshengB/rt-n56u.git /opt/rt-n56u
</code></pre>
<div><span>1</span><br></div></div><h3 id="_3、准备工具链"> 3、准备工具链</h3>
<div><pre><code><span>cd</span> /opt/rt-n56u/toolchain-mipsel

<span># （推荐）使用脚本下载预编译的工具链：</span>
<span>sudo</span> <span>sh</span> dl_toolchain.sh

<span># 或者，也可以从源码编译工具链，这需要一些时间：</span>
<span># Manjaro/ArchLinux 用户请使用gcc-8</span>
<span># sudo pacman -S gcc8</span>
<span># sudo ln -sf /usr/bin/gcc-8 /usr/local/bin/gcc</span>
<span># sudo ln -sf /usr/bin/g++-8 /usr/local/bin/g++</span>

<span>sudo</span> ./clean_toolchain
<span>sudo</span> ./build_toolchain
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="_4、自定义插件-可选"> 4、自定义插件（可选）</h3>
<div><pre><code><span>cd</span> /opt/rt-n56u/trunk
<span>sudo</span> <span>nano</span> build_firmware_modify		<span>#用nano编辑build_firmware_modify文件</span>
<span>#将下图中的插件自定义修改y/n，y是编译，n是不编译，修改好之后，Ctrl+O保存，Ctrl+X退出</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src="./assets/padavan_1.png" alt="" loading="lazy"></p>
<h3 id="_5、修改机型配置文件-可选"> 5、修改机型配置文件（可选）</h3>
<div><pre><code><span># cd /opt/rt-n56u/trunk/configs/templates/  #进入此路径</span>
<span># ls  #查看所有型号路由器的配置文件</span>
<span>nano</span> /opt/rt-n56u/trunk/configs/templates/RM2100.config		<span>#RM2100.config为红米AC2100路由器</span>
<span># 根据自身情况。自行修改对应的配置文件（可选）</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="_6、清理代码树并开始编译"> 6、清理代码树并开始编译</h3>
<div><pre><code><span>cd</span> /opt/rt-n56u/trunk
<span>sudo</span> ./clear_tree
<span>sudo</span> fakeroot ./build_firmware_modify RM2100		<span>#RM2100就是对应型号路由器的配置文件名</span>
<span># 脚本第一个参数为路由型号，在trunk/configs/templates/中</span>
<span># 编译好的固件在trunk/images里</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="云编译"> 云编译</h2>
<p>以 C 大的 padavan 自编译项目</p>
<p>地址：<a href="https://github.com/chongshengB/Padavan-build" target="_blank" rel="noopener noreferrer">https://github.com/chongshengB/Padavan-build</a></p>
<div><p>说明</p>
<p>现在不需要新建Release了，已经更改了脚本，直接fork，修改好之后，点击右上角的 Star 星星按钮即可开始自动编译（自己点击才会编译）。</p>
</div>
<p>首先你得有个 github 账号（此处省略怎么注册）</p>
<h3 id="_1、进入项目地址"> 1、进入项目地址</h3>
<p>浏览器进入 <a href="https://github.com/chongshengB/Padavan-build" target="_blank" rel="noopener noreferrer">https://github.com/chongshengB/Padavan-build</a></p>
<h3 id="_2、fork-项目"> 2、Fork 项目</h3>
<p>点击右上的 Fork，就把这个项目 Fork 到自己的账号下了</p>
<p><img src="./assets/padavan_2.png" alt="" loading="lazy"></p>
<h3 id="_3、进入已-fork-的项目"> 3、进入已 Fork 的项目</h3>
<p>然后会自动进入自己账号刚刚 Fork 的项目，点击 <code>.guthub/workflows</code></p>
<p><img src="./assets/padavan_3.png" alt="" loading="lazy"></p>
<h3 id="_4、找到-build-padavan-yml"> 4、找到 build-padavan.yml</h3>
<p>进入到 <code>Padavan-build/.github/workflows/</code>，点击 <code>build-padavan.yml</code></p>
<p><img src="./assets/padavan_4.png" alt="" loading="lazy"></p>
<h3 id="_5、编辑-build-padavan-yml"> 5、编辑 build-padavan.yml</h3>
<p>可以看到 <code>build-padavan.yml</code> 文件的内容了，点击右上的 <strong>笔</strong> 图标，进入编辑状态</p>
<p><img src="./assets/padavan_5.png" alt="" loading="lazy"></p>
<h3 id="_6、修改型号"> 6、修改型号</h3>
<p>根据第一行的提示内容，找到 <code>TNAME: K2P-5.0</code>，把 <code>K2P-5.0</code> 改成你要编译的型号（比如红米 AC2100 对应的是 <code>RM2100</code>）</p>
<p><img src="./assets/padavan_6.png" alt="" loading="lazy"></p>
<p><img src="./assets/padavan_7.png" alt="" loading="lazy"></p>
<div><p>说明：怎么看不同机器的型号</p>
<ul>
<li>找到 <u>git clone --depth=1 https://github.com/chongshengB/rt-n56u.git /opt/rt-n56u</u> 这一行</li>
<li>浏览器打开中间的网址（https://开头.git结尾）<u>https://github.com/chongshengB/rt-n56u.git</u></li>
<li>依次进入 <code>rt-n56u/trunk/configs/templates</code>，这里面就是所支持编译的所有机器型号（例如 <code>360P2.config</code> 文件，对应的机器型号是 360路由器P2，红米AC2100 就是 RM2100.config，上面修改 TNAME 时，不需要 .config 后缀）</li>
</ul>
<p><img src="./assets/padavan_8.png" alt="" loading="lazy"></p>
</div>
<h3 id="_7、自定义插件"> 7、自定义插件</h3>
<p>自定义插件，具体看解释，很简单</p>
<div><pre><code> <span>sed</span> -i <span>'s/CONFIG_FIRMWARE_INCLUDE_OPENSSL_EXE=n/CONFIG_FIRMWARE_INCLUDE_OPENSSL_EXE=y/g'</span> .config
 <span>################################################################################################</span>
 <span>#因不同型号配置功能不一样，所以先把配置项删除，如果你自己要添加其他的，也要写上删除这一条，切记！！！</span>
 <span>################################################################################################</span>
 <span>sed</span> -i <span>'/CONFIG_FIRMWARE_INCLUDE_MENTOHUST/d'</span> .config <span>#删除配置项MENTOHUST</span>
 <span>sed</span> -i <span>'/CONFIG_FIRMWARE_INCLUDE_SCUTCLIENT/d'</span> .config <span>#删除配置项SCUTCLIENT</span>
 <span>sed</span> -i <span>'/CONFIG_FIRMWARE_INCLUDE_SHADOWSOCKS/d'</span> .config <span>#删除配置项SS plus+</span>
 <span>sed</span> -i <span>'/CONFIG_FIRMWARE_INCLUDE_SSSERVER/d'</span> .config <span>#删除配置项SS server</span>
 <span>sed</span> -i <span>'/CONFIG_FIRMWARE_INCLUDE_DNSFORWARDER/d'</span> .config <span>#删除配置项DNSFORWARDER</span>
 <span>sed</span> -i <span>'/CONFIG_FIRMWARE_INCLUDE_ADBYBY/d'</span> .config <span>#删除配置项adbyby plus+</span>
 <span>sed</span> -i <span>'/CONFIG_FIRMWARE_INCLUDE_FRPC/d'</span> .config <span>#删除配置项内网穿透FRPC</span>
 <span>sed</span> -i <span>'/CONFIG_FIRMWARE_INCLUDE_FRPS/d'</span> .config <span>#删除配置项内网穿透FRPS</span>
 <span>sed</span> -i <span>'/CONFIG_FIRMWARE_INCLUDE_TUNSAFE/d'</span> .config <span>#删除配置项TUNSAFE</span>
 <span>sed</span> -i <span>'/CONFIG_FIRMWARE_INCLUDE_ALIDDNS/d'</span> .config <span>#删除配置项阿里DDNS</span>
 <span>sed</span> -i <span>'/CONFIG_FIRMWARE_INCLUDE_V2RAY/d'</span> .config <span>#删除配置项v2ray</span>
 <span>sed</span> -i <span>'/CONFIG_FIRMWARE_INCLUDE_TROJAN/d'</span> .config <span>#删除配置项trojan</span>
 <span>sed</span> -i <span>'/CONFIG_FIRMWARE_INCLUDE_WYYBIN/d'</span> .config <span>#删除配置项网易云解锁GO版本</span>
 <span>sed</span> -i <span>'/CONFIG_FIRMWARE_INCLUDE_ZEROTIER/d'</span> .config <span>#删除配置项zerotier</span>
 <span>sed</span> -i <span>'/CONFIG_FIRMWARE_INCLUDE_SMARTDNS/d'</span> .config
 <span>sed</span> -i <span>'/CONFIG_FIRMWARE_INCLUDE_SRELAY/d'</span> .config
 <span>sed</span> -i <span>'s/CONFIG_FIRMWARE_INCLUDE_OPENSSL_EXE=n/CONFIG_FIRMWARE_INCLUDE_OPENSSL_EXE=y/g'</span> .config
 <span>######################################################################</span>
 <span>#以下选项是定义你需要的功能（y=集成,n=忽略），重新写入到.config文件</span>
 <span>######################################################################</span>
 <span>echo</span> <span>"CONFIG_FIRMWARE_INCLUDE_MENTOHUST=n"</span> <span>>></span> .config <span>#MENTOHUST</span>
 <span>echo</span> <span>"CONFIG_FIRMWARE_INCLUDE_SCUTCLIENT=n"</span> <span>>></span> .config <span>#SCUTCLIENT</span>
 <span>echo</span> <span>"CONFIG_FIRMWARE_INCLUDE_SHADOWSOCKS=y"</span> <span>>></span> .config <span>#SS plus+</span>
 <span>echo</span> <span>"CONFIG_FIRMWARE_INCLUDE_SSOBFS=n"</span> <span>>></span> .config <span># simple-obfs混淆插件</span>
 <span>echo</span> <span>"CONFIG_FIRMWARE_INCLUDE_SSSERVER=n"</span> <span>>></span> .config <span>#SS server</span>
 <span>echo</span> <span>"CONFIG_FIRMWARE_INCLUDE_DNSFORWARDER=n"</span> <span>>></span> .config <span>#DNSFORWARDER</span>
 <span>echo</span> <span>"CONFIG_FIRMWARE_INCLUDE_ADBYBY=y"</span> <span>>></span> .config <span>#adbyby plus+</span>
 <span>echo</span> <span>"CONFIG_FIRMWARE_INCLUDE_FRPC=n"</span> <span>>></span> .config <span>#内网穿透FRPC</span>
 <span>echo</span> <span>"CONFIG_FIRMWARE_INCLUDE_FRPS=n"</span> <span>>></span> .config <span>#内网穿透FRPS</span>
 <span>echo</span> <span>"CONFIG_FIRMWARE_INCLUDE_TUNSAFE=n"</span> <span>>></span> .config <span>#TUNSAFE</span>
 <span>echo</span> <span>"CONFIG_FIRMWARE_INCLUDE_ALIDDNS=y"</span> <span>>></span> .config <span>#阿里DDNS</span>
 <span>echo</span> <span>"CONFIG_FIRMWARE_INCLUDE_SMARTDNS=y"</span> <span>>></span> .config <span>#smartdns</span>
 <span>echo</span> <span>"CONFIG_FIRMWARE_INCLUDE_SMARTDNSBIN=y"</span> <span>>></span> .config <span>#smartdns二进制文件</span>
 <span>echo</span> <span>"CONFIG_FIRMWARE_INCLUDE_V2RAY=y"</span> <span>>></span> .config <span>#集成v2ray执行文件（3.8M左右)，如果不集成，会从网上下载下来执行，不影响正常使用</span>
 <span>echo</span> <span>"CONFIG_FIRMWARE_INCLUDE_TROJAN=y"</span> <span>>></span> .config <span>#集成trojan执行文件(1.1M左右)，如果不集成，会从网上下载下来执行，不影响正常使用</span>
 <span>echo</span> <span>"CONFIG_FIRMWARE_INCLUDE_KOOLPROXY=y"</span> <span>>></span> .config <span>#KP广告过滤</span>
 <span>echo</span> <span>"CONFIG_FIRMWARE_INCLUDE_CADDY=y"</span> <span>>></span> .config <span>#在线文件管理服务</span>
 <span>echo</span> <span>"CONFIG_FIRMWARE_INCLUDE_CADDYBIN=n"</span> <span>>></span> .config <span>#集成caddu执行文件（13M左右），如果不集成，会从网上下载下来执行，不影响正常使用</span>
 <span>echo</span> <span>"CONFIG_FIRMWARE_INCLUDE_ADGUARDHOME=y"</span> <span>>></span> .config
 <span>echo</span> <span>"CONFIG_FIRMWARE_INCLUDE_SRELAY=n"</span> <span>>></span> .config <span>#可以不集成</span>
 <span>echo</span> <span>"CONFIG_FIRMWARE_INCLUDE_WYY=y"</span> <span>>></span> .config <span>#网易云解锁</span>
 <span>echo</span> <span>"CONFIG_FIRMWARE_INCLUDE_WYYBIN=y"</span> <span>>></span> .config <span>#网易云解锁GO版本执行文件（4M多）注意固件超大小,不集成会自动下载</span>
 <span>echo</span> <span>"CONFIG_FIRMWARE_INCLUDE_ZEROTIER=y"</span> <span>>></span> .config <span>#zerotier ~1.3M</span>
 <span>#########################################################################################</span>
 <span>#自定义添加其它功能请参考源码configs/templates/目录下的config文件。按照上面的格式添加即可</span>
 <span>#格式如下：</span>
 <span>#sed -i '/自定义项/d' .config</span>
 <span>#echo "自定义项=y" >> .config</span>
 <span>#########################################################################################</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><h3 id="_8、提交修改"> 8、提交修改</h3>
<p>修改完成之后，点击右上的 <strong>Start commit</strong>，跳出小窗口点击 <strong>Commit changes</strong></p>
<p><img src="./assets/padavan_9.png" alt="" loading="lazy"></p>
<h3 id="_9、点击-star"> 9、点击 star</h3>
<p>提交之后，再点击右上的 <strong>Star</strong>，然后在点击 <strong>Action</strong></p>
<p><img src="./assets/padavan_10.png" alt="" loading="lazy"></p>
<h3 id="_10、继续"> 10、继续</h3>
<p>第一次云编译需要点击 <strong>I understand myworkflows , go ahead and enable them</strong></p>
<p><img src="./assets/padavan_11.png" alt="" loading="lazy"></p>
<h3 id="_11、刷新确认"> 11、刷新确认</h3>
<p>如果还没有编译，在次点击两次 <strong>Star</strong>，让五角星变成黑色填充（文字变成 <strong>Unstar</strong>），刷新网址，就可以看到在编译了</p>
<p><img src="./assets/padavan_12.png" alt="" loading="lazy"></p>
<h3 id="_12、等待完成"> 12、等待完成</h3>
<p>大概等 20 分钟左右，就会编译完成，期间不用管，可以干点其他事情，完成之后（用时21分27秒），点击 <strong>Build Padavan</strong></p>
<p><img src="./assets/padavan_13.png" alt="" loading="lazy"></p>
<h3 id="_13、查看下载"> 13、查看下载</h3>
<p>点击 <strong>Padavan-packages</strong> 下载到本地，解压后得到的固件就是刚刚编译的，之后就是刷机了</p>
<p><img src="./assets/padavan_14.png" alt="" loading="lazy"></p>
<h2 id="参考文档"> 参考文档</h2>
<p><a href="https://github.com/chongshengB/Padavan-build" target="_blank" rel="noopener noreferrer">https://github.com/chongshengB/Padavan-build</a></p>
<p><a href="https://github.com/chongshengB/rt-n56u" target="_blank" rel="noopener noreferrer">https://github.com/chongshengB/rt-n56u</a></p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-04-09T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">【squashfs】解包打包</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/operate/squashfs/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/operate/squashfs/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="查看文件类型"> 查看文件类型</h2>
<p>使用 <code>file</code> 命令查看文件的文件类型，以便使用对应的命令工具去执行操作。</p>
<div><pre><code>kei@kei-KVM:~<span># file SYSTEM</span>
SYSTEM: Squashfs filesystem, little endian, version <span>4.0</span>, <span>906421384</span> bytes, <span>17904</span> inodes, blocksize: <span>524288</span> bytes, created: Fri Jun <span>18</span> <span>21</span>:05:07 <span>2021</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="安装工具"> 安装工具</h2>
<p>根据上面查看到的 SYSTEM 文件类型是 Squashfs filesystem，那么需要用到 squashfs-tools 工具命令，直接安装。</p>
<div><pre><code>kei@kei-KVM:~$ <span>sudo</span> <span>apt</span> <span>install</span> squashfs-tools 
<span>[</span>sudo<span>]</span> karin 的密码： 
正在读取软件包列表<span>..</span>. 完成
正在分析软件包的依赖关系树       
正在读取状态信息<span>..</span>. 完成       
下列软件包是自动安装的并且现在不需要了：
  fonts-liberation2 fonts-opensymbol gir1.2-gst-plugins-base-1.0
  gir1.2-gstreamer-1.0 gir1.2-gudev-1.0 gir1.2-udisks-2.0
  grilo-plugins-0.3-base gstreamer1.0-gtk3 libboost-date-time1.65.1
  libboost-filesystem1.65.1 libboost-iostreams1.65.1 libboost-locale1.65.1
  libcdr-0.1-1 libclucene-contribs1v5 libclucene-core1v5 libcmis-0.5-5v5
  libdazzle-1.0-0 libe-book-0.1-1 libedataserverui-1.2-2 libeot0
  libepubgen-0.1-1 libetonyek-0.1-1 libevent-2.1-6 libexiv2-14
  libfreerdp-client2-2 libfreerdp2-2 libgee-0.8-2 libgexiv2-2 libgom-1.0-0
  libgpgmepp6 libgpod-common libgpod4 liblangtag-common liblangtag1
  liblirc-client0 liblua5.3-0 libmediaart-2.0-0 libmspub-0.1-1 libodfgen-0.1-1
  libqqwing2v5 librevenge-0.0-0 libsgutils2-2 libssh-4 libvncclient1
  libwinpr2-2 libxapian30 libxmlsec1 libxmlsec1-nss
  linux-hwe-5.4-headers-5.4.0-72 lp-solve media-player-info python3-mako
  python3-markupsafe syslinux syslinux-common syslinux-legacy
  usb-creator-common
使用<span>'sudo apt autoremove'</span>来卸载它<span>(</span>它们<span>)</span>。
下列软件包将被升级：
  squashfs-tools
升级了 <span>1</span> 个软件包，新安装了 <span>0</span> 个软件包，要卸载 <span>0</span> 个软件包，有 <span>123</span> 个软件包未被升级。
需要下载 <span>111</span> kB 的归档。
解压缩后会消耗 <span>0</span> B 的额外空间。
获取:1 http://cn.archive.ubuntu.com/ubuntu bionic-updates/main amd64 squashfs-tools amd64 <span>1</span>:4.3-6ubuntu0.18.04.2 <span>[</span><span>111</span> kB<span>]</span>
已下载 <span>111</span> kB，耗时 <span>2</span>秒 <span>(</span><span>51.9</span> kB/s<span>)</span>      
<span>(</span>正在读取数据库 <span>..</span>. 系统当前共安装有 <span>190664</span> 个文件和目录。<span>)</span>
正准备解包 <span>..</span>./squashfs-tools_1%3a4.3-6ubuntu0.18.04.2_amd64.deb  <span>..</span>.
正在将 squashfs-tools <span>(</span><span>1</span>:4.3-6ubuntu0.18.04.2<span>)</span> 解包到 <span>(</span><span>1</span>:4.3-6ubuntu0.18.04.1<span>)</span> 上 <span>..</span>.
正在设置 squashfs-tools <span>(</span><span>1</span>:4.3-6ubuntu0.18.04.2<span>)</span> <span>..</span>.
正在处理用于 man-db <span>(</span><span>2.8</span>.3-2ubuntu0.1<span>)</span> 的触发器 <span>..</span>.
kei@kei-KVM:~$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><h2 id="unsquashfs-命令解压解包"> unsquashfs 命令解压解包</h2>
<p>解包打包最好切换到 root 用户操作。用 <code>unsquashfs</code> 命令解压缩。</p>
<div><pre><code><span># 切换 root 用户</span>
kei@kei-KVM:~$ <span>su</span> -
root@kei-KVM:~<span>#</span>

<span># 复制上面解压的 SYSTEM 文件到当前位置</span>
root@kei-KVM:~<span># cp /home/kei/桌面/SYSTEM .</span>

<span># unsquashfs 命令解包 SYSTEM 文件</span>
root@kei-KVM:~<span># unsquashfs SYSTEM </span>
Parallel unsquashfs: Using <span>2</span> processors
<span>16882</span> inodes <span>(</span><span>19542</span> blocks<span>)</span> to <span>write</span>

<span>[</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>=</span><span>\</span><span>]</span> <span>19542</span>/19542 <span>100</span>%

created <span>15854</span> files
created <span>1022</span> directories
created <span>1028</span> symlinks
created <span>0</span> devices
created <span>0</span> fifos

<span># 解压完成后，查看一下，多出一个 squashfs-root 文件夹</span>
root@kei-KVM:~<span># ls -l</span>
总用量 <span>885196</span>
drwxrwxr-x <span>12</span> root root      <span>4096</span> <span>6</span>月  <span>19</span> 05:03 squashfs-root
-rw-------  <span>1</span> root root <span>906424320</span> <span>9</span>月  <span>16</span> <span>14</span>:04 SYSTEM

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h2 id="查看与修改"> 查看与修改</h2>
<p>根据需求，适当修改里面的相关文件。</p>
<div><pre><code><span># 查看一下 squashfs-root 目录</span>
root@kei-KVM:~/squashfs-root<span># ls -l squashfs-root/</span>
总用量 <span>44</span>
lrwxrwxrwx  <span>1</span> root root    <span>8</span> <span>6</span>月  <span>19</span> 05:03 bin -<span>></span> /usr/bin
drwxrwxr-x  <span>2</span> root root <span>4096</span> <span>6</span>月  <span>19</span> 05:02 dev
-rw-rw-r--  <span>1</span> root root   <span>11</span> <span>6</span>月  <span>19</span> 05:03 ee_arch
lrwxrwxrwx  <span>1</span> root root   <span>24</span> <span>6</span>月  <span>19</span> 05:03 emuelec -<span>></span> /storage/.config/emuelec
drwxrwxr-x <span>27</span> root root <span>4096</span> <span>6</span>月  <span>19</span> 05:03 etc
drwxrwxr-x  <span>2</span> root root <span>4096</span> <span>6</span>月  <span>19</span> 05:02 flash
lrwxrwxrwx  <span>1</span> root root    <span>8</span> <span>6</span>月  <span>19</span> 05:03 lib -<span>></span> /usr/lib
lrwxrwxrwx  <span>1</span> root root   <span>10</span> <span>6</span>月  <span>19</span> 05:03 media -<span>></span> /var/media
lrwxrwxrwx  <span>1</span> root root   <span>13</span> <span>6</span>月  <span>19</span> 05:03 opt -<span>></span> /storage/.opt
drwxrwxr-x  <span>2</span> root root <span>4096</span> <span>6</span>月  <span>19</span> 05:02 proc
drwxrwxr-x  <span>2</span> root root <span>4096</span> <span>6</span>月  <span>19</span> 05:02 run
lrwxrwxrwx  <span>1</span> root root    <span>9</span> <span>6</span>月  <span>19</span> 05:03 sbin -<span>></span> /usr/sbin
drwxrwxr-x  <span>2</span> root root <span>4096</span> <span>6</span>月  <span>19</span> 05:02 storage
drwxrwxr-x  <span>2</span> root root <span>4096</span> <span>6</span>月  <span>19</span> 05:02 sys
drwxrwxr-x  <span>2</span> root root <span>4096</span> <span>6</span>月  <span>19</span> 05:02 tmp
drwxrwxr-x <span>10</span> root root <span>4096</span> <span>6</span>月  <span>19</span> 05:03 usr
drwxrwxr-x  <span>2</span> root root <span>4096</span> <span>6</span>月  <span>19</span> 05:02 var
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>相关文件所在位置：</p>
<ul>
<li>
<p>Emuelec 启动脚本：<code>squashfs-root/usr/bin/emuelecRunEmu.sh</code></p>
</li>
<li>
<p>自启动脚本：<code>squashfs-root/usr/config/autostart.sh</code></p>
</li>
<li>
<p>修改开机视频：<code>squashfs-root/usr/bin/show_splash.sh</code></p>
</li>
<li>
<p>修改边框：<code>squashfs-root/usr/bun/bezels.sh</code></p>
</li>
</ul>
<h2 id="查看原包信息"> 查看原包信息</h2>
<p>使用 <code>unsquashfs -s [filename]</code> 命令来查看 squashfs 文件类型的包压缩信息。</p>
<div><pre><code><span># 查看一下原 SYSTEM 文件的 squashfs 压缩信息</span>
root@kei-KVM:~<span># unsquashfs -s SYSTEM </span>
Found a valid SQUASHFS <span>4</span>:0 superblock on SYSTEM.
Creation or last append <span>time</span> Sat Jun <span>19</span> 05:05:07 <span>2021</span>
Filesystem size <span>885177.13</span> Kbytes <span>(</span><span>864.43</span> Mbytes<span>)</span>
Compression lzo					<span>#压缩方式：-comp lzo</span>
	algorithm lzo1x_999		<span>#压缩算法：-Xalgorithm lzo1x_999</span>
	compression level <span>9</span>		<span>#压缩等级：-Xcompression-level 9</span>
Block size <span>524288</span>				<span>#块大小：-b 524288</span>
Filesystem is exportable via NFS
Inodes are compressed
Data is compressed
Fragments are compressed
Always-use-fragments option is not specified
Xattrs are not stored			<span>#扩展属性：-no-xattrs</span>
Duplicates are removed
Number of fragments <span>988</span>
Number of inodes <span>17904</span>
Number of ids <span>2</span>

<span># 可以看到压缩方式是 lzo，压缩算法是 lzo1x_999，压缩等级是 9 ，块大小是 524288 ，扩展属性是 not stored 等信息。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h2 id="mksquashfs-命令压缩打包"> mksquashfs 命令压缩打包</h2>
<p>最后，使用 <code>mksquashfs</code> 命令，根据上面查看到的压缩参数信息，对 <code>squashfs-root/</code> 目录进行压缩打包。</p>
<div><pre><code>root@kei-KVM:~<span># mksquashfs squashfs-root/ SYSTEM_changed -comp lzo -Xalgorithm lzo1x_999 -Xcompression-level 9 -b 524288 -no-xattrs</span>
Parallel mksquashfs: Using <span>2</span> processors
Creating <span>4.0</span> filesystem on SYSTEM_changed, block size <span>524288</span>.
<span>[</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>=</span>/<span>]</span> <span>18514</span>/18514 <span>100</span>%

Exportable Squashfs <span>4.0</span> filesystem, lzo compressed, data block size <span>524288</span>
	compressed data, compressed metadata, compressed fragments, no xattrs
	duplicates are removed
Filesystem size <span>885177.12</span> Kbytes <span>(</span><span>864.43</span> Mbytes<span>)</span>
	<span>46.45</span>% of uncompressed filesystem size <span>(</span><span>1905511.20</span> Kbytes<span>)</span>
Inode table size <span>218226</span> bytes <span>(</span><span>213.11</span> Kbytes<span>)</span>
	<span>36.69</span>% of uncompressed inode table size <span>(</span><span>594786</span> bytes<span>)</span>
Directory table size <span>194409</span> bytes <span>(</span><span>189.85</span> Kbytes<span>)</span>
	<span>49.83</span>% of uncompressed directory table size <span>(</span><span>390171</span> bytes<span>)</span>
Number of duplicate files found <span>854</span>
Number of inodes <span>17904</span>
Number of files <span>15854</span>
Number of fragments <span>988</span>
Number of symbolic links  <span>1028</span>
Number of device nodes <span>0</span>
Number of fifo nodes <span>0</span>
Number of socket nodes <span>0</span>
Number of directories <span>1022</span>
Number of ids <span>(</span>unique uids + gids<span>)</span> <span>2</span>
Number of uids <span>1</span>
	root <span>(</span><span>0</span><span>)</span>
Number of gids <span>2</span>
	root <span>(</span><span>0</span><span>)</span>
	unknown <span>(</span><span>81</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h2 id="对比原包信息"> 对比原包信息</h2>
<p>压缩完成后，<code>unsquashfs -s</code> 命令再次查看一下新生城的文件信息。</p>
<div><pre><code>root@kei-KVM:~<span># unsquashfs -s SYSTEM_changed </span>
Found a valid SQUASHFS <span>4</span>:0 superblock on SYSTEM_changed.
Creation or last append <span>time</span> Thu Sep <span>16</span> <span>14</span>:39:18 <span>2021</span>
Filesystem size <span>885177.12</span> Kbytes <span>(</span><span>864.43</span> Mbytes<span>)</span>
Compression lzo
	algorithm lzo1x_999
	compression level <span>9</span>
Block size <span>524288</span>
Filesystem is exportable via NFS
Inodes are compressed
Data is compressed
Fragments are compressed
Always-use-fragments option is not specified
Xattrs are not stored
Duplicates are removed
Number of fragments <span>988</span>
Number of inodes <span>17904</span>
Number of ids <span>2</span>

<span># file 命令再次查看一下</span>
root@kei-KVM:~<span># file SYSTEM_changed </span>
SYSTEM_changed: Squashfs filesystem, little endian, version <span>4.0</span>, <span>906421372</span> bytes, <span>17904</span> inodes, blocksize: <span>524288</span> bytes, created: Thu Sep <span>16</span> 06:39:18 <span>2021</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>和原始的 SYSTEM 比较一下，除了时间和名字，（文件的大小有微小变化，因为修改了文件）其它信息没有任何变化。</p>
<p>以上，就是 squashfs 文件类型的解包和打包的过程。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-09-15T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">【VuePress】博客搭建</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/operate/vuepress_blog/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/operate/vuepress_blog/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="环境配置"> 环境配置</h2>
<p>你需要安装最新的 Node.js 和 Yarn。</p>
<p>在安装过程中，保持所有的默认设置，一路下一步即可。</p>
<h3 id="安装-node-js"> 安装 node.js</h3>
<ul>
<li>源码安装</li>
</ul>
<div><pre><code><span>[</span>karin@karin-KVM<span>]</span>$ <span>cd</span> /usr/local/src/
<span>#进入目录 /usr/local/src/</span>
<span>[</span>karin@karin-KVM<span>]</span>$ <span>wget</span> https://nodejs.org/dist/v14.16.1/node-v14.16.1.tar.gz
<span>#下载源码包</span>
<span>[</span>karin@karin-KVM<span>]</span>$ <span>tar</span> -zxvf node-v14.16.1.tar.gz
<span>#解压</span>
<span>[</span>karin@karin-KVM<span>]</span>$ ./configure
<span>#预编译</span>
<span>[</span>karin@karin-KVM<span>]</span>$ <span>make</span>
<span>#编译</span>
<span>[</span>karin@karin-KVM<span>]</span>$ <span>make</span> <span>install</span>
<span>#安装</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><ul>
<li>验证安装结果</li>
</ul>
<div><pre><code><span>[</span>karin@karin-KVM<span>]</span>$ <span>node</span> -v
<span>#查看node版本</span>
<span>[</span>karin@karin-KVM<span>]</span>$ <span>npm</span> -v
<span>#查看npm版本</span>
<span>[</span>karin@karin-KVM<span>]</span>$ npx -v
<span>#查看npx版本</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>或者</p>
<div><pre><code><span>[</span>karin@karin-KVM<span>]</span>$ <span>curl</span> -fsSL https://deb.nodesource.com/setup_17.x <span>|</span> <span>sudo</span> -E <span>bash</span> -
<span>[</span>karin@karin-KVM<span>]</span>$ <span>sudo</span> <span>apt</span> <span>install</span> nodejs
<span>#参考：https://github.com/nodesource/distributions</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="安装-yarn"> 安装 yarn</h3>
<div><pre><code><span>[</span>karin@karin-KVM<span>]</span>$ <span>npm</span> i -g <span>yarn</span>
<span>#安装 yarn</span>
<span>[</span>karin@karin-KVM<span>]</span>$ <span>yarn</span> config <span>set</span> registry https://registry.npm.taobao.org
<span>#添加淘宝源</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>或者</p>
<div><pre><code><span>[</span>karin@karin-KVM<span>]</span>$ <span>curl</span> -sS https://dl.yarnpkg.com/debian/pubkey.gpg <span>|</span> <span>sudo</span> apt-key <span>add</span> -
<span>[</span>karin@karin-KVM<span>]</span>$ <span>echo</span> <span>"deb https://dl.yarnpkg.com/debian/ stable main"</span> <span>|</span> <span>sudo</span> <span>tee</span> /etc/apt/sources.list.d/yarn.list
<span>[</span>karin@karin-KVM<span>]</span>$ <span>sudo</span> <span>apt</span> update <span>&amp;&amp;</span> <span>sudo</span> <span>apt</span> <span>install</span> <span>yarn</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="vuepress-搭建"> vuepress 搭建</h2>
<h3 id="创建模板"> 创建模板</h3>
<div><pre><code><span>[</span>karin@karin-KVM<span>]</span>$ <span>cd</span> ~
<span>#进入家目录</span>
<span>[</span>karin@karin-KVM<span>]</span>$ <span>mkdir</span> blog <span>&amp;&amp;</span> <span>cd</span> blog
<span>#创建本地工作目录并进入</span>
<span>[</span>karin@karin-KVM<span>]</span>$ <span>yarn</span> create vuepress-theme-hope docs
<span>#创建模板，hope的主题</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>创建过程中，需要填写一些信息，等到下载搭建完成</p>
<h3 id="文件结构"> 文件结构</h3>
<div><pre><code>├── dist → 构建输出目录
│
├── src
│ ├── .vuepress <span>(</span>可选的<span>)</span> → 用于存放全局的配置、组件、静态资源等
│ │ ├── components <span>(</span>可选的<span>)</span> → 该目录中的 Vue 组件将会被自动注册为全局组件
│ │ │
│ │ ├── theme <span>(</span>可选的<span>)</span> → 用于存放本地主题
│ │ │ │
│ │ │ ├── <span>..</span>. → 在主题部分查看更多详情
│ │ │ │
│ │ │ └── Layout.vue → 布局
│ │ │
│ │ ├── public <span>(</span>可选的<span>)</span> → 静态资源目录
│ │ │
│ │ ├── styles <span>(</span>可选的<span>)</span> → 用于存放样式相关的文件
│ │ │ ├── index.styl → 将会被自动应用的全局样式文件，会生成在最终的 CSS 文件结尾，具有比默认样式更高的优先级。
│ │ │ └── palette.styl → 用于重写默认颜色常量，或者设置新的 stylus 颜色常量
│ │ │
│ │ ├── templates <span>(</span>可选的, 谨慎配置<span>)</span> → 存储 HTML 模板文件
│ │ │ ├── dev.html → 用于开发环境的 HTML 模板文件
│ │ │ └── ssr.html → 构建时基于 Vue SSR 的 HTML 模板文件
│ │ │
│ │ ├── config.js <span>(</span>可选的<span>)</span> → 配置文件的入口文件
│ │ │
│ │ └── enhanceApp.js <span>(</span>可选的<span>)</span> → 客户端应用的增强
│ │
│ ├── readme.md → 主页
│ ├── vuepress
│ │ ├── <span>..</span>.
│ │ └── readme.md
│ ├── markdown
│ │ ├── <span>..</span>.
│ │ └── readme.md
│ │
│ └── en → English Folder → 英文语言文件夹
│ ├── readme.md → 主页
│ │
│ ├── vuepress
│ │ ├── <span>..</span>.
│ │ └── readme.md
│ │
│ └── markdown
│ ├── <span>..</span>.
│ └── readme.md
│
├─── readme.md → 项目中文说明
├─── readme.en-US.md → 项目英文说明
│
├── LICENSE → 许可证文件
│
├── package-lock.json → 项目实际使用的 package 结构
└── package.json → Nodejs 配置文件，也是项目的声明文件
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br></div></div><h3 id="配置文件"> 配置文件</h3>
<p>一个 VuePress 网站必要的配置文件是 <code>.vuepress/config.js</code>，它应该导出一个 JavaScript 对象：</p>
<p><a href="https://vuepress.vuejs.org/zh/config/#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener noreferrer">参考链接</a></p>
<h3 id="主题配置"> 主题配置</h3>
<p>一个 VuePress 主题应该负责整个网站的布局和交互细节。在 VuePress  中，目前自带了一个默认的主题，它是为技术文档而设计的。同时，默认主题提供了一些选项，让你可以去自定义导航栏（navbar）、 侧边栏（sidebar）和 首页（homepage） 等</p>
<h3 id="开启测试"> 开启测试</h3>
<p>创建完成后，开启本地服务</p>
<div><pre><code><span>[</span>karin@karin-KVM<span>]</span>$ <span>yarn</span> run docs:dev
</code></pre>
<div><span>1</span><br></div></div><p>浏览器地址栏输入 <code>localhost:8080/</code> 就可以访问服务器了。看看搭建的网站效果。</p>
<p>如果要终止开发服务器，连续两次按下 <code>Ctrl + C</code>。</p>
<h2 id="部署网站"> 部署网站</h2>
<h3 id="本地创建-ssh-keys"> 本地创建 ssh keys</h3>
<p>本地 git 项目与远程的 GitHub 建立联系 ------&gt; 用 SSH keys</p>
<ul>
<li>检查 SSH keys的设置</li>
</ul>
<div><pre><code><span>[</span>karin@karin-KVM<span>]</span>$ <span>cd</span> ~/.ssh
<span>#果提示：No such file or directory 说明你是第一次使用 git或没有ssh远程连接过其他机器</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>生成新的 SSH Key</li>
</ul>
<div><pre><code><span>[</span>karin@karin-KVM<span>]</span>$ ssh-keygen -t rsa -C <span>"邮件地址@youremail.com"</span>					<span>#你的github注册使用的邮箱</span>
    Generating public/private rsa key pair.
    Enter <span>file</span> <span>in</span> <span>which</span> to save the key <span>(</span>/Users/your_user_directory/.ssh/id_rsa<span>)</span>:  <span>#&lt;回车就好></span>
Enter passphrase <span>(</span>empty <span>for</span> no passphrase<span>)</span>: 	<span>#&lt;输入加密串></span>
Enter same passphrase  again:					<span>#&lt;再次输入加密串></span>
Your identification has been saved <span>in</span> /Users/tianqixin/.ssh/id_rsa.
Your public key has been saved <span>in</span> /Users/tianqixin/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:MDKVidPTDXIQoJwoqUmI4LBAsg5XByBlrOEzkxrwARI <span>429240967</span>@qq.com
The key's randomart image is:
+---<span>[</span>RSA <span>3072</span><span>]</span>----+
<span>|</span>E*+.<span>+=</span>**oo       <span>|</span>
<span>|</span>%Oo+oo<span>=</span>o. <span>.</span>      <span>|</span>
<span>|</span>%**.o.o.         <span>|</span>
<span>|</span>OO.  o o         <span>|</span>
<span>|</span>+o+     S        <span>|</span>
<span>|</span><span>.</span>                <span>|</span>
<span>|</span>                 <span>|</span>
<span>|</span>                 <span>|</span>
<span>|</span>                 <span>|</span>
+----<span>[</span>SHA256<span>]</span>-----+
<span>[</span>karin@karin-KVM<span>]</span>$ <span>ls</span> ~/.ssh					<span>#查看生成的密钥文件  id_rsa 、 id_rsa.pub</span>
id_rsa    id_rsa.pub    known_hosts
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h3 id="添加-ssh-key-到-github"> 添加 ssh key 到 github</h3>
<ul>
<li>打开本地 <code>id_rsa.pub</code> 文件，里面是刚才生成的秘钥。</li>
</ul>
<div><pre><code><span>[</span>karin@karin-KVM<span>]</span>$ <span>cat</span> id_rsa.pub
    ssh-rsa AAAAB3NzaC1yc······mIdnXExvYlmLeLKRuh ryuukaringo@gmail.com
<span>#复制id_rsa.pub文件里的内容备用</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>
<p>回到 github 上，进入 <strong>Account =&gt; Settings</strong>（账户配置）。</p>
<p><img src="./assets/Account_settings.png" alt="Account_settings" loading="lazy"></p>
</li>
<li>
<p>左边选择 <strong>SSH and GPG keys</strong>，然后点击 <strong>New SSH key</strong> 按钮。</p>
<p><img src="./assets/SSH_and_GPG_keys.png" alt="SSH and GPG keys" loading="lazy"></p>
</li>
<li>
<p>title 设置标题，可以随便填，key 粘贴在你电脑上生成的 <strong>key</strong>（ 上面生成的<code>~/.ssh/id_rsa.pub</code>文件内容），最后点击 <strong>Add SSH key</strong> 按钮添加。</p>
</li>
</ul>
<p><img src="./assets/add_key.png" alt="add_key" loading="lazy"></p>
<ul>
<li>
<p>添加成功后界面如下所示</p>
<p><img src="./assets/SSH_and_GPG_keys.png" alt="SSH and GPG keys" loading="lazy"></p>
</li>
</ul>
<h3 id="测试-ssh-到-github"> 测试 ssh 到 github</h3>
<p>输入下面的命令，看看设置是否成功，git@GitHub.com 的部分不要修改：</p>
<div><pre><code><span>[</span>karin@karin-KVM<span>]</span>$ <span>ssh</span> -T git@GitHub.com
<span>#看到以下内容说明以上操作没毛病</span>
<span>..</span><span>..</span><span>..</span>
Hi Ryukarin<span>!</span> You've successfully authenticated, but GitHub does not provide shell access.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="github-新建仓库"> github 新建仓库</h3>
<p>在 github上创建一个新的仓库</p>
<ul>
<li>
<p>如果打算发布到 <code>https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;/</code>（也就是说你的仓库在 <code>https://github.com/&lt;USERNAME&gt;/&lt;REPO&gt;</code>），则将 base 设置为 <code>/&lt;REPO&gt;/</code>，例如设置为 /blog/ 。</p>
</li>
<li>
<p>如果打算发布到 <code>https://&lt;USERNAME&gt;.github.io/&lt;USERNAME&gt;/</code>（也就是说你的仓库在 <code>https://github.com/&lt;USERNAME&gt;/&lt;USERNAME&gt;</code>），则将 base 默认设置为 <code>/&lt;USERNAME&gt;/</code>，不用理会。</p>
</li>
</ul>
<p>之后点击 <strong>New repository</strong> 如下图所示：</p>
<p><img src="./assets/New_repository.png" alt="New_repository" loading="lazy"></p>
<p>之后在在 <strong>Repository name</strong> 填入 myblog（远程仓库名） ，其他保持默认设置，点击<strong>Create repository</strong>按钮，就成功地创建了一个新的Git仓库：</p>
<p><img src="./assets/repository_name.png" alt="repository_name" loading="lazy"></p>
<p>创建成功后，显示如下信息：</p>
<p><img src="./assets/created_repository.png" alt="created_repository" loading="lazy"></p>
<p>以上信息告诉我们可以从这个仓库克隆出新的仓库，也可以把本地仓库的内容推送到 GitHub 仓库。</p>
<h3 id="本地仓库配置"> 本地仓库配置</h3>
<p>在项目根目录中（docs 同一目录），创建一个 deploy.sh 脚本文件，请自行修改github仓库地址</p>
<div><pre><code><span>[</span>karin@karin-KVM<span>]</span>$ <span>git</span>           
    Command <span>'git'</span> not found, but can be installed with:
    <span>sudo</span> <span>apt</span> <span>install</span> <span>git</span>
<span>#此命令如果出现上面内容，说明没有安装git</span>
<span>[</span>karin@karin-KVM<span>]</span>$ <span>sudo</span> <span>apt</span> <span>install</span> <span>git</span>
<span>#执行安装git命令</span>
<span>[</span>karin@karin-KVM<span>]</span>$ <span>touch</span> deploy.sh
<span>#新建脚本文件</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>脚本文件写入如下内容：</p>
<div><pre><code><span>#!/usr/bin/env sh</span>


<span>set</span> -e
<span># 确保脚本抛出遇到的错误</span>

<span>yarn</span> run docs:build
<span># 生成静态文件</span>

<span>cd</span> docs/.vuepress/dist
<span># 进入生成的文件夹</span>

<span># 如果是发布到自定义域名</span>
<span># echo 'www.example.com' > CNAME</span>

<span>git</span> init
<span>git</span> <span>add</span> -A
<span>git</span> commit -m <span>'deploy'</span>

<span># 如果发布到 https://&lt;USERNAME>.github.io</span>
<span>git</span> push -f git@github.com:Ryukarin/Ryuukarin.git master

<span># 如果发布到 https://&lt;USERNAME>.github.io/&lt;REPO></span>
<span># git push -f git@github.com:&lt;USERNAME>/&lt;REPO>.git master:gh-pages</span>

<span>cd</span> -
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h3 id="运行脚本"> 运行脚本</h3>
<div><pre><code><span>[</span>karin@karin-KVM<span>]</span>$ <span>git</span> config --global user.email <span>"ryuukaringo@gmail.com"</span>
<span>[</span>karin@karin-KVM<span>]</span>$ <span>git</span> config --global user.name <span>"Ryuukarin"</span>
<span>#设置git自己的名字和电子邮件</span>

<span>[</span>karin@karin-KVM<span>]</span>$ <span>git</span> config -l
<span>#查看配置</span>

<span>[</span>karin@karin-KVM<span>]</span>$ <span>chmod</span> u+x deploy.sh
<span>#赋予执行权限</span>

<span>[</span>karin@karin-KVM<span>]</span>$ ./deploy.sh
<span>#执行脚本</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="开启-github-pages-部署"> 开启 github pages 部署</h3>
<p>在 GitHub 项目点击 Setting 按钮，找到 GitHub Pages - Source，选择 master 分支，点击 Save 按钮后，静静地等待它部署完成即可。</p>
<p><img src="./assets/settings.png" alt="settings" loading="lazy"></p>
<h3 id="备份源文件"> 备份源文件</h3>
<p>当然，编译好的 pages 源文件用脚本 <code>deploy.sh</code> 就可以上传部署了。那么我想把部署网页之前的文件备份上传到仓库要怎么作呢？当然，脚本修改以下，很简单。但是，这次我想手动推送到仓库。方便练习以下 Git 的用法。具体如下：</p>
<div><pre><code><span>[</span>karin@karin-KVM<span>]</span>$ <span>ls</span> -a ~/blog
<span>.</span>  <span>..</span>  deploy.sh  dist  docs  .git  node_modules  package.json  package-lock.json
<span># ~/blog 是我搭建 vuepress 的目录，所有文件都在这里，.git 是仓库 pages 初始化生成的，所以在此目录下不好再次推送其他内容</span>
<span>[</span>karin@karin-KVM<span>]</span>$ <span>mkdir</span> ~/blog_md
<span>#新建一个目录</span>
<span>[</span>karin@karin-KVM<span>]</span>$ <span>cd</span> ~/blog
<span>#进入 ~/blog 目录</span>
<span>[</span>karin@karin-KVM<span>]</span>$ <span>cp</span> -r docs/ deploy.sh package.json package-lock.json ~/blog_md/
<span>#把 ~/blog/ 目录里的文件复制到 ~/blog_md/目录下</span>
<span>[</span>karin@karin-KVM<span>]</span>$ <span>cd</span> ~/blog_md
<span>#进入 ~/blog_md 目录</span>
<span>[</span>karin@karin-KVM<span>]</span>$ <span>git</span> init
<span>#初始化本地仓库，会在当前目录下生成一个 .git 目录</span>
<span>[</span>karin@karin-KVM<span>]</span>$ <span>git</span> <span>add</span> -A
<span>#把所有文件及其修改部分提交到本地暂存区，即上面复制的所有文件</span>
<span>[</span>karin@karin-KVM<span>]</span>$ <span>git</span> commit -m <span>'备注信息，随意写'</span>
<span># git commit 命令将暂存区内容添加到本地仓库中，-m 是备注信息，后面随意写</span>
<span>[</span>karin@karin-KVM<span>]</span>$ <span>git</span> push -f git@github.com:Ryukarin/blog.git main
<span>#强制推送更新到你的仓库</span>
<span>#你的仓库：git@github.com:Ryukarin/blog.git</span>
<span>#你的仓库分支：main</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>好了，上面的操作就把你的本地的源文件推送到仓库的 main 分支了。gh-pages 分支用于 blog 的静态页面。当然，上面的操作你也可以改成脚本，执行一下，也很方便。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-05-09T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">项目主页</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2022-01-26T06:11:29.000Z</published>
    <rights>Copyright © 2021 karin</rights>
  </entry>
  <entry>
    <title type="html">初识 Docker 与容器</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Docker/01.docker/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Docker/01.docker/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="什么是-docker"> 什么是 Docker</h2>
<h3 id="_1、docker-开源项目背景"> 1、Docker 开源项目背景</h3>
<p>Docker 是基于 Go 语言实现的开源容器项目。它诞生于 2013 年年初，最初发起者是 dotCloud 公司。Docker 自开源后受到业界广泛的关注和参与，目前已有 80 多个相关开源组件项目（包括 Containerd、Moby、Swarm 等），逐渐形成了围绕 Docker 容器的完整的生态体系。</p>
<p>Docker 的构想是要实现“Build，Ship and Run Any App，Anywhere”，即通过对应用的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）生命周期进行管理，达到应用组件级别的“<strong>一次封装，到处运行</strong>”。这里的应用组件，既可以是一个 Web 应用、一个编译环境、也可以是一套数据库平台服务，甚至是一个操作系统或集群。</p>
<p>基于 Linux 平台上的多项开源技术，Docker 提供了高效、敏捷和轻量级的容器方案，并
支持部署到本地环境和多种主流云平台。可以说，Docker 首次为应用的开发、运行和部署提供了“一站式”的实用解决方案。</p>
<p>现在主流的操作系统包括 Linux 各大发行版、macOS、Windows 等都已经支持 Docker。</p>
<h3 id="_2、linux-容器技术-巨人的肩膀"> 2、Linux 容器技术---巨人的肩膀</h3>
<p>与大部分新兴技术的诞生一样，Docker 也并非“从石头缝里蹦出来的”，而是站
在前人的肩膀上。其中最重要的就是 Linux 容器（Linux Containers，LXC）技术。IBM
DeveloperWorks 网站关于容器技术的描述十分准确：<u>“容器有效地将由单个操作系统管理的资源划分到孤立的组中，以更好地在孤立的组之间平衡有冰突的资源使用需求。与虚拟化相比，这样既不需要指令级模拟，也不需要即时编译。容器可以在核心 CPU 本地运行指令，而不需要任何专门的解释机制。此外，也避免了准虚拟化（para-virtualization）和系统调用替换中的复杂性。“</u></p>
<p>当然，LXC 也经历了长期的演化。最早的容器技术可以追溯到 1982 年 Unix 系列操作
系统上的 chroot 工具（直到今天，主流的 Unix、Linux 操作系统仍然支持和带有该工具）。</p>
<p>在 LXC 之前，这些相关技术经过多年的演化已经十分成熟和稳定，但是由于种种原因，它们并没有被很好地集成到主流的 Linux 内核中，使用起来并不方便。</p>
<p>后来 LXC 项目借鉴了前人成熟的容器设计理念，并基于一系列新引入的内核特性，实现了更具扩展性的虚拟化容器方案。更加关键的是，LXC 终于被集成到到主流 Linux 内核中，进而成为 Linux 系统轻量级容器技术的事实标准。从技术层面来看，LXC 已经趟过了绝大部分的“坑”，完成了容器技术实用化的大半历程。</p>
<h3 id="_3、从-linux-容器到-docker"> 3、从 Linux 容器到 Docker</h3>
<p>在 LXC 的基础上，Docker 进一步优化了容器的使用体验，让它进人寻常百姓家。首先，Docker 提供了各种容器管理工具（如分发、版本、移植等），让用户无须关注底层的操作，更加简单明了地管理和使用容器：其次，Docker 通过引入分层文件系统构建和高效的镜像机制，降低了迁移难度，极大地改善了用户体验。用户操作 Docker 容器就像操作应用自身一样简单。</p>
<p>简单地讲，可以将 Docker 容器理解为一种轻量级的沙盒（sandbox）。每个容器内运行着一个应用，不同的容器相互隔离、容器之间也可以通过网络互相通信。容器的创建和停止十分快速，几乎路创建和终止原生应用一致：另外，容器自身对系统资源的额外需求也十分有限，远远低于传统虚拟机。很多时候，甚至直接把容器当作应用本身也没有任何问题。</p>
<p>相信随着 Docker 技术的进一步成熟，它将成为更受欢迎的容器虚拟化技术实现，并在云计算和 DevOps 等领域得到更广泛的应用。</p>
<h2 id="为什么要使用-docker"> 为什么要使用 Docker</h2>
<h3 id="_1、docker-容器虚拟化的好处"> 1、Docker 容器虚拟化的好处</h3>
<p>Docker 项目的发起人、Docker 公司 CTO Solomon Hykes 认为，Docker 在正确的地点、正确的时间顺应了正确的趋势---如何正确地构建应用。</p>
<p>在云时代，开发者创建的应用必须要能很方便地在网络上传播，也就是说应用必须脱离底层物理硬件的限制；同时必须是“任何时间任何地点”可获取的。因此，开发者们需要一种新型的创建分布式应用程序的方式，快速分发和部署，而这正是 Docker 所能够提供的最大优势。</p>
<p>举个简单的例子，假设用户试图基于最常见的 LAMP（Linux+Apache+MySQL+PHP）组合来构建网站。按照传统的做法，首先需要安装 Apache、MySQL 和 PHP 以及它们各自运行所依赖的环境；之后分别对它们进行配置（包括创建合适的用户、配置参数等）；经过大量的操作后，还需要进行功能测试，看是否工作正常；如果不正常，则进行调试追踪，意味着更多的时间代价和不可控的风险。可以想象，如果应用数目变多，事情会变得更加难以
处理。</p>
<p>更为可怕的是，一旦需要服务器迁移（例如从亚马逊云迁移到其他云），往往需要对每个应用都进行重新部署和调试。这些琐碎而无趣的“体力活”，极大地降低了用户的工作效率。究其根源，是这些应用直接运行在底层操作系统上，无法保证同一份应用在不同的环境中行为一致。</p>
<p>而 Docker 提供了一种更为聪明的方式，通过容器来打包应用、解耦应用和运行平台。这意昧着迁移的时候，只需要在新的服务器上启动需要的容器就可以了，无论新旧服务器是否是同一类型的平台。这无疑将帮助我们节约大量的宝贵时间，并降低部署过程出现问题的风险。</p>
<h3 id="_2、docker-在开发和运维中的优势"> 2、Docker 在开发和运维中的优势</h3>
<p>对开发和运维（DevOps）人员来说，最梦寐以求的效果可能就是一次创建或配置，之后可以在任意地方、任意时间让应用正常运行，而 Docker 恰恰是可以实现这一终极目标的“瑞士军刀”。具体说来，在开发和运维过程中，Docker 具有如下几个方面的优势：</p>
<ul>
<li>
<p><strong>更快速的交付和部署</strong>。使用 Docker，开发人员可以使用镜像来快速构建一套标准的开发环境：开发完成之后，测试和运维人员可以直接使用完全相同的环境来部署代码。只要是开发测试过的代码，就可以确保在生产环境无缝运行。Docker可以快速创建和删除容器，实现快速迭代，节约开发、测试、部署的大量时间。并且，整个过程全程可见，使团队更容易理解应用的创建和工作过程。</p>
</li>
<li>
<p><strong>更高效的资源利用</strong>。运行 Docker 容器不需要额外的虚拟化管理程序（Virtual Machine Manager，VMM，以及 Hypervisor）的支持，Docker 是内核级的虚拟化，可以实现更高的性能，同时对资源的频外需求很低。与传统虚拟机方式相比，Docker 的性能要提高 1-2 个数量级。</p>
</li>
<li>
<p><strong>更轻松的迁移和扩展</strong>。Docker 容器几乎可以在任意的平台上运行，包挠物理机、虚拟机、公有云、私有云、个人电脑、服务器等，同时支持主流的操作系统发行版本。这种兼容性让用户可以在不同平台之间轻松地迁移应用。</p>
</li>
<li>
<p><strong>更简单的更新管理</strong>。使用 Dockerfile，只需要小小的配置修政，就可以替代以往大量的更新工作。所有修改都以增量的方式被分发和更新，从而实现自动化并且高效的容器管理。</p>
</li>
</ul>
<h3 id="_3、docker-与虚拟机比较"> 3、Docker 与虚拟机比较</h3>
<p>作为一种轻量级的虚拟化方式，Docker 在运行应用上跟传统的虚拟机方式相比具有如下显著优势：</p>
<ul>
<li>
<p><strong>Docker 容器很快</strong>，启动和停止可以在秒级实现，这相比传统的虚拟机方式（数分钟）要快得多；</p>
</li>
<li>
<p><strong>Docker 容器对系统资源需求很少</strong>，一台主机上可以同时运行数千个 Docker 容器（在 IBM 服务器上已经实现了同时运行 10K 量级的容器实例）；</p>
</li>
<li>
<p><strong>Docker</strong> 通过类似 Git 设计理念的操作来<strong>方便用户获取、分发和更新应用镜像，存储复用，增量更新</strong>；</p>
</li>
<li>
<p><strong>Docker</strong> 通过 Dockerfile <strong>支持灵活的自动化创建和部署机制</strong>，以提高工作效率，并标准化流程。</p>
</li>
</ul>
<p>Docker 容器除了运行其中的应用外，基本不消耗额外的系统资源，在保证应用性能的同时，尽量减小系统开销。传统虚拟机方式运行 N 个不同的应用就要启用 N 个虚拟机（每个虚拟机需要单狡分配独占的内存、磁盘等资源），而 Docker 只需要启动 N 个隔离得“很薄的”容器，并将应用放进容器内即可。应用获得的是接近原生的运行性能。</p>
<p>当然，在隔离性方面，传统的虚拟机方式提供的是相对封闭的隔离。但这并不意味着 Docker 不安全。Docker 利用 Linux 系统上的多种防护技术实现了严格的隔离可靠性，并目可以整合众多安全工具。从 1.3.0 版本开始，Docker 重点改善了容器的安全控制和镜像的安全机制，极大地提高了使用 Docker 的安全性。在已知的大规模应用中，目前尚未出现值得担忧的安全隐患。</p>
<p>下表比较了使用 Docker 容器技术与传统虚拟机技术的各种特性，可见容器技术在很多应用场景下都具有巨大的优势。</p>
<p><u>表 1-1</u>	Docker 容器技术与传统虚拟机技术的比较</p>
<table>
<thead>
<tr>
<th><u>特性</u></th>
<th><u>容器</u></th>
<th><u>虚拟机</u></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>启动速度</strong></td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>接近原生</td>
<td>较弱</td>
</tr>
<tr>
<td><strong>内存代价</strong></td>
<td>很小</td>
<td>较多</td>
</tr>
<tr>
<td><strong>硬盘使用</strong></td>
<td>一般为 MB</td>
<td>一般为 GB</td>
</tr>
<tr>
<td><strong>运行密度</strong></td>
<td>单机支持上千个容器</td>
<td>一般几十个</td>
</tr>
<tr>
<td><strong>隔离性</strong></td>
<td>安全隔离</td>
<td>完全隔离</td>
</tr>
<tr>
<td><strong>迁移性</strong></td>
<td>优秀</td>
<td>一般</td>
</tr>
</tbody>
</table>
<h2 id="docker-与虚拟化"> Docker 与虚拟化</h2>
<p>虚拟化（virtualization）技术是一个通用的概念，在不同领域有不同的理解。在计算领域，一般指的是计算虚拟化（computing virtualization），或通常说的服务器虚拟化。维基百科上的定义如下：</p>
<blockquote>
<p>“在计算机技术中，虚拟化是一种资源管理技术，是将计算机的各种实体资
源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以用比原本的组态更好的方式来应用这些资源。“</p>
</blockquote>
<p>可见，虚拟化的核心是对资源的抽象，目标往往是为了在同一个主机上同时运行多个系统或应用，从而提高系统资源的利用率，并丁带来降低成本、方便管理和容错容灾等好处。</p>
<p>从大类上分，虚拟化技术可分为基于<strong>硬件的虚拟化</strong>和基于<strong>软件的虚拟化</strong>。其中，真正意义上的基于硬件的虚拟化技术不多见，基于软件的虚拟化从对象所在的层次，又可以分为<strong>应用虚拟化</strong>和<strong>平台虚拟化</strong>（通常说的虚拟机技术即属于这个范畴）。前者一般指的是一些模拟设备或诸如 Wine 这样的软件，后者又可以细分为几个子类：</p>
<ul>
<li>
<p><strong>完全虚拟化</strong>。虑拟机模拟完整的底层硬件环境和特权指令的执行过程，客户操作系统无须进行修改。例如 IBM p 和 z 系列的康拟化、VMware Workstation、VirtualBox、QEMU 等；</p>
</li>
<li>
<p><strong>硬件辅助虚拟化</strong>。利用硬件（主要是 CPU）辅助支持（目前 x86 体系结构上可用的硬件辅助虚拟化技术包括 Intel-VT 和 AMD-V）处理敏感指令来实现完全虚拟化的功能，客户操作系统无须修政，例如 VMware Workstation，Xen，KVM；</p>
</li>
<li>
<p><strong>部分虚拟化</strong>。只针对部分硬件资源进行虚拟化，客户操作系统需要进行修改。现在有些虚拟化技术的早期版本仅支持部分虚拟化；</p>
</li>
<li>
<p><strong>超虚拟化（paravirtualization）</strong>。部分硬件接口以软件的形式提供给客户机操作系统，客户操作系统需要进行修改，例如早期的 Xen；</p>
</li>
<li>
<p><strong>操作系统级虚拟化</strong>。内核通过创建多个虚拟的操作系统实例（内核和库）来隔离不同的进程。容器相关技术即在这个范畴。</p>
</li>
</ul>
<p>可见，Docker 以及其他容器技术都属于操作系统虚拟化这个范畴，操作系统虚拟化最大的特点就是不需要额外的 supervisor 支持。Docker 虚拟化方式之所以有众多优势，跟操作系统虚拟化技术自身的设计和实现是分不开的。</p>
<p>下图比较了 Docker 和常见的虚拉机方式的不同之处。</p>
<div>
<p><img src="./assets/docker_1-1.png" alt="" loading="lazy"></p>
<p><u>图 1-1</u>	Docker 和传统的虚拟化方式的不同之处</p>
</div>
<p>传统方式是在硬件层面实现虚拟化，需要有额外的虎拟机管理应用和虚拟机操作系统层。Docker 容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，因此更加轻量级。</p>
<h2 id="小结"> 小结</h2>
<p>介绍了容器虚拟化的基本概念、Docker 的诞生历史，以及容器在云时代应用分发场景下的巨大优势。</p>
<p>与传统的虚拟机方式相比，容器虚拟化方式在很多场景下都存在极为明显的优势。无论是系统管理员、应用开发人员、测试人员，还是运维管理人员，都应该尽快掌握 Docker，尽早享受其带来的巨大便利。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-08-23T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">核心概念与安装配置</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Docker/02.docker/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Docker/02.docker/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>首先介绍 Docker 的三大核心概念：</p>
<ul>
<li>镜像（Image）</li>
<li>口容器（Container）</li>
<li>口仓库（Reposit）</li>
</ul>
<p>只有理解了这三个核心概念，才能顺利地理解 Docker 容器的整个生命周期 。
随后，将介绍如何在常见的操作系统平台上安装 Docker ，包括 Ubuntu、CentOS 、
MacOS 和 Windows 等主流操作系统 。</p>
<h2 id="核心概念"> 核心概念</h2>
<p>Docker 大部分的操作都围绕着它的三大核心概念：<strong>镜像</strong>、<strong>容器</strong>和<strong>仓库</strong>。因此，准确把握这三大核心概念对于掌握 Docker 技术尤为重要。</p>
<h3 id="_1、docker-镜像"> 1、Docker 镜像</h3>
<p>Docker 镜像类似于虚拟机镜像，可以将它理解为一个只读的模板 。</p>
<p>例如，一个镜像可以包含一个基本的操作系统环境，里面仅安装了 Apache 应用程序（或用户需要的其他软件）。可以把它称为一个 Apache 镜像 。</p>
<p>镜像是创建 Docker 容器的基础 。</p>
<p>通过版本管理和增量的文件系统，Docker 提供了一套十分简单的机制来创建和更新现有
的镜像，用户甚至可以从网上下载一个已经做好的应用镜像，并直接使用 。</p>
<h3 id="_2、docker-容器"> 2、Docker 容器</h3>
<p>Docker 容器类似于一个轻量级的沙箱， Docker 利用容器来运行和隔离应用 。</p>
<p>容器是从镜像创建的应用运行实例 。它可以启动、开始、停止、删除，而这些容器都是彼此相互隔离、互不可见的。</p>
<p>可以把容器看作一个简易版的 Linux 系统环境（包括 root 用户权限、进程空间、用户空间和网络空间等）以及运行在其中的应用程序打包而成的盒子。</p>
<div><p>注意</p>
<p>镜像自身是只读的 。 容器从镜像启动的时候，会在镜像的最上层创建一个可写层 。</p>
</div>
<h3 id="_3、docker-仓库"> 3、Docker 仓库</h3>
<p>Docker 仓库类似于代码仓库，是 Docker 集中存放镜像文件的场所。</p>
<p>有时候我们会将 Docker 仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。实际上，仓库注册服务器是存放仓库的地方，其上往往存放着多个仓库。每个仓库集中存放某一类镜像，往往包括多个镜像文件，通过不同的标签（tag）来进行区分。例如存放 Ubuntu 操作系统镜像的仓库，被称为 Ubuntu 仓库，其中可能包括 16.04、18.04 等不同版本的镜像。仓库注册服务器的示例如下图所示。</p>
<div>
<p><img src="./assets/docker_2-1.png" alt="" loading="lazy"></p>
<p><u>图 2-1</u>	注册服务器与仓库</p>
</div>
<p>根据所存储的镜像公开分享与否， Docker 仓库可以分为<strong>公开仓库</strong>（Public）和<strong>私有仓库</strong>（Private）两种形式 。</p>
<p>目前，最大的公开仓库是官方提供的 Docker Hub，其中存放着数量庞大的镜像供用户下载。国内不少云服务提供商（如腾讯云、阿里云等）也提供了仓库的本地源，可以提供稳定的国内访问 。</p>
<p>当然，用户如果不希望公开分享自己的镜像文件，Docker 也支持用户在本地网络内创建一个只能自己访问的私有仓库。</p>
<p>当用户创建了自己的镜像之后就可以使用 push 命令将它上传到指定的公有或者私有仓库。这样用户下次在另外一台机器上使用该镜像时，只需要将其从仓库上 pull 下来就可以了。</p>
<div><p>注意</p>
<p>可以看出，Docker 利用仓库管理镜像的设计理念与 Git 代码仓库的概念非常相似，实际上 Docker 设计上借鉴了 Git 的很多优秀思想。</p>
</div>
<h2 id="安装-docker-引擎"> 安装 Docker 引擎</h2>
<p>Docker 引擎是使用 Docker 容器的核心组件，可以在主流的操作系统和云平台上使用，包括 Linux 操作系统（如 Ubuntu、Debian、CentOS、Redhat 等)，macOS 和 Windows 操作系统，以及 IBM、亚马逊、微软等知名云平台。</p>
<p>用户可以访问 Docker 官网的 <a href="https://www.docker.com/get-docker" target="_blank" rel="noopener noreferrer">Get Docker</a> 页面，查看获取 Docker 的方式，以及 Docker 支持的平台类型，如下图所示。</p>
<div>
<p><img src="./assets/docker_2-2.png" alt="" loading="lazy"></p>
<p><u>图 2-2</u>	获取 Docker</p>
</div>
<p>目前 Docker 支持 Docker 引擎、Docker Hub、Docker Cloud 等多种服务 。</p>
<ul>
<li>
<p>Docker 引擎：包括支持在桌面系统或云平台安装 Docker，以及为企业提供简单安全弹性的容器集群编排和管理；</p>
</li>
<li>
<p>Docker Hub：官方提供的云托管服务，可以提供公有或私有的镜像仓库；</p>
</li>
<li>
<p>Docker Cloud：官方提供的容器云服务，可以完成容器的部署与管理，可以完整地支持容器化项目，还有 CI、CD 功能。</p>
</li>
</ul>
<p>Docker 引擎目前分为两个版本：社区版本（Community Edition，CE）和企业版本（Enterprise Edition，EE）。社区版本包括大部分的核心功能，企业版本则通过付费形式提供认证支持、镜像管理、容器托管、安全扫描等高级服务。通常情况下，用户使用社区版本可以满足大部分需求；若有更苛刻的需求，可以购买企业版本服务。社区版本每个月会发布一次尝鲜（Edge）版本，每个季度（ 3、6、9、12 月）会发行一次稳定（Stable）版本。版本号命名格式为“年份.月份”，如 2018 年 6 月发布的版本号为 vl8.06 。</p>
<p>我们首选在 Linux 环境中使用 Docker 社区稳定版本，以获取最佳的原生支持体验。</p>
<h3 id="_1、ubuntu-环境下安装-dokeer"> 1、Ubuntu 环境下安装 Dokeer</h3>
<ul>
<li>系统要求</li>
</ul>
<p>Ubuntu 操作系统对 Docker 的支持十分成熟，可以支持包括 x86_64、armhf、s390x（IBM Z)、ppc64le 等系统架构，只要是 64 位即可。</p>
<p>Docker 目前支持的最低 Ubuntu 版本为 14.04 LTS，但实际上从稳定性上考虑，推荐使用 16.04 LTS 或 18.0.4 LTS 版本，并且系统内核越新越好，以支持 Docker 最新的特性 。</p>
<p>用户可以通过如下命令检查自己的内核版本详细信息：</p>
<div><pre><code>$ <span>uname</span> -a
Linux localhost <span>4.9</span>.36-x86_64-generic
<span>#或者 :</span>
$ <span>cat</span> /proc/version
Linux version <span>4.9</span>.36-x86_64-generic <span>(</span>maker@linux.com<span>)</span> <span>(</span>gcc version <span>4.9</span>.2 <span>(</span>Debian <span>4.9</span>.2-10<span>))</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>如果使用 Ubuntu 16.04 LTS 版本，为了让 Docker 使用 aufs 存储，推荐安装如下两个软件包：</p>
<div><pre><code>$ <span>sudo</span> <span>apt-get</span> update
$ <span>sudo</span> <span>apt-get</span> <span>install</span> -y linux-image-extra-<span><span>$(</span><span>uname</span> -r<span>)</span></span> linux image-extra-virtual
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><p>注意</p>
<p>Ubuntu 发行版中，LTS（Long-Term- Support）意味着更稳定的功能和更长期（目前为 5 年）的升级支持，生产环境中推荐尽量使用 LTS 版本。</p>
</div>
<ul>
<li>添加镜像源</li>
</ul>
<p>首先需要安装 <code>apt-transport-https</code> 等软件包支持 https 协议的源：</p>
<div><pre><code>$ <span>sudo</span> <span>apt-get</span> update
$ <span>sudo</span> <span>apt-get</span> <span>install</span> apt-transport-https ca-certificates <span>curl</span> software-properties-common
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>添加源的 gpg 密钥：</p>
<div><pre><code>$ <span>curl</span> -fsSL https://download.docker.com/linux/ubuntu/gpg <span>|</span> <span>sudo</span> apt-key <span>add</span> -
OK
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>确认导入指纹为“<u>9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88</u>”的 GPG公钥：</p>
<div><pre><code>$ <span>sudo</span> apt-key fingerprint 0EBFCD88
pub   rsa4096 <span>2017</span>-02-22 <span>[</span>SCEA<span>]</span>
      9DC8 <span>5822</span> 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88
uid           <span>[</span> 未知 <span>]</span> Docker Release <span>(</span>CE deb<span>)</span> <span>&lt;</span>docker@docker.com<span>></span>
sub   rsa4096 <span>2017</span>-02-22 <span>[</span>S<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>获取当前操作系统的代号 :</p>
<div><pre><code>$ lsb_release -cs
bionic
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>一般情况下，Ubuntu 16.04 LTS 代号为 xenial，Ubuntu 18.04 LTS 代号为 bionic 。</p>
<p>接下来通过如下命令添加 Docker 稳定版的官方软件源，非 bionic 版本的系统注意修改为自己对应的代号：</p>
<div><pre><code>$ <span>sudo</span> add-apt-repository <span>"deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable"</span>
</code></pre>
<div><span>1</span><br></div></div><p>添加成功后，再次更新 apt 软件包缓存：</p>
<div><pre><code>$ <span>sudo</span> <span>apt-get</span> update
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>开始安装 Docker</li>
</ul>
<p>在成功添加源之后，就可以安装最新版本的 Docker 了，软件包名称为 docker-ce，代表是社区版本：</p>
<div><pre><code>$ <span>sudo</span> <span>apt-get</span> <span>install</span> -y docker-ce
</code></pre>
<div><span>1</span><br></div></div><p>如果系统中存在较旧版本的 Docker，会提示是否先删除，选择是即可。</p>
<p>除了基于手动添加软件源的方式之外，也可以使用官方提供的脚本来自动化安装 Docker：</p>
<div><pre><code>$ <span>sudo</span> <span>curl</span> - sSL https://get.docker.com/ <span>|</span> <span>sh</span>
</code></pre>
<div><span>1</span><br></div></div><p>安装成功后，会自动启动 Docker 服务 。</p>
<p>用户也可以指定安装软件源中其他版本的 Docker：</p>
<div><pre><code>$ <span>sudo</span> <span>apt-cache</span> madison docker-ce
 docker-ce <span>|</span> <span>5</span>:20.10.8~3-0~ubuntu-bionic <span>|</span> https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages
 docker-ce <span>|</span> <span>5</span>:20.10.7~3-0~ubuntu-bionic <span>|</span> https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages
<span>..</span>.
 docker-ce <span>|</span> <span>18.06</span>.0~ce~3-0~ubuntu <span>|</span> https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages
 docker-ce <span>|</span> <span>18.03</span>.1~ce~3-0~ubuntu <span>|</span> https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages
$ <span>sudo</span> <span>apt-get</span> <span>install</span> <span>18.03</span>.1~ce~3-0~ubuntu
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="_2、centos-环境下安装-docker"> 2、CentOS 环境下安装 Docker</h3>
<p>Docker 目前支持 CentOS 7 及以后的版本。系统的要求跟 Ubuntu 情况类似，64 位操作系统，内核版本至少为 3.10 。</p>
<p>首先，为了方便添加软件源，以及支持 devicemapper 存储类型，安装如下软件包：</p>
<div><pre><code>$ <span>sudo</span> yum update
$ <span>sudo</span> yum <span>install</span> -y yum-utils device-mapper-persistent-data lvm2
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>添加 Docker 稳定版本的 yum 软件源：</p>
<div><pre><code>$ <span>sudo</span> yum-config-manager --add-repo https://download.docker.corn/linux/centos/docker-ce.repo
</code></pre>
<div><span>1</span><br></div></div><p>之后更新 yum 软件源缓存，并安装 Docker：</p>
<div><pre><code>$ <span>sudo</span> yum update
$ <span>sudo</span> yum <span>install</span> -y docker-ce
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>最后，确认 Docker 服务启动正常 :</p>
<div><pre><code>$ <span>sudo</span> systernctl start <span>docker</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="_3、通过脚本安装"> 3、通过脚本安装</h3>
<p>用户还可以使用官方提供的 shell 脚本来在 Linux 系统（目前支持 Ubuntu、Debian、Oracleserver、Fedora、Centos、OpenSuse、Gentoo 等常见发行版）上安装 Docker 的最新正式版本，该脚本会自动检测系统信息并进行相应配置：</p>
<div><pre><code>$ <span>curl</span> -fsSL https://get.docker.com/ <span>|</span> <span>sh</span>
或者：
$ <span>wget</span> -qO- https://get.docker.com/ <span>|</span> <span>sh</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果想尝鲜最新功能，可以使用下面的脚本来安装最新的“尝鲜”版本。但要注意，非稳定版本往往意味着功能还不够稳定，不要在生产环境中使用：</p>
<div><pre><code>$ <span>curl</span> -fsSL https://test.docker.com/ <span>|</span> <span>sh</span>
</code></pre>
<div><span>1</span><br></div></div><p>另外，也可以从 store.docker.com/search?offering=community&amp;q=&amp;type=edition 找到各个平台上的 Docker 安装包，自行下载使用。</p>
<div><p>说明</p>
<p>关于 macOS 和 Windows 系统的 Docker 安装方法，此处省略，不进行说明。</p>
</div>
<h2 id="配置-docker-服务"> 配置 Docker 服务</h2>
<p>为了避免每次使用 Docker 命令时都需要切换到特权身份，可以将当前用户加入安装中自动创建的 docker 用户组，代码如下：</p>
<div><pre><code>$ <span>sudo</span> <span>usermod</span> -aG <span>docker</span> USER_NAME
<span>#USER_NAME是你使用的用户名，可以 echo $USER 命令查看</span>
<span>#或者直接用下面命令，将当前用户加入到docker组</span>
$ <span>sudo</span> <span>usermod</span> -aG <span>docker</span> <span>$USER</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>用户更新组信息，退出并重新登录后即可生效。</p>
<p>Docker 服务启动时实际上是调用了 <code>dockerd</code> 命令，支持多种启动参数。因此，用户可以直接通过执行 <code>dockerd</code> 命令来启动 Docker 服务，如下面的命令启动 Docker 服务，开启 Debug 模式，并监听在本地的 2376 端口：</p>
<div><pre><code>$ dockerd -D -H tcp://127.0.0.1:2376
</code></pre>
<div><span>1</span><br></div></div><p>这些选项可以写入 <code>/etc/docker/</code> 路径下的 <code>daemon.json</code> 文件中，由 dockerd 服务启动时读取：</p>
<div><pre><code><span>{</span>
		<span>"debug"</span> <span>:</span> <span>true</span><span>,</span>
		<span>"hosts"</span> <span>:</span> <span>[</span><span>"tcp://127.0.0.1:2376"</span><span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>当然，操作系统也对 Docker 服务进行了封装，以使用 Upstart 来管理启动服务的
Ubuntu 系统为例，Docker 服务的默认配置文件为 <code>/etc/default/docker</code> ，可以通过修改其中的 DOCKER_OPTS 来修改服务启动的参数，例如让 Docker 服务开启网络 2375 端口的监昕：</p>
<div><pre><code><span>DOCKER_OPTS</span><span>=</span><span>"<span>$DOCKER_OPTS</span> -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock"</span>
</code></pre>
<div><span>1</span><br></div></div><p>修改之后，通过 <code>service</code> 命令来重启 Docker 服务：</p>
<div><pre><code>$ <span>sudo</span> <span>service</span> <span>docker</span> restart
</code></pre>
<div><span>1</span><br></div></div><p>对于 CentOS、RedHat 等系统，服务通过 systemd 来管理，配置文件路径为 <code>/etc/systemd/system/docker.service.d/docker.conf</code>。更新配置后需要通过 <code>systemctl</code> 命令来管理 Docker 服务：</p>
<div><pre><code>$ <span>sudo</span> systemctl daemon-reload
$ <span>sudo</span> systemctl start docker.service
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>此外，如果服务工作不正常，可以通过查看 Docker 服务的日志信息来确定问题，例如在 RedHat 系统上日志文件可能为 <code>/var/log/messages</code>，在 Ubuntu 或 CentOS 系统上可以执行命令 <code>journalctl -u docker.service</code>。</p>
<p>每次重启 Docker 服务后，可以通过查看 Docker 信息（docker info 命令），确保服务已经正常运行 。</p>
<h2 id="推荐实践环境"> 推荐实践环境</h2>
<p>从稳定性上考虑，推荐实践环境的操作系统是 Ubuntu 18.04 LTS 系统或 Debian 稳
定版本系统，使用 Linux 4.0 以上内核 。 Docker 不同版本的 API 会略有差异，推荐根据需求选择较新的稳定版本 。</p>
<p>如无特殊说明，默认数据网段地址范围为 10.0.0.0/24，管理网段地址范围为 192.168.0.0/24 。</p>
<p>另外，执行命令代码中以 <strong>$</strong> 开头的，表明为普通用户；以 <strong>#</strong> 开头的，表明为特权用户（root）。如果用户已经添加到了 docker 用户组，大部分时候都无须管理员权限，否则需要在命令前使用 sudo 来临时提升权限。</p>
<p>部分命令执行结果输出内容较长的，只给出关键部分输出。</p>
<h2 id="小结"> 小结</h2>
<p>介绍了 Docker 的三大核心概念：镜像、容器和仓库，以及如何安装和配置 Docker 引擎服务。</p>
<p>在后面的实践中，你会感受到，基于三大核心概念所构建的高效工作流程，正是 Docker 从众多容器虚拟化方案中脱颖而出的重要原因。实际上，Docker 和 Docker Hub 的工作流也并非凭空创造的，很大程度上参考了 Git 和 Github 的设计理念，从而为应用分发和团队合作都带来了众多优势。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-08-23T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">使用 Docker 镜像</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Docker/03.docker/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Docker/03.docker/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>镜像是 Docker 三大核心概念中最重要的，自 Docker 诞生之日起镜像就是相关社区最为热门的关键词。</p>
<p>Docker 运行容器前需要本地存在对应的镜像，如果镜像不存在，Docker 会尝试先从默认镜像仓库下载（默认使用 Docker Hub 公共注册服务器中的仓库），用户也可以通过配置，使用自定义的镜像仓库。</p>
<p>本章将围绕镜像这一核心概念介绍具体操作，包括如何使用 <code>pull</code> 命令从 Docker Hub 仓库中下载镜像到本地；如何查看本地已有的镜像信息和管理镜像标签；如何在远端仓库使用 <code>search</code> 命令进行搜索和过滤；如何删除镜像标签和镜像文件；如何创建用户定制的镜像并且保存为外部文件。最后，还将介绍如何往 Docker Hub 仓库中推送自己的镜像。</p>
<h2 id="获取镜像"> 获取镜像</h2>
<p>镜像是运行容器的前提，官方的 Docker Hub 网站已经提供了数十万个镜像供大家开放下载。但是，根据 Docker 公司政策，2020 年 11 月 01 日起将逐步向 Docker Hub 匿名和免费用户实施速率和拉取请求次数限制。因此，如果您在个人版中构建服务拉取 Docker Hub 镜像，将可能受此影响导致构建失败。</p>
<p>关于 Docker Hub 拉取请求次数限制的详细介绍，请参见 <a href="https://docs.docker.com/docker-hub/download-rate-limit/" target="_blank" rel="noopener noreferrer">Download rate limit</a>。</p>
<div><p>解决方法</p>
<p>要解决此问题，需要配置国内仓库源。</p>
<div><pre><code>$ <span>sudo</span> <span>vim</span> /etc/docker/daemon.json
<span>#新建daemon.json文件，并配置以下内容</span>
<span>{</span>
  <span>"registry-mirrors"</span><span>:</span> <span>[</span><span>"&lt;国内加速镜像源地址>"</span><span>]</span>
<span>}</span>
<span>#保存推出</span>

<span>#国内加速镜像源地址</span>
https://registry.docker-cn.com
http://hub-mirror.c.163.com
https://3laho3y3.mirror.aliyuncs.com
http://f1361db2.m.daocloud.io
https://mirror.ccs.tencentyun.com

<span>#然后重新加载配置，重启服务</span>
$ <span>sudo</span> systemctl daemon-reload
$ <span>sudo</span> systemctl restart <span>docker</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>之后就可以正常 pull 镜像了。</p>
</div>
<p>我们可以使用 <code>docker [image] pull</code> 命令直接从 Docker Hub 镜像源来下载镜像。该命令的格式为 <code>docker [image] pull NAME[:TAG]</code>。</p>
<p>其中，NAME 是镜像仓库名称（用来区分镜像），TAG 是镜像的标签（往往用来表示版本
信息）。通常情况下，描述一个镜像需要包括“名称+标签”信息。</p>
<p>例如，获取一个 Ubuntu 18.04 系统的基础镜像可以使用如下的命令：</p>
<div><pre><code>$ <span>docker</span> pull ubuntu:18.04
<span>18.04</span>: Pulling from library/ubuntu
e4ca327ec0e7: Pull complete 
Digest: sha256:9bc830af2bef73276515a29aa896eedfa7bdf4bdbc5c1063b4c457a4bbb8cd79
Status: Downloaded newer image <span>for</span> ubuntu:18.04
docker.io/library/ubuntu:18.04
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>对于 Docker 镜像来说，如果不显式指定 TAG，则默认会选择 latest 标签，这会下载仓库中最新版本的镜像。</p>
<p>下面的例子将从 centos 仓库下载一个最新版本的 centos 操作系统的镜像：</p>
<div><pre><code>$ <span>docker</span> pull centos
Using default tag: latest
latest: Pulling from library/centos
7a0437f04f83: Pull complete 
Digest: sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1
Status: Downloaded newer image <span>for</span> centos:latest
docker.io/library/centos:latest
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>该命令实际上下载的就是 centos:latest 镜像。</p>
<div><p>注意</p>
<p>一般来说，镜像的 latest 标签意味着该镜像的内容会跟踪最新版本的变更而变化，内容是不稳定的。因此，从稳定性上考虑，不要在生产环境中忽略镜像的标签信息或使用默认的 latest 标记的镜像。</p>
</div>
<p>下载过程中可以看出，镜像文件一般由若干层（layer）组成，e4ca327ec0e7 这样的串是层的唯一 id（实际上完整的 id 包括 256 比特，64 个十六进制字符组成）。使用 <code>docker pull</code> 命令下载中会获取并输出镜像的各层信息。当不同的镜像包括相同的层时，本地仅存储了层的一份内容，减小了存储空间。</p>
<p>你可能会想到，在不同的镜像仓库服务器的情况下，可能会出现镜像重名的情况。</p>
<p>严格地讲，镜像的仓库名称中还应该添加仓库地址（即 registry，注册服务器）作为前缀，只是默认使用的是官方 Docker Hub 服务，该前缀可以忽略。</p>
<p>例如，<code>docker pull ubuntu:18.04</code> 命令相当于 <code>docker pull registry.hub.docker.com/ubuntu:18.04</code> 命令，即从默认的注册服务器 Docekr Hub Registry 中的 ubuntu 仓库来下载标记为 18.04 的镜像。</p>
<p>如果从非官方的仓库下载，则需要在仓库名称前指定完整的仓库地址。例如从网易蜂巢命令，此时下载的镜像名称为 <code>hub.c.163.com/public/ubuntu:18.04</code>：</p>
<div><pre><code>$ <span>docker</span> pull hub.c.163.com/public/ubuntu:18.04
</code></pre>
<div><span>1</span><br></div></div><p><code>pull</code> 子命令支持的选项主要包括：</p>
<ul>
<li>
<p>-a，--all-tags=true|false：是否获取仓库中的所有镜像，默认为否；</p>
</li>
<li>
<p>--disable-content-trust：取消镜像的内容校验，默认为真。</p>
</li>
</ul>
<p>另外，有时需要使用镜像代理服务来加速 Docke 镜像获取过程，可以在 Docker 服务
启动配置中增加 --registry-mirror=proxy_URL 来指定镜像代理服务地址（如 https://
registry.docker-en.com）</p>
<p>下载镜像到本地后，即可随时使用该镜像了，例如利用该镜像创建一个容器，在其中运
行 bash 应用，执行打印&quot;HelloWorld&quot;命令：</p>
<div><pre><code>$ <span>docker</span> run -it ubuntu:18.04 <span>bash</span>
root@65663247040f:/<span># echo "Hello World"</span>
Hello World
root@65663247040f:/<span># exit</span>
<span>exit</span>
$  
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="查看镜像信息"> 查看镜像信息</h2>
<p>主要介绍 Docker 镜像的 <code>ls</code>、<code>tag</code> 和 <code>inspect</code> 子命令。</p>
<h3 id="_1、使用-images-命令列出镜像"> 1、使用 images 命令列出镜像</h3>
<p>使用 <code>docker images</code> 或 <code>docker image ls</code> 命令可以列出本地主机上已有镜像的基本信息。</p>
<p>例如，下面的命令列出了之前下载的镜像信息：</p>
<div><pre><code>$ <span>docker</span> images
REPOSITORY    TAG       IMAGE ID       CREATED        SIZE
ubuntu        <span>18.04</span>     54919e10a95d   <span>2</span> days ago     <span>63</span>.1MB
hello-world   latest    d1165f221234   <span>6</span> months ago   <span>13</span>.3kB
centos        latest    300e315adb2f   <span>8</span> months ago   209MB
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>在列出信息中，可以看到几个字段信息：</p>
<ul>
<li>
<p>来自于哪个仓库，比如 ubuntu 表示 ubuntu 系列的基础镜像；</p>
</li>
<li>
<p>镜像的标答信息，比如 18.04、latest 表示不同的版本信息。标签只是标记，并不能标
识镜像内容；</p>
</li>
<li>
<p>镜像的 ID（唯一标识镜像），如果两个镜像的 ID 相同，说明它们实际上指向了同一个镜像，只是具有不同标签名称而已；</p>
</li>
<li>
<p>创建时间，说明镜像最后的更新时间；</p>
</li>
<li>
<p>镜像大小，优秀的镜像往往体积都较小。</p>
</li>
</ul>
<p>其中镜像的 ID 信息十分重要，它唯一标识了镜像。在使用镜像 ID 的时候，一般可以使用该 ID 的前若干个字符组成的可区分串来替代完整的 ID。</p>
<p>TAG 信息用于标记来自同一个仓库的不同镜像。例如 ubuntu 仓库中有多个镜像，通过 TAG 信息来区分发行版本，如 18.04、18.10 等。</p>
<p>镜像大小信息只是表示了该镜像的逻辑体积大小，实际上由于相同的镜像层本地只会存储一份，物理上占用的存储空间会小于各镜像逻辑体积之和。</p>
<p>images 子命令主要支持如下选项，用户可以自行进行尝试：</p>
<ul>
<li>
<p>-a，--all=true|false：列出所有（包括临时文件）镜像文件，默认为否；</p>
</li>
<li>
<p>--digests=true|false：列出镜像的数字摘要值，默认为否；</p>
</li>
<li>
<p>-f，--filter=[]：过滤列出的镜像，如 dangling=true 只显示没有被使用的镜像；也可指定带有特定标注的镜像等；</p>
</li>
<li>
<p>--format=&quot;TEMPLATE&quot;：控制输出格式，如 <code>.ID</code> 代表 ID 信息，<code>.Repository</code> 代表仓库信息等；</p>
</li>
<li>
<p>--no-trunc=true|false：对输出结果中太长的部分是否进行截断，如镜像的 ID 信息，默认为是；</p>
</li>
<li>
<p>-q，--quiet=true|false：仅输出 ID 信息，默认为否。</p>
</li>
</ul>
<p>其中，还支持对输出结果进行控制的选项，如 -f. --filter=[]、--no-trunc=true|false、-q、--quiet=true|false 等。</p>
<p>更多子命令选项还可以通过 <code>man docker-images</code> 来查看。</p>
<h3 id="_2、使用-tag-命令添加镜像标签"> 2、使用 tag 命令添加镜像标签</h3>
<p>为了方便在后续工作中使用特定镜像，还可以使用 <code>docker tag</code> 命令来为本地镜像任意添加新的标签。 例如，添加 一 个新的 centos:latest 镜像标签：</p>
<div><pre><code>$ <span>docker</span> tag centos:latest mycentos
</code></pre>
<div><span>1</span><br></div></div><p>再次使用 <code>docker images</code> 列出本地主机上镜像信息， 可以看到多了一 个 mycentos:latest 标签的镜像：</p>
<div><pre><code>$ <span>docker</span> images
REPOSITORY    TAG       IMAGE ID       CREATED        SIZE
ubuntu        <span>18.04</span>     54919e10a95d   <span>2</span> days ago     <span>63</span>.1MB
hello-world   latest    d1165f221234   <span>6</span> months ago   <span>13</span>.3kB
centos        latest    300e315adb2f   <span>8</span> months ago   209MB
mycentos      latest    300e315adb2f   <span>8</span> months ago   209MB
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>之后， 用户就可以直接使用 mycentos:latest 来表示这个镜像了。
细心的你可能注意到， 这些 mycentos:latest 镜像的 ID 跟 centos:latest 是完全一致的，它们实际上指向了同一个镜像文件，只是别名不同而巳。<code>docker tag</code> 命令添加的标签实际上起到了类似链接的作用。</p>
<h3 id="_3、使用-inspect-命令查看详细信息"> 3、使用 inspect 命令查看详细信息</h3>
<p>使用 <code>docker [image] inspect</code> 命令可以获取该镜像的详细信息，包括制作者、适应架构、各层的数字摘要等：</p>
<div><pre><code>$ <span>docker</span> inspect ubuntu:18.04
<span>[</span>
    <span>{</span>
        <span>"Id"</span><span>:</span> <span>"sha256:54919e10a95d6f756f7286dc0fa6b3e25b637a7f90e361504b0b14ab6762a547"</span>,
        <span>"RepoTags"</span><span>:</span> <span>[</span>
            <span>"ubuntu:18.04"</span>
        <span>]</span>,
        <span>"RepoDigests"</span><span>:</span> <span>[</span>
            <span>"ubuntu@sha256:9bc830af2bef73276515a29aa896eedfa7bdf4bdbc5c1063b4c457a4bbb8cd79"</span>
        <span>]</span>,
        <span>"Parent"</span><span>:</span> <span>""</span>,
        <span>"Comment"</span><span>:</span> <span>""</span>,
        <span>"Created"</span><span>:</span> <span>"2021-08-31T01:20:48.414661265Z"</span>,
<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>上面代码返回的是一个 JSON 格式的消息，如果我们只要其中一项内容时，可以使用 -f 来指定，例如，获取镜像的 Architecture：</p>
<div><pre><code>$ <span>docker</span> inspect -f <span>{</span><span>{</span><span>".Architecture"</span><span>}</span><span>}</span> ubuntu:18.04
amd64
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="_4、使用-history-命令查看镜像历史"> 4、使用 history 命令查看镜像历史</h3>
<p>既然镜像文件由多个层组成， 那么怎么知道各个层的内容具体是什么呢？这时候可以使用 <code>history</code> 子命令，该命令将列出各层的创建信息。</p>
<p>例如，查看 ubuntu:18.04 镜像的创建过程，可以使用如下命令：</p>
<div><pre><code>$ <span>docker</span> <span>history</span> ubuntu:18.04
IMAGE          CREATED      CREATED BY                                      SIZE      COMMENT
54919e10a95d   <span>2</span> days ago   /bin/sh -c <span>#(nop)  CMD ["bash"]                 0B        </span>
<span>&lt;</span>missing<span>></span>      <span>2</span> days ago   /bin/sh -c <span>#(nop) ADD file:425a053fd043786e9…  63.1MB    </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><p>注意</p>
<p>过长的命令被自动截断了，可以使用前面提到的 --no-trunc 选项来输出完整命令。</p>
</div>
<h2 id="搜寻镜像"> 搜寻镜像</h2>
<p>本节主要介绍 Docker 镜像的 <code>search</code> 子命令。使用 <code>docker search</code> 命令可以搜索 Docker Hub 官方仓库中的镜像。 语法为 <code>docker search [option] keyword</code>。支持的命令选项主要包括：</p>
<ul>
<li>
<p>-f，--filter filter：过滤输出内容；</p>
</li>
<li>
<p>--format string：格式化输出内容；</p>
</li>
<li>
<p>--limit int：限制输出结果个数，默认为 25 个；</p>
</li>
<li>
<p>--no-trunc：不截断输出结果。</p>
</li>
</ul>
<p>例如，搜索官方提供的带 nginx 关键字的镜像，如下所示：</p>
<div><pre><code>$ <span>docker</span> search --filter<span>=</span>is-official<span>=</span>true nginx
NAME      DESCRIPTION                STARS     OFFICIAL   AUTOMATED
nginx     Official build of Nginx.   <span>15394</span>     <span>[</span>OK<span>]</span>       
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>再比如，搜索所有收藏数超过 4 的关键词包括 tensorflow 的镜像：</p>
<div><pre><code>$ <span>docker</span> search --filter<span>=</span>stars<span>=</span><span>4</span> tensorflow
NAME                                       DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
tensorflow/tensorflow                      Official Docker images <span>for</span> the machine learn…   <span>1944</span>                 
jupyter/tensorflow-notebook                Jupyter Notebook Scientific Python Stack w/ …   <span>280</span>                  
tensorflow/serving                         Official images <span>for</span> TensorFlow Serving <span>(</span>http…   <span>117</span>                  
rocm/tensorflow                            Tensorflow with ROCm backend support            	<span>62</span>                   
xblaster/tensorflow-jupyter                Dockerized Jupyter with tensorflow              	<span>56</span>                   <span>[</span>OK<span>]</span>
floydhub/tensorflow                        tensorflow                                      	<span>29</span>                   <span>[</span>OK<span>]</span>
opensciencegrid/tensorflow-gpu             TensorFlow GPU <span>set</span> up <span>for</span> OSG                   	<span>12</span>                   
emacski/tensorflow-serving                 Project images from https://github.com/emacs…   <span>10</span>                   
tokunagaken/tensorflow-keras-jupyter-py3   TensorFlow-gpu <span>1.13</span>.1 Keras <span>2.2</span>.4 python <span>3.5</span>…   <span>5</span>                    
tensorflow/tf_grpc_test_server             Testing server <span>for</span> GRPC-based distributed ru…   <span>4</span>               
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受欢迎程度）、是否官方创建、是否自动创建等。默认的输出结果将按照星级评价进行排序。</p>
<h2 id="删除和清理镜像"> 删除和清理镜像</h2>
<p>主要介绍 Docker 镜像的 <code>rm</code> 和 <code>prune</code> 子命令。</p>
<h3 id="_1、使用标签删除镜像"> 1、使用标签删除镜像</h3>
<p>使用 <code>docker rmi</code> 或 <code>docker image rm</code> 命令可以删除镜像，命令格式为 <code>docker rmi IMAGE [IMAGE...]</code>，其中 IMAGE 可以为标签或 ID。</p>
<p>支持选项包括：</p>
<ul>
<li>-f，-force：强制删除镜像，即使有容器依赖它；</li>
<li>-no-prune：不要清理未带标签的父镜像。</li>
</ul>
<p>例如，要删除掉 mycentos:latest 镜像，可以使用如下命令：</p>
<div><pre><code>$ <span>docker</span> rmi mycentos:latest 
Untagged: mycentos:latest
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>你可能会想到，本地的 centos:latest 镜像是否会受到此命令的影响。无须担心，当同一个镜像拥有多个标签的时候，<code>docker rmi</code> 命令只是删除了该镜像多个标签中的指定标签而巳，并不影响镜像文件。因此上述操作相当于只是删除了镜像 300e315adb2f 的一个标签副本而已。</p>
<p>保险起见，再次查看本地的镜像，发现 centos:latest 镜像（准确地说，300e315adb2f
镜像）仍然存在：</p>
<div><pre><code>$ <span>docker</span> images
REPOSITORY    TAG       IMAGE ID       CREATED        SIZE
ubuntu        <span>18.04</span>     54919e10a95d   <span>2</span> days ago     <span>63</span>.1MB
hello-world   latest    d1165f221234   <span>6</span> months ago   <span>13</span>.3kB
centos        latest    300e315adb2f   <span>8</span> months ago   209MB
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>但当镜像只剩下一个标签的时候就要小心了，此时再使用 <code>docker rmi</code> 命令会彻底删除镜像。</p>
<p>例如通过执行 <code>docker rmi</code> 命令来删除只有一个标签的镜像，可以看出会删除这个镜像文件的所有文件层：</p>
<div><pre><code>$ <span>docker</span> rmi hello-world:latest 
Untagged: hello-world:latest
Untagged: hello-world@sha256:7d91b69e04a9029b99f3585aaaccae2baa80bcf318f4a5d2165a9898cd2dc0a1
Deleted: sha256:d1165f2212346b2bab48cb01c1e39ee8ad1be46b87873d9ca7a4e434980a7726
Deleted: sha256:f22b99068db93900abe17f7f5e09ec775c2826ecfe9db961fea68293744144bd
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><p>说明</p>
<p>如果在删除镜像，遇到下面的 Erroe 时，需要先删除容器，再删除镜像。</p>
<div><pre><code><span># 1、删除镜像时出现 Error</span>
$ <span>docker</span> rmi hello-world:latest 
Error response from daemon: conflict: unable to remove repository reference <span>"hello-world:latest"</span> <span>(</span>must force<span>)</span> - container 882249d25e88 is using its referenced image d1165f221234

<span># 2、先删除容器（可以查到镜像所在容器的CONTAINER ID）</span>
$ <span>docker</span> <span>ps</span> -a
CONTAINER ID   IMAGE          COMMAND    CREATED       STATUS                   PORTS     NAMES
882249d25e88   hello-world    <span>"/hello"</span>   <span>4</span> hours ago   Exited <span>(</span><span>0</span><span>)</span> <span>4</span> hours ago             priceless_neumann
dba94731dbca   centos         <span>"bash"</span>     <span>4</span> hours ago   Exited <span>(</span><span>0</span><span>)</span> <span>4</span> hours ago             romantic_benz
810d3dbcd35b   ubuntu:18.04   <span>"bash"</span>     <span>4</span> hours ago   Exited <span>(</span><span>0</span><span>)</span> <span>4</span> hours ago             naughty_hoover
<span>#删除容器（对应的CONTAINER ID）</span>
$ <span>docker</span> <span>rm</span> 882249d25e88
882249d25e88

<span># 3、最后删除镜像</span>
$ <span>docker</span> rmi hello-world:latest 
Untagged: hello-world:latest
Untagged: hello-world@sha256:7d91b69e04a9029b99f3585aaaccae2baa80bcf318f4a5d2165a9898cd2dc0a1
Deleted: sha256:d1165f2212346b2bab48cb01c1e39ee8ad1be46b87873d9ca7a4e434980a7726
Deleted: sha256:f22b99068db93900abe17f7f5e09ec775c2826ecfe9db961fea68293744144bd
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div></div>
<h3 id="_2、使用镜像-id-来删除镜像"> 2、使用镜像 ID 来删除镜像</h3>
<p>当使用 <code>docker rmi</code> 命令，并且后面跟上镜像的 ID （也可以是能进行区分的部分 ID 前缀）时， 会先尝试删除所有指向该镜像的标签，然后删除该镜像文件本身。</p>
<p>注意，当有该镜像创建的容器存在时，镜像文件默认是无法被删除的，例如：先利用 ubuntu:18.04 镜像创建一个简单的容器来输出 一 段话：</p>
<div><pre><code>$ <span>docker</span> run ubuntu:18.04 <span>echo</span> <span>'hello! I am here!'</span>
hello<span>!</span> i am here<span>!</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>使用 <code>docker ps -a</code> 命令可以看到本机上存在的所有容器：</p>
<div><pre><code>$ <span>docker</span> <span>ps</span> -a
CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS                      PORTS     NAMES
586d17fcdf93   ubuntu:18.04   <span>"echo 'hello! i am h…"</span>  <span>25</span> seconds ago   Exited <span>(</span><span>0</span><span>)</span> <span>23</span> seconds ago             vigilant_wu
dba94731dbca   centos         <span>"bash"</span>                   <span>4</span> hours ago      Exited <span>(</span><span>0</span><span>)</span> <span>4</span> hours ago                romantic_benz
810d3dbcd35b   ubuntu:18.04   <span>"bash"</span>                   <span>4</span> hours ago      Exited <span>(</span><span>0</span><span>)</span> <span>4</span> hours ago                naughty_hoover
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>可以看到，后台存在一个退出状态的容器，是刚基于 ubuntu:18.04 镜像创建的。试图删除该镜像，Docker 会提示有容器正在运行，无法删除：</p>
<div><pre><code>$ <span>docker</span> rmi ubuntu:18.04 
Error response from daemon: conflict: unable to remove repository reference <span>"ubuntu:18.04"</span> <span>(</span>must force<span>)</span> - container 810d3dbcd35b is using its referenced image 54919e10a95d
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果要想强行删除镜像， 可以使用 -f 参数：</p>
<div><pre><code>$ <span>docker</span> rmi -f ubuntu:18.04 
Untagged: ubuntu:18.04
Untagged: ubuntu@sha256:9bc830af2bef73276515a29aa896eedfa7bdf4bdbc5c1063b4c457a4bbb8cd79
Deleted: sha256:54919e10a95d6f756f7286dc0fa6b3e25b637a7f90e361504b0b14ab6762a547
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>注意，通常并不推荐使用 -f 参数来强制删除一个存在容器依赖的镜像。正确的做法是，先删除依赖该镜像的所有容器，再来删除镜像。</p>
<p>首先删除容器 <u>586d17fcdf93</u>：</p>
<div><pre><code>$ <span>docker</span> <span>rm</span> 586d17fcdf93
</code></pre>
<div><span>1</span><br></div></div><p>然后使用 ID 来删除镜像，此时会正常打印出删除的各层信息：</p>
<div><pre><code>$ <span>docker</span> rmi 54919e10a95d
Untagged: ubuntu:18.04
Untagged: ubuntu@sha256:9bc830af2bef73276515a29aa896eedfa7bdf4bdbc5c1063b4c457a4bbb8cd79
Deleted: sha256:54919e10a95d6f756f7286dc0fa6b3e25b637a7f90e361504b0b14ab6762a547
Deleted: sha256:6babb56be2593d69d561cae7ad16b670a1ee7c0a32b4fa715007fba7febd5ddb
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="_3、清理镜像"> 3、清理镜像</h3>
<p>使用 Docker 一段时间后，系统中可能会遗留一些临时的镜像文件，以及一些没有被使用的镜像，可以通过 <code>docker image prune</code> 命令来进行清理。</p>
<p>支待选项包括：</p>
<ul>
<li>
<p>-a，-all：删除所有无用镜像，不光是临时镜像；</p>
</li>
<li>
<p>-filter filter：只清理符合给定过滤器的镜像；</p>
</li>
<li>
<p>-f，-force：强制删除镜像，而不进行提示确认。</p>
</li>
</ul>
<p>例如，如下命令会自动清理临时的遗留镜像文件层，最后会提示释放的存储空间：</p>
<div><pre><code> $ <span>docker</span> image prune -f
 <span>.</span> <span>.</span> <span>.</span>
 Total reclaimed space: <span>1.4</span> GB
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="创建镜像"> 创建镜像</h2>
<p>创建镜像的方法主要有三种：基于已有镜像的容器创建、基于本地模板导入、基于 Dockerfile 创建。</p>
<p>这里主要介绍 Docker 的 <code>commit</code>、<code>import</code> 和 <code>build</code> 子命令。</p>
<h3 id="_1、基于已有容器创建"> 1、基于已有容器创建</h3>
<p>该方法主要是使用 <code>docker [container] commit</code> 命令。</p>
<p>命令格式为 <code>docker [container] commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</code>，主要选项包括：</p>
<ul>
<li>
<p>-a，--author=&quot;&quot;：作者信息；</p>
</li>
<li>
<p>-c，--change=[]：提交的时候执行 Dockerfile 指令，</p>
<p>包括CMD|ENTRYPOINT|ENV|EXPOSE|LABEL|ONBUILD|USER|VOLUME|WORKDIR 等；</p>
</li>
<li>
<p>-m，--message= “”：提交消息；</p>
</li>
<li>
<p>-p，--pause=true：提交时暂停容器运行。</p>
</li>
</ul>
<p>下面将演示如何使用该命令创建一个新镜像。</p>
<p>首先，启动一个镜像，并在其中进行修改操作。例如，创建一个 test 文件，之后退出，代码如下：</p>
<div><pre><code>$ <span>docker</span> run -it ubuntu:18.04 /bin/bash
root@38e4a9445436:/<span># touch test</span>
root@38e4a9445436:/<span># exit</span>
<span>exit</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>记住容器的 ID 为 38e4a9445436。此时该容器与原 ubuntu:18.04 镜像相比，已经发生了改变，可以使用 <code>docker [container] commit</code> 命令来提交为一个新的镜像。提交时可以使用 ID 或名称来指定容器：</p>
<div><pre><code>$ <span>docker</span> commit -m <span>"ADDed a new file"</span> -a <span>"Docker Newbee"</span> 38e4a9445436 test:0.1
sha256:fdebc600d6f4ff0296917924668be67608af1af4ae10e4a9583478d9815a7969
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>顺利的话，会返回新创建镜像的 ID 信息，例如：</p>
<p><u>fdebc600d6f4ff0296917924668be67608af1af4ae10e4a9583478d9815a7969</u>。</p>
<p>此时查看本地镜像列表，会发现新创建的镜像已经存在了：</p>
<div><pre><code>$ <span>docker</span> images
REPOSITORY   TAG       IMAGE ID       CREATED          SIZE
<span>test</span>         <span>0.1</span>       fdebc600d6f4   <span>28</span> seconds ago   <span>63</span>.1MB
ubuntu       <span>18.04</span>     54919e10a95d   <span>2</span> days ago       <span>63</span>.1MB
centos       latest    300e315adb2f   <span>8</span> months ago     209MB
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="_2、基于本地模板导入"> 2、基于本地模板导入</h3>
<p>用户也可以直接从一个操作系统模板文件导人一个镜像，主要使用 docker [container] import 命令。命令格式为 <code>docker [image] import [OPTIONS] file|URL| - [REPOSITORY [:TAG]]</code></p>
<p>要直接导人一个镜像，可以使用 OpenVZ 提供的模板来创建，或者用其他已导出的镜像模板来创建。OPENVZ 模板的下载地址为 <a href="https://download.openvz.org/template/precreated/" target="_blank" rel="noopener noreferrer">https://download.openvz.org/template/precreated/</a>。</p>
<p>例如，下载了 ubuntu-18.04 的模板压缩包，之后使用以下命令导人即可：</p>
<div><pre><code>$ <span>wget</span> https://download.openvz.org/template/precreated/centos-7-x86_64-minimal.tar.gz
--2021-09-02 <span>16</span>:25:09--  https://download.openvz.org/template/precreated/centos-7-x86_64-minimal.tar.gz
正在解析主机 download.openvz.org <span>(</span>download.openvz.org<span>)</span><span>..</span>. <span>185.231</span>.241.69
正在连接 download.openvz.org <span>(</span>download.openvz.org<span>)</span><span>|</span><span>185.231</span>.241.69<span>|</span>:443<span>..</span>. 已连接。
已发出 HTTP 请求，正在等待回应<span>..</span>. <span>200</span> OK
长度： <span>145639219</span> <span>(</span>139M<span>)</span> <span>[</span>application/x-gzip<span>]</span>
正在保存至: “centos-7-x86_64-minimal.tar.gz”

centos-7-x86_64-minimal.tar.gz        <span>100</span>%<span>[</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>></span><span>]</span> <span>138</span>.89M  <span>2</span>.15MB/s    用时 4m 48ss

<span>2021</span>-09-02 <span>16</span>:29:59 <span>(</span><span>494</span> KB/s<span>)</span> - 已保存 “centos-7-x86_64-minimal.tar.gz” <span>[</span><span>145639219</span>/145639219<span>]</span><span>)</span>

$ <span>cat</span> centos-7-x86_64-minimal.tar.gz <span>|</span> <span>docker</span> <span>import</span> - centos:7
sha256:f1dbb0e36a07382f4f6b2001836374e51d297c841fb1fe4e85dfa92ba3f43139
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>然后查看新导人的镜像，已经在本地存在了 :</p>
<div><pre><code>$ <span>docker</span> images
REPOSITORY   TAG       IMAGE ID       CREATED         SIZE
centos       <span>7</span>         f1dbb0e36a07   <span>8</span> seconds ago   435MB
<span>test</span>         <span>0.1</span>       fdebc600d6f4   <span>2</span> hours ago     <span>63</span>.1MB
ubuntu       <span>18.04</span>     54919e10a95d   <span>2</span> days ago      <span>63</span>.1MB
centos       latest    300e315adb2f   <span>8</span> months ago    209MB
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="_3、基于-dockefile-创建"> 3、基于 Dockefile 创建</h3>
<p>基于 Dockerfile 创建是最常见的方式。Dockerfile 是一个文本文件，利用给定的指令描述基于某个父镜像创建新镜像的过程。</p>
<p>下面给出 Dockerfile 的一个简单示例，基于 debian:stretch-slim 镜像安装 Python 3 环境，构成一个新的 python:3 镜像：</p>
<div><pre><code>FROM debian:stretch-slim

LABEL <span>version</span><span>=</span><span>"1.0"</span> <span>maintainer</span><span>=</span><span>"docker user &lt;docker_user@githubs>"</span>

RUN <span>apt-get</span> update <span>&amp;&amp;</span> <span>\</span>
	<span>apt-get</span> instal l-y python3 <span>&amp;&amp;</span> <span>\</span>
	<span>apt-get</span> clean <span>&amp;&amp;</span> <span>\</span>
	<span>rm</span> -rf /var/lib/apt/lists/*
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>创建镜像的过程可以使用 <code>docker [image] build</code> 命令，编译成功后本地将多出一个 python:3 镜像：</p>
<div><pre><code>$ <span>docker</span> build -t python:3 <span>.</span>
Sending build context to Docker daemon  <span>2</span>.048kB
Step <span>1</span>/3 <span>:</span> FROM debian:stretch-slim
 ---<span>></span> 750df3e387d7
Step <span>2</span>/3 <span>:</span> LABEL <span>version</span><span>=</span><span>"1.0"</span> <span>maintainer</span><span>=</span><span>"docker user &lt;docker_user@githubs>"</span>
 ---<span>></span> Using cache
 ---<span>></span> 89c03eb7f46d
Step <span>3</span>/3 <span>:</span> RUN <span>apt-get</span> update <span>&amp;&amp;</span> <span>apt-get</span> <span>install</span> -y python3 <span>&amp;&amp;</span> <span>apt-get</span> clean <span>&amp;&amp;</span> <span>rm</span> -rf /var/lib/apt/lists/*
 ---<span>></span> Running <span>in</span> 81e5fe4c9c9a
Get:1 http://security.debian.org/debian-security stretch/updates InRelease <span>[</span><span>53.0</span> kB<span>]</span>
Ign:2 http://deb.debian.org/debian stretch InRelease
Get:3 http://security.debian.org/debian-security stretch/updates/main amd64 Packages <span>[</span><span>710</span> kB<span>]</span>
<span>..</span><span>..</span><span>..</span>
Setting up python3 <span>(</span><span>3.5</span>.3-1<span>)</span> <span>..</span>.
running python rtupdate hooks <span>for</span> python3.5<span>..</span>.
running python post-rtupdate hooks <span>for</span> python3.5<span>..</span>.
Processing triggers <span>for</span> libc-bin <span>(</span><span>2.24</span>-11+deb9u4<span>)</span> <span>..</span>.
Removing intermediate container 81e5fe4c9c9a
 ---<span>></span> cb3faf5fd7e5
Successfully built cb3faf5fd7e5
Successfully tagged python:3
<span># 编译完成，再次查看下镜像，多出一个 python 的镜像</span>
$ <span>docker</span> images
REPOSITORY   TAG            IMAGE ID       CREATED        SIZE
python       <span>3</span>              cb3faf5fd7e5   <span>15</span> hours ago   <span>95</span>.2MB
centos       <span>7</span>              f1dbb0e36a07   <span>16</span> hours ago   435MB
<span>test</span>         <span>0.1</span>            fdebc600d6f4   <span>18</span> hours ago   <span>63</span>.1MB
ubuntu       <span>18.04</span>          54919e10a95d   <span>2</span> days ago     <span>63</span>.1MB
debian       stretch-slim   750df3e387d7   <span>2</span> weeks ago    <span>55</span>.3MB
centos       latest         300e315adb2f   <span>8</span> months ago   209MB
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>更多使用 Dockerfile 的技巧将将在后面进行介绍。</p>
<h2 id="存出和载人镜像"> 存出和载人镜像</h2>
<p>主要介绍 Docker 镜像的 <code>save</code> 和 <code>load</code> 子命令。用户可以使用 <code>docker save</code> 和 <code>docker</code>
<code>[image] load</code> 命令来存出和载人镜像 。</p>
<h3 id="_1、存出镜像"> 1、存出镜像</h3>
<p>如果要导出镜像到本地文件，可以使用 <code>docker [image] save</code> 命令。该命令支持 -o、-output string 参数，导出镜像到指定的文件中。</p>
<p>例如，导出本地的 ubuntu:18.04 镜像为文件 ubuntu_18.04.tar，如下所示：</p>
<div><pre><code>$ <span>docker</span> images
REPOSITORY   TAG            IMAGE ID       CREATED        SIZE
python       <span>3</span>              cb3faf5fd7e5   <span>15</span> hours ago   <span>95</span>.2MB
centos       <span>7</span>              f1dbb0e36a07   <span>16</span> hours ago   435MB
<span>test</span>         <span>0.1</span>            fdebc600d6f4   <span>18</span> hours ago   <span>63</span>.1MB
ubuntu       <span>18.04</span>          54919e10a95d   <span>2</span> days ago     <span>63</span>.1MB
debian       stretch-slim   750df3e387d7   <span>2</span> weeks ago    <span>55</span>.3MB
centos       latest         300e315adb2f   <span>8</span> months ago   209MB
$ <span>docker</span> save -o ubuntu_18.04.tar ubuntu:18.04 
$ <span>ls</span> -lh
总用量 63M
-rw-r--r-- <span>1</span> kei <span>docker</span> <span>197</span> <span>9</span>月   <span>2</span> <span>16</span>:57 Dockerfile
-rw------- <span>1</span> kei <span>docker</span> 63M <span>9</span>月   <span>3</span> 08:48 ubuntu_18.04.tar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>之后，用户就可以通过复制 ubuntu_18.04.tar 文件将该镜像分享给他人。</p>
<h3 id="_2、载入镜像"> 2、载入镜像</h3>
<p>可以使用 <code>docker [image] load</code> 将导出的 tar 文件再导人到本地镜像库。支持 -i、-input string 选项，从指定文件中读人镜像内容。</p>
<p>例如，从文件 ubuntu_18.04.tar 导人镜像到本地镜像列表，如下所示：</p>
<div><pre><code>$ <span>docker</span> load -i ubuntu_ <span>18</span> 04.tar
Loaded image: ubuntu:18.04
或者 <span>:</span>
$ <span>docker</span> load <span>&lt;</span> ubuntu_18 04.tar
Loaded image: ubuntu:18.04
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这将导人镜像及其相关的元数据信息（包括标签等）。导入成功后，可以使用 <code>docker images</code> 命令进行查看，与原镜像一致。</p>
<h2 id="上传镜像"> 上传镜像</h2>
<p>主要介绍 Docker 镜像的 <code>push</code> 子命令。可以使用 <code>docker [image] push</code> 命令上传镜像到仓库，默认上传到 Docker Hub 官方仓库（需要登录）。</p>
<p>命令格式为 <code>docker push NAME [:TAG] | [image] [REGISTRY_HOST[:REGISTRY_PORT]/]NAME[:TAG]</code>。</p>
<p>用户在 Docker Hub 网站注册后可以上传自制的镜像。</p>
<p>例如，用户 user 上传本地的 test:latest 镜像，可以先添加新的标签 user/test:latest，然后用 <code>docker [image] push</code> 命令上传镜像：</p>
<div><pre><code>$ <span>docker</span> tag test:latest user/test:latest
$ <span>docker</span> push user/test:latest
The push refers to a repository <span>[</span>docker.io/user/test<span>]</span>
Sending image list

Please login prior to push:
Username <span>:</span>
Password:
Email <span>:</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>第一次上传时，会提示输入登录信息或进行注册，之后登录信息会记录到本地 <code>~/.docker</code>
目录下。</p>
<h2 id="小结"> 小结</h2>
<p>具体介绍了围绕 Docker 镜像的一系列重要命令操作，包括获取、查看、搜索、删除、创建、存出和载入、上传等。你可以使用 <code>docker image help</code> 命令查看 Docker 支持的镜像操作子命令。</p>
<p>镜像是使用 Docker 的前提，也是最基本的资源。所以，在平时的 Docker 使用中，要注意积累自己定制的镜像文件，并将自己创建的高质量镜像分享到社区中。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-08-23T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">操作 Docker 容器</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Docker/04.docker/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Docker/04.docker/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>容器是 Docker 的另 一个核心概念。简单来说，容器是镜像的一个运行实例。所不同的是，镜像是静态的只读文件，而容器带有运行时需要的可写文件层，同时，容器中的应用进程处于运行状态。</p>
<p>如果认为虚拟机是模拟运行的一整套操作系统（包括内核、应用运行态环境和其他系统环境）和跑在上面的应用。那么 Docker 容器就是独立运行的一个（或一组）应用，以及它们必需的运行环境。</p>
<p>接下来将具体介绍围绕容器的重要操作，包括创建一个容器、启动容器、终止一个容器、进入容器内执行操作、删除容器和通过导人导出容器来实现容器迁移等。</p>
<h2 id="创建容器"> 创建容器</h2>
<p>从现在开始，忘掉“朦肿”的虚拟机吧，对容器的操作就像直接操作应用一样简单和快速。</p>
<p>这里主要介绍 Docker 容器的 <code>create</code>、<code>start</code>、<code>run</code>、<code>wait</code> 和 <code>logs</code> 子命令。</p>
<h3 id="_1、新建容器"> 1、新建容器</h3>
<p>可以使用 <code>docker [container] create</code> 命令新建一个容器，例如：</p>
<div><pre><code>$ <span>docker</span> container create -it ubuntu:latest
Unable to <span>find</span> image <span>'ubuntu:latest'</span> locally
latest: Pulling from library/ubuntu
35807b77a593: Pull complete 
Digest: sha256:9d6a8699fb5c9c39cf08a0871bd6219f0400981c570894cd8cbea30d3424a31f
Status: Downloaded newer image <span>for</span> ubuntu:latest
fcc4e0885754efa016594c98d606dd5666ad751c76884c41685d46715a9a70fc

$ <span>docker</span> <span>ps</span> -a
CONTAINER ID   IMAGE           COMMAND   CREATED              STATUS                    PORTS     NAMES
fcc4e0885754   ubuntu:latest   <span>"bash"</span>    About a minute ago   Created                             gracious_ellis
dba94731dbca   centos          <span>"bash"</span>    <span>23</span> hours ago         Exited <span>(</span><span>0</span><span>)</span> <span>23</span> hours ago             romantic_benz
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>使用 <code>docker [container] create</code> 命令新建的容器处于停止状态，可以使用 <code>docker [container] start</code> 命令来启动它。</p>
<p>由于容器是整个 Docker 技术栈的核心，<code>create</code> 命令和后续的 <code>run</code> 命令支持的选项都十分复杂，需要你在实践中不断体会。</p>
<p>选项主要包括如下几大类：与容器运行模式相关、与容器环境配置相关、与容器资源限制和安全保护相关，参见表 4-1 和表 4-3。</p>
<p><u>表4-1</u>	create 命令与容器运行模式相关的选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a，--attach=[ ]</td>
<td>是否绑定到标准输入、输出和错误</td>
</tr>
<tr>
<td>-d，--detach=true|false</td>
<td>是否在后台运行容器，默认为否</td>
</tr>
<tr>
<td>--detach-keys=&quot; &quot;</td>
<td>从 attach 模式退出的快捷键</td>
</tr>
<tr>
<td>--entrypoint=&quot; &quot;</td>
<td>镜像存在入口命令时，覆盖为新的命令</td>
</tr>
<tr>
<td>--expose=[ ]</td>
<td>指定容器会暴露出来的端口或端口范围</td>
</tr>
<tr>
<td>--group-add=[ ]</td>
<td>运行容器的用户组</td>
</tr>
<tr>
<td>-i，--interactive=true|false</td>
<td>保持标准输入打开，默认为 false</td>
</tr>
<tr>
<td>--ipc=&quot; &quot;</td>
<td>容器 IPC 命名空间，可以为其他容器或主机</td>
</tr>
<tr>
<td>--isolation=&quot;default&quot;</td>
<td>容器使用的隔离机制</td>
</tr>
<tr>
<td>--log-driver=&quot;json-file&quot;</td>
<td>指定容器的日志驱动类型，可以为 json-file、syslog、journald、gelf、fluentd、awslogs、splunk、etwlogs、gcplogs或none</td>
</tr>
<tr>
<td>--log-opt=[ ]</td>
<td>传递给日志驱动的选项</td>
</tr>
<tr>
<td>--net=&quot;bridge&quot;</td>
<td>指定容器网络模式，包括 bridge、none、其他容器内网络、host 的网络或某个现有网络等</td>
</tr>
<tr>
<td>--net-alias=[ ]</td>
<td>容器在网络中的别名</td>
</tr>
<tr>
<td>-P，--publish-all=true|false</td>
<td>通过 NAT 机制将容器标记暴露的端口自动映射到本地主机的临时端口</td>
</tr>
<tr>
<td>-p，--publishs=[ ]</td>
<td>指定如何映射到本地主机端口，例如 -p 11234-12234:1234-2234</td>
</tr>
<tr>
<td>--pid=host</td>
<td>容器的 PID 命名空间</td>
</tr>
<tr>
<td>--userns=&quot; &quot;</td>
<td>启用 userns-remap 时配置用户命名空间的模式</td>
</tr>
<tr>
<td>--uts=host</td>
<td>容器的 UTS 命名空间</td>
</tr>
<tr>
<td>--restart=&quot;no&quot;</td>
<td>容器的重启策略，包括 no、on-failure[:max-retry]、always、unless-stopped 等</td>
</tr>
<tr>
<td>-rm=true|false</td>
<td>容器退出后是否自动删除，不能跟 -d 同时使用</td>
</tr>
<tr>
<td>-t，--tty=true|false</td>
<td>是否分配一个伪终端，默认为 false</td>
</tr>
<tr>
<td>--tmpfs=[ ]</td>
<td>挂载临时文件系统到容器</td>
</tr>
<tr>
<td>-v|--volume[=[[HOST-DIR:]CONTAINER-DIR [:OPTIONS]]]</td>
<td>挂载主机上的文件卷到容器内</td>
</tr>
<tr>
<td>--volume-driver=&quot; &quot;</td>
<td>挂载文件卷的驱动类型</td>
</tr>
<tr>
<td>--volumes-from=[ ]</td>
<td>从其他容器挂载卷</td>
</tr>
<tr>
<td>-w，--workdir=&quot; &quot;</td>
<td>容器内的默认工作目录</td>
</tr>
</tbody>
</table>
<p><u>表 4-2</u>	create 命令与容器环境和配置相关的选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>--add-host=[ ]</td>
<td>在容器内添加一个主机名到 IP 地址的映射关系（通过 /etc/hosts 文件）</td>
</tr>
<tr>
<td>--device=[ ]</td>
<td>映射物理机上的设备到容器内</td>
</tr>
<tr>
<td>--dns-search=[ ]</td>
<td>DNS 搜索域</td>
</tr>
<tr>
<td>--dns-opt=[ ]</td>
<td>自定义的 DNS 选项</td>
</tr>
<tr>
<td>--dns=[ ]</td>
<td>自定义的 DNS 服务器</td>
</tr>
<tr>
<td>-e，--env=[ ]</td>
<td>指定容器内环境变量</td>
</tr>
<tr>
<td>--env-file=[ ]</td>
<td>从文件中读取环境变量到容器内</td>
</tr>
<tr>
<td>-h，--hostname=&quot; &quot;</td>
<td>指定容器内的主机名</td>
</tr>
<tr>
<td>--ip=&quot; &quot;</td>
<td>指定容器的 IPv4 地址</td>
</tr>
<tr>
<td>--ip6=&quot; &quot;</td>
<td>指定容器的 IPv6 地址</td>
</tr>
<tr>
<td>--link=[&lt;name or id&gt;:alias]</td>
<td>链接到其他容器</td>
</tr>
<tr>
<td>--link-local-ip=[ ]:</td>
<td>容器的本地链接地址列表</td>
</tr>
<tr>
<td>--mac-address=&quot; &quot;</td>
<td>指定容器的 Mac 地址</td>
</tr>
<tr>
<td>--name=&quot; &quot;</td>
<td>指定容器的别名</td>
</tr>
</tbody>
</table>
<p><u>表 4-3</u>	create 命令与容器资源限制和安全保护相关的选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>--blkio-weight=10~1000</td>
<td>容器读写块设备的 I/O 性能权重，默认为 0</td>
</tr>
<tr>
<td>--blkio-weight-device=[DEVICE_NAME:WEIGHT]</td>
<td>指定各个块设备的 I/O 性能权重</td>
</tr>
<tr>
<td>--cpu-shares=0</td>
<td>允许容器使用 CPU 资源的相对权重，默认一个容器能用满一个核的 CPU</td>
</tr>
<tr>
<td>--cap-add=[ ]</td>
<td>增加容器的 Linux 指定安全能力</td>
</tr>
<tr>
<td>--cap-drop=[ ]</td>
<td>移除容器的 Linux 指定安全能力</td>
</tr>
<tr>
<td>--cgroup-parent=&quot; &quot;</td>
<td>容器 cgroups 限制的创建路径</td>
</tr>
<tr>
<td>--cidfile=&quot; &quot;</td>
<td>指定容器的进程 ID 号写到文件</td>
</tr>
<tr>
<td>--cpu-period=0</td>
<td>限制容器在 CFS 调度器下的 CPU 占用时间片</td>
</tr>
<tr>
<td>--cpuset-cpus=&quot; &quot;</td>
<td>限制容器能使用哪些 CPU 核心</td>
</tr>
<tr>
<td>--cpuset-mems=&quot; &quot;</td>
<td>NUMA 架构下使用哪些核心的内存</td>
</tr>
<tr>
<td>--cpu-quota=0</td>
<td>限制容器在 CFS 调度器下的 CPU 配额</td>
</tr>
<tr>
<td>--device-read-bps=[ ]</td>
<td>挂载设备的读吞吐率（以 bps 为单位）限制</td>
</tr>
<tr>
<td>--device-write-bps=[ ]</td>
<td>挂载设备的写吞吐率（以 bps 为单位）限制</td>
</tr>
<tr>
<td>--device-read-iops=[ ]</td>
<td>挂载设备的读速率（以每秒 i/o 次数为单位）限制</td>
</tr>
<tr>
<td>--device-write-iops=[ ]</td>
<td>挂载设备的写速率（以每秒 i/o 次数为单位）限制</td>
</tr>
<tr>
<td>--health-cmd=&quot; &quot;</td>
<td>指定检查容器健康状态的命令</td>
</tr>
<tr>
<td>--health-interval=0s</td>
<td>执行健康检查的间隔时间，单位可以为 ms、s、m 或 h</td>
</tr>
<tr>
<td>--health-retries=int</td>
<td>健康检查失败重试次数，超过则认为不健康</td>
</tr>
<tr>
<td>--health-start-period=0s</td>
<td>容器启动后进行健康检查的等待时间，单位可以为 ms、s、m 或 h</td>
</tr>
<tr>
<td>--health-timeout=0s</td>
<td>健康检查的执行超时，单位可以为 ms、s、m 或 h</td>
</tr>
<tr>
<td>--no-healthcheck=true|false</td>
<td>是否禁用健康检查</td>
</tr>
<tr>
<td>--init</td>
<td>在容器中执行一个 init 进程，来负责响应信号和处理僵尸状态子进程</td>
</tr>
<tr>
<td>--kernel-memory=&quot; &quot;</td>
<td>限制容器使用内核的内存大小，单位可以是 b、k、m 或 g</td>
</tr>
<tr>
<td>-m，--memory=&quot; &quot;</td>
<td>限制容器内应用使用的内存，单位可以是 b、k、m 或 g</td>
</tr>
<tr>
<td>--memory-reservation=&quot; &quot;</td>
<td>当系统中内存过低时，容器会被强制限制内存到给定值，默认情况下等于内存限制值</td>
</tr>
<tr>
<td>--memory-swap=&quot;LIMIT&quot;</td>
<td>限制容器使用内存和交换区的总大小</td>
</tr>
<tr>
<td>--oom-kill-disable=true|false</td>
<td>内存耗尽时是否杀死容器</td>
</tr>
<tr>
<td>--oom-score-adj=&quot; &quot;</td>
<td>调整容器的内存耗尽参数</td>
</tr>
<tr>
<td>--pids-limit=&quot; &quot;</td>
<td>限制容器的 pid 个数</td>
</tr>
<tr>
<td>--privileged=true|false</td>
<td>是否给容器高权限，这意味着容器内应用将不受权限的限制，一般不推荐</td>
</tr>
<tr>
<td>--read-only=true|false</td>
<td>是否让容器内的文件系统只读</td>
</tr>
<tr>
<td>--security-opt=[ ]</td>
<td>指定一些安全参数，包括权限、安全能力、apparmor 等</td>
</tr>
<tr>
<td>--stop-signal=SIGTERM</td>
<td>指定停止容器的系统信号</td>
</tr>
<tr>
<td>--gshm-size=&quot; &quot;</td>
<td>/dev/shm的大小</td>
</tr>
<tr>
<td>--gsig-proxy=true|false</td>
<td>是否代理收到的信号给应用，默认为 true，不能代理 SIGCHLD、SIGSTOP 和 SIGKILL 信号</td>
</tr>
<tr>
<td>--memory-swappiness=&quot;0~100&quot;</td>
<td>调整容器的内存交换区参数</td>
</tr>
<tr>
<td>-u，--user=&quot; &quot;</td>
<td>指定在容器内执行命令的用户信息</td>
</tr>
<tr>
<td>--userns=&quot; &quot;</td>
<td>指定用户命名空间</td>
</tr>
<tr>
<td>--ulimit=[ ]</td>
<td>通过 ulimit 来限制最大文件数、最大进程数等</td>
</tr>
</tbody>
</table>
<p>其他选项还包括：</p>
<ul>
<li>-l，--label=[ ]：以键值对方式指定容器的标签信息；</li>
<li>--label-file=[ ]：从文件中读取标签信息。</li>
</ul>
<h3 id="_2、启动容器"> 2、启动容器</h3>
<p>使用 <code>docker [container] start</code> 命令来启动一个已经创建的容器。例如，启动刚创建的 ubuntu 容器：</p>
<div><pre><code>$ <span>docker</span> start fcc
fcc
<span># 启动ID为fcc开头的容器（开头为 fcc 的 ID ，确保可以确定是哪一个容器）</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>此时，通过 <code>docker ps</code> 命令，可以查看到一个运行中的容器：</p>
<div><pre><code>$ <span>docker</span> <span>ps</span> 
CONTAINER ID   IMAGE           COMMAND   CREATED       STATUS              PORTS     NAMES
fcc4e0885754   ubuntu:latest   <span>"bash"</span>    <span>3</span> hours ago   Up About a minute             gracious_ellis
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="_3、新建井启动容器"> 3、新建井启动容器</h3>
<p>除了创建容器后通过 <code>start</code> 命令来启动，也可以直接新建并启动容器。</p>
<p>所需要的命令主要为 <code>docker [container] run</code> 命令，等价于先执行 <code>docker [container] create</code> 命令，再执行  <code>docker [container] start</code>。</p>
<p>例如，下面的命令输出 一个“Hello World“，之后容器自动终止：</p>
<div><pre><code>$ <span>docker</span> run ubuntu /bin/echo <span>'Hello world'</span>
Hello world
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这跟在本地直接执行 <code>/bin/echo 'hello world'</code> 相比几乎感觉不出任何区别。</p>
<p>当利用 <code>docker [container] run</code> 来创建并启动容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>
<p>检查本地是否存在指定的镜像，不存在就从公有仓库下载；</p>
</li>
<li>
<p>利用镜像创建一个容器，并启动该容器；</p>
</li>
<li>
<p>分配一个文件系统给容器，并在只读的镜像层外面挂载一层可读写层；</p>
</li>
<li>
<p>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去；</p>
</li>
<li>
<p>从网桥的地址池配置一个 IP 地址给容器；</p>
</li>
<li>
<p>执行用户指定的应用程序；</p>
</li>
<li>
<p>执行完毕后容器被自动终止 。</p>
</li>
</ul>
<p>下面的命令启动一个 bash 终端，允许用户进行交互：</p>
<div><pre><code>$ <span>docker</span> run -it ubuntu:18.04 /bin/bash
root@b76dabdabb3f:/<span># </span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>其中，-t 选项让 Docker 分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上，-i 则让容器的标准输入保持打开。更多的命令选项可以通过 <code>man docker-run</code> 命令来查看。</p>
<p>在交互模式下，用户可以通过所创建的终端来输人命令，例如：</p>
<div><pre><code>root@b76dabdabb3f:/<span># pwd</span>
/
root@b76dabdabb3f:/<span># ls</span>
bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
root@b76dabdabb3f:/<span># ps</span>
  PID TTY          TIME CMD
    <span>1</span> pts/0    00:00:00 <span>bash</span>
   <span>11</span> pts/0    00:00:00 <span>ps</span>
root@b76dabdabb3f:/<span># </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>在容器内用 <code>ps</code> 命令查看进程，可以看到，只运行了 bash 应用，并没有运行其他无关的进程。用户可以按 <kbd>Ctrl</kbd>+<kbd>D</kbd> 或输入 <code>exit</code> 命令来退出容器：</p>
<div><pre><code>root@b76dabdabb3f:/<span># exit</span>
<span>exit</span>
$ 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>对于所创建的 bash 容器，当用户使用 <code>exit</code> 命令退出 bash 进程之后，容器也会自动退出。这是因为对于容器来说，当其中的应用退出后，容器的使命完成，也就没有继续运行的必要了。</p>
<p>可以使用 <code>docker container wait CONTAINER [CONTAINER...]</code> 子命令来等待容器退出，并打印退出返回结果。</p>
<p>某些时候，执行 <code>docker [container] run</code> 的时候因为命令无法正常执行容器会出错直接退出，此时可以查看退出的错误代码。</p>
<p>默认情况下，常见错误代码包括：</p>
<ul>
<li>
<p>125：Docker daemon 执行出错，例如指定了不支持的 Docker 命令参数；</p>
</li>
<li>
<p>126：所指定命令无法执行，例如权限出错；</p>
</li>
<li>
<p>127：容器内命令无法找到。</p>
</li>
</ul>
<p>命令执行后出错，会默认返回命令的退出错误码。</p>
<h3 id="_4、守护态运行"> 4、守护态运行</h3>
<p>更多的时候，需要让 Docker 容器在后台以守护态（Daemonized）形式运行。此时，可以
通过添加 -d 参数来实现。</p>
<p>例如，下面的命令会在后台运行容器：</p>
<div><pre><code>$ <span>docker</span> run -d ubuntu /bin/sh -c <span>"while true; do echo hello world; sleep 1; done"</span>
3bbfb70ef02e07b81229d56259d07c0bd75bb62128c4cef3a81a09c08a920ff9
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>容器启动后会返回一个唯一的 id，也可以通过 <code>docker ps</code> 或 <code>docker container ls</code> 命令来查看容器信息：</p>
<div><pre><code>$ <span>docker</span> <span>ps</span>
CONTAINER ID   IMAGE           COMMAND                  CREATED              STATUS              PORTS     NAMES
3bbfb70ef02e   ubuntu          <span>"/bin/sh -c 'while t…"</span>   About a minute ago  Up About a minute             beautiful_ganguly
fcc4e0885754   ubuntu:latest   <span>"bash"</span>                   <span>4</span> hours ago          Up <span>2</span> hours                    gracious_ellis
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="_5、查看容器输出"> 5、查看容器输出</h3>
<p>要获取容器的输出信息，可以通过 <code>docker [container] logs</code> 命令。</p>
<p>该命令支持的选项包括：</p>
<ul>
<li>
<p>-details：打印详细信息；</p>
</li>
<li>
<p>-f，-follow：持续保持输出；</p>
</li>
<li>
<p>-since string：输出从某个时间开始的日志；</p>
</li>
<li>
<p>-tail string：输出最近的若干日志；</p>
</li>
<li>
<p>-t，timestamps：显示时间戳信息；</p>
</li>
<li>
<p>-until string：输出某个时间之前的日志。</p>
</li>
</ul>
<p>例如，查看某容器的输出可以使用如下命令：</p>
<div><pre><code>$ <span>docker</span> logs 3bbfb70ef02e
hello world
hello world
hello world
<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="停止容器"> 停止容器</h2>
<p>这里主要介绍 Docker 容器的 <code>pause/unpause</code>、<code>stop</code> 和 <code>prune</code> 子命令。</p>
<h3 id="_1、暂停容器"> 1、暂停容器</h3>
<p>可以使用 <code>docker [container] pause CONTAINER [CONTAINER...]</code> 命令来暂停一个运行中的容器。</p>
<p>例如，启动一个容器，并将其暂停，处于 paused 状态的容器，可以使用 <code>docker [container] unpause CONTAINER [CONTAINER...]</code> 命令来恢复到运行状态。</p>
<div><pre><code><span># 新建一个容器，名字为 test，查看其状态</span>
$ <span>docker</span> run --name<span>=</span><span>"test"</span> -it ubuntu <span>bash</span>
root@c8d20c12cccb:/<span># exit</span>
$ <span>docker</span> <span>ps</span> -a
CONTAINER ID   IMAGE     COMMAND   CREATED         STATUS                     PORTS     NAMES
c8d20c12cccb   ubuntu    <span>"bash"</span>    <span>9</span> seconds ago   Exited <span>(</span><span>0</span><span>)</span> <span>5</span> seconds ago             <span>test</span>

<span># 启动容器</span>
$ <span>docker</span> start <span>test</span> 
<span>test</span>
$ <span>docker</span> <span>ps</span>
CONTAINER ID   IMAGE     COMMAND   CREATED          STATUS         PORTS     NAMES
c8d20c12cccb   ubuntu    <span>"bash"</span>    <span>20</span> seconds ago   Up <span>2</span> seconds             <span>test</span>

<span>#暂停容器</span>
$ <span>docker</span> pause <span>test</span> 
<span>test</span>
$ <span>docker</span> <span>ps</span> 
CONTAINER ID   IMAGE     COMMAND   CREATED          STATUS                   PORTS     NAMES
c8d20c12cccb   ubuntu    <span>"bash"</span>    <span>54</span> seconds ago   Up <span>36</span> seconds <span>(</span>Paused<span>)</span>             <span>test</span>

<span>#恢复暂停的容器</span>
$ <span>docker</span> unpause <span>test</span> 
<span>test</span>
$ <span>docker</span> <span>ps</span>
CONTAINER ID   IMAGE     COMMAND   CREATED              STATUS          PORTS     NAMES
c8d20c12cccb   ubuntu    <span>"bash"</span>    About a minute ago   Up <span>53</span> seconds             <span>test</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h3 id="_2、终止容器"> 2、终止容器</h3>
<p>可以使用 <code>docker [container] stop</code> 来终止一个运行中的容器。该命令的格式为 <code>docker</code>
<code>[container] stop [-t|--time[=10]] [CONTAINER...]</code>。</p>
<p>该命令会首先向容器发送 SIGTERM 信号，等待一段超时时间后（默认为 10 秒），再发
送 SIGKILL 信号来终止容器：</p>
<div><pre><code>$ <span>docker</span> stop <span>test</span> 
<span>test</span>
$ <span>docker</span> <span>ps</span> -a
CONTAINER ID   IMAGE     COMMAND   CREATED          STATUS                     PORTS     NAMES
c8d20c12cccb   ubuntu    <span>"bash"</span>    <span>10</span> minutes ago   Exited <span>(</span><span>0</span><span>)</span> <span>5</span> seconds ago             <span>test</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>此时，执行 docker container prune 命令，会自动清除掉所有处于停止状态的容器。此外，还可以通过 <code>docker [container] kill</code> 直接发送 SIGKILL 信号来强行终止容器。</p>
<p>当 Docker 容器中指定的应用终结时，容器也会自动终止。例如，对于前面只启动了一个终端的容器，用户通过 <code>exit</code> 命令或 <kbd>Ctrl</kbd>+<kbd>d</kbd> 来退出终端时，所创建的容器立刻终止，处于 stopped 状态。</p>
<p>可以用 <code>docker ps -qa</code> 命令看到所有容器的 ID。例如：</p>
<div><pre><code>$ <span>docker</span> <span>ps</span> -aq
3c64d4d3197c
08bd1bc56ed2
c8d20c12cccb
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>处于终止状态的容器，可以通过 <code>docker [container] start</code> 命令来重新启动：</p>
<div><pre><code>$ <span>docker</span> <span>ps</span> -a
CONTAINER ID   IMAGE           COMMAND       CREATED      STATUS                     PORTS     NAMES
3c64d4d3197c   centos:latest   <span>"/bin/bash"</span>   <span>2</span> days ago   Exited <span>(</span><span>0</span><span>)</span> <span>2</span> days ago                cool_bell
08bd1bc56ed2   centos:latest   <span>"bash"</span>        <span>2</span> days ago   Exited <span>(</span><span>0</span><span>)</span> <span>2</span> days ago                gracious_tesla
c8d20c12cccb   ubuntu          <span>"bash"</span>        <span>2</span> days ago   Exited <span>(</span><span>0</span><span>)</span> <span>8</span> seconds ago             <span>test</span>
$ <span>docker</span> start c8d20c12cccb
c8d20c12cccb
$ <span>docker</span> <span>ps</span>
CONTAINER ID   IMAGE     COMMAND   CREATED      STATUS         PORTS     NAMES
c8d20c12cccb   ubuntu    <span>"bash"</span>    <span>2</span> days ago   Up <span>4</span> seconds             <span>test</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><code>docker [container] restart</code> 命令会将一个运行态的容器先终止，然后再重新启动：</p>
<div><pre><code>$ <span>docker</span> restart c8d20c12cccb
c8d20c12cccb
$ <span>docker</span> <span>ps</span>
CONTAINER ID   IMAGE     COMMAND   CREATED      STATUS         PORTS     NAMES
c8d20c12cccb   ubuntu    <span>"bash"</span>    <span>2</span> days ago   Up <span>2</span> seconds             <span>test</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="进人容器"> 进人容器</h2>
<p>在使用 -d 参数时，容器启动后会进入后台，用户无法看到容器中的信息，也无法进行操作。
这个时候如果需要进入容器进行操作，推荐使用官方的 <code>attach</code> 或 <code>exec</code> 命令。</p>
<h3 id="_1、attach-命令"> 1、attach 命令</h3>
<p><code>attach</code> 是 Docker 自带的命令，命令格式为：</p>
<p><code>docker [container] attach [--detach-keys[=[]]] \[--no-stdin] [--sig-proxy[=true]] CONTAINER</code></p>
<p>这个命令支持三个主要选项：</p>
<ul>
<li>--detach-keys [=[]]：指定退出 attach 模式的快捷键序列，默认是 CTRL-p CTRL-q；</li>
<li>--no-stdin=true|false：是否关闭标准输入，默认是保持打开；</li>
<li>--sig-proxy=true|false：是否代理收到的系统信号给应用进程，默认为 true。</li>
</ul>
<p>下面示例如何使用该命令：</p>
<div><pre><code>$ <span>docker</span> run -itd ubuntu
4be7970cb6b869a4857887036a6ae555f412a8fbe785ff71f027214276f14a1c
$ <span>docker</span> <span>ps</span>
CONTAINER ID   IMAGE     COMMAND   CREATED         STATUS         PORTS     NAMES
4be7970cb6b8   ubuntu    <span>"bash"</span>    <span>6</span> seconds ago   Up <span>5</span> seconds             priceless_chandrasekhar
$ <span>docker</span> attach priceless_chandrasekhar 
root@4be7970cb6b8:/<span># </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>然而使用 <code>attach</code> 命令有时候并不方便。当多个窗口同时 <code>attach</code> 到同一个容器的时候，所有窗口都会同步显示；当某个窗口因命令阻塞时，其他窗口也无法执行操作了。</p>
<h3 id="_2、exec-命令"> 2、exec 命令</h3>
<p>从 Docker 的 1.3.0 版本起，Docker 提供了一个更加方便的工具 <code>exec</code> 命令，可以在运行中容器内直接执行任意命令。</p>
<p>该命令的基本格式为：</p>
<p><code>docker [container] exec [-d|--detach] [--detach-keys[=[]]] [-i|--interactive] [--privileged] [-t|--tty] [-u|--user[=USER]] CONTAINER COMMAND [ARG...]</code></p>
<p>比较重要的参数有：</p>
<ul>
<li>-d，--detach：在容器中后台执行命令；</li>
<li>--detach-keys=&quot; &quot;：指定将容器切回后台的按键；</li>
<li>-e，--env=[]：指定环境变量列表；</li>
<li>-i，--interactive=true|false：打开标准输入接受用户输入命令，默认值为 false；</li>
<li>--privileged=true|false：是否给执行命令以高权限，默认值为 false；</li>
<li>-t，--tty=true|false：分配伪终端，默认值为 false；</li>
<li>-u，--user=&quot; &quot;：执行命令的用户名或 ID。</li>
</ul>
<p>例如，进入到刚创建的容器中，并启动一个 bash：</p>
<div><pre><code>$ <span>docker</span> <span>exec</span> -it 4be7970cb6b8 /bin/bash
root@4be7970cb6b8:/<span># </span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>可以看到会打开一个新的 bash 终端，在不影响容器内其他应用的前提下，用户可以与容器进行交互。</p>
<div><p>注意</p>
<p>通过指定 - it 参数来保持标准输入打开，并且分配一个伪终端。通过 <code>exec</code> 命令对容器执行操作是最为推荐的方式。</p>
</div>
<p>进一步地，可以在容器中查看容器中的用户和进程信息：</p>
<div><pre><code>root@4be7970cb6b8:/<span># w</span>
 02:45:03 up <span>34</span> min,  <span>0</span> users,  load average: <span>1.39</span>, <span>0.78</span>, <span>0.67</span>
<span>USER</span>     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
root@4be7970cb6b8:/<span># ps -ef</span>
<span>UID</span>        PID  <span>PPID</span>  C STIME TTY          TIME CMD
root         <span>1</span>     <span>0</span>  <span>0</span> 02:42 pts/0    00:00:00 <span>bash</span>
root         <span>9</span>     <span>0</span>  <span>0</span> 02:42 pts/1    00:00:00 /bin/bash
root        <span>18</span>     <span>9</span>  <span>0</span> 02:45 pts/1    00:00:00 <span>ps</span> -ef
root@4be7970cb6b8:/<span># </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="删除容器"> 删除容器</h2>
<p>可以使用 <code>docker [container] rm</code> 命令来删除处于终止或退出状态的容器，命令格式为 <code>docker</code>
<code>[container] rm [-f|--force] [-l|--link] [-v|--volumes] CONTAINER [CONTAINER...]</code>。</p>
<p>主要支持的选项包括：</p>
<ul>
<li>
<p>-f，--force=false：是否强行终止并删除一个运行中的容器；</p>
</li>
<li>
<p>-l，--link=false：删除容器的连接，但保留容器；</p>
</li>
<li>
<p>-v，--volumes=false：删除容器挂载的数据卷。</p>
</li>
</ul>
<p>例如，查看处于终止状态的容器，并删除：</p>
<div><pre><code>$ <span>docker</span> <span>ps</span> -a
CONTAINER ID   IMAGE           COMMAND       CREATED          STATUS                      PORTS     NAMES
4be7970cb6b8   ubuntu          <span>"bash"</span>        <span>27</span> minutes ago   Up <span>13</span> minutes                         priceless_chandrasekhar
3c64d4d3197c   centos:latest   <span>"/bin/bash"</span>   <span>2</span> days ago       Exited <span>(</span><span>0</span><span>)</span> <span>2</span> days ago                 cool_bell
08bd1bc56ed2   centos:latest   <span>"bash"</span>        <span>2</span> days ago       Exited <span>(</span><span>0</span><span>)</span> <span>2</span> days ago                 gracious_tesla
c8d20c12cccb   ubuntu          <span>"bash"</span>        <span>2</span> days ago       Exited <span>(</span><span>0</span><span>)</span> <span>27</span> minutes ago             <span>test</span>
$ <span>docker</span> <span>rm</span> 08bd1bc56ed2
08bd1bc56ed2
$ <span>docker</span> <span>ps</span> -a
CONTAINER ID   IMAGE           COMMAND       CREATED          STATUS                      PORTS     NAMES
4be7970cb6b8   ubuntu          <span>"bash"</span>        <span>28</span> minutes ago   Up <span>14</span> minutes                         priceless_chandrasekhar
3c64d4d3197c   centos:latest   <span>"/bin/bash"</span>   <span>2</span> days ago       Exited <span>(</span><span>0</span><span>)</span> <span>2</span> days ago                 cool_bell
c8d20c12cccb   ubuntu          <span>"bash"</span>        <span>2</span> days ago       Exited <span>(</span><span>0</span><span>)</span> <span>28</span> minutes ago             <span>test</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>默认情况下，<code>docker rm</code> 命令只能删除已经处于终止或退出状态的容器，并不能删除还处于运行状态的容器。</p>
<p>如果要直接删除一个运行中的容器，可以添加 -f 参数。Docker 会先发送 SIGKILL 信号给容器，终止其中的应用，之后强行删除：</p>
<div><pre><code>$ <span>docker</span> <span>ps</span>
CONTAINER ID   IMAGE     COMMAND   CREATED          STATUS         PORTS     NAMES
acca51225fce   ubuntu    <span>"bash"</span>    <span>29</span> seconds ago   Up <span>3</span> seconds             musing_edison
$ <span>docker</span> <span>rm</span> acca51225fce
Error response from daemon: You cannot remove a running container acca51225fce4f1072a7ffd0fdac860e9d93c1bc8c84db6197d71ea292d7ca90. Stop the container before attempting removal or force remove
$ <span>docker</span> <span>rm</span> -f acca51225fce
acca51225fce
$ <span>docker</span> <span>ps</span>
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="导人和导出容器"> 导人和导出容器</h2>
<p>某些时候，需要将容器从一个系统迁移到另外一个系统，此时可以使用 Docker 的导入和导出功能，这也是 Docker 自身提供的一个重要特性。</p>
<h3 id="_1、导出容器"> 1、导出容器</h3>
<p>导出容器是指，导出一个已经创建的容器到一个文件，不管此时这个容器是否处于运行状态。可以使用 <code>docker [container] export</code> 命令，该命令格式为：</p>
<p><code>docker [container] export [-o|--output [ =&quot; &quot;] CONTAINER</code></p>
<p>其中，可以通过 -o 选项来指定导出的 tar 文件名，也可以直接通过重定向来实现。首先，查看所有的容器，如下所示：</p>
<div><pre><code>$ docker ps -a
CONTAINER ID   IMAGE           COMMAND       CREATED      STATUS                   PORTS     NAMES
3c64d4d3197c   centos:latest   &quot;/bin/bash&quot;   2 days ago   Exited (0) 2 days ago              cool_bell
c8d20c12cccb   ubuntu          &quot;bash&quot;        2 days ago   Exited (0) 2 hours ago             test

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>分别导出 3c64d4d3197c 容器和 c8d20c12cccb 容器到文件 <code>cool_for_centos.tar</code> 文件和 <code>test_for_ubuntu.tar</code> 文件：</p>
<div><pre><code>$ <span>docker</span> <span>export</span> -o cool_for_centos.tar 3c64d4d3197c
$ <span>ls</span> -l
总用量 <span>211484</span>
-rw------- <span>1</span> root root <span>216525312</span> <span>9</span>月   <span>6</span> <span>12</span>:10 cool_for_centos.tar
$ <span>docker</span> <span>export</span> c8d20c12cccb <span>></span> test_for_ubuntu.tar
$ <span>ls</span> -l
总用量 <span>284884</span>
-rw------- <span>1</span> root root <span>216525312</span> <span>9</span>月   <span>6</span> <span>12</span>:10 cool_for_centos.tar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>之后，可将导出的 tar 文件传输到其他机器上，然后再通过导人命令导入到系统中，实现容器的迁移。</p>
<h3 id="_2、导入容器"> 2、导入容器</h3>
<p>导出的文件又可以使用 <code>docker [container] import</code> 命令导人变成镜像，该命令格式为：</p>
<p><code>docker import [-c|--change[=[]]] [-m|--message[=MESSAGE]] file|URL|-[REPOSITORY[:TAG]]</code></p>
<p>用户可以通过 -c，--change=[] 选项在导人的同时执行对容器进行修改的 Dockerfile 指令（可参考后续相关内容）。</p>
<p>下面将导出的 <code>test_for_ubuntu.tar</code> 文件导人到系统中：</p>
<div><pre><code>r$ <span>docker</span> <span>import</span> test_for_ubuntu.tar test/ubuntu:v1.0
sha256:00cf452ac39b9eecff28658850094bac5e345f0ac0f06ff44897873464c7ae00
$ <span>docker</span> images
REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
test/ubuntu   v1.0      00cf452ac39b   <span>4</span> seconds ago   <span>72</span>.8MB
ubuntu        latest    fb52e22af1b0   <span>6</span> days ago      <span>72</span>.8MB
ubuntu        <span>18.04</span>     54919e10a95d   <span>6</span> days ago      <span>63</span>.1MB
centos        latest    300e315adb2f   <span>9</span> months ago    209MB
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>之前曾介绍过使用 <code>docker load</code> 命令来导入一个镜像文件，与 <code>docke [container] import</code> 命令十分类似。
实际上，既可以使用 <code>docker load</code> 命令来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 命令来导入一个容器快照到本地镜像库。这两者的区别在于：容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积更大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p>
<h2 id="查看容器"> 查看容器</h2>
<p>主要介绍 Docker 容器的 <code>inspect</code>、<code>top</code> 和 <code>stats</code> 子命令。</p>
<h3 id="_1、查看容器详情"> 1、查看容器详情</h3>
<p>查看容器详情可以使用 <code>docker container inspect [OPTIONS] CONTAINER [CONTAINER...]</code>子命令。
例如，查看某容器的具体信息，会以 json 格式返回包括容器 Id、创建时间、路径、状态、镜像、配置等在内的各项信息：</p>
<div><pre><code>$ <span>docker</span> container inspect <span>test</span>
<span>[</span>
    <span>{</span>
        <span>"Id"</span><span>:</span> <span>"c8d20c12cccbf317c5f9257b3abe542f98dba3b92b7f72d963427413e5ebf2ad"</span>，
        <span>"Created"</span><span>:</span> <span>"2021-09-03T07:45:47.300705248Z"</span>，
        <span>"Path"</span><span>:</span> <span>"bash"</span>，
        <span>"Args"</span><span>:</span> <span>[</span><span>]</span>，
        <span>"State"</span><span>:</span> <span>{</span>
            <span>"Status"</span><span>:</span> <span>"exited"</span>，
<span>..</span><span>..</span><span>..</span>
        <span>}</span>
    <span>}</span>
<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="_2、查看容器内进程"> 2、查看容器内进程</h3>
<p>查看容器内进程可以使用 <code>docker [container] top [OPTIONS] CONTAINER [CONTAINER...]</code>子命令。</p>
<p>这个子命令类似于 Linux 系统中的 <code>top</code> 命令，会打印出容器内的进程信息，包括 PID、用户、时间、命令等。例如，查看某容器内的进程信息，命令如下：</p>
<div><pre><code>$ <span>docker</span> <span>ps</span>
CONTAINER ID   IMAGE     COMMAND   CREATED      STATUS         PORTS     NAMES
c8d20c12cccb   ubuntu    <span>"bash"</span>    <span>2</span> days ago   Up <span>2</span> seconds             <span>test</span>
kei@kei-KVM:~/docker$ <span>docker</span> <span>top</span> <span>test</span> 
<span>UID</span>                 PID                 <span>PPID</span>                C                   STIME               TTY                 TIME                CMD
root                <span>9758</span>                <span>9723</span>                <span>0</span>                   <span>13</span>:18               pts/0               00:00:00            <span>bash</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="_3、查看统计信息"> 3、查看统计信息</h3>
<p>查看统计信息可以使用 <code>docker [container] stats [OPTIONS] [CONTAINER...]</code> 子命令，会显示 CPU、内存、存储、网络等使用情况的统计信息。</p>
<p>支持选项包括：</p>
<ul>
<li>a，-all：输出所有容器统计信息，默认仅在运行中；</li>
<li>-format string：格式化输出信息；</li>
<li>-no-stream：不持续输出，默认会自动更新持续实时结果；</li>
<li>-no-trunc：不截断输出信息。</li>
</ul>
<p>例如，查看当前运行中容器的系统资源使用统计：</p>
<div><pre><code>$ <span>docker</span> stats
CONTAINER ID   NAME      CPU %     MEM USAGE / LIMIT     MEM %     NET I/O       BLOCK I/O     PIDS
c8d20c12cccb   <span>test</span>      <span>0.00</span>%     <span>2</span>.562MiB / <span>3</span>.844GiB   <span>0.07</span>%     <span>3</span>.51kB / 0B   <span>1</span>.25MB / 0B   <span>1</span>
<span># 可使用 Ctrl + C 退出</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="其他容器命令"> 其他容器命令</h2>
<p>主要介绍 Docker 容器的 <code>cp</code>、<code>diff</code>、<code>port</code> 和 <code>update</code> 子命令。</p>
<h3 id="_1、复制文件"> 1、复制文件</h3>
<p><code>container cp</code> 命令支持在容器和主机之间复制文件。</p>
<p>命令格式为 <code>docker [container] cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</code>。支持的选项包括 ：</p>
<ul>
<li>-a，-archive：打包模式，复制文件会带有原始的 uid/gid 信息；</li>
<li>-L，-follow-link：跟随软连接。当原路径为软连接时，默认只复制链接信息，使用该选项会复制链接的目标内容。</li>
</ul>
<p>例如，将本地的路径 data 复制到 test 容器的 /tmp 路径下：</p>
<div><pre><code>$ <span>touch</span> test_file.txt
$ <span>nano</span> test_file.txt 
$ <span>cat</span> test_file.txt 
hello world<span>!</span>
$ <span>docker</span> <span>ps</span>
CONTAINER ID   IMAGE     COMMAND   CREATED      STATUS          PORTS     NAMES
c8d20c12cccb   ubuntu    <span>"bash"</span>    <span>2</span> days ago   Up <span>12</span> minutes             <span>test</span>
$ <span>docker</span> <span>cp</span> test_file.txt test:/tmp/
$ <span>docker</span> attach <span>test</span> 
root@c8d20c12cccb:/<span># cd /tmp/ &amp;&amp; ls</span>
test_file.txt
root@c8d20c12cccb:/tmp<span># cat test_file.txt </span>
hello world<span>!</span>
root@c8d20c12cccb:/tmp<span># </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="_2、查看变更"> 2、查看变更</h3>
<p><code>container diff</code> 查看容器内文件系统的变更。</p>
<p>命令格式为 <code>docker [container] diff CONTAINER</code>。例如，查看 test 容器内的数据修改：</p>
<div><pre><code>$ <span>docker</span> container <span>diff</span> <span>test</span> 
C /root
A /root/.bash_history
C /tmp
A /tmp/test_file.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="_3、查看端口映射"> 3、查看端口映射</h3>
<p><code>container port</code> 命令可以查看容器的端口映射’情况。</p>
<p>命令格式为 <code>docker container port CONTAINER [PRIVATE_PORT[/PROTO]]</code>。例如，查看 test 容器的端口映射’情况：</p>
<div><pre><code>$ <span>docker</span> container port <span>test</span>
<span>9000</span>/tcp -<span>></span> <span>0.0</span>.0.0:9000
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="_4、更新配置"> 4、更新配置</h3>
<p><code>container update</code> 命令可以更新容器的一些运行时配置，主要是一些资源限制份额。</p>
<p>命令格式为 <code>docker [container] update [OPTIONS] CONTAINER [CONTAINER...]</code>。</p>
<p>支持的选项包括：</p>
<ul>
<li>blkio-weight uint16：更新块 IO 限制，10~1000，默认值为 0，代表着无限制；</li>
<li>-cpu-period int：限制 CPU 调度器 CFS（Completely Fair Scheduler）使用时间，单位为微秒，最小 1000；</li>
<li>-cpu-quota int：限制 CPU 调度器 CFS 配额，单位为微秒，最小 1000；</li>
<li>-cpu-rt-period int：限制 CPU 调度器的实时周期，单位为微秒；</li>
<li>-cpu-rt-runtime int：限制 CPU 调度器的实时运行时，单位为微秒；</li>
<li>-c，-cpu-shares int：限制 CPU 使用份额；</li>
<li>-cpus decimal：限制 CPU 个数；</li>
<li>-cpuset-cpus string：允许使用的 CPU 核，如 0-3，0，1；</li>
<li>-cpuset-mems string：允许使用的内存块，如 0-3，0，1；</li>
<li>-kernel-memory bytes：限制使用的内核内存；</li>
<li>-m，-memory bytes：限制使用的内存；</li>
<li>-memory-reservation bytes：内存软限制；</li>
<li>-memory-swap bytes：内存加上缓存区的限制，-1 表示为对缓冲区无限制；</li>
<li>-restart string：容器退出后的重启策略。</li>
</ul>
<p>例如，限制总配额为 1 秒，容器 test 所占用时间为 10% ，代码如下所示：</p>
<div><pre><code>$ <span>docker</span> update --cpu-quota <span>1000000</span> <span>test</span> 
<span>test</span>
$ <span>docker</span> update --cpu-period <span>100000</span> <span>test</span> 
<span>test</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="小结"> 小结</h2>
<p>容器是直接提供应用服务的组件，也是 Docker 整个技术核中最为核心的概念。围绕容器，Docker 提供了十分丰富的操作命令，允许用户高效地管理容器的整个生命周期。你可以使用 <code>docker container help</code> 命令查看 Docker 支持的容器操作子命令。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-08-23T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">访问 Docker 仓库</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Docker/05.docker/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Docker/05.docker/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>仓库（Repository）是集中存放镜像的地方，又分公共仓库和私有仓库。</p>
<p>有时候容易把仓库与注册服务器（Registry）混淆。实际上注册服务器是存放仓库的具体服务器，一个注册服务器上可以有多个仓库，而每个仓库下面可以有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 private-docker.com/ubuntu 来说，private-docker.com 是注册服务器地址，ubuntu 是仓库名。</p>
<p>接下来，将分别介绍使用 Docker Hub 官方仓库进行登录、载等基本操作，以及使用国内社区提供的仓库下载镜像；最后还将介绍创建和使用私有仓库的基本操作。</p>
<h2 id="docker-hub-公共镜像市场"> Docker Hub 公共镜像市场</h2>
<p>Docker Hub 是 Docker 官方提供的最大的公共镜像仓库，目前包括了超过 100000 的镜像，地址为 <a href="https://hub.docker.com" target="_blank" rel="noopener noreferrer">https://hub.docker.com</a>。大部分对镜像的需求，都可以通过在 Docker Hub 中直接下载镜像来实现，如图 5-1 所示。</p>
<h3 id="_1、登录"> 1、登录</h3>
<p>可以通过命令行执行 <code>docker login</code> 命令来输入用户名、密码和邮箱来完成注册和登录。注册成功后，本地用户目录下会自动创建 <code>.docker/config.json</code> 文件，保存用户的认证信息。</p>
<p>登录成功的用户可以上传个人制作的镜像到 Docker Hub。</p>
<h3 id="_2、基本操作"> 2、基本操作</h3>
<p>用户无须登录即可通过 <code>docker search</code> 命令来查找官方仓库中的镜像，并利用 <code>docker [image] pull</code> 命令来将它下载到本地。</p>
<div>
<p><img src="./assets/docker_5-1.png" alt="" loading="lazy"></p>
<p><u>图 5-1</u>	Docker Hub 是最大的公共镜像仓库</p>
</div>
<p>前面已经具体介绍了如何使用 <code>docker [image] pull</code> 命令来搜寻镜像。例如以 centos 为关键词进行搜索：</p>
<div><pre><code>$ <span>docker</span> search centos
NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
centos                            The official build of CentOS.                   <span>6736</span>      <span>[</span>OK<span>]</span>       
ansible/centos7-ansible           Ansible on Centos7                              <span>134</span>                  <span>[</span>OK<span>]</span>
consol/centos-xfce-vnc            Centos container with <span>"headless"</span> VNC session…  <span>130</span>                  <span>[</span>OK<span>]</span>
jdeathe/centos-ssh                OpenSSH / Supervisor / EPEL/IUS/SCL Repos - …  <span>120</span>                  <span>[</span>OK<span>]</span>
centos/systemd                    systemd enabled base container.                 <span>101</span>                  <span>[</span>OK<span>]</span>
<span>..</span><span>..</span><span>..</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>根据是否为官方提供，可将这些镜像资源分为两类：</p>
<ul>
<li>
<p>一种是类似于 centos 这样的基础镜像，也称为根镜像。这些镜像是由 Docker 公司创建、验证、支持、提供，这样的镜像往往使用单个单词作为名字；</p>
</li>
<li>
<p>另一种类型的镜像，比如 ansible/centos7-ansible 镜像，是由 Docker 用户 ansible 创建并维护的，带有用户名称为前缀，表明是某用户下的某仓库。可以通过用户名称前缀“user_name/镜像名”来指定使用某个用户提供的镜像。</p>
</li>
</ul>
<p>下载官方 centos 镜像到本地，代码如下所示：</p>
<div><pre><code>$ <span>docker</span> pull centos
Using default tag: latest
latest: Pulling from library/centos
7a0437f04f83: Pull complete 
Digest: sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1
Status: Downloaded newer image <span>for</span> centos:latest
docker.io/library/centos:latest
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>用户也可以在登录后通过 <code>docker push</code> 命令来将本地镜像推送到 Docker Hub。</p>
<h3 id="_3、自动创建"> 3、自动创建</h3>
<p>自动创建（Automated Builds）是 Docker Hub 提供的自动化服务，这一功能可以自动跟随项目代码的变更而重新构建镜像。</p>
<p>例如，用户构建了某应用镜像，如果应用发布新版本，用户需要手动更新镜像。而自动创建则允许用户通过 Docker Hub 指定跟踪一个目标网站（目前支持 GitHub 或 BitBucket）上的项目，一旦项目发生新的提交，则自动执行创建。</p>
<p>要配置自动创建，包括如下的步骤：</p>
<ol>
<li>创建并登录 Docker Hub，以及目标网站如 Github；</li>
<li>在目标网站中允许 Docker Hub 访问服务；</li>
<li>在 Docker Hub 中配置一个“自动创建”类型的项目；</li>
<li>选取一个目标网站中的项目（需要含 Dockerfile）和分支；</li>
<li>指定 Dockerfile 的位置，并提交创建。</li>
</ol>
<p>之后，可以在 Docker Hub 的“自动创建”页面中跟踪每次创建的状态。</p>
<h2 id="第三方镜像市场"> 第三方镜像市场</h2>
<p>国内不少云服务商都提供了 Docker 镜像市场，包括腾讯云、网易云、阿里云等。下面以<a href="https://hub.tenxcloud.com/" target="_blank" rel="noopener noreferrer">时速云</a>为例，介绍如何使用这些市场，如图 5-2 所示。</p>
<div>
<p><img src="./assets/docker_5-2.png" alt="" loading="lazy"></p>
<p><u>图 5-2</u>	时速云镜像市场</p>
</div>
<h3 id="_1、查看镜像"> 1、查看镜像</h3>
<p>访问 <a href="https://hub.tenxcloud.com" target="_blank" rel="noopener noreferrer">https://hub.tenxcloud.com</a> ，即可看到己存在的仓库和存储的镜像，包括 Ubuntu、Java、Mongo、MySQL、Nginx 等热门仓库和镜像。时速云官方仓库中的镜像会保持与Docker Hub 中官方镜像的同步。</p>
<p>以 MongoDB 仓库为例，其中包括了 2.6、3.0 和 3.2 等镜像。</p>
<h3 id="_2、下载镜像"> 2、下载镜像</h3>
<p>下载镜像也是使用 <code>docker pull</code> 命令，但是要在镜像名称前添加注册服务器的具体地址。格式为 index.tenxcloud.com/&lt;namespace&gt;/&lt;reposito ry&gt;:&lt;tag &gt;。</p>
<p>例如，要下载 Docker 官方仓库中的 node:latest 镜像，可以使用如下命令：</p>
<div><pre><code>$ <span>docker</span> pull hub.c.163.com/public/centos:6.5
<span>6.5</span>: Pulling from public/centos
96057de2d572: Pull complete 
a3ed95caeb02: Pull complete 
8a1dcc3f76c2: Pull complete 
8fe56c90e86a: Pull complete 
43fc3558431f: Pull complete 
5881bc109689: Pull complete 
Digest: sha256:92fd18cda0cbf63bb4b5ffd0c073a9d689d5b202e3b491cbc74488fff1c37d11
Status: Downloaded newer image <span>for</span> hub.c.163.com/public/centos:6.5
hub.c.163.com/public/centos:6.5

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>正常情况下，镜像下载会比直接从 Docker Hub 下载快得多。通过 <code>docker images</code> 命令来查看下载到本地的镜像：</p>
<div><pre><code>$ <span>docker</span> images
REPOSITORY                    TAG       IMAGE ID       CREATED        SIZE
test/ubuntu                   v1.0      00cf452ac39b   <span>23</span> hours ago   <span>72</span>.8MB
ubuntu                        latest    fb52e22af1b0   <span>7</span> days ago     <span>72</span>.8MB
ubuntu                        <span>18.04</span>     54919e10a95d   <span>7</span> days ago     <span>63</span>.1MB
centos                        latest    300e315adb2f   <span>9</span> months ago   209MB
hub.c.163.com/public/centos   <span>6.5</span>       997f0ed97903   <span>5</span> years ago    442MB
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>下载后，可以更新镜像的标签，与官方标签保持一致，方便使用：</p>
<div><pre><code>$ <span>docker</span> tag hub.c.163.com/public/centos:6.5  centos:6.5
kei@kei-KVM:/etc/docker$ <span>docker</span> images
REPOSITORY                    TAG       IMAGE ID       CREATED        SIZE
test/ubuntu                   v1.0      00cf452ac39b   <span>23</span> hours ago   <span>72</span>.8MB
ubuntu                        latest    fb52e22af1b0   <span>7</span> days ago     <span>72</span>.8MB
ubuntu                        <span>18.04</span>     54919e10a95d   <span>7</span> days ago     <span>63</span>.1MB
centos                        latest    300e315adb2f   <span>9</span> months ago   209MB
centos                        <span>6.5</span>       997f0ed97903   <span>5</span> years ago    442MB
hub.c.163.com/public/centos   <span>6.5</span>       997f0ed97903   <span>5</span> years ago    442MB
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>除了使用这些公共镜像服务外，还可以搭建本地的私有仓库服务器。</p>
<h2 id="搭建本地私有仓库"> 搭建本地私有仓库</h2>
<h3 id="_1、创建私有仓库"> 1、创建私有仓库</h3>
<p>安装 Docker 后，可以通过官方提供的 registry 镜像来简单搭建一套本地私有仓库环境：</p>
<div><pre><code>$ <span>docker</span> pull registry:2
<span>2</span>: Pulling from library/registry
6a428f9f83b0: Pull complete 
90cad49de35d: Pull complete 
b215d0b40846: Pull complete 
429305b6c15c: Pull complete 
6f7e10a4e907: Pull complete 
Digest: sha256:265d4a5ed8bf0df27d1107edb00b70e658ee9aa5acb3f37336c5a17db634481e
Status: Downloaded newer image <span>for</span> registry:2
docker.io/library/registry:2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>这将自动下载井启动一个 registry 容器，创建本地的私有仓库服务。默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code> 目录下。可以通过 -v 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到 <code>/opt/data/registry</code> 目录：</p>
<div><pre><code>$ <span>docker</span> run -d -v /opt/registry:/var/lib/registry -p <span>5000</span>:5000 --name myregistry registry:2
933e961801d6fb8292f97f1d1eeeeb2457ac40333a562d82907f1b9bea08924c
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>此时，在本地将启动一个私有仓库服务，监听端口为 5000。</p>
<p>浏览器访问 http://127.0.0.1:5000/v2，出现下面情况说明 registry 运行正常。</p>
<div>
<p><img src="./assets/docker_5-3.png" alt="" loading="lazy"></p>
<p><u>图 5-3</u>	registry 运行情况</p>
</div>
<h3 id="_2、管理私有仓库"> 2、管理私有仓库</h3>
<p>首先在你的系统上搭建私有仓库，查看其地址为 127.0.0.1:5000，然后测试上传和下载镜像 ubuntu:18.04。</p>
<div><pre><code>$ <span>docker</span> images
REPOSITORY   TAG       IMAGE ID       CREATED        SIZE
registry     <span>2</span>         b2cb11db9d3d   <span>6</span> days ago     <span>26</span>.2MB
ubuntu       <span>18.04</span>     54919e10a95d   <span>7</span> days ago     <span>63</span>.1MB
centos       latest    300e315adb2f   <span>9</span> months ago   209MB
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>使用 <code>docker tag</code> 命令将这个镜像标记为 localhost:5000/ubuntu:18.04（格式为 docker tag [IMAGE[:TAG]] [REGISTRYHOST/] [USERNAME/] NAME [:TAG ]）。</p>
<div><pre><code>$ <span>docker</span> tag ubuntu:18.04 localhost:5000/ubuntu:18.04
$ <span>docker</span> images
REPOSITORY              TAG       IMAGE ID       CREATED        SIZE
registry                <span>2</span>         b2cb11db9d3d   <span>6</span> days ago     <span>26</span>.2MB
localhost:5000/ubuntu   <span>18.04</span>     54919e10a95d   <span>7</span> days ago     <span>63</span>.1MB
ubuntu                  <span>18.04</span>     54919e10a95d   <span>7</span> days ago     <span>63</span>.1MB
centos                  latest    300e315adb2f   <span>9</span> months ago   209MB
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>使用 <code>docker push</code> 上传标记的镜像：</p>
<div><pre><code>$ <span>docker</span> push localhost:5000/ubuntu:18.04 
The push refers to repository <span>[</span>localhost:5000/ubuntu<span>]</span>
6babb56be259: Pushed 
<span>18.04</span>: digest: sha256:b9caadbf898c50ce67da0ab5bafc4680997b010c3e17d2bb73d2ae5fe056e52b size: <span>529</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>访问 http://127.0.0.1:5000/v2/_catalog 查看私有仓库目录，可以看到刚上传的镜像了：</p>
<div>
<p><img src="./assets/docker_5-4.png" alt="" loading="lazy"></p>
<p><u>图 5-4</u>	私有仓库目录</p>
</div>
<p>下载私有仓库的镜像：</p>
<div><pre><code>$ <span>docker</span> images
REPOSITORY   TAG       IMAGE ID       CREATED        SIZE
registry     <span>2</span>         b2cb11db9d3d   <span>6</span> days ago     <span>26</span>.2MB
ubuntu       <span>18.04</span>     54919e10a95d   <span>7</span> days ago     <span>63</span>.1MB
centos       latest    300e315adb2f   <span>9</span> months ago   209MB
$ <span>docker</span> pull localhost:5000/ubuntu:18.04
<span>18.04</span>: Pulling from ubuntu
Digest: sha256:b9caadbf898c50ce67da0ab5bafc4680997b010c3e17d2bb73d2ae5fe056e52b
Status: Downloaded newer image <span>for</span> localhost:5000/ubuntu:18.04
localhost:5000/ubuntu:18.04
$ <span>docker</span> images
REPOSITORY              TAG       IMAGE ID       CREATED        SIZE
registry                <span>2</span>         b2cb11db9d3d   <span>6</span> days ago     <span>26</span>.2MB
ubuntu                  <span>18.04</span>     54919e10a95d   <span>7</span> days ago     <span>63</span>.1MB
localhost:5000/ubuntu   <span>18.04</span>     54919e10a95d   <span>7</span> days ago     <span>63</span>.1MB
centos                  latest    300e315adb2f   <span>9</span> months ago   209MB
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>下载后，还可以添加 一个更通用的标签 ubuntu:04，方便后续使用：</p>
<div><pre><code>$ <span>docker</span> tag localhost:5000/ubuntu:18.04 test_ubuntu:18.04 
</code></pre>
<div><span>1</span><br></div></div><div><p>说明</p>
<p>如果要使用安全证书，用户也可以从较知名的 CA 服务商（如 verisign）申请公开的
SSL/TLS 证书，或者使用 OpenSSL 等软件来自行生成。</p>
</div>
<h2 id="小结"> 小结</h2>
<p>仓库是集中维护容器镜像的地方，为 Docker 镜像文件的分发和管理提供了便捷的途径。这里介绍的 Docker Hub 和时速云镜像市场两个公共仓库服务，可以方便个人用户进行镜像的下载和使用等操作。</p>
<p>在企业的生产环境中，往往需要使用私有仓库来维护内部镜像，这里也介绍了基本的搭建操作，在后续部分中，将介绍私有仓库的更多配置选项。</p>
<p>除了官方的 registry 项目外，用户还可以使用其他的开源方案（例如 nexus）来搭建私有化的容器镜像仓库。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-08-23T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Docker 数据管理</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Docker/06.docker/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Docker/06.docker/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>在生产环境中使用 Docker，往往需要对数据进行持久化，或者需要在多个容器之间进行数据共享，这必然涉及容器的数据管理操作。</p>
<p>容器中的管理数据主要有两种方式：</p>
<ul>
<li>
<p><strong>数据卷（Data Volumes）</strong>：容器内数据直接映射到本地主机环境；</p>
</li>
<li>
<p><strong>数据卷容器（Data Volume Containers）</strong>：使用特定容器维护数据卷。</p>
</li>
</ul>
<p>将首先介绍如何在容器内创建数据卷，并且把本地的目录或文件挂载到容器内的数据卷中。接下来，介绍如何使用数据卷容器在容器和主机、容器和容器之间共享数据，并实现数据的备份和恢复。</p>
<h2 id="数据卷"> 数据卷</h2>
<p>数据卷（Data Volumes）是一个可供容器使用的特殊目录，它将主机操作系统目录直接映射进容器，类似于 Linux 中的 <code>mount</code> 行为。</p>
<p>数据卷可以提供很多有用的特性：</p>
<ul>
<li>数据卷可以在容器之间共享和重用，容器间传递数据将变得高效与方便；</li>
<li>对数据卷内数据的修改会立马生效，无论是容器内操作还是本地操作；</li>
<li>对数据卷的更新不会影响镜像，解耦开应用和数据 ；</li>
<li>卷会一直存在，直到没有容器使用，可以安全地卸载它。</li>
</ul>
<h3 id="_1、创建数据卷"> 1、创建数据卷</h3>
<p>Docker 提供了 <code>volume</code> 子命令来管理数据卷，如下命令可以快速在本地创建一个数据卷：</p>
<div><pre><code>$ <span>docker</span> volume create -d <span>local</span> <span>test</span>
<span>test</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>此时，<code>docker volume ls</code> 命令可以查看已有的数据卷，<code>docker inspect test</code>  可以查看数据卷 test 的具体信息：</p>
<div><pre><code>$ <span>docker</span> volume <span>ls</span>
DRIVER    VOLUME NAME
<span>local</span>     <span>test</span>
$ <span>docker</span> inspect <span>test</span> 
<span>[</span>
    <span>{</span>
        <span>"CreatedAt"</span><span>:</span> <span>"2021-09-22T15:06:05+08:00"</span>,
        <span>"Driver"</span><span>:</span> <span>"local"</span>,
        <span>"Labels"</span><span>:</span> <span>{</span><span>}</span>,
        <span>"Mountpoint"</span><span>:</span> <span>"/var/lib/docker/volumes/test/_data"</span>,
        <span>"Name"</span><span>:</span> <span>"test"</span>,
        <span>"Options"</span><span>:</span> <span>{</span><span>}</span>,
        <span>"Scope"</span><span>:</span> <span>"local"</span>
    <span>}</span>
<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>除了 <code>create</code> 子命令外，<code>docker volume</code> 还支持 <code>inspect</code>（查看详细信息）、<code>ls</code>（列出已有数据卷）、<code>prune</code>（清理无用数据卷）、<code>rm</code>（删除数据卷）等，大家可以自行实践。</p>
<h3 id="_2、绑定数据卷"> 2、绑定数据卷</h3>
<p>除了使用 <code>volume</code> 子命令来管理数据卷外，还可以在创建容器时将主机本地的任意路径挂载到容器内作为数据卷，这种形式创建的数据卷称为绑定数据卷。</p>
<p>在用 <code>docker [container] run</code> 命令的时候，可以使用 -mount 选项来使用数据卷。</p>
<p>-mount 选项支持三种类型的数据卷，包括：</p>
<ul>
<li>volume：普通数据卷，映射到主机 <code>/var/lib/docker/volumes</code> 路径下；</li>
<li>bind：绑定数据卷，映射到主机指定路径下；</li>
<li>tmpfs ：临时数据卷，只存在于内存中。</li>
</ul>
<p>下面使用 training/webapp 镜像创建一个 Web 容器，并创建一个数据卷挂载到容器的 <code>/opt/webapp</code> 目录：</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-08-23T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">端口映射与容器互联</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Docker/07.docker/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Docker/07.docker/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>通过前面的学习，相信你已经掌握了单个容器的管理操作。在实践中，经常会碰到需要多个服务组件容器共同协作的情况，这往往需要多个容器之间能够互相访问到对方的服务。</p>
<p>Docker 除了通过网络访间外，还提供了两个很方便的功能来满足服务访问的基本需求：一个是允许映射容器内应用的服务端口到本地宿主主机；另一个是互联机制实现多个容器间通过容器名来快速访问。下面将分别讲解这两个很实用的功能。</p>
<h2 id="端口映射实现容器访问"> 端口映射实现容器访问</h2>
<h3 id="_1、从外部访问容器应用"> 1、从外部访问容器应用</h3>
<p>在启动容器的时候，如果不指定对应参数，在容器外部是无法通过网络来访问容器内的网络应用和服务的。</p>
<p>当容器中运行一些网络应用，要让外部访问这些应用时，可以通过 -P 或 -p 参数来指定端口映射。当使用 -P（大写的）标记时，Docker 会随机映射一个 49000～49900 的端口到内部容器开放的网络端口：</p>
<div><pre><code>$ <span>docker</span> run -d -P training/webapp python app.py
Unable to <span>find</span> image <span>'training/webapp:latest'</span> locally
latest: Pulling from training/webapp
Image docker.io/training/webapp:latest uses outdated schema1 manifest format. Please upgrade to a schema2 image <span>for</span> better future compatibility. More information at https://docs.docker.com/registry/spec/deprecated-schema-v1/
e190868d63f8: Pull complete 
909cd34c6fd7: Pull complete 
0b9bfabab7c1: Pull complete 
a3ed95caeb02: Pull complete 
10bbbc0fc0ff: Pull complete 
fca59b508e9f: Pull complete 
e7ae2541b15b: Pull complete 
9dd97ef58ce9: Pull complete 
a4c1b0cb7af7: Pull complete 
Digest: sha256:06e9c1983bd6d5db5fba376ccd63bfa529e8d02f23d5079b8f74a616308fb11d
Status: Downloaded newer image <span>for</span> training/webapp:latest
1d3cb3e3c02c0d02fba3f997c31d56755658f177d6776e72994aa435dca6cca4
$ <span>docker</span> <span>ps</span> -l
CONTAINER ID   IMAGE             COMMAND           CREATED         STATUS         PORTS                                         NAMES
1d3cb3e3c02c   training/webapp   <span>"python app.py"</span>   <span>4</span> minutes ago   Up <span>4</span> minutes   <span>0.0</span>.0.0:49153-<span>></span><span>5000</span>/tcp，:::49153-<span>></span><span>5000</span>/tcp   trusting_chaum
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>此时，可以使用 <code>docker ps</code> 看到，本地主机的 49153 被映射到了容器的 5000 端口。</p>
<p>访间宿主主机的 49153 端口即可访问容器内 web 应用提供的界面。</p>
<div>
<p><img src="./assets/docker_7-1.png" alt="" loading="lazy"></p>
<p><u>图 7-1</u>	浏览器访问本机的 49153 端口</p>
</div>
<p>同样，可以通过 <code>docker logs</code> 命令来查看应用的信息：</p>
<div><pre><code>$ <span>docker</span> logs -f trusting_chaum 
 * Running on http://0.0.0.0:5000/ <span>(</span>Press CTRL+C to quit<span>)</span>
<span>172.17</span>.0.1 - - <span>[</span>08/Sep/2021 07:43:47<span>]</span> <span>"GET / HTTP/1.1"</span> <span>200</span> -
<span>172.17</span>.0.1 - - <span>[</span>08/Sep/2021 07:43:48<span>]</span> <span>"GET /favicon.ico HTTP/1.1"</span> <span>404</span> -
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>-p（小写的）则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 <code>IP:HostPort:ContainerPort | IP:: ContainerPort | HostPort:ContainerPort</code>。</p>
<h3 id="_2、映射所有接口地址"> 2、映射所有接口地址</h3>
<p>使用 HostPort:ContainerPort 格式把本地的 5000 端口映射到容器的 5000 端口，可以执行如下命令：</p>
<div><pre><code>$ <span>docker</span> run -d -p <span>5000</span>:5000 training/webapp python app.py
739716a4c97b68979f205c412ca0e0ddd1722badca142409ff1b6c05095112e2
$ <span>docker</span> <span>ps</span>
CONTAINER ID   IMAGE             COMMAND           CREATED          STATUS          PORTS                                       NAMES
739716a4c97b   training/webapp   <span>"python app.py"</span>   <span>4</span> seconds ago    Up <span>2</span> seconds    <span>0.0</span>.0.0:5000-<span>></span><span>5000</span>/tcp, :::5000-<span>></span><span>5000</span>/tcp   gifted_hoover
57f6feb67848   ubuntu:18.04      <span>"/bin/bash"</span>       <span>42</span> minutes ago   Up <span>42</span> minutes                                               interesting_bardeen
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>此时默认会绑定本地所有接口上的所有地址。多次使用 -p 标记可以绑定多个端口。例如：</p>
<div><pre><code>$ <span>docker</span> run -d -p <span>5000</span>:5000 -p <span>3000</span>:80 training/webapp python app.py
a8693f3c75a12c4a51be104a587307d254862b2d98d8242dc18cc4f91a487a4d
$ <span>docker</span> <span>ps</span>
CONTAINER ID   IMAGE             COMMAND           CREATED          STATUS          PORTS                                                                              NAMES
a8693f3c75a1   training/webapp   <span>"python app.py"</span>   <span>4</span> seconds ago    Up <span>3</span> seconds    <span>0.0</span>.0.0:5000-<span>></span><span>5000</span>/tcp, :::5000-<span>></span><span>5000</span>/tcp, <span>0.0</span>.0.0:3000-<span>></span><span>80</span>/tcp, :::3000-<span>></span><span>80</span>/tcp   wizardly_torvalds
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="_3、映射到指定地址的指定端口"> 3、映射到指定地址的指定端口</h3>
<p>可以使用 <code>IP:HostPort:ContainerPort</code> 格式指定映射使用一个特定地址，比如地址 127.0.2.1:5000：</p>
<div><pre><code>$ <span>docker</span> run -d -p <span>127.0</span>.0.1:5000:5000 training/webapp python app.py
16df89a9037cc439fd0dcf5905b21679ec729188158427080bcbd4a3c7b14de7
$ <span>docker</span> <span>ps</span>
CONTAINER ID   IMAGE             COMMAND           CREATED          STATUS          PORTS                      NAMES
16df89a9037c   training/webapp   <span>"python app.py"</span>   <span>4</span> seconds ago    Up <span>2</span> seconds    <span>127.0</span>.2.1:5000-<span>></span><span>5000</span>/tcp   serene_williamson
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="_4、映射到指定地址的任意端口"> 4、映射到指定地址的任意端口</h3>
<p>使用 IP::ContainerPort 绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口：</p>
<div><pre><code>$ <span>docker</span> run -d -p <span>127.0</span>.0.1::5000 training/webapp python app.py
ad5320b5cbc11774a0677a973d49a3696769d09a5fc2360b46dc4475d34b4132
$ <span>docker</span> <span>ps</span>
CONTAINER ID   IMAGE             COMMAND           CREATED          STATUS          PORTS                       NAMES
ad5320b5cbc1   training/webapp   <span>"python app.py"</span>   <span>5</span> seconds ago    Up <span>4</span> seconds    <span>127.0</span>.0.1:49153-<span>></span><span>5000</span>/tcp   gifted_bell
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>还可以使用 udp 标记来指定 udp 端口：</p>
<div><pre><code>$ <span>docker</span> run -d -p <span>127.0</span>.0.1:5000:5000/udp training/webapp python app.py
4da22d44f5575a180d8e494e65440b3b45a59f5d489e8d4aaa350d95ea1c2c14
$ <span>docker</span> <span>ps</span>
CONTAINER ID   IMAGE             COMMAND           CREATED          STATUS          PORTS                                NAMES
4da22d44f557   training/webapp   <span>"python app.py"</span>   <span>4</span> seconds ago    Up <span>2</span> seconds    <span>5000</span>/tcp, <span>127.0</span>.0.1:5000-<span>></span><span>5000</span>/udp   determined_turing
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="_5、查看映射端口配置"> 5、查看映射端口配置</h3>
<p>使用 <code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址：</p>
<div><pre><code>$ <span>docker</span> run -d -p <span>127.0</span>.0.1::5000 training/webapp python app.py
ac00973485fb8aa90443fd6a1fc7203d80b577d99757d5d5181f931b37b8bfc3
$ <span>docker</span> port compassionate_brattain 
<span>5000</span>/tcp -<span>></span> <span>127.0</span>.0.1:49154
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><p>注意</p>
<p>容器有自己的内部网络和 IP 地址，使用 <code>docker [container] inspect 容器ID</code> 可以获取容器的具体信息。</p>
</div>
<h2 id="互联机制实现便捷互访"> 互联机制实现便捷互访</h2>
<p>容器的互联（Iinking）是一种让多个容器中的应用进行快速交互的方式。它会在源和接收容器之间创建连接关系，接收容器可以通过容器名快速访问到源容器，而不用指定具体的 IP 地址。</p>
<h3 id="_1、自定义容器命名"> 1、自定义容器命名</h3>
<p>连接系统依据容器的名称来执行。因此，首先需要自定义一个好记的容器命名。虽然当创建容器的时候，系统默认会分配一个名字，但自定义命名容器有两个好处：</p>
<ul>
<li>自定义的命名，比较好记，比如一个 Web 应用容器我们可以给它起名叫 web，一目了然；</li>
<li>当要连接其他容器时候（即便重启），也可以使用容器名而不用改变，比如连接 web 容器到 db 容器。</li>
</ul>
<p>使用 --name 标记可以为容器自定义命名：</p>
<div><pre><code>$ <span>docker</span> run -d -P --name web training/webapp python app.py
34c73b3f41309246047c1eff9e49888b71a6a7191c1ddb57cec2115d4fb54d3c
$ <span>docker</span> <span>ps</span>
CONTAINER ID   IMAGE             COMMAND           CREATED             STATUS             PORTS                                         NAMES
34c73b3f4130   training/webapp   <span>"python app.py"</span>   <span>3</span> seconds ago       Up <span>2</span> seconds       <span>0.0</span>.0.0:49154-<span>></span><span>5000</span>/tcp, :::49154-<span>></span><span>5000</span>/tcp   web
<span>#使用 docker ps 来验证设定的命名</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>也可以使用 <code>docker [container) inspect</code> 来查看容器的名字：</p>
<div><pre><code>$ <span>docker</span> inspect -f <span>"{{.Name}}"</span> 34c73b3f4130
/web
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><p>注意</p>
<p>容器的名称是唯一的。如果巳经命名了一个叫 web 的容器，当你要再次使用 web 这个名称的时候，需要先用 <code>docker rm</code> 命令删除之前创建的同名容器。</p>
</div>
<p>在执行 <code>docker [container] run</code> 的时候如果添加 --rm 标记，则容器在终止后会立刻删除。注意，--rm 和 -d 参数不能同时使用。</p>
<h3 id="_2、容器互联"> 2、容器互联</h3>
<p>使用 --link 参数可以让容器之间安全地进行交互。</p>
<p>下面先创建一个新的数据库容器：</p>
<div><pre><code>$ <span>docker</span> run -d --name db training/postgres
Unable to <span>find</span> image <span>'training/postgres:latest'</span> locally
latest: Pulling from training/postgres
Image docker.io/training/postgres:latest uses outdated schema1 manifest format. Please upgrade to a schema2 image <span>for</span> better future compatibility. More information at https://docs.docker.com/registry/spec/deprecated-schema-v1/
a3ed95caeb02: Pull complete 
6e71c809542e: Downloading 
2978d9af87ba: Download complete 
e1bca35b062f: Download complete 
500b6decf741: Download complete 
74b14ef2151f: Download complete 
7afd5ed3826e: Download complete 
3c69bb244f5e: Download complete 
d86f9ec5aedf: Download complete 
010fabf20157: Download complete 
latest: Pulling from training/postgres
Image docker.io/training/postgres:latest uses outdated schema1 manifest format. Please upgrade to a schema2 image <span>for</span> better future compatibility. More information at https://docs.docker.com/registry/spec/deprecated-schema-v1/
a3ed95caeb02: Pull complete 
6e71c809542e: Pull complete 
2978d9af87ba: Pull complete 
e1bca35b062f: Pull complete 
500b6decf741: Pull complete 
74b14ef2151f: Pull complete 
7afd5ed3826e: Pull complete 
3c69bb244f5e: Pull complete 
d86f9ec5aedf: Pull complete 
010fabf20157: Pull complete 
Digest: sha256:a945dc6dcfbc8d009c3d972931608344b76c2870ce796da00a827bd50791907e
Status: Downloaded newer image <span>for</span> training/postgres:latest
dd2bf319cac08333c221abd08748a8f06b5ae75f4bab9c45e74785e0d56932e0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>删除之前创建的 web 容器：</p>
<div><pre><code>$ <span>docker</span> <span>rm</span> -f web
</code></pre>
<div><span>1</span><br></div></div><p>然后创建 一 个新的 web 容器，并将它连接到 db 容器：</p>
<div><pre><code>$ <span>docker</span> run -d -P --name web --link db:db training/webapp python app.py
b726365f50d7a4a4b31570bcd8a9ccbe77e6b63fd8f1438182398b5e1426ed21
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>此时，db 容器和 web 容器建立互联关系。</p>
<p>--link 参数的格式为 --link name:alias，其中 name 是要链接的容器的名称，alias 是别名。</p>
<p>使用 <code>docker inspect web</code> 来查看 web 容器的详情（Links）：</p>
<div><pre><code>$ <span>docker</span> inspect web 
<span>[</span>
    <span>{</span>
        <span>"Id"</span><span>:</span> <span>"68f6051bd5be4c13b1d97fdfee1b468c1ecbb0ecc203b26ce3673b3744d74b69"</span>,
        <span>"Created"</span><span>:</span> <span>"2021-09-09T00:59:29.018886397Z"</span>,
        <span>"Path"</span><span>:</span> <span>"python"</span>,
        <span>"Args"</span><span>:</span> <span>[</span>
            <span>"app.py"</span>
        <span>]</span>,
        <span>"State"</span><span>:</span> <span>{</span>
            <span>"Status"</span><span>:</span> <span>"running"</span>,
<span>..</span><span>..</span><span>..</span>
<span>"Links"</span><span>:</span> <span>[</span>
                <span>"/db:/web/db"</span>
            <span>]</span>,
<span>..</span><span>..</span><span>..</span>
    <span>}</span>
<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>Docker 相当于在两个互联的容器之间创建了一个虚机通道，而且不用映射它们的端口到宿主主机上。在启动 db 容器的时候并没有使用 -p 和 -P 标记，从而避免了暴露数据库服务端口到外部网络上。</p>
<p>Docker 通过两种方式为容器公开连接信息：</p>
<ul>
<li>更新环境变量;</li>
<li>更新 <code>/etc/hosts</code> 文件。</li>
</ul>
<p>使用 <code>env</code> 命令来查看 web 容器的环境变量：</p>
<div><pre><code>$ <span>docker</span> run --rm --name web2 --link db:db training/webapp <span>env</span>
<span><span>PATH</span></span><span>=</span>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
<span><span>HOSTNAME</span></span><span>=</span>4acbb47609c1
<span>DB_PORT</span><span>=</span>tcp://172.17.0.2:5432
<span>DB_PORT_5432_TCP</span><span>=</span>tcp://172.17.0.2:5432
<span>DB_PORT_5432_TCP_ADDR</span><span>=</span><span>172.17</span>.0.2
<span>DB_PORT_5432_TCP_PORT</span><span>=</span><span>5432</span>
<span>DB_PORT_5432_TCP_PROTO</span><span>=</span>tcp
<span>DB_NAME</span><span>=</span>/web2/db
<span>DB_ENV_PG_VERSION</span><span>=</span><span>9.3</span>
<span><span>HOME</span></span><span>=</span>/root
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>其中 DB_ 开头的环境变量是供 web 容器连接 db 容器使用，前缀采用大写的连接别名。</p>
<p>除了环境变量，Docker 还添加 host 信息到父容器的 /etc/hosts 的文件。下面是父容器 web 的 hosts 文件：</p>
<div><pre><code>$ <span>docker</span> run -it --rm --link db:db training/webapp /bin/bash
root@4581c58ad217:/opt/webapp<span># cat /etc/hosts </span>
<span>127.0</span>.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
ff00::0	ip6-mcastprefix
ff02::1	ip6-allnodes
ff02::2	ip6-allrouters
<span>172.17</span>.0.2	db 7d1b09695298
<span>172.17</span>.0.4	4581c58ad217
root@4581c58ad217:/opt/webapp<span># </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>这里有 2 个 hosts 信息，第一个是 web 容器，web 容器用自己的 id 作为默认主机名，第二个是 db 容器的 IP 和主机名。</p>
<p>可以在 web 容器中安装 <code>ping</code> 命令来测试跟 db 容器的连通：</p>
<div><pre><code>root@17d65c4c4712:/opt/webapp<span># apt install -yqq inetutils-ping</span>
The following packages will be REMOVED:
  iputils-ping ubuntu-minimal
The following NEW packages will be installed:
  inetutils-ping
<span>0</span> upgraded, <span>1</span> newly installed, <span>2</span> to remove and <span>3</span> not upgraded.
Need to get <span>55.6</span> kB of archives.
After this operation, <span>131</span> kB of additional disk space will be used.
<span>(</span>Reading database <span>..</span>. <span>18233</span> files and directories currently installed.<span>)</span>
Removing ubuntu-minimal <span>(</span><span>1.325</span><span>)</span> <span>..</span>.
Removing iputils-ping <span>(</span><span>3</span>:20121221-4ubuntu1.1<span>)</span> <span>..</span>.
Selecting previously unselected package inetutils-ping.
<span>(</span>Reading database <span>..</span>. <span>18221</span> files and directories currently installed.<span>)</span>
Preparing to unpack <span>..</span>./inetutils-ping_2%3a1.9.2-1_amd64.deb <span>..</span>.
Unpacking inetutils-ping <span>(</span><span>2</span>:1.9.2-1<span>)</span> <span>..</span>.
Setting up inetutils-ping <span>(</span><span>2</span>:1.9.2-1<span>)</span> <span>..</span>.
root@17d65c4c4712:/opt/webapp<span># ping db</span>
PING db <span>(</span><span>172.17</span>.0.2<span>)</span>: <span>56</span> data bytes
<span>64</span> bytes from <span>172.17</span>.0.2: <span>icmp_seq</span><span>=</span><span>0</span> <span>ttl</span><span>=</span><span>64</span> <span>time</span><span>=</span><span>0.933</span> ms
<span>64</span> bytes from <span>172.17</span>.0.2: <span>icmp_seq</span><span>=</span><span>1</span> <span>ttl</span><span>=</span><span>64</span> <span>time</span><span>=</span><span>0.278</span> ms
<span>64</span> bytes from <span>172.17</span>.0.2: <span>icmp_seq</span><span>=</span><span>2</span> <span>ttl</span><span>=</span><span>64</span> <span>time</span><span>=</span><span>0.172</span> ms
<span>64</span> bytes from <span>172.17</span>.0.2: <span>icmp_seq</span><span>=</span><span>3</span> <span>ttl</span><span>=</span><span>64</span> <span>time</span><span>=</span><span>0.150</span> ms
^C--- db <span>ping</span> statistics ---
<span>6</span> packets transmitted, <span>6</span> packets received, <span>0</span>% packet loss
round-trip min/avg/max/stddev <span>=</span> <span>0.089</span>/0.290/0.933/0.293 ms
root@17d65c4c4712:/opt/webapp<span># </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>用 ping 来测试 db 容器，它会解析成 172.17.0.2。</p>
<p>用户可以链接多个子容器到父容器，比如可以链接多个 web 到同一个 db 容器上。</p>
<h2 id="小结"> 小结</h2>
<p>毫无疑问，容器服务的访间是很关键的一个用途。通过具体案例讲解了 Docker 容器服务访问的两大基本操作，包括基础的容器端口映射机制和容器互联机制。同时，Docker 目前可以成熟支持 Linux 系统自带的网络服务和功能，这既可以利用现有成熟的技术提供稳定支持，又可以实现快速的高性能转发。</p>
<p>在生产环境中，网络方面的需求更加复杂和多变，包括跨主机甚至跨数据中心的通信，这时候往往就需要引入额外的机制，例如 SDN（软件定义网络）或 NFV （网络功能虚拟化）
的相关技术。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-08-23T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">使用 Dockerfile 创建镜像</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Docker/08.docker/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Docker/08.docker/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>Dockerfile 是一个文本格式的配置文件，用户可以使用 Dockerfile 来快速创建自定义的镜像。</p>
<p>下面首先将介绍 Dockerfile 典型的基本结构及其支持的众多指令，并具体讲解通过这些指令来编写定制镜像的 Dockerfile，以及如何生成镜像。最后，会介绍使用 Dockerfile 的一些最佳实践经验。</p>
<h2 id="基本结构"> 基本结构</h2>
<p>Dockerfile 由一行行命令语句组成，并且支持以 <strong>#</strong> 开头的注释行。
一般而言，Dockerfile 主体内容分为四部分：<strong>基础镜像信息</strong>、<strong>维护者信息</strong>、<strong>镜像操作指令</strong>和<strong>容器启动时执行指令</strong>。</p>
<p>下面给出 一 个简单的示例：</p>
<div><pre><code><span># escape=\(backslash)</span>
<span># This dockerfile uses the ubuntu:xeniel image</span>
<span># VERSION 2 - EDITION 1</span>
<span># Author: docker_user</span>
<span># Command format: Instruction [arguments / command] ...</span>

<span># Base image to use, this must be set as the first line</span>
FROM ubuntu:xeniel

<span># Maintainer: docker_user &lt;docker_user at email.com> (@docker_user)</span>
LABEL maintainer docker_user<span>&lt;</span>docker_user@email.com<span>></span>

<span># Commands to update the image</span>
RUN <span>echo</span> <span>"deb http://archive.ubuntu.com/ubuntu/ xeniel main universe"</span> <span>>></span> /etc/app/sources.list
RUN <span>apt-get</span> update <span>&amp;&amp;</span> <span>apt-get</span> <span>install</span> -y nginx
RUN <span>echo</span> <span>"<span title="\n">\n</span>daernon off;"</span> <span>>></span> /etc/nginx/nginx.conf

<span># Commands when creating a new container</span>
CMD /usr/sbin/nginx
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>首行可以通过注释来指定解析器命令，后续通过注释说明镜像的相关信息。主体部分首先使用 FROM 指令指明所基于的镜像名称，接下来一般是使用 LABEL 指令说明维护者信息。后面则是镜像操作指令，例如 RUN 指令将对镜像执行跟随的命令。每运行一条 RUN 指令，镜像添加新的一层，并提交。最后是 CMD 指令，来指定运行容器时的操作命令。</p>
<p>下面是 Docker Hub 上两个热门镜像 nginx 和 Go 的 Dockerfile 的例子，通过这两个例子。你可以对 Dockerfile 结构有个基本的感知。</p>
<p>第一个是在 debian:jessie 基础镜像基础上安装 Nginx 环境，从而创建一个新的 nginx 镜像：</p>
<div><pre><code>FROM debian:jessie
LABEL maintainer docker_user<span>&lt;</span>docker_user@email.com<span>></span>
ENV NGINX_VERSION <span>1.10</span>.1-1-jessie
RUN apt-key adv --keyserver hkp://pgp.mit.edu:80 --recv-keys 573BFD6B3DBFBC641079A6ABABF5BDB27BD9BF62 <span>\</span>
		<span>&amp;&amp;</span> <span>echo</span> <span>"deb http://nginx.org/packages/debian/ jessie nginx"</span> <span>>></span> /etc/apt/sources.list <span>\</span>
		<span>&amp;&amp;</span> <span>apt-get</span> update <span>\</span>
		<span>&amp;&amp;</span> <span>apt-get</span> <span>install</span> --no-install-recommends --no-install-suggests -y <span>\</span>
		ca-certificates <span>\</span>
		<span>nginx</span><span>=</span><span>${NGINX_VERSION}</span> <span>\</span>
		nginx-module-xslt <span>\</span>
		nginx-module-geoip <span>\</span>
		nginx-module-image-filter <span>\</span>
		nginx-module-perl <span>\</span>
		nginx-module-njs <span>\</span>
		gettext-base <span>\</span>
		<span>&amp;&amp;</span> <span>rm</span> -rf /var/lib/apt/lists/*
----------------------------
<span># forward request and error logs to docker log collector</span>
RUN <span>ln</span> -sf /dev/stdout /var/log/nginx/access.log <span>\</span>
		<span>&amp;&amp;</span> <span>ln</span> -sf /dev/stderr /var/log/nginx/error.log

EXPOSE <span>80</span> <span>443</span>

CMD <span>[</span><span>"nginx"</span>,<span>"-g"</span>,<span>"daemon off;"</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>第二个是基于 buildpack-deps:jessie-scm 基础镜像，安装 Golang 相关环境，制作一个 Go 语言的运行环境镜像：</p>
<div><pre><code>FROM buildpack-deps:jessie-scm

<span>#gcc for cgo</span>

RUN <span>apt-get</span> update <span>&amp;&amp;</span> <span>apt-get</span> <span>install</span> -y --no-install-recommends <span>\</span>
		g++ <span>\</span>
		gcc <span>\</span>
		libe6-dev <span>\</span>
		<span>make</span> <span>\</span>
		<span>&amp;&amp;</span> <span>rm</span> -rf /var/lib/apt/lists/*
		
ENV GOLANG VERSION <span>1.6</span>.3
ENV GOLANG_DOWNLOAD_URL https://golang.org/dl/go<span>$GOLANG_VERSION</span>.linux-amd64.tar.gz
ENV GOLANG_DOWNLOAD_SHA256 cdde5e08530c0579255d6153b08fdb3b8e47caabbe717bc7bcd7561275a87aeb

RUN <span>curl</span> -fsSL <span>"<span>$GOLANG_DOWNLOAD_URL</span>"</span> -o golang.tar.gz <span>\</span>
		<span>&amp;&amp;</span> <span>echo</span> <span>"<span>$GOLANG_DOWNLOAD_SHA256</span> golang.tar.gz"</span> <span>|</span> sha256sum -c - <span>\</span>
		<span>&amp;&amp;</span> <span>tar</span> -C /usr/local -xzf golang.tar.gz <span>\</span>
		<span>&amp;&amp;</span> <span>rm</span> golang.tar.gz
		
ENV GOPATH /go
ENV <span>PATH</span> <span>$GOPATH</span>/bin:/usr/local/go/bin:<span>$PATH</span>

RUN <span>mkdir</span> -p <span>"<span>$GOPATH</span>/src"</span> <span>"<span>$GOPATH</span>/bin"</span> <span>&amp;&amp;</span> <span>chmod</span> -R <span>777</span> <span>"<span>$GOPATH</span>"</span>
WORKDIR <span>$GOPATH</span>

COPY go-wrapper /usr/local/bin/
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>下面，将讲解 Dockerfile 中各种指令的应用。</p>
<h2 id="指令说明"> 指令说明</h2>
<p>Dockerfile 中指令的一般格式为 INSTRUCTION arguments，包括“配置指令”（配置镜像信息）和“操作指令“（具体执行操作），参见表 8-1。</p>
<p><u>表 8-1</u>	Dockerfile 中的指令及说明</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-08-23T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">虚拟化的发展</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Docker/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Docker/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="虚拟化"> 虚拟化</h2>
<p>如果说主机时代比拼的是单个服务器物理性能（如 CPU 主频和内存）的强弱，那么在云时代，最为看重的则是凭借虚拟化技术所构建的集群处理能力 。</p>
<p>伴随着信息技术的飞速发展，虚拟化的概念早已经广泛应用到各种关键场景中 。 从 20 世纪 60 年代 IBM 推出的大型主机虚拟化，到后来以 Xen 、KVM 为代表的虚拟机虚拟化，再到现在以 Docker 为代表的容器技术，虚拟化技术自身也在不断进行创新和突破。</p>
<p>传统来看，虚拟化既可以通过硬件模拟来实现，也可以通过操作系统软件来实现 。 而容器技术则更为优雅，它充分利用了操作系统本身已有的机制和特性，可以实现远超传统虚拟机的轻量级虚拟化 。 因此，有人甚至把它称为“新一代的虚拟化”技术，并将基于容器打造的云平台亲切地称为“容器云” 。</p>
<p>毫无疑问， Docker 正是众多容器技术中的佼佼者，是容器技术发展过程中耀眼的一抹亮色 。</p>
<h2 id="docker"> Docker</h2>
<p>Docker 是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。</p>
<p>Docker 主要解决环境配置问题，它是一种虚拟化技术，对进程进行隔离，被隔离的进程独立于宿主操作系统和其它隔离的进程。使用 Docker 可以不修改应用程序代码，不需要开发人员学习特定环境下的技术，就能够将现有的应用程序部署在其它机器上。</p>
<p><img src="./assets/1.png" alt="" loading="lazy"></p>
<p>就在 Docker 容器技术被炒得热火朝天之时，大家发现，如果想要将 Docker 应用于具体的业务实现，是存在困难的——编排、管理和调度等各个方面，都不容易。于是，人们迫切需要一套管理系统，对 Docker 及容器进行更高级更灵活的管理。就在这个时候，K8S 出现了。</p>
<div><p>说明</p>
<p>K8S，就是基于容器的集群管理平台，它的全称是 kubernetes（k8s 这个缩写是因为 k 和 s 之间有八个字符的关系）。</p>
</div>
<h2 id="kubernetes"> Kubernetes</h2>
<p>Kubernetes 是 Google 团队发起并维护的开源容器集群管理系统, 底层基于 Docker、rkt 等容器技术，提供强大的应用管理和资源调度能力。 Kubernetes 已经成为目前容器云领域影响力最大的开源平台，使用 Kubernetes，用户可以轻松搭建和管理 一 个可扩展的生产级别容器云。</p>
<p><img src="./assets/2.png" alt="" loading="lazy"></p>
<p>容器是打包和运行应用程序的好方式。在生产环境中，你需要管理运行应用程序的容器，并确保不会停机。 例如，如果一个容器发生故障，则需要启动另一个容器。如果系统处理此行为，会不会更容易？</p>
<p>这就是 Kubernetes 来解决这些问题的方法！ Kubernetes 为你提供了一个可弹性运行分布式系统的框架。 Kubernetes 会满足你的扩展要求、故障转移、部署模式等。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-08-23T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Excel 快捷键</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Excel/01.Excel_hotkey/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Excel/01.Excel_hotkey/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>只会用<kbd>Ctrl</kbd>+<kbd>C</kbd>和<kbd>Ctrl</kbd>+<kbd>V</kbd>怎么面对职场挑战！</p>
<p>当然 这些快捷键不需要全部记住，咱们只要收藏一下，<strong>记住几个常用的快捷键</strong>就可以了，对于提高效率和逼格，作用都是不错的。</p>
<div>
<p><img src="./assets/kbd1.jpg" alt="kbd1" loading="lazy"></p>
<p><img src="./assets/kbd2.jpg" alt="kbd2" loading="lazy"></p>
<p><img src="./assets/kbd3.jpg" alt="kbd3" loading="lazy"></p>
<p><img src="./assets/kbd4.jpg" alt="kbd4" loading="lazy"></p>
<p><img src="./assets/kbd5.jpg" alt="kbd5" loading="lazy"></p>
<p><img src="./assets/kbd6.jpg" alt="kbd6" loading="lazy"></p>
<p><img src="./assets/kbd7.jpg" alt="kbd7" loading="lazy"></p>
<p><img src="./assets/kbd8.jpg" alt="kbd8" loading="lazy"></p>
<p><img src="./assets/kbd9.jpg" alt="kbd9" loading="lazy"></p>
</div>
<div><p>注</p>
<p>以上图片来自于 <a href="https://www.excelhome.net/436.html" target="_blank" rel="noopener noreferrer">ExcelHome</a></p>
</div>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-07-02T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Excel 函数</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Excel/02.Excel_function/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Excel/02.Excel_function/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>Excel 的常用函数大致可分为以下几大类：</p>
<ul>
<li>统计函数</li>
<li>逻辑函数</li>
<li>文本函数</li>
<li>数学函数</li>
<li>查找引用函数</li>
<li>日期时间函数</li>
<li>信息函数</li>
<li>......</li>
</ul>
<p>当然，工作中很多问题不是单单一个函数就可以解决的，而是多个函数的组合才能沟解决问题的，这就要我们灵活的运用函数套嵌，或者需要辅助列等等。同一个问题也不是只有一个方法，可以有多种方法，具体情况具体对待。</p>
<h2 id="统计函数"> 统计函数</h2>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/average-%E5%87%BD%E6%95%B0-047bac88-d466-426c-a32b-8f33eb960cf6" target="_blank" rel="noopener noreferrer">AVERAGE 函数</a></td>
<td>返回其参数的平均值</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/averageif-%E5%87%BD%E6%95%B0-faec8e2e-0dec-4308-af69-f5576d8ac642" target="_blank" rel="noopener noreferrer">AVERAGEIF 函数</a></td>
<td>返回区域中满足给定条件的所有单元格的平均值（算术平均值）</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/averageifs-%E5%87%BD%E6%95%B0-48910c45-1fc0-4389-a028-f7c5c3001690" target="_blank" rel="noopener noreferrer">AVERAGEIFS 函数</a></td>
<td>返回满足多个条件的所有单元格的平均值（算术平均值）</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/count-%E5%87%BD%E6%95%B0-a59cd7fc-b623-4d93-87a4-d23bf411294c" target="_blank" rel="noopener noreferrer">COUNT 函数</a></td>
<td>计算参数列表中数字的个数</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/counta-%E5%87%BD%E6%95%B0-7dc98875-d5c1-46f1-9a82-53f3219e2509" target="_blank" rel="noopener noreferrer">COUNTA 函数</a></td>
<td>计算参数列表中值的个数</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/countblank-%E5%87%BD%E6%95%B0-6a92d772-675c-4bee-b346-24af6bd3ac22" target="_blank" rel="noopener noreferrer">COUNTBLANK 函数</a></td>
<td>计算区域内空白单元格的数量</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/countif-%E5%87%BD%E6%95%B0-e0de10c6-f885-4e71-abb4-1f464816df34" target="_blank" rel="noopener noreferrer">COUNTIF 函数</a></td>
<td>计算区域内符合给定条件的单元格的数量</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/countifs-%E5%87%BD%E6%95%B0-dda3dc6e-f74e-4aee-88bc-aa8c2a866842" target="_blank" rel="noopener noreferrer">COUNTIFS 函数</a></td>
<td>计算区域内符合多个条件的单元格的数量</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/large-%E5%87%BD%E6%95%B0-3af0af19-1190-42bb-bb8b-01672ec00a64" target="_blank" rel="noopener noreferrer">LARGE 函数</a></td>
<td>返回数据集中第 k 个最大值</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/small-%E5%87%BD%E6%95%B0-17da8222-7c82-42b2-961b-14c45384df07" target="_blank" rel="noopener noreferrer">SMALL 函数</a></td>
<td>返回数据集中的第 k 个最小值</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/max-%E5%87%BD%E6%95%B0-e0012414-9ac8-4b34-9a47-73e662c08098" target="_blank" rel="noopener noreferrer">MAX 函数</a></td>
<td>返回参数列表中的最大值</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/median-%E5%87%BD%E6%95%B0-d0916313-4753-414c-8537-ce85bdd967d2" target="_blank" rel="noopener noreferrer">MEDIAN 函数</a></td>
<td>返回给定数值集合的中值</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/min-%E5%87%BD%E6%95%B0-61635d12-920f-4ce2-a70f-96f202dcc152" target="_blank" rel="noopener noreferrer">MIN 函数</a></td>
<td>返回参数列表中的最小值</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/subtotal-%E5%87%BD%E6%95%B0-7b027003-f060-4ade-9040-e478765b9939" target="_blank" rel="noopener noreferrer">SUBTOTAL 函数</a></td>
<td>返回列表或数据库中的分类汇总</td>
</tr>
</tbody>
</table>
<h2 id="逻辑函数"> 逻辑函数</h2>
<table>
<thead>
<tr>
<th>函数</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/if-%E5%87%BD%E6%95%B0-69aed7c9-4e8a-4755-a9bc-aa8bbff73be2" target="_blank" rel="noopener noreferrer">IF 函数</a></td>
<td>指定要执行的逻辑检测</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/ifs-%E5%87%BD%E6%95%B0-36329a26-37b2-467c-972b-4a39bd951d45" target="_blank" rel="noopener noreferrer">IFS 函数</a></td>
<td>检查是否满足一个或多个条件，且是否返回与第一个 TRUE 条件对应的值。</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/iferror-%E5%87%BD%E6%95%B0-c526fd07-caeb-47b8-8bb6-63f3e417f611" target="_blank" rel="noopener noreferrer">IFERROR 函数</a></td>
<td>如果公式的计算结果错误，则返回您指定的值；否则返回公式的结果</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/ifna-%E5%87%BD%E6%95%B0-6626c961-a569-42fc-a49d-79b4951fd461" target="_blank" rel="noopener noreferrer">IFNA 函数</a></td>
<td>如果该表达式解析为 #N/A，则返回指定值；否则返回该表达式的结果</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/and-%E5%87%BD%E6%95%B0-5f19b2e8-e1df-4408-897a-ce285a19e9d9" target="_blank" rel="noopener noreferrer">AND 函数</a></td>
<td>如果其所有参数均为 TRUE，则返回 TRUE</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/or-%E5%87%BD%E6%95%B0-7d17ad14-8700-4281-b308-00b131e22af0" target="_blank" rel="noopener noreferrer">OR 函数</a></td>
<td>如果任一参数为 TRUE，则返回 TRUE</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/not-%E5%87%BD%E6%95%B0-9cfc6011-a054-40c7-a140-cd4ba2d87d77" target="_blank" rel="noopener noreferrer">NOT 函数</a></td>
<td>对其参数的逻辑求反</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/true-%E5%87%BD%E6%95%B0-7652c6e3-8987-48d0-97cd-ef223246b3fb" target="_blank" rel="noopener noreferrer">TRUE 函数</a></td>
<td>返回逻辑值 TRUE</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/false-%E5%87%BD%E6%95%B0-2d58dfa5-9c03-4259-bf8f-f0ae14346904" target="_blank" rel="noopener noreferrer">FALSE 函数</a></td>
<td>返回逻辑值 FALSE</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/switch-%E5%87%BD%E6%95%B0-47ab33c0-28ce-4530-8a45-d532ec4aa25e" target="_blank" rel="noopener noreferrer">SWITCH 函数</a></td>
<td>根据值列表计算表达式，并返回与第一个匹配值对应的结果。 <br />如果不匹配，则可能返回可选默认值。</td>
</tr>
</tbody>
</table>
<h2 id="文本函数"> 文本函数</h2>
<table>
<thead>
<tr>
<th>函数</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/asc-%E5%87%BD%E6%95%B0-0b6abf1c-c663-4004-a964-ebc00b723266" target="_blank" rel="noopener noreferrer">ASC 函数</a></td>
<td>将字符串中的全角（双字节）英文字母或片假名更改为半角（单字节）字符</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/dbcs-%E5%87%BD%E6%95%B0-a4025e73-63d2-4958-9423-21a24794c9e5" target="_blank" rel="noopener noreferrer">DBCS 函数</a></td>
<td>将字符串中的半角（单字节）英文字母或片假名更改为全角（双字节）字符</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/char-%E5%87%BD%E6%95%B0-bbd249c8-b36e-4a91-8017-1c133f9b837a" target="_blank" rel="noopener noreferrer">CHAR 函数</a></td>
<td>返回由代码数字指定的字符</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/concat-%E5%87%BD%E6%95%B0-9b1a9a3f-94ff-41af-9736-694cbd6b4ca2" target="_blank" rel="noopener noreferrer">CONCAT 函数</a></td>
<td>将多个区域和/或字符串的文本组合起来，<br />但不提供分隔符或 IgnoreEmpty 参数。</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/concatenate-%E5%87%BD%E6%95%B0-8f8ae884-2ca8-4f7a-b093-75d702bea31d" target="_blank" rel="noopener noreferrer">CONCATENATE 函数</a></td>
<td>将几个文本项合并为一个文本项</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/dollar-%E5%87%BD%E6%95%B0-a6cd05d9-9740-4ad3-a469-8109d18ff611" target="_blank" rel="noopener noreferrer">DOLLAR 函数</a></td>
<td>使用 ￥（人民币）货币格式将数字转换为文本</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/exact-%E5%87%BD%E6%95%B0-d3087698-fc15-4a15-9631-12575cf29926" target="_blank" rel="noopener noreferrer">EXACT 函数</a></td>
<td>检查两个文本值是否相同</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/fixed-%E5%87%BD%E6%95%B0-ffd5723c-324c-45e9-8b96-e41be2a8274a" target="_blank" rel="noopener noreferrer">FIXED 函数</a></td>
<td>将数字格式设置为具有固定小数位数的文本</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/find%E3%80%81findb-%E5%87%BD%E6%95%B0-c7912941-af2a-4bdf-a553-d0d89b0a0628" target="_blank" rel="noopener noreferrer">FIND、FINDB 函数</a></td>
<td>在一个文本值中查找另一个文本值（区分大小写）</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/left%E3%80%81leftb-%E5%87%BD%E6%95%B0-9203d2d2-7960-479b-84c6-1ea52b99640c" target="_blank" rel="noopener noreferrer">LEFT、LEFTB 函数</a></td>
<td>返回文本值中最左边的字符</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/right%E3%80%81rightb-%E5%87%BD%E6%95%B0-240267ee-9afa-4639-a02b-f19e1786cf2f" target="_blank" rel="noopener noreferrer">RIGHT、RIGHTB 函数</a></td>
<td>返回文本值中最右边的字符</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/mid%E3%80%81midb-%E5%87%BD%E6%95%B0-d5f9e25c-d7d6-472e-b568-4ecb12433028" target="_blank" rel="noopener noreferrer">MID、MIDB 函数</a></td>
<td>从文本字符串中的指定位置起返回特定个数的字符</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/len%E3%80%81lenb-%E5%87%BD%E6%95%B0-29236f94-cedc-429d-affd-b5e33d2c67cb" target="_blank" rel="noopener noreferrer">LEN、LENB 函数</a></td>
<td>返回文本值中最左边的字符</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/lower-%E5%87%BD%E6%95%B0-3f21df02-a80c-44b2-afaf-81358f9fdeb4" target="_blank" rel="noopener noreferrer">LOWER 函数</a></td>
<td>将文本转换为小写</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/upper-%E5%87%BD%E6%95%B0-c11f29b3-d1a3-4537-8df6-04d0049963d6" target="_blank" rel="noopener noreferrer">UPPER 函数</a></td>
<td>将文本转换为大写形式</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/proper-%E5%87%BD%E6%95%B0-52a5a283-e8b2-49be-8506-b2887b889f94" target="_blank" rel="noopener noreferrer">PROPER 函数</a></td>
<td>将文本值的每个字的首字母大写</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/phonetic-%E5%87%BD%E6%95%B0-9a329dac-0c0f-42f8-9a55-639086988554" target="_blank" rel="noopener noreferrer">PHONETIC 函数</a></td>
<td>提取文本字符串中的拼音（汉字注音）字符</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/replace%E3%80%81replaceb-%E5%87%BD%E6%95%B0-8d799074-2425-4a8a-84bc-82472868878a" target="_blank" rel="noopener noreferrer">REPLACE、REPLACEB 函数</a></td>
<td>替换文本中的字符</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/search%E3%80%81searchb-%E5%87%BD%E6%95%B0-9ab04538-0e55-4719-a72e-b6f54513b495" target="_blank" rel="noopener noreferrer">SEARCH、SEARCHB 函数</a></td>
<td>在一个文本值中查找另一个文本值（不区分大小写）</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/text-%E5%87%BD%E6%95%B0-20d5ac4d-7b94-49fd-bb38-93d29371225c" target="_blank" rel="noopener noreferrer">TEXT 函数</a></td>
<td>设置数字格式并将其转换为文本</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/textjoin-%E5%87%BD%E6%95%B0-357b449a-ec91-49d0-80c3-0e8fc845691c" target="_blank" rel="noopener noreferrer">TEXTJOIN 函数</a></td>
<td>将多个区域和/或字符串的文本组合起来，并包括你在要组合的<br />各文本值之间指定的分隔符。 如果分隔符是空的文本字符串，<br />则此函数将有效连接这些区域。</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/substitute-%E5%87%BD%E6%95%B0-6434944e-a904-4336-a9b0-1e58df3bc332" target="_blank" rel="noopener noreferrer">SUBSTITUTE 函数</a></td>
<td>在文本字符串中用新文本替换旧文本</td>
</tr>
</tbody>
</table>
<h2 id="数学函数"> 数学函数</h2>
<table>
<thead>
<tr>
<th>函数</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/abs-%E5%87%BD%E6%95%B0-3420200f-5628-4e8c-99da-c99d7c87713c" target="_blank" rel="noopener noreferrer">ABS 函数</a></td>
<td>返回数字的绝对值</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/int-%E5%87%BD%E6%95%B0-a6c4af9e-356d-4369-ab6a-cb1fd9d343ef" target="_blank" rel="noopener noreferrer">INT 函数</a></td>
<td>将数字向下舍入到最接近的整数</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/mod-%E5%87%BD%E6%95%B0-9b6cd169-b6ee-406a-a97b-edf2a9dc24f3" target="_blank" rel="noopener noreferrer">MOD 函数</a></td>
<td>返回除法的余数</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/pi-%E5%87%BD%E6%95%B0-264199d0-a3ba-46b8-975a-c4a04608989b" target="_blank" rel="noopener noreferrer">PI 函数</a></td>
<td>返回 pi 的值</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/rand-%E5%87%BD%E6%95%B0-4cbfa695-8869-4788-8d90-021ea9f5be73" target="_blank" rel="noopener noreferrer">RAND 函数</a></td>
<td>返回 0 和 1 之间的一个随机数</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/randbetween-%E5%87%BD%E6%95%B0-4cc7f0d1-87dc-4eb7-987f-a469ab381685" target="_blank" rel="noopener noreferrer">RANDBETWEEN 函数</a></td>
<td>返回位于两个指定数之间的一个随机数</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/round-%E5%87%BD%E6%95%B0-c018c5d8-40fb-4053-90b1-b3e7f61a213c" target="_blank" rel="noopener noreferrer">ROUND 函数</a></td>
<td>将数字按指定位数舍入</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/rounddown-%E5%87%BD%E6%95%B0-2ec94c73-241f-4b01-8c6f-17e6d7968f53" target="_blank" rel="noopener noreferrer">ROUNDDOWN 函数</a></td>
<td>向绝对值减小的方向舍入数字</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/roundup-%E5%87%BD%E6%95%B0-f8bc9b23-e795-47db-8703-db171d0c42a7" target="_blank" rel="noopener noreferrer">ROUNDUP 函数</a></td>
<td>向绝对值增大的方向舍入数字</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/sum-%E5%87%BD%E6%95%B0-043e1c7d-7726-4e80-8f32-07b23e057f89" target="_blank" rel="noopener noreferrer">SUM 函数</a></td>
<td>求参数的和</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/sumif-%E5%87%BD%E6%95%B0-169b8c99-c05c-4483-a712-1697a653039b" target="_blank" rel="noopener noreferrer">SUMIF 函数</a></td>
<td>按给定条件对指定单元格求和</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/sumifs-%E5%87%BD%E6%95%B0-c9e748f5-7ea7-455d-9406-611cebce642b" target="_blank" rel="noopener noreferrer">SUMIFS 函数</a></td>
<td>在区域中添加满足多个条件的单元格</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/sumproduct-%E5%87%BD%E6%95%B0-16753e75-9f68-4874-94ac-4d2145a2fd2e" target="_blank" rel="noopener noreferrer">SUMPRODUCT 函数</a></td>
<td>返回对应的数组元素的乘积和</td>
</tr>
</tbody>
</table>
<h2 id="查找引用函数"> 查找引用函数</h2>
<table>
<thead>
<tr>
<th>函数</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/address-%E5%87%BD%E6%95%B0-d0c26c0d-3991-446b-8de4-ab46431d4f89" target="_blank" rel="noopener noreferrer">ADDRESS 函数</a></td>
<td>以文本形式将引用值返回到工作表的单个单元格</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/choose-%E5%87%BD%E6%95%B0-fc5c184f-cb62-4ec7-a46e-38653b98f5bc" target="_blank" rel="noopener noreferrer">CHOOSE 函数</a></td>
<td>从值的列表中选择值</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/filter-%E5%87%BD%E6%95%B0-f4f7cb66-82eb-4767-8f7c-4877ad80c759" target="_blank" rel="noopener noreferrer">FILTER 函数</a></td>
<td>FILTER 函数可以基于定义的条件筛选一系列数据。</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/index-%E5%87%BD%E6%95%B0-a5dcf0dd-996d-40a4-a822-b56b061328bd" target="_blank" rel="noopener noreferrer">INDEX 函数</a></td>
<td>使用索引从引用或数组中选择值</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/indirect-%E5%87%BD%E6%95%B0-474b3a3a-8a26-4f44-b491-92b6306fa261" target="_blank" rel="noopener noreferrer">INDIRECT 函数</a></td>
<td>返回由文本值指定的引用</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/lookup-%E5%87%BD%E6%95%B0-446d94af-663b-451d-8251-369d5e3864cb" target="_blank" rel="noopener noreferrer">LOOKUP 函数</a></td>
<td>在向量或数组中查找值</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/vlookup-%E5%87%BD%E6%95%B0-0bbc8083-26fe-4963-8ab8-93a18ad188a1" target="_blank" rel="noopener noreferrer">VLOOKUP 函数</a></td>
<td>在数组第一列中查找，然后在行之间移动以返回单元格的值</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/match-%E5%87%BD%E6%95%B0-e8dffd45-c762-47d6-bf89-533f4a37673a" target="_blank" rel="noopener noreferrer">MATCH 函数</a></td>
<td>在引用或数组中查找值</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/offset-%E5%87%BD%E6%95%B0-c8de19ae-dd79-4b9b-a14e-b4d906d11b66" target="_blank" rel="noopener noreferrer">OFFSET 函数</a></td>
<td>从给定引用中返回引用偏移量</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/sort-%E5%87%BD%E6%95%B0-22f63bd0-ccc8-492f-953d-c20e8e44b86c" target="_blank" rel="noopener noreferrer">SORT 函数</a></td>
<td>对区域或数组的内容进行排序</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/row-%E5%87%BD%E6%95%B0-3a63b74a-c4d0-4093-b49a-e76eb49a6d8d" target="_blank" rel="noopener noreferrer">ROW 函数</a></td>
<td>返回引用的行号</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/rows-%E5%87%BD%E6%95%B0-b592593e-3fc2-47f2-bec1-bda493811597" target="_blank" rel="noopener noreferrer">ROWS 函数</a></td>
<td>返回引用中的行数</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/column-%E5%87%BD%E6%95%B0-44e8c754-711c-4df3-9da4-47a55042554b" target="_blank" rel="noopener noreferrer">COLUMN 函数</a></td>
<td>返回引用的列号</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/columns-%E5%87%BD%E6%95%B0-4e8e7b4e-e603-43e8-b177-956088fa48ca" target="_blank" rel="noopener noreferrer">COLUMNS 函数</a></td>
<td>返回引用中包含的列数</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/transpose-%E5%87%BD%E6%95%B0-ed039415-ed8a-4a81-93e9-4b6dfac76027" target="_blank" rel="noopener noreferrer">TRANSPOSE 函数</a></td>
<td>返回数组的转置</td>
</tr>
</tbody>
</table>
<h2 id="日期时间函数"> 日期时间函数</h2>
<table>
<thead>
<tr>
<th>函数</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/date-%E5%87%BD%E6%95%B0-e36c0c8c-4104-49da-ab83-82328b832349" target="_blank" rel="noopener noreferrer">DATE 函数</a></td>
<td>返回特定日期的序列号</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/year-%E5%87%BD%E6%95%B0-c64f017a-1354-490d-981f-578e8ec8d3b9" target="_blank" rel="noopener noreferrer">YEAR 函数</a></td>
<td>将序列号转换为年</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/month-%E5%87%BD%E6%95%B0-579a2881-199b-48b2-ab90-ddba0eba86e8" target="_blank" rel="noopener noreferrer">MONTH 函数</a></td>
<td>将序列号转换为月</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/day-%E5%87%BD%E6%95%B0-8a7d1cbb-6c7d-4ba1-8aea-25c134d03101" target="_blank" rel="noopener noreferrer">DAY 函数</a></td>
<td>将序列号转换为月份日期</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/time-%E5%87%BD%E6%95%B0-9a5aff99-8f7d-4611-845e-747d0b8d5457" target="_blank" rel="noopener noreferrer">TIME 函数</a></td>
<td>返回特定时间的序列号</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/hour-%E5%87%BD%E6%95%B0-a3afa879-86cb-4339-b1b5-2dd2d7310ac7" target="_blank" rel="noopener noreferrer">HOUR 函数</a></td>
<td>将序列号转换为小时</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/minute-%E5%87%BD%E6%95%B0-af728df0-05c4-4b07-9eed-a84801a60589" target="_blank" rel="noopener noreferrer">MINUTE 函数</a></td>
<td>将序列号转换为分钟</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/second-%E5%87%BD%E6%95%B0-740d1cfc-553c-4099-b668-80eaa24e8af1" target="_blank" rel="noopener noreferrer">SECOND 函数</a></td>
<td>将序列号转换为秒</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/today-%E5%87%BD%E6%95%B0-5eb3078d-a82c-4736-8930-2f51a028fdd9" target="_blank" rel="noopener noreferrer">TODAY 函数</a></td>
<td>返回今天日期的序列号</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/now-%E5%87%BD%E6%95%B0-3337fd29-145a-4347-b2e6-20c904739c46" target="_blank" rel="noopener noreferrer">NOW 函数</a></td>
<td>返回当前日期和时间的序列号</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/weekday-%E5%87%BD%E6%95%B0-60e44483-2ed1-439f-8bd0-e404c190949a" target="_blank" rel="noopener noreferrer">WEEKDAY 函数</a></td>
<td>将序列号转换为星期日期</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/weeknum-%E5%87%BD%E6%95%B0-e5c43a03-b4ab-426c-b411-b18c13c75340" target="_blank" rel="noopener noreferrer">WEEKNUM 函数</a></td>
<td>将序列号转换为代表该星期为一年中第几周的数字</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/datedif-%E5%87%BD%E6%95%B0-25dba1a4-2812-480b-84dd-8b32a451b35c" target="_blank" rel="noopener noreferrer">DATEDIF 函数</a></td>
<td>计算两个日期之间的天数、月数或年数。 此函数在用于计算年龄的公式中很有用。</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/days-%E5%87%BD%E6%95%B0-57740535-d549-4395-8728-0f07bff0b9df" target="_blank" rel="noopener noreferrer">DAYS 函数</a></td>
<td>返回两个日期之间的天数</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/edate-%E5%87%BD%E6%95%B0-3c920eb2-6e66-44e7-a1f5-753ae47ee4f5" target="_blank" rel="noopener noreferrer">EDATE 函数</a></td>
<td>返回用于表示开始日期之前或之后月数的日期的序列号</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/eomonth-%E5%87%BD%E6%95%B0-7314ffa1-2bc9-4005-9d66-f49db127d628" target="_blank" rel="noopener noreferrer">EOMONTH 函数</a></td>
<td>返回指定月数之前或之后的月份的最后一天的序列号</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/networkdays-%E5%87%BD%E6%95%B0-48e717bf-a7a3-495f-969e-5005e3eb18e7" target="_blank" rel="noopener noreferrer">NETWORKDAYS 函数</a></td>
<td>返回两个日期间的完整工作日的天数</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/networkdays-intl-%E5%87%BD%E6%95%B0-a9b26239-4f20-46a1-9ab8-4e925bfd5e28" target="_blank" rel="noopener noreferrer">NETWORKDAYS.INTL 函数</a></td>
<td>返回两个日期之间的完整工作日的天数（使用参数指明周末有几天并指明是哪几天）</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/workday-%E5%87%BD%E6%95%B0-f764a5b7-05fc-4494-9486-60d494efbf33" target="_blank" rel="noopener noreferrer">WORKDAY 函数</a></td>
<td>返回指定的若干个工作日之前或之后的日期的序列号</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/workday-intl-%E5%87%BD%E6%95%B0-a378391c-9ba7-4678-8a39-39611a9bf81d" target="_blank" rel="noopener noreferrer">WORKDAY.INTL 函数</a></td>
<td>返回日期在指定的工作日天数之前或之后的序列号（使用参数指明周末有几天并指明是哪几天）</td>
</tr>
</tbody>
</table>
<h2 id="信息函数"> 信息函数</h2>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/cell-%E5%87%BD%E6%95%B0-51bd39a5-f338-4dbe-a33f-955d67c2b2cf" target="_blank" rel="noopener noreferrer">CELL 函数</a></td>
<td>返回有关单元格格式、位置或内容的信息</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/is-%E5%87%BD%E6%95%B0-0f2d7971-6019-40a0-a171-f2d869135665" target="_blank" rel="noopener noreferrer">ISBLANK 函数</a></td>
<td>如果值为空，则返回 TRUE</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/is-%E5%87%BD%E6%95%B0-0f2d7971-6019-40a0-a171-f2d869135665" target="_blank" rel="noopener noreferrer">ISERR 函数</a></td>
<td>如果值为除 #N/A 以外的任何错误值，则返回 TRUE</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/is-%E5%87%BD%E6%95%B0-0f2d7971-6019-40a0-a171-f2d869135665" target="_blank" rel="noopener noreferrer">ISERROR 函数</a></td>
<td>如果值为任何错误值，则返回 TRUE</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/iseven-%E5%87%BD%E6%95%B0-aa15929a-d77b-4fbb-92f4-2f479af55356" target="_blank" rel="noopener noreferrer">ISEVEN 函数</a></td>
<td>如果数字为偶数，则返回 TRUE</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/is-%E5%87%BD%E6%95%B0-0f2d7971-6019-40a0-a171-f2d869135665" target="_blank" rel="noopener noreferrer">ISODD 函数</a></td>
<td>如果数字为奇数，则返回 TRUE</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/is-%E5%87%BD%E6%95%B0-0f2d7971-6019-40a0-a171-f2d869135665" target="_blank" rel="noopener noreferrer">ISLOGICAL 函数</a></td>
<td>如果值为逻辑值，则返回 TRUE</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/is-%E5%87%BD%E6%95%B0-0f2d7971-6019-40a0-a171-f2d869135665" target="_blank" rel="noopener noreferrer">ISNA 函数</a></td>
<td>如果值为错误值 #N/A，则返回 TRUE</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/is-%E5%87%BD%E6%95%B0-0f2d7971-6019-40a0-a171-f2d869135665" target="_blank" rel="noopener noreferrer">ISNUMBER 函数</a></td>
<td>如果值为数字，则返回 TRUE</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/is-%E5%87%BD%E6%95%B0-0f2d7971-6019-40a0-a171-f2d869135665" target="_blank" rel="noopener noreferrer">ISTEXT 函数</a></td>
<td>如果值为文本，则返回 TRUE</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/n-%E5%87%BD%E6%95%B0-a624cad1-3635-4208-b54a-29733d1278c9" target="_blank" rel="noopener noreferrer">N 函数</a></td>
<td>返回转换为数字的值</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/t-%E5%87%BD%E6%95%B0-fb83aeec-45e7-4924-af95-53e073541228" target="_blank" rel="noopener noreferrer">T 函数</a></td>
<td>将参数转换为文本</td>
</tr>
<tr>
<td><a href="https://support.microsoft.com/zh-cn/office/type-%E5%87%BD%E6%95%B0-45b4e688-4bc3-48b3-a105-ffa892995899" target="_blank" rel="noopener noreferrer">TYPE 函数</a></td>
<td>返回表示值的数据类型的数字</td>
</tr>
</tbody>
</table>
<p>更多的函数分类及其详细用法，请参考<a href="https://support.microsoft.com/zh-cn/office/excel-%E5%87%BD%E6%95%B0%EF%BC%88%E6%8C%89%E7%B1%BB%E5%88%AB%E5%88%97%E5%87%BA%EF%BC%89-5f91f4e9-7b42-46d2-9bd1-63f26a86c0eb" target="_blank" rel="noopener noreferrer">官方文档</a></p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-07-02T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">VBA 之 Range 对象</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Excel/03.VBA_Range/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Excel/03.VBA_Range/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>Range 对象是 Excel 应用程序中最常用的对象，一个 Range 对象代表一个单元格、一行、一列、包含一个或者更多单元格区域（可以是连续的单元格，也可以是不连续的单元格）中选定的单元格，甚至是多个工作表上的一组单元格，在操作 Excel 内的任何区域之前都需要将其表示为一个 Range 对象，然后使用该 Range 对象的方法和属性。</p>
<h2 id="_1、单元格的引用方法"> 1、单元格的引用方法</h2>
<p>在 VBA 中经常需要引用单元格或单元格区域区域，主要有以下几种方法。</p>
<h3 id="_1-使用-range-属性"> 1）使用 Range 属性</h3>
<p>VBA 中可以使用 Range 属性返回单元格或单元格区域，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> RngSelect<span>(</span><span>)</span> 
	Sheet1<span>.</span>Range<span>(</span><span>"A3:F6, B1:C5"</span><span>)</span><span>.</span><span>Select</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>RngSelect 过程使用 Select 方法选中 <code>A3:F6, B1:C5</code> 单元格区域。</p>
<p>Range 属性返回一个 Range 对象，该对象代表一个单元格或单元格区域，语法如下：</p>
<div><pre><code>Range<span>(</span>Cell1<span>,</span> Cell2<span>)</span>

参数Cell1是必需的，必须为 A1 样式引用的宏语言，可包括区域操作符（冒号）、相交区域操作符（空格）或合并区域操作符（逗号）。也可包括美元符号（即绝对地址，如<span>“$A$1”</span>）。
参数Cell2是可选的，区域左上角和右下角的单元格。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>运行 Sub RngSelect 过程，选中 <code>A3:F6, B1:C5</code> 单元格区域，如图 1-1 所示。</p>
<div>
<p><img src="./assets/1-1.png" alt="" loading="lazy"></p>
<p><u>图 1-1</u>	使用 Range 属性引用单元格区域</p>
</div>
<h3 id="_2-使用-cells-属性"> 2）使用 Cells 属性</h3>
<p>使用 Cells 属性返回一个 Range 对象，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> Cell<span>(</span><span>)</span>
	<span>Dim</span> icell <span>As</span> <span>Integer</span>
	<span>For</span> icell <span>=</span> <span>1</span> <span>To</span> <span>100</span>
		Sheet2<span>.</span>Cells<span>(</span>icell<span>,</span> <span>1</span><span>)</span><span>.</span>Value <span>=</span> icell
	<span>Next</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>代码解析：</p>
<p>Cell 过程使用 For...Next 语句为工作表中的 <code>A1:A100</code> 单元格区域填入序号。</p>
<p>Cells 属性指定单元格区域中的单元格，语法如下：</p>
<div><pre><code>Cells<span>(</span>RowIndex<span>,</span> ColumnIndex<span>)</span>

参数RowIndex是可选的，表示引用区域中的行序号。
参数ColumnIndex是可选的，表示引用区域中的列序号。当然也可以用列的名称，如Cells<span>(</span><span>2</span><span>,</span><span>"B"</span><span>)</span>代表B2单元格
如果缺省参数，Cells属性返回引用对象的所有单元格。

Cells属性的参数可以使用变量，因此经常应用于在单元格区域中循环。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="_3-使用快捷记号"> 3）使用快捷记号</h3>
<p>在 VBA 中可以将 <code>A1</code> 引用样式或命名区域名称使用方括号括起来，作为 Range 属性的快捷方式，这样就不必键入单词“Range”或使用引号，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> Fastmark<span>(</span><span>)</span>
	[A1：A5] <span>=</span> <span>2</span>
	[C8] <span>=</span> <span>4</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>代码解析：</p>
<p>Fastmark 过程使用快捷记号为单元格区域赋值。</p>
<p>第 2 行代码使用快捷记号将活动工作表中的 <code>A1:A5</code> 单元格赋值为 2。</p>
<p>第 3 行代码使用快捷记号将活动工作表中的 <code>C8</code> 单元格赋值为 4。</p>
<h3 id="_4-使用-offset-属性"> 4）使用 Offset 属性</h3>
<p>可以使用 Range 对象的 Offset 属性返回一个基于引用的 Range 对象的单元格区域，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> Offset<span>(</span><span>)</span>
	Sheet3<span>.</span>Range<span>(</span><span>"A1:C3"</span><span>)</span><span>.</span>Offset<span>(</span><span>3</span><span>,</span> <span>3</span><span>)</span><span>.</span><span>Select</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>Offset 过程使用 Range 对象的 Offset 属性选中 <code>A1:A3</code> 单元格偏移三行三列后的区域。</p>
<p>应用于 Range 对象的 Offset 属性的语法如下：</p>
<div><pre><code>expression<span>.</span>Offset<span>(</span>RowOffset<span>,</span> ColumnOffset<span>)</span>

参数expression是必需的，该表达式返回一个Range对象。
参数RowOffset是可选的，区域偏移的行数（正值、负值或 <span>0</span>（零））。正值表示向下偏移，负值表示向上偏移，默认值为 <span>0</span>。
参数ColumnOffset是可选的，区域偏移的列数（正值、负值或 <span>0</span>（零））。正值表示向右偏移，负值表示向左偏移，默认值为 <span>0</span>。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>运行 Offset 过程，选中 <code>A1:A3</code> 单元格偏称三行三列后的区域，如图 1-2 所示。</p>
<div>
<p><img src="./assets/1-2.png" alt="" loading="lazy"></p>
<p><u>图 1-2</u>	使用 Range 对象的 Offset 属性</p>
</div>
<h3 id="_5-使用-resize-属性"> 5）使用 Resize 属性</h3>
<p>用 Range 对象的 Resize 属性调整指定区域的大小，并返回调整大小后的单元格区域，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> Resize<span>(</span><span>)</span>
	Sheet4<span>.</span>Range<span>(</span><span>"A1"</span><span>)</span><span>.</span>Resize<span>(</span><span>3</span><span>,</span> <span>3</span><span>)</span><span>.</span><span>Select</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>Resize 过程使用 Range 对象的 Resize 属性选中 <code>A1</code> 单元格扩展为三行三列后的区域。</p>
<p>Resize 属性的语法如下：</p>
<div><pre><code>expression<span>.</span>Resize<span>(</span>RowSize<span>,</span> ColumnSize<span>)</span>

参数expression是必需的，返回要调整大小的Range 对象
参数RowSize是可选的，新区域中的行数。如果省略该参数，则该区域中的行数保持不变。
参数ColumnSize是可选的，新区域中的列数。如果省略该参数。则该区域中的列数保持不变。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>运行 Resize 过程，选中 <code>A1</code> 单元格扩展为三行三列后的区域，如图 1-3 所示。</p>
<div>
<p><img src="./assets/1-3.png" alt="" loading="lazy"></p>
<p><u>图 1-3</u>	使用 Resize 属性调整区域大小</p>
</div>
<h3 id="_6-使用-union-方法"> 6）使用 Union 方法</h3>
<p>使用 Union 方法可以将多个非连续区域连接起来成为一个区域，从而可以实现对多个非连续区域一起进行操作，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> UnSelect<span>(</span><span>)</span>
	Union<span>(</span>Sheet5<span>.</span>Range<span>(</span><span>"A1:D4"</span><span>)</span><span>,</span> Sheet5<span>.</span>Range<span>(</span><span>"E5:H8"</span><span>)</span><span>)</span><span>.</span><span>Select</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>UnSelect 过程选择单元格 <code>A1:D4</code> 和 <code>E5:H8</code> 所组成的区域。Union 方法返回两个或多个区域的合并区域，语法如下：</p>
<div><pre><code>expression<span>.</span>Union<span>(</span>Arg1<span>,</span> Arg2<span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span>
    
其中参数expression是可选的，返回一个Application对象。
参数Arg1<span>,</span> Arg2<span>,</span> <span>.</span><span>.</span><span>.</span>是必需的，至少指定两个Range对象。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>运行 UnSelect 过程，选中单元格 <code>A1:D4</code> 和 <code>E5:H8</code> 所组成的区域，如图 1-4 所示。</p>
<div>
<p><img src="./assets/1-4.png" alt="" loading="lazy"></p>
<p><u>图 1-4</u>	使用 Union 方法将多个非连续区域连接成一个区域</p>
</div>
<h3 id="_7-使用-usedrange-属性"> 7）使用 UsedRange 属性</h3>
<p>使用 UsedRange 属性返回指定工作表上已使用单元格组成的区域，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> UseSelect<span>(</span><span>)</span>
	Sheet6<span>.</span>UsedRange<span>.</span><span>Select</span>
<span>End</span> Su
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>UseSelect 过程使用 UsedRange 属性选择工作表上已使用单元格组成的区域，包括空单元格。如工作表中已使用 <code>A1</code> 单元格和 <code>D8</code> 单元格，运行 UseSelect过程将选择 <code>A1</code> 到 <code>D8</code> 单元格区域，如图 1-5 所示。</p>
<div>
<p><img src="./assets/1-5.png" alt="" loading="lazy"></p>
<p><u>图 1-5</u>	使用 UsedRange 属性选择已使用区域</p>
</div>
<h3 id="_8-使用-currentregion-属性"> 8）使用 CurrentRegion 属性</h3>
<p>使用 CurrentRegion 属性返回指定工作表上当前的区域，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> CurrentSelect<span>(</span><span>)</span>
	Sheet7<span>.</span>Range<span>(</span><span>"A5"</span><span>)</span><span>.</span>CurrentRegion<span>.</span><span>Select</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>CurrentSelect 过程使用 CurrentRegion 属性选择工作表上 <code>A5</code> 单元格当前的区域，当前区域是一个边缘是任意空行和空列组合成的范围。</p>
<p>运行 CurrentSelect 过程将选择 <code>A5</code> 到 <code>B6</code> 单元格区域，如图 1-6 所示。</p>
<div>
<p><img src="./assets/1-6.png" alt="" loading="lazy"></p>
<p><u>图 1-6</u>	CurrentRegion 属性选择当前的区域</p>
</div>
<h2 id="_2、选定单元格区域的方法"> 2、选定单元格区域的方法</h2>
<h3 id="_1-使用-select-方法"> 1）使用 Select 方法</h3>
<p>在 VBA 中一般使用 Select 方法选定单元格或单元格区域，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> RngSelect<span>(</span><span>)</span>
	Sheet3<span>.</span>Activate
	Sheet3<span>.</span>Range<span>(</span><span>"A1：B10"</span><span>)</span><span>.</span><span>Select</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>代码解析：</p>
<p>RngSelect 过程使用 Select 方法选定 Sheet3 中的 <code>A1:B10</code> 单元格区域，Select 方法应用于 Range 对象时语法如下：</p>
<div><pre><code>expression<span>.</span><span>Select</span><span>(</span>Replace<span>)</span>

参数expression是必需的，一个有效的对象。
参数Replace是可选的，要替换的对象。
使用<span>Select</span>方法选定单元格时，单元格所在的工作表必需为活动工作表
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>所以在第 2 行代码中先使用 Activate 方法使 Sheet3 成为活动工作表，否则 Select 方法有可能出错，显示如图 2-1 所示的错误提示。</p>
<div>
<p><img src="./assets/2-1.png" alt="" loading="lazy"></p>
<p><u>图 2-1</u>	Select 方法无效提示</p>
</div>
<h3 id="_2-使用-activate-方法"> 2）使用 Activate 方法</h3>
<p>还可以使用 Activate 方法选定单元格或单元格区域，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> RngActivate<span>(</span><span>)</span>
	Sheet3<span>.</span>Activate
	Sheet3<span>.</span>Range<span>(</span><span>"A1:B10"</span><span>)</span><span>.</span>Activate
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>代码解析：</p>
<p>RngActivate 过程使用 Activate 方法选定 Sheet3 中的 <code>A1:B10</code> 单元格区域，Activate 方法应用于 Range 对象时语法如下：</p>
<div><pre><code>expression<span>.</span>Activate
</code></pre>
<div><span>1</span><br></div></div><p>使用 Activate 方法选定单元格时，单元格所在的工作表也必需为活动工作表，否则 Activate 方法有可能出错</p>
<div>
<p><img src="./assets/2-2.png" alt="" loading="lazy"></p>
<p><u>图 2-2</u>	Activate 方法无效提示</p>
</div>
<h3 id="_3-使用-goto-方法"> 3）使用 Goto 方法</h3>
<p>使用 Goto 方法无需使单元格所在的工作表成为活动工作表，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> RngGoto<span>(</span><span>)</span>
	Application<span>.</span><span>Goto</span> Reference<span>:</span><span>=</span>Sheet3<span>.</span>Range<span>(</span><span>"A1:B10"</span><span>)</span><span>,</span> scroll<span>:</span><span>=</span><span>True</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>RngGoto 过程使用 Goto 方法选定 Sheet3 中的 <code>A1:B10</code> 单元格区域，并滚动工作表以显示该单元格。</p>
<p>Goto 方法选定任意工作簿中的任意区域或任意 Visual Basic 过程，并且如果该工作簿未处于活动状态，就激活该工作簿，语法如下：</p>
<div><pre><code>expression<span>.</span><span>Goto</span><span>(</span>Reference<span>,</span> Scroll<span>)</span>

参数expression是必需的，返回一个Application对象。
参数Reference是可选的，<span>Variant</span>类型，指定目标。可以是Range对象、包含R1C1样式记号的单元格引用的字符串或包含Visual Basic过程名的字符串。如果省略本参数，目标将是最近一次用<span>Goto</span>方法选定的区域。
参数Scroll是可选的，<span>Variant</span>类型，如果该值为<span>True</span>，则滚动窗口直至目标区域的左上角单元格出现在窗口的左上角。如果该值为<span>False</span>，则不滚动窗口。默认值为<span>False</span>。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="_3、获得行、列中的最后一个非空单元格"> 3、获得行、列中的最后一个非空单元格</h2>
<p>使用 VBA 对工作表进行操作时，经常需要定位到指定行或列中最后一个非空单元格，此时可以使用 Range 对象的 End 属性，在取得单元格对象后便能获得该单元格的相关属性，如单元格地址、行列号、数值等，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> LastRow<span>(</span><span>)</span>
	<span>Dim</span> rng <span>As</span> Range
	<span>Set</span> rng <span>=</span> Sheet1<span>.</span>Range<span>(</span><span>"A65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span>
	MsgBox <span>"A列中最后一个非空单元格是"</span> <span>&amp;</span> rng<span>.</span>Address<span>(</span><span>0</span><span>,</span> <span>0</span><span>)</span> <span>&amp;</span> <span>",行号"</span> <span>&amp;</span> rng<span>.</span>Row <span>&amp;</span> <span>",数值"</span> <span>&amp;</span> rng<span>.</span>Value
	<span>Set</span> rng <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>代码解析：</p>
<p>LastRow 过程使用消息框显示工作表中 A 列最后非空单元格的地址、行号和数值。</p>
<p>End 属性返回一个 Range 对象，该对象代表包含源区域的区域尾端的单元格。等同于按键 <kbd>End</kbd>+<kbd>↑</kbd> 、 <kbd>End</kbd>+<kbd>↓</kbd> 、 <kbd>End</kbd>+<kbd>←</kbd> 或 <kbd>End</kbd>+<kbd>→</kbd>，语法如下：</p>
<div><pre><code>expression<span>.</span><span>End</span><span>(</span>Direction<span>)</span>

参数expression是必需的，一个有效的对象。
参数Direction是可选的，所要移动的方向，可以为表格<span>3</span><span>-</span><span>1</span>所示的XlDirection常量之一。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><u>表格 3-1</u>	XlDirection 常量</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值（非官方数值）</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>xlToLeft</td>
<td>-4159（1）</td>
<td>向左</td>
</tr>
<tr>
<td>xlToRight</td>
<td>-4161（2）</td>
<td>向右</td>
</tr>
<tr>
<td>xlUp</td>
<td>-4162（3）</td>
<td>向上</td>
</tr>
<tr>
<td>xlDown</td>
<td>-4121（4）</td>
<td>向下</td>
</tr>
</tbody>
</table>
<p>Range 对象的 End 属性返回的是一个 Range 对象，因此可以直接使用该对象的属性和方法。</p>
<p>运行 LastRow 过程结果如图 3-1 所示。</p>
<div>
<p><img src="./assets/3-1.png" alt="" loading="lazy"></p>
<p><u>图 3-1</u>	获得 A 列最后一个非空单元格</p>
</div>
<h2 id="_4、定位单元格"> 4、定位单元格</h2>
<p>在 Excel 中使用定位对话框可以选中工作表中特定的单元格区域，而在 VBA 中则使用 SpecialCells 方法，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> SpecialAddress<span>(</span><span>)</span>
	<span>Dim</span> rng <span>As</span> Range
	<span>Set</span> rng <span>=</span> Sheet1<span>.</span>UsedRange<span>.</span>SpecialCells<span>(</span>xlCellTypeFormulas<span>)</span>
	rng<span>.</span><span>Select</span>
	MsgBox <span>"工作表中有公式的单元格为： "</span> <span>&amp;</span> rng<span>.</span>Address
	<span>Set</span> rng <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>SpecialAddress 过程使用 SpecialCells 方法选中工作表中有公式的单元格，并用消息框显示其地址。</p>
<p>SpecialCells 方法返回一个 Range 对象，该对象代表与指定类型及值相匹配的所有单元格，语法如下：</p>
<div><pre><code>expression<span>.</span>SpecialCells<span>(</span><span>Type</span><span>,</span> Value<span>)</span>

参数expression是必需的，返回一个有效的对象。
参数<span>Type</span>是必需的，要包含的单元格，可为表格<span>4</span><span>-</span><span>1</span>所列的XlCellType常量之一。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><u>表格 4-1</u>	XlCellType 常量</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>xlCellTypeAllFormatConditions</td>
<td>-4172</td>
<td>任意格式单元格</td>
</tr>
<tr>
<td>xlCellTypeAllValidation</td>
<td>-4174</td>
<td>含有验证条件的单元格</td>
</tr>
<tr>
<td>xlCellTypeBlanks</td>
<td>4</td>
<td>空单元格</td>
</tr>
<tr>
<td>xlCellTypeComments</td>
<td>-4144</td>
<td>含有注释的单元格</td>
</tr>
<tr>
<td>xlCellTypeConstants</td>
<td>2</td>
<td>含有常量的单元格</td>
</tr>
<tr>
<td>xlCellTypeFormulas</td>
<td>-4123</td>
<td>含有公式的单元格</td>
</tr>
<tr>
<td>xlCellTypeLastCell</td>
<td>11</td>
<td>使用区域中最后的单元格</td>
</tr>
<tr>
<td>xlCellTypeSameFormatConditions</td>
<td>-4173</td>
<td>含有相同格式的单元格</td>
</tr>
<tr>
<td>xlCellTypeSameValidation</td>
<td>-4175</td>
<td>含有相同验证条件的单元格</td>
</tr>
<tr>
<td>xlCellTypeVisible</td>
<td>12</td>
<td>所有可见单元格</td>
</tr>
</tbody>
</table>
<p>第 3 行代码将 SpecialCells 方法的 Type 参数设置为 xlCellTypeFormulas，返回的是含有公式的单元格，通过修改相应的参数可以返回不同的单元格。</p>
<p>参数 Value 是可选的，如果 Type 参数为 xlCellTypeConstants 或 xlCellTypeFormulas， 此参数可用于确定结果中应包含哪几类单元格。将某几个值相加可使此方法返回多种类型的单元格。如果省略将选定所有常量或公式，可为表格 4-2 所列的 XlSpecialCellsValue 常量之一。</p>
<p><u>表格 4-2</u> XlSpecialCellsValue 常量</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>xlErrors</td>
<td>16</td>
<td>错误</td>
</tr>
<tr>
<td>xlLogical</td>
<td>4</td>
<td>逻辑值</td>
</tr>
<tr>
<td>xlNumbers</td>
<td>1</td>
<td>数字</td>
</tr>
<tr>
<td>xlTextValues</td>
<td>2</td>
<td>文本</td>
</tr>
</tbody>
</table>
<p>第 5 行代码使用消息框显示工作表中含有公式单元格的地址。SpecialCells 方法返回的是 Range 对象，因此可以直接使用该对象的属性和方法。</p>
<p>运行 SpecialAddress 过程结果如图 4-1 所示。</p>
<div>
<p><img src="./assets/4-1.png" alt="" loading="lazy"></p>
<p><u>图 4-1</u>	SpecialCells 方法</p>
</div>
<h2 id="_5、查找单元格"> 5、查找单元格</h2>
<h3 id="_1-使用-find-方法"> 1）使用 Find 方法</h3>
<p>在 Excel 中使用查找对话框可以查找工作表中特定内容的单元格，而在 VBA 中则使用 Find 方法，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> RngFind<span>(</span><span>)</span>
	<span>Dim</span> StrFind <span>As</span> <span>String</span>
	<span>Dim</span> Rng <span>As</span> Range
	StrFind <span>=</span> InputBox<span>(</span><span>"请输入要查找的值:"</span><span>)</span>
	<span>If</span> Trim<span>(</span>StrFind<span>)</span> <span>&lt;</span><span>></span> <span>""</span> <span>Then</span>
		<span>With</span> Sheet1<span>.</span>Range<span>(</span><span>"A:A"</span><span>)</span>
			<span>Set</span> Rng <span>=</span> <span>.</span>Find<span>(</span>What<span>:</span><span>=</span>StrFind<span>,</span> <span>_</span>
			After<span>:</span><span>=</span><span>.</span>Cells<span>(</span><span>.</span>Cells<span>.</span>Count<span>)</span><span>,</span> <span>_</span>
			LookIn<span>:</span><span>=</span>xlValues<span>,</span> <span>_</span>
			LookAt<span>:</span><span>=</span>xlWhole<span>,</span> <span>_</span>
			SearchOrder<span>:</span><span>=</span>xlByRows<span>,</span> <span>_</span>
			SearchDirection<span>:</span><span>=</span>xlNext<span>,</span> <span>_</span>
			MatchCase<span>:</span><span>=</span><span>False</span><span>)</span>
			<span>If</span> <span>Not</span> Rng <span>Is</span> <span>Nothing</span> <span>Then</span>
				Application<span>.</span><span>Goto</span> Rng<span>,</span> <span>True</span>
			<span>Else</span>
				MsgBox <span>"没有找到该单元格!"</span>
			<span>End</span> <span>If</span>
		<span>End</span> <span>With</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>代码解析：</p>
<p>RngFind 过程使用 Find 方法在工作表 Sheet1 的 A 列中查找 InputBox 函数对话框中所输入的值，并查找该值所在的第一个单元格。</p>
<p>第 6 到第 13 行代码在工作表 Sheet1 的 A 列中查找 InputBox 函数对话框中所输入的值。应用于 Range 对象的 Find 方法在区域中查找特定信息，并返回 Range 对象，该对象代表用于查找信息的第一个单元格。如果未发现匹配单元格，就返回 Nothing，语法如下：</p>
<div><pre><code>expression<span>.</span>Find<span>(</span>What<span>,</span> After<span>,</span> LookIn<span>,</span> LookAt<span>,</span> SearchOrder<span>,</span> SearchDirection<span>,</span> MatchCase<span>,</span> MatchByte<span>,</span> SerchFormat<span>)</span>

参数expression是必需的，该表达式返回一个Range对象。
参数What是必需的，要搜索的数据，可为字符串或任意数据类型。
参数After是可选的，表示搜索过程将从其之后开始进行的单元格，必须是区域中的单个单元格。查找时是从该单元格之后开始的，直到本方法绕回到指定的单元格时，才对其进行搜索。如果未指定本参数，搜索将从区域的左上角单元格之后开始。
参数LookIn是可选的，信息类型。
参数LookAt是可选的，可为XlLookAt常量的xlWhole或xlPart之一。
参数SearchOrder是可选的，可为XlSearchOrder常量的xlByRows或lByColumns之一。
参数SearchDirection是可选的，搜索的方向，可为XlSearchDirection常量的xlNext或 xlPrevious之一。
参数MatchCase是可选的，若为<span>True</span>，则进行区分大小写的查找。默认值为<span>False</span>。
参数MatchByte是可选的，仅在选择或安装了双字节语言支持时使用。若为<span>True</span>，则双字节字符仅匹配双字节字符。若为<span>False</span>，则双字节字符可匹配其等价的单字节字符。
参数SerchFormat是可选的，搜索的格式。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>在本例中将 After 参数设置为 A 列的最后一个单元格，所以查找时从 A1 单元格开始搜索。</p>
<p>每次使用 Find 方法后，参数 LookIn、LookAt、SearchOrder 和 MatchByte 的设置将保存。如果下次调用 Find 方法时不指定这些参数的值，就使用保存的值。因此每次使用该方法时请明确设置这些参数。</p>
<p>如果工作表的 A 列中存在重复的数值，那么需要使用 FindNext 方法或 FindPrevious 方法进行重复搜索，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> RngFindNext<span>(</span><span>)</span>
	<span>Dim</span> StrFind <span>As</span> <span>String</span>
	<span>Dim</span> Rng <span>As</span> Range
	<span>Dim</span> FindAddress <span>As</span> <span>String</span>
	StrFind <span>=</span> InputBox<span>(</span><span>"请输入要查找的值:"</span><span>)</span>
	<span>If</span> Trim<span>(</span>StrFind<span>)</span> <span>&lt;</span><span>></span> <span>""</span> <span>Then</span>
		<span>With</span> Sheet1<span>.</span>Range<span>(</span><span>"A:A"</span><span>)</span>
			<span>Set</span> Rng <span>=</span> <span>.</span>Find<span>(</span>What<span>:</span><span>=</span>StrFind<span>,</span> <span>_</span>
				After<span>:</span><span>=</span><span>.</span>Cells<span>(</span><span>.</span>Cells<span>.</span>Count<span>)</span><span>,</span> <span>_</span>
				LookIn<span>:</span><span>=</span>xlValues<span>,</span> <span>_</span>
				LookAt<span>:</span><span>=</span>xlWhole<span>,</span> <span>_</span>
				SearchOrder<span>:</span><span>=</span>xlByRows<span>,</span> <span>_</span>
				SearchDirection<span>:</span><span>=</span>xlNext<span>,</span> <span>_</span>
				MatchCase<span>:</span><span>=</span><span>False</span><span>)</span>
			<span>If</span> <span>Not</span> Rng <span>Is</span> <span>Nothing</span> <span>Then</span>
				FindAddress <span>=</span> Rng<span>.</span>Address
				<span>Do</span>
					Rng<span>.</span>Interior<span>.</span>ColorIndex <span>=</span> <span>6</span>
					<span>Set</span> Rng <span>=</span> <span>.</span>FindNext<span>(</span>Rng<span>)</span>
				<span>Loop</span> <span>While</span> <span>Not</span> Rng <span>Is</span> <span>Nothing</span> <span>And</span> Rng<span>.</span>Address <span>&lt;</span><span>></span> FindAddress
			<span>End</span> <span>If</span>
		<span>End</span> <span>With</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>代码解析：</p>
<p>RngFindNext 过程在工作表 Sheet1 的 A 列中查找 InputBox 函数对话框中所输入的值，并将查到单元格底色设置成黄色。</p>
<p>第 8 行到第 17 行代码使用 Find 方法在工作表 Sheet1 的 A 列中查找。</p>
<p>第 16 行代码将查找到的第一个单元格地址赋给字符串变量 FindAddress。</p>
<p>第 18 行代码将查找到的单元格底色设置成黄色。</p>
<p>第 19 行代码使用 FindNext 方法进行重复搜索。FindNext 方法继续执行用 Find 方法启动的搜索。查找下一个匹配相同条件的单元格并返回代表单元格的 Range 对象，语法如下：</p>
<div><pre><code>expression<span>.</span>FindNext<span>(</span>After<span>)</span>

参数expression是必需的，返回一个Range对象。
参数After是可选的，指定一个单元格，查找将从该单元格之后开始。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第 20 行代码如果查找到的单元格地址等于字符串变量 FindAddress 所记录的地址，说明 A 列已搜索完毕，结束查找过程。</p>
<p>运行 RngFindNext 过程，在 InputBox 函数输入框中输入“196.01”后结果如图 5-1 所示。</p>
<div>
<p><img src="./assets/5-1.png" alt="" loading="lazy"></p>
<p><u>图 5-1</u>	使用 FindNext 方法重复搜索</p>
</div>
<p>还可以使用 FindPrevious 方法进行重复搜索，FindPrevious 方法的语法如下：</p>
<div><pre><code>expression<span>.</span>FindPrevious<span>(</span>After<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>FindPrevious 方法和 FindNext 方法唯一的区别是 FindPrevious 方法查找匹配相同条件的前一个单元格而 FindNext 方法是查找匹配相同条件的下一个单元格。</p>
<h3 id="_2-使用-like-运算符"> 2）使用 Like 运算符</h3>
<p>使用 Like 运算符可以进行更为复杂的模式匹配查找，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> RngLike<span>(</span><span>)</span>
	<span>Dim</span> rng <span>As</span> Range
	<span>Dim</span> a <span>As</span> <span>Integer</span>
	a <span>=</span> <span>1</span>
	<span>With</span> Sheet2
		<span>.</span>Range<span>(</span><span>"A:A"</span><span>)</span><span>.</span>ClearContents
		<span>For</span> <span>Each</span> rng <span>In</span> <span>.</span>Range<span>(</span><span>"B1:E1000"</span><span>)</span>
			<span>If</span> rng<span>.</span>Text <span>Like</span> <span>"*a*"</span> <span>Then</span>
				<span>.</span>Range<span>(</span><span>"A"</span> <span>&amp;</span> a<span>)</span> <span>=</span> rng<span>.</span>Text
				a <span>=</span> a <span>+</span> <span>1</span>
			<span>End</span> <span>If</span>
		<span>Next</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>代码解析：</p>
<p>RngLike 过程使用 For Each...Next 语句和 Like 运算符在单元格区域 <code>B1:E10000</code> 中搜索含有“a”字符的单元格，找到匹配单元格以后将单元格的值写入到 A 列中。</p>
<p>第 6 行代码使用 ClearContents 方法清除 A 列区域的数据。</p>
<p>第 7 行代码使用 For Each...Next 语句在单元格区域 <code>B1:E10000</code> 中循环。</p>
<p>第 8 行代码使用 Like 运算符在单元格区域 <code>B1:E10000</code> 中搜索含有“a”字符的单元格。</p>
<p>Like 运算符用来比较两个字符串，语法如下：</p>
<div><pre><code>result <span>=</span> <span>string</span> <span>Like</span> pattern

参数<span>string</span>是必需的，字符串表达式。
参数pattern是必需的，字符串表达式。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果 string 与 pattern 匹配，则 result 为 True；如果不匹配，则 result 为 False。但是如果 string 或 pattern 中有一个为 Null，则 result 为 Null。</p>
<p>参数 pattern 可以使用通配符、字符串列表或字符区间的任何组合来匹配字符串。表格 5-1 列出 pattern 中允许的字符以及它们与什么进行匹配。</p>
<p><u>表格 5-1</u>	pattern 中的匹配字符串</p>
<table>
<thead>
<tr>
<th>pattern中的字符</th>
<th>符合string中的字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>?</td>
<td>任何单一字符</td>
</tr>
<tr>
<td>*</td>
<td>零个或多个字符</td>
</tr>
<tr>
<td>#</td>
<td>任何一个数字 (0–9)</td>
</tr>
<tr>
<td>[charlist]</td>
<td>charlist中的任何单一字符</td>
</tr>
<tr>
<td>[!charlist]</td>
<td>不在charlist中的任何单一字符</td>
</tr>
</tbody>
</table>
<p>第 9 行代码将找到的匹配单元格的值写入到 A 列中。</p>
<p>运行 RngLike 过程结果如图 5-2 所示。</p>
<div>
<p><img src="./assets/5-2.png" alt="" loading="lazy"></p>
<p><u>图 5-2</u>	使用 Like 运算符进行模式匹配查找</p>
</div>
<h2 id="_6、替换单元格内字符串"> 6、替换单元格内字符串</h2>
<p>如果需要替换单元格内指定的字符串，那么使用 Range 对象的 Replace 方法，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> RngReplace<span>(</span><span>)</span>
	Range<span>(</span><span>"A1:A5"</span><span>)</span><span>.</span>Replace <span>"通州"</span><span>,</span> <span>"南通"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>RngReplace 过程将工作表 <code>A1:A5</code> 单元格中的“通州”字符串替换成“南通”字符串。</p>
<p>应用于 Range 对象的 Replace 方法替换指定区域内单元格中的字符，语法如下：</p>
<div><pre><code>expression<span>.</span>Replace<span>(</span>What<span>,</span> Replacement<span>,</span> LookAt<span>,</span> SearchOrder<span>,</span> MatchCase<span>,</span> MatchByte<span>,</span> SearchFormat<span>,</span> ReplaceFormat<span>)</span>

参数expression是必需的，返回一个Range对象。
参数What是必需的，要搜索的字符串。
参数Replacement是必需的，替换的字符串。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>运行 RngReplace 过程前工作表如图 6-1 所示，运行 RngReplace 过程后结果如图 6-2 所示。</p>
<div>
<p><img src="./assets/6-1.png" alt="" loading="lazy"></p>
<p><u>图 6-1</u>	替换前单元格</p>
<p><img src="./assets/6-2.png" alt="" loading="lazy"></p>
<p><u>图 6-2</u>	替换后单元格</p>
</div>
<h2 id="_7、复制单元格区域"> 7、复制单元格区域</h2>
<p>在实际操作中，经常需要复制指定的单元格区域到另外一个单元格区域。要复制指定单元格区域到其他位置，使用 Range 对象的 Copy 方法，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> RangeCopy<span>(</span><span>)</span>
	Application<span>.</span>DisplayAlerts <span>=</span> <span>False</span>
	Sheet1<span>.</span>Range<span>(</span><span>"A1"</span><span>)</span><span>.</span>CurrentRegion<span>.</span>Copy Sheet2<span>.</span>Range<span>(</span><span>"A1"</span><span>)</span>
	Application<span>.</span>DisplayAlerts <span>=</span> <span>True</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>代码解析：</p>
<p>RangeCopy 过程将如图 7-1 所示的 Sheet1 工作表中 <code>A1</code> 单元格的当前区域复制到 Sheet2 工作表中以 <code>A1</code> 单元格为左上角单元格的区域，如图 7-2 所示。</p>
<div>
<p><img src="./assets/7-1.png" alt="" loading="lazy"></p>
<p><u>图 7-1</u>	需复制的数据表</p>
<p><img src="./assets/7-2.png" alt="" loading="lazy"></p>
<p><u>图 7-2</u>	复制结果</p>
</div>
<p>Range 对象的 Copy 方法的语法如下：</p>
<div><pre><code>Copy<span>(</span>Destination<span>)</span>

参数Destination表示复制单元格区域的目标区域，如果省略该参数，Excel将把该区域复制到剪贴板中。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>使用 Copy 方法复制单元格区域时，也复制了该单元格区域的格式，如图 7-2 所示。</p>
<p>复制单元格区域时，如果目标区域为非空单元格区域，Excel 将显示如图 7-3 所示的消息框提示是否替换单元格内容，可以设置 Application.DisplayAlerts 属性值为 False，使复制时不出现该消息框。</p>
<div>
<p><img src="./assets/7-3.png" alt="" loading="lazy"></p>
<p><u>图 7-3</u>	替换对话框</p>
</div>
<p>第 2 行代码通常复制单元格区域的操作不会将单元格区域的列宽大小同时复制，如图 7-2 所示。如果希望在复制单元格区域的同时，也复制源区域的列宽大小，可以使用下面的代码。</p>
<div><pre><code><span>Sub</span> CopyWithSameColumnWidths<span>(</span><span>)</span>
	Sheet1<span>.</span>Range<span>(</span><span>"A1"</span><span>)</span><span>.</span>CurrentRegion<span>.</span>Copy
	<span>With</span> Sheet3<span>.</span>Range<span>(</span><span>"A1"</span><span>)</span>
		<span>.</span>PasteSpecial xlPasteColumnWidths
		<span>.</span>PasteSpecial xlPasteAll
	<span>End</span> <span>With</span>
	Application<span>.</span>CutCopyMode <span>=</span> <span>False</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>代码解析：</p>
<p>第 4 行代码使用 Range 对象的 PasteSpecial 方法选择性粘贴剪贴板中的 Range 对象的列宽。</p>
<p>第 5 行代码粘贴剪贴板中的 Range 对象全部内容。</p>
<p>第 7 行代码取消应用程序复制模式。</p>
<p>应用于 Range 对象的 PasteSpecial 方法将剪贴板中的 Range 对象粘贴到指定区域，在粘贴时可以有选择的粘贴对象的部分属性。其语法如下：</p>
<div><pre><code>PasteSpecial<span>(</span>Paste<span>,</span> Operation<span>,</span> SkipBlanks<span>,</span> Transpose<span>)</span>
    
参数Paste指定要粘贴的区域部分，可为表格<span>7</span><span>-</span><span>1</span>所列的XlPasteType常量之一。
参数Operation指定粘贴操作。可为表格<span>7</span><span>-</span><span>2</span>所列的XlPasteSpecialOperation常量之一。
参数SkipBlanks指示是否跳过空单元格，若参数值为<span>True</span>，则不将剪贴板上区域中的空白单元格粘贴到目标区域中。默认值为<span>False</span>。
参数Transpose指示是否进行转置，若参数值为<span>True</span>，则粘贴区域时转置行和列。默认值为<span>False</span>。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><u>表格 7-1</u>	XlPasteType 常量</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>xlPasteAll</td>
<td>-4104</td>
<td>全部（默认值）</td>
</tr>
<tr>
<td>xlPasteAllExceptBorders</td>
<td>7</td>
<td>边框除外</td>
</tr>
<tr>
<td>xlPasteColumnWidths</td>
<td>8</td>
<td>列宽</td>
</tr>
<tr>
<td>xlPasteComments</td>
<td>-4144</td>
<td>批注</td>
</tr>
<tr>
<td>xlPasteFormats</td>
<td>-4122</td>
<td>格式</td>
</tr>
<tr>
<td>xlPasteFormulas</td>
<td>-4123</td>
<td>公式</td>
</tr>
<tr>
<td>xlPasteFormulasAndNumberFormats</td>
<td>11</td>
<td>公式和数字格式</td>
</tr>
<tr>
<td>xlPasteValidation</td>
<td>6</td>
<td>有效性验证</td>
</tr>
<tr>
<td>xlPasteValues</td>
<td>-4163</td>
<td>数值</td>
</tr>
<tr>
<td>xlPasteValuesAndNumberFormats</td>
<td>12</td>
<td>值和数字格式</td>
</tr>
</tbody>
</table>
<p><u>表格 7-2</u>	XlPasteSpecialOperation 常量</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>xlPasteSpecialOperationNone</td>
<td>-4142</td>
<td>无（默认值）</td>
</tr>
<tr>
<td>xlPasteSpecialOperationAdd</td>
<td>2</td>
<td>加</td>
</tr>
<tr>
<td>xlPasteSpecialOperationSubtract</td>
<td>3</td>
<td>减</td>
</tr>
<tr>
<td>xlPasteSpecialOperationMultiply</td>
<td>4</td>
<td>乘</td>
</tr>
<tr>
<td>xlPasteSpecialOperationDivide</td>
<td>5</td>
<td>除</td>
</tr>
</tbody>
</table>
<p>运行 CopyWithSameColumnWidths 过程后，Sheet3 工作表如图 7-4 所示，目标区域的各列列宽与源区域一致。</p>
<div>
<p><img src="./assets/7-4.png" alt="" loading="lazy"></p>
<p><u>图 7-4</u>	粘贴列宽后的复制结果</p>
</div>
<div><p>注意</p>
<p>使用 PasteSpecial 方法时指定 xlPasteAll （粘贴全部），不会粘贴列宽。</p>
</div>
<h2 id="_8、仅复制数值到另一区域"> 8、仅复制数值到另一区域</h2>
<p>如果在复制单元格区域时，仅希望复制单元格区域的数值，有下面几种方法。</p>
<h3 id="_1-使用选择性粘贴"> 1）使用选择性粘贴</h3>
<p>使用选择性粘贴功能并指定粘贴数值，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> CopyPasteSpecial<span>(</span><span>)</span>
	Sheet1<span>.</span>Range<span>(</span><span>"A1"</span><span>)</span><span>.</span>CurrentRegion<span>.</span>Copy
	Sheet2<span>.</span>Range<span>(</span><span>"A1"</span><span>)</span><span>.</span>PasteSpecial Paste<span>:</span><span>=</span>xlPasteValues
	Application<span>.</span>CutCopyMode <span>=</span> <span>False</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>代码解析：</p>
<p>CopyPasteSpecial 过程复制工作表 Sheet1 中 <code>A1</code> 单元格的当前区域的数值到工作表 Sheet2 的 <code>A1</code> 单元格所在区域中。</p>
<p>第 2 行代码将如图 8-1 所示的 Sheet1 中 <code>A1</code> 单元格的当前区域进行复制。</p>
<div>
<p><img src="./assets/8-1.png" alt="" loading="lazy"></p>
<p><u>图 8-1</u>	需复制的数据表</p>
</div>
<p>第 3 行代码使用选择性粘贴功能并指定粘贴数值，选择性粘贴数值仅复制了单元格区域的数值，单元格区域的格式（背景颜色、字体对齐格式和边框等）不会被复制，复制结果如图 8-2 所示。</p>
<div>
<p><img src="./assets/8-2.png" alt="" loading="lazy"></p>
<p><u>图 8-2</u>	复制单元格区域数值</p>
</div>
<h3 id="_2-直接赋值的方法"> 2）直接赋值的方法</h3>
<p>除了使用 Copy 方法外，还可以使用直接赋值的方法，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> GetValueResize<span>(</span><span>)</span>
	<span>With</span> Sheet1<span>.</span>Range<span>(</span><span>"A1"</span><span>)</span><span>.</span>CurrentRegion
		Sheet3<span>.</span>Range<span>(</span><span>"A1"</span><span>)</span><span>.</span>Resize<span>(</span><span>.</span>Rows<span>.</span>Count<span>,</span> <span>.</span>Columns<span>.</span>Count<span>)</span><span>.</span>Value <span>=</span> <span>.</span>Value
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>代码解析：</p>
<p>GetValueResize 过程将工作表 Sheet1 中的 <code>A1</code> 单元格的当前区域的数值赋予工作表 Sheet3 的 <code>A1</code> 单元格所在的单元格区域。</p>
<p>在对单元格区域直接赋值时，应保证源区域大小与目标区域的大小一致，如果源区域为动态的单元格区域，可使用 Resize 方法确定目标区域。</p>
<p>运行 GetValueResize 过程，赋值结果如图 8-2 所示。</p>
<h2 id="_9、单元格自动进入编辑状态"> 9、单元格自动进入编辑状态</h2>
<p>当光标选择单元格时无需双击，自动进入编辑状态，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Worksheet_SelectionChange<span>(</span><span>ByVal</span> Target <span>As</span> Range<span>)</span>
	<span>If</span> Target<span>.</span>Column <span>=</span> <span>3</span> <span>And</span> Target<span>.</span>Count <span>=</span> <span>1</span> <span>Then</span>
		<span>If</span> Target <span>&lt;</span><span>></span> <span>""</span> <span>Then</span>
			Application<span>.</span>SendKeys <span>"{F2}"</span>
		<span>End</span> <span>If</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>工作表的 SelectionChange 事件过程，当选择工作表 C 列有数据单元格时自动进入编辑状态。</p>
<p>第 2、3 行代码设置 SelectionChange 事件的触发条件，利用 Target 参数的 Column 属性和 Count 属性将事件的触发条件限制在 C 列并且只有在选择一个单元格时才发生。</p>
<p>第 4 行代码使用 SendKeys 方法发送一个 F2 键到应用程序，等同于选择单元格后按 <kbd>F2</kbd> 键，使单元格进入编辑状态。关于 SendKeys 方法请参阅 12-4。</p>
<h2 id="_10、禁用单元格拖放功能"> 10、禁用单元格拖放功能</h2>
<p>在工作表中可以拖放单元格右下角的小十字对单元格内容进行复制等操作，如果不希望用户进行此操作可以禁用单元格拖放功能，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Worksheet_SelectionChange<span>(</span><span>ByVal</span> Target <span>As</span> Range<span>)</span>
	<span>If</span> <span>Not</span> Application<span>.</span>Intersect<span>(</span>Target<span>,</span> Range<span>(</span><span>"A1:A15"</span><span>)</span><span>)</span> <span>Is</span> <span>Nothing</span> <span>Then</span>
		Application<span>.</span>CellDragAndDrop <span>=</span> <span>False</span>
	<span>Else</span>
		Application<span>.</span>CellDragAndDrop <span>=</span> <span>True</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>工作表的 SelectionChange 事件过程，在指定的单元格区域禁用单元格的拖放功能。</p>
<p>CellDragAndDrop 属性设置单元格的拖放功能，如果允许使用单元格拖放功能，则该值为 True。</p>
<p>为了不影响其他工作表，应在工作表的 Deactivate 事件中恢复单元格的拖放功能，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Worksheet_Deactivate<span>(</span><span>)</span>
	Application<span>.</span>CellDragAndDrop <span>=</span> <span>True</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>工作表的 Deactivate 事件过程，恢复单元格的拖放功能。</p>
<p>工作表的 Deactivate 事件当工作表从活动状态转为非活动状态时产生，语法如下：</p>
<div><pre><code><span>Private</span> <span>Sub</span> object_Deactivate<span>(</span><span>)</span>
    
参数<span>object</span>代表Worksheet对象。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>当选择工作表“Sheet1”的 <code>A1:A15</code> 单元格时将禁用单元格的拖放功能，如图 10-1 所示。</p>
<div>
<p><img src="./assets/10-1.png" alt="" loading="lazy"></p>
<p><u>图 10-1</u>	复制单元格区域数值</p>
</div>
<h2 id="_11、单元格格式操作"> 11、单元格格式操作</h2>
<h3 id="_1-单元格字体格式设置"> 1）单元格字体格式设置</h3>
<p>在 VBA 中可以对单元格的字体格式进行各种设置，如下面的代码所示。</p>
<div><pre><code><span>Public</span> <span>Sub</span> RngFont<span>(</span><span>)</span>
	<span>With</span> Range<span>(</span><span>"A1"</span><span>)</span><span>.</span>Font
		<span>.</span>Name <span>=</span> <span>"华文彩云"</span>
		<span>.</span>FontStyle <span>=</span> <span>"Bold"</span>
		<span>.</span>Size <span>=</span> <span>18</span>
		<span>.</span>ColorIndex <span>=</span> <span>3</span>
		<span>.</span>Underline <span>=</span> <span>2</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>代码解析：</p>
<p>RngFont 过程对单元格 <code>A1</code> 的字体格式进行设置。</p>
<p>其中第 3 行代码设置字体为“华文彩云”，应用于 Font 对象的 Name 属性返回或设置对象的名称。</p>
<p>第 4 行代码设置字体为加粗，FontStyle 属性返回或设置字体样式。设置为“Bold” 加粗字体，设置为“Italic”倾斜字体，也可以设置成“Bold Italic”。</p>
<p>第 5 行代码设置字体的大小为 18 磅，Size 属性返回或设置字体大小。</p>
<p>第 6 行代码设置字体的颜色为红色，应用于 Font 对象的 ColorIndex 属性返回或设置字体的颜色，该颜色可指定为当前调色板中颜色的编号，如图 11-1 所示。</p>
<div>
<p><img src="./assets/11-1.png" alt="" loading="lazy"></p>
<p><u>图 11-1</u>	调色板中颜色的编号</p>
</div>
<p>第 7 行代码设置字体为单下划线类型，Underline 属性返回或设置应用于字体的下划线类型，可为表格 11-1 所列的 XlUnderlineStyle 常量之一。</p>
<p><u>表格 11-1</u>	XlUnderlineStyle 常量</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>xlUnderlineStyleNone</td>
<td>-4142</td>
<td>无</td>
</tr>
<tr>
<td>xlUnderlineStyleSingle</td>
<td>2</td>
<td>单下划线</td>
</tr>
<tr>
<td>xlUnderlineStyleDouble</td>
<td>-4119</td>
<td>双下划线</td>
</tr>
<tr>
<td>xlUnderlineStyleSingleAccounting</td>
<td>4</td>
<td>会计用单下划线</td>
</tr>
<tr>
<td>xlUnderlineStyleDoubleAccounting</td>
<td>5</td>
<td>会计用双下划线</td>
</tr>
</tbody>
</table>
<p>运行 RngFont 过程结果如图 11-2 所示。</p>
<div>
<p><img src="./assets/11-2.png" alt="" loading="lazy"></p>
<p><u>图 11-2</u>	单元格字体设置</p>
</div>
<h3 id="_2-设置单元格内部格式"> 2）设置单元格内部格式</h3>
<p>设置单元格的 Interior 属性可以对单元格的内部格式进行设置，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> RngInterior<span>(</span><span>)</span>
	<span>With</span> Range<span>(</span><span>"A1"</span><span>)</span><span>.</span>Interior
		<span>.</span>ColorIndex <span>=</span> <span>3</span>
		<span>.</span>Pattern <span>=</span> xlPatternCrissCross
		<span>.</span>PatternColorIndex <span>=</span> <span>6</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>RngInterior 过程对 <code>A1</code> 单元格的内部格式进行设置。</p>
<p>第 2 行代码使用 Interior 属性返回单元格对象的内部。</p>
<p>第 3 行代码设置单元格边框内部的颜色为红色。应用于 Interior 对象的 ColorIndex 属性返回或设置边框内部的颜色，可指定为如图 11-1 所示的当前调色板中颜色的编号或为 XlColorIndex 常量之一：xlColorIndexAutomatic （自动填充）、xlColorIndexNone （无内部填充）。</p>
<p>第 4 行代码设置单元格设置内部图案为十字图案。应用于 Interior 对象的 Pattern 属性返回或者设置内部图案。</p>
<p>第 5 行代码设置单元格设置内部图案的颜色为黄色。应用于 Interior 对象的 PatternColorIndex 属性返回或设置内部图案的颜色，可指定为如图 11-1 所示的当前调色板中颜色的编号 XlColorIndex 常量之一：xlColorIndexAutomatic （自动填充）、xlColorIndexNone （无内部填充）。</p>
<p>运行 RngInterior 过程结果如图 11-3 所示。</p>
<div>
<p><img src="./assets/11-3.png" alt="" loading="lazy"></p>
<p><u>图 11-3</u>	设置单元格内部格式</p>
</div>
<h3 id="_3-为单元格区域添加边框"> 3）为单元格区域添加边框</h3>
<p>我们为单元格区域添加边框时往往通过录制宏获取代码，但宏录制器生成的代码分别设置单元格区域的每个边框，因此代码多且效率低。使用 Range 对象的 Borders 集合可以快速的对单元格区域的每个边框应用相同的格式，而 Range 对象的 BorderAround 方法则可以快速地为单元格区域添加一个外边框，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> AddBorders<span>(</span><span>)</span>
	 <span>Dim</span> rng <span>As</span> Range
	 <span>Set</span> rng <span>=</span> Range<span>(</span><span>"B4:G10"</span><span>)</span>
	 <span>With</span> rng<span>.</span>Borders
		 <span>.</span>LineStyle <span>=</span> xlContinuous
		 <span>.</span>Weight <span>=</span> xlThin
		 <span>.</span>ColorIndex <span>=</span> <span>5</span>
	 <span>End</span> <span>With</span>
	 rng<span>.</span>BorderAround xlContinuous<span>,</span> xlMedium<span>,</span> <span>5</span>
	 <span>Set</span> rng <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>代码解析：</p>
<p>AddBorders 过程为单元格区域 <code>B4:G10</code> 设置内部统一边框并添加一个加粗外边框。</p>
<p>第 4 行到第 8 行代码使用 Borders 属性引用单元格区域的 Borders 集合，其中第 5 行代码设置其边框样式线条的样式，第 6 行代码设置边框线条的粗细，第 7 行代码设置边框的颜色。</p>
<p>应用于 Range 对象的 Borders 集合代表 Range 对象的 4 个边框（左边框、右边框、顶部边框和底部边框）的 4 个 Border 对象组成的集合，这 4 个边框既可单独返回，也可作为一个组同时返回。</p>
<p>第 9 行代码使用 BorderAround 方法为单元格区域添加一个加粗外边框。</p>
<p>应用于 Range 对象的 BorderAround 方法向单元格区域添加整个区域的外边框，并设置该边框的相关属性，其语法如下：</p>
<div><pre><code>BorderAround<span>(</span>LineStyle<span>,</span> Weight<span>,</span> ColorIndex<span>,</span> Color<span>)</span>

LineStyle参数设置边框线条的样式
Weight参数设置边框线条的粗细
ColorIndex设置边框颜色
Color参数以RGB值指定边框的颜色
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><p>注意</p>
<p>指定 Color 参数可以设置颜色为当前调色板之处的其它颜色，不能同时指定 ColorIndex 参数和 Color 参数。</p>
</div>
<p>运行 AddBorders 过程，效果如图 11-4 所示。</p>
<div>
<p><img src="./assets/11-4.png" alt="" loading="lazy"></p>
<p><u>图 11-4</u>	设置单元格区域边框</p>
</div>
<p>如果需要在单元格区域中应用多种边框格式，则需分别设置各边框格式，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> BordersDemo<span>(</span><span>)</span>
	 <span>Dim</span> rng <span>As</span> Range
	 <span>Set</span> rng <span>=</span> Sheet2<span>.</span>Range<span>(</span><span>"B4:G10"</span><span>)</span>
	 <span>With</span> rng<span>.</span>Borders<span>(</span>xlInsideHorizontal<span>)</span>
		 <span>.</span>LineStyle <span>=</span> xlDot
		 <span>.</span>Weight <span>=</span> xlThin
		 <span>.</span>ColorIndex <span>=</span> <span>5</span>
	 <span>End</span> <span>With</span>
	 <span>With</span> rng<span>.</span>Borders<span>(</span>xlInsideVertical<span>)</span>
		 <span>.</span>LineStyle <span>=</span> xlContinuous
		 <span>.</span>Weight <span>=</span> xlThin
		 <span>.</span>ColorIndex <span>=</span> <span>5</span>
	 <span>End</span> <span>With</span>
	 rng<span>.</span>BorderAround xlContinuous<span>,</span> xlMedium<span>,</span> <span>5</span>
	 <span>Set</span> rng <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>代码解析：</p>
<p>BordersDemo 过程代码为单元格区域内部边框在水平和垂直方向上应用不同格式，并为区域添加一个加粗外边框。</p>
<p>Borders(index) 属性返回单个 Border 对象，其 Index 参数取值可为表格 11-2 所列的 XlBordersIndex 常量之一。</p>
<p><u>表格 11-2</u>	XlBordersIndex 常量</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>xlDiagonalDown</td>
<td>5</td>
<td>斜下边框</td>
</tr>
<tr>
<td>xlDiagonalUp</td>
<td>6</td>
<td>斜上边框</td>
</tr>
<tr>
<td>xlEdgeBottom</td>
<td>9</td>
<td>底部边框</td>
</tr>
<tr>
<td>xlEdgeLeft</td>
<td>7</td>
<td>左边框</td>
</tr>
<tr>
<td>xlEdgeRight</td>
<td>10</td>
<td>右边框</td>
</tr>
<tr>
<td>xlEdgeTop</td>
<td>8</td>
<td>顶部边框</td>
</tr>
<tr>
<td>xlInsideHorizontal</td>
<td>12</td>
<td>内部水平</td>
</tr>
<tr>
<td>xlInsideVertical</td>
<td>11</td>
<td>内部垂直</td>
</tr>
</tbody>
</table>
<p>运行 BordersDemo 过程效果如图 11-5 所示。</p>
<div>
<p><img src="./assets/11-5.png" alt="" loading="lazy"></p>
<p><u>图 11-5</u>	应用不同格式内部边框</p>
</div>
<h3 id="_4-灵活设置单元格的行高列宽"> 4）灵活设置单元格的行高列宽</h3>
<p>一般情况下单元格的行高列宽都是以磅为单位进行设置的，也可以使用英寸和厘米计量单位设置单元格的行高列宽，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> RngToPoints<span>(</span><span>)</span>
	<span>With</span> Range<span>(</span><span>"A1"</span><span>)</span>
		<span>.</span>RowHeight <span>=</span> Application<span>.</span>CentimetersToPoints<span>(</span><span>2</span><span>)</span>
		<span>.</span>ColumnWidth <span>=</span> Application<span>.</span>CentimetersToPoints<span>(</span><span>1.5</span><span>)</span>
	<span>End</span> <span>With</span>
	<span>With</span> Range<span>(</span><span>"A2"</span><span>)</span>
		<span>.</span>RowHeight <span>=</span> Application<span>.</span>InchesToPoints<span>(</span><span>1.2</span><span>)</span>
		<span>.</span>ColumnWidth <span>=</span> Application<span>.</span>InchesToPoints<span>(</span><span>0.3</span><span>)</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>代码解析：</p>
<p>RngToPoints 过程以英寸和厘米计量单位设置单元格的行高列宽。</p>
<p>第 3、4 行代码使用 CentimetersToPoints 方法以厘米为计量单位设置 <code>A1</code> 单元格的行高列宽。CentimetersToPoints 方法将计量单位从厘米转换为磅（一磅等于 0.035 厘米），语法如下：</p>
<div><pre><code>expression<span>.</span>CentimetersToPoints<span>(</span>Centimeters<span>)</span>

参数expression是必需的，返回一个Application对象。
参数Centimeters是必需的，指定要转换为磅值的厘米值。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第 5、6 行代码使用 InchesToPoints 方法以英寸为计量单位设置 <code>A2</code> 单元格的行高列宽。InchesToPoints 方法将计量单位从英寸转换为磅，语法如下：</p>
<div><pre><code>expression<span>.</span>InchesToPoints<span>(</span>Inches<span>)</span>

参数expression是必需的，返回一个Application对象。
参数Inches是必需的，指定要转换为磅值的英寸值。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>运行 RngToPoints 过程结果如图 11-6 所示。</p>
<div>
<p><img src="./assets/11-6.png" alt="" loading="lazy"></p>
<p><u>图 11-6</u>	灵活设置单元格的行高列宽</p>
</div>
<h2 id="_12、单元格中的数据有效性"> 12、单元格中的数据有效性</h2>
<h3 id="_1-在单元格中建立数据有效性"> 1）在单元格中建立数据有效性</h3>
<p>在单元格中建立数据有效性可以使用 Add 方法，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> Validation<span>(</span><span>)</span>
	<span>With</span> Range<span>(</span><span>"A1:A10"</span><span>)</span><span>.</span>Validation
	 <span>.</span>Delete
		<span>.</span>Add <span>Type</span><span>:</span><span>=</span>xlValidateList<span>,</span> <span>_</span>
			AlertStyle<span>:</span><span>=</span>xlValidAlertStop<span>,</span> <span>_</span>
			<span>Operator</span><span>:</span><span>=</span>xlBetween<span>,</span> <span>_</span>
			Formula1<span>:</span><span>=</span><span>"1,2,3,4,5,6,7,8"</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>代码解析：</p>
<p>使用 Add 方法在 <code>A1:A10</code> 单元格中建立数据有效性。</p>
<p>第 3 行代码删除已建立的数据有效性，防止代码运行出错。</p>
<p>第 4 行到第 7 行代码使用 Add 方法建立数据有效性。应用于 Validation 对象的 Add 方法的语法如下：</p>
<div><pre><code>expression<span>.</span>Add<span>(</span><span>Type</span><span>,</span> AlertStyle<span>,</span> <span>Operator</span><span>,</span> Formula1<span>,</span> Formula2<span>)</span>

参数expression是必需的，返回一个Validation对象。
参数<span>Type</span>是必需的，数据有效性类型。
参数AlertStyl是可选的，有效性检验警告样式。
参数<span>Operator</span>是可选的，数据有效性运算符。
参数Formula1是可选的，数据有效性公式的第一部分。
参数Formula2是可选的，当<span>Operator</span>为xlBetween或xlNotBetween时，数据有效性公式的第二部分（其他情况下，此参数被忽略）。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>Add 方法所要求的参数依有效性检验的类型而定，如表格 12-1 所示。</p>
<p><u>表格 12-1</u>	数据有效性类型</p>
<table>
<thead>
<tr>
<th>数据有效性类型</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>xlValidateCustom</td>
<td>Formula1 必需，忽略 Formula2。Formula1 必须包含一个表达式，数据项有效时该表达式取值为 True，而数据项无效时取值为 False。</td>
</tr>
<tr>
<td>xlInputOnly</td>
<td>能使用 AlertStyle、Formula1 或 Formula2 参数。</td>
</tr>
<tr>
<td>xlValidateList</td>
<td>Formula1 必需，忽略 Formula2。Formula1 必须包含以逗号分隔的取值列表，或引用此列表的工作表。</td>
</tr>
<tr>
<td>xlValidateWholeNumber、xlValidateDate、xlValidateDecimal、xlValidateTextLength 或 xlValidateTime</td>
<td>必须指定 Formula1 或 Formula2 之一，或两者均指定。</td>
</tr>
</tbody>
</table>
<h3 id="_2-判断单元格是否存在数据有效性"> 2）判断单元格是否存在数据有效性</h3>
<p>在 VBA 中没有专门的属性判断单元格是否存在数据有效性设置，可以使用 Validation 对象的有效性类型和错误陷阱来判断，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> Validation<span>(</span><span>)</span>
	<span>On</span> <span>Error</span> <span>GoTo</span> Line
	<span>If</span> Range<span>(</span><span>"A2"</span><span>)</span><span>.</span>Validation<span>.</span><span>Type</span> <span>></span><span>=</span> <span>0</span> <span>Then</span>
		MsgBox <span>"单元格有数据有效性!"</span>
		<span>Exit</span> <span>Sub</span>
	<span>End</span> <span>If</span>
Line<span>:</span>
	MsgBox <span>"单元格没有数据有效性!"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>代码解析：</p>
<p>Validation 过程使用 Validation 对象的有效性类型和错误陷阱来判断 <code>A2</code> 单元格中是否存在数据有效性。</p>
<p>第 6 行代码，如果 <code>A2</code> 单元格中存在数据有效性，Type 参数值就会大于等于 0，否则就会发生错误，使用 On Error GoTo 捕捉到错误后转移到第 8 行代码，显示一个消息框。</p>
<h3 id="_3-动态的数据有效性"> 3）动态的数据有效性</h3>
<p>利用 VBA 可以在单元格中建立动态的数据有效性，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Worksheet_SelectionChange<span>(</span><span>ByVal</span> Target <span>As</span> Range<span>)</span>
	<span>If</span> Target<span>.</span>Column <span>=</span> <span>1</span> <span>And</span> Target<span>.</span>Count <span>=</span> <span>1</span> <span>And</span> Target<span>.</span>Row <span>></span> <span>1</span> <span>Then</span>
		<span>With</span> Target<span>.</span>Validation
			<span>.</span>Delete
			<span>.</span>Add <span>Type</span><span>:</span><span>=</span>xlValidateList<span>,</span> <span>_</span>
				AlertStyle<span>:</span><span>=</span>xlValidAlertStop<span>,</span> <span>_</span>
				<span>Operator</span><span>:</span><span>=</span>xlBetween<span>,</span> <span>_</span>
				Formula1<span>:</span><span>=</span><span>"主机,显示器"</span>
		<span>End</span> <span>With</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
<span>Private</span> <span>Sub</span> Worksheet_Change<span>(</span><span>ByVal</span> Target <span>As</span> Range<span>)</span>
	<span>If</span> Target<span>.</span>Column <span>=</span> <span>1</span> <span>And</span> Target<span>.</span>Row <span>></span> <span>1</span> <span>And</span> Target<span>.</span>Count <span>=</span> <span>1</span> <span>Then</span>
		<span>With</span> Target<span>.</span>Offset<span>(</span><span>0</span><span>,</span> <span>1</span><span>)</span><span>.</span>Validation
			<span>.</span>Delete
			<span>Select</span> <span>Case</span> Target
				<span>Case</span> <span>"主机"</span>
					<span>.</span>Add <span>Type</span><span>:</span><span>=</span>xlValidateList<span>,</span> <span>_</span>
						AlertStyle<span>:</span><span>=</span>xlValidAlertStop<span>,</span> <span>_</span>
						<span>Operator</span><span>:</span><span>=</span>xlBetween<span>,</span> <span>_</span>
						Formula1<span>:</span><span>=</span><span>"Z286,Z386,Z486,Z586"</span>
				<span>Case</span> <span>"显示器"</span>
					<span>.</span>Add <span>Type</span><span>:</span><span>=</span>xlValidateList<span>,</span> <span>_</span>
						AlertStyle<span>:</span><span>=</span>xlValidAlertStop<span>,</span> <span>_</span>
						<span>Operator</span><span>:</span><span>=</span>xlBetween<span>,</span> <span>_</span>
						Formula1<span>:</span><span>=</span><span>"三星17,飞利浦15,三星15,飞利浦17"</span>
			<span>End</span> <span>Select</span>
		<span>End</span> <span>With</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>代码解析：</p>
<p>第 1 行到第 11 行代码，工作表的 SelectionChange 事件，当选择工作表的 A 列单元格时，在 <code>A2</code> 以下的单元格中建立动态的数据有效性。</p>
<p>其中第 2 行代码，利用 SelectionChange 事件的 Target 参数来限制事件的触发条件。</p>
<p>第 3 行到第 9 行代码使用 Add 方法在 A 列单元格中建立数据有效性。应用于 Validation 对象的 Add 方法请参阅 12-1。</p>
<p>第 12 行到第 30 行代码，工作表的 Change 事件，当工作表 A 列单元格内容改变时，在 B 列单元格中建立动态的数据有效性。</p>
<p>其中第 16 行到第 27 行代码，根据A列单元格的内容在 B 列对应的单元格中建立数据有效性，其 Formula1 参数的值根据A列单元格的内容而变化，使之达到动态数据有效性的效果，如图 12-1、图 12-2 所示。</p>
<div>
<p><img src="./assets/12-1.png" alt="" loading="lazy"></p>
<p><u>图 12-1</u>	动态数据有效性1</p>
<p><img src="./assets/12-2.png" alt="" loading="lazy"></p>
<p><u>图 12-2</u>	动态数据有效性2</p>
</div>
<h3 id="_4-自动展开数据有效性下拉列表"> 4）自动展开数据有效性下拉列表</h3>
<p>选择工作表单元格时自动展开数据有效性的下拉列表，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Worksheet_SelectionChange<span>(</span><span>ByVal</span> Target <span>As</span> Range<span>)</span>
	<span>If</span> Target<span>.</span>Column <span>=</span> <span>5</span> <span>Then</span> Application<span>.</span>SendKeys <span>"%{down}"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>当选择工作表的 E 列中有数据有效性的单元格时使用 SendKeys 方法发送 <kbd>Alt</kbd> + <kbd>↓</kbd>，打开数据有效性的下拉列表。</p>
<p>应用于 Application 对象的 SendKeys 方法将击键发送给活动应用程序，语法如下：</p>
<div><pre><code>expression<span>.</span>SendKeys<span>(</span>Keys<span>,</span> Wait<span>)</span>

参数expression是可选的，该表达式返回一个Application对象。
参数Keys是必需的，要发送的键或者组合键，以文本方式表示。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>Keys 参数可以指定任何单个键或与 <kbd>Alt</kbd>、<kbd>Ctrl</kbd> 或 <kbd>Shift</kbd> 的组合键（或者这些键的组合）。每个键可用一个或多个字符表示。例如，&quot;a&quot; 表示字符 a，或者 &quot;{ENTER}&quot; 表示 <kbd>Enter</kbd>。</p>
<p>若要指定在按相应键时不会显示的字符（例如，<kbd>Enter</kbd> 或 <kbd>Tab</kbd>），请使用如表格 12-2 所列的代码来表示相应的键，表中的每个代码表示键盘上的一个键。</p>
<p><u>表格 12-2</u>	按键代码</p>
<table>
<thead>
<tr>
<th>键</th>
<th>代码</th>
</tr>
</thead>
<tbody>
<tr>
<td>Backspace</td>
<td>{BACKSPACE} 或 {BS}</td>
</tr>
<tr>
<td>Break</td>
<td>{BREAK}</td>
</tr>
<tr>
<td>Caps Lock</td>
<td>{CAPSLOCK}</td>
</tr>
<tr>
<td>Clear</td>
<td>{CLEAR}</td>
</tr>
<tr>
<td>Delete 或 Del</td>
<td>{DELETE} 或 {DEL}</td>
</tr>
<tr>
<td>End</td>
<td>{END}</td>
</tr>
<tr>
<td>Enter</td>
<td>~（波形符）</td>
</tr>
<tr>
<td>Enter（数字小键盘）</td>
<td>{ENTER}</td>
</tr>
<tr>
<td>Esc</td>
<td>{ESCAPE} 或 {ESC}</td>
</tr>
<tr>
<td>F1 到 F15</td>
<td>{F1} 到 {F15}</td>
</tr>
<tr>
<td>Help</td>
<td>{HELP}</td>
</tr>
<tr>
<td>Home</td>
<td>{HOME}</td>
</tr>
<tr>
<td>Ins</td>
<td>{INSERT}</td>
</tr>
<tr>
<td>Num Lock</td>
<td>{NUMLOCK}</td>
</tr>
<tr>
<td>Page Down</td>
<td>{PGDN}</td>
</tr>
<tr>
<td>Page Up</td>
<td>{PGUP}</td>
</tr>
<tr>
<td>Return</td>
<td>{RETURN}</td>
</tr>
<tr>
<td>Scroll Lock</td>
<td>{SCROLLLOCK}</td>
</tr>
<tr>
<td>Tab</td>
<td>{TAB}</td>
</tr>
<tr>
<td>向上键</td>
<td>{UP}</td>
</tr>
<tr>
<td>向下键</td>
<td>{DOWN}</td>
</tr>
<tr>
<td>向右键</td>
<td>{RIGHT}</td>
</tr>
<tr>
<td>向左键</td>
<td>{LEFT}</td>
</tr>
</tbody>
</table>
<h2 id="_13、单元格中的公式"> 13、单元格中的公式</h2>
<h3 id="_1-在单元格中写入公式"> 1）在单元格中写入公式</h3>
<p>使用 Range 对象的 Formula 属性可以在单元格区域中写入公式，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> rngFormula<span>(</span><span>)</span>
	Sheet1<span>.</span>Range<span>(</span><span>"C1:C10"</span><span>)</span><span>.</span>Formula <span>=</span> <span>"=SUM(A1+B1)"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>应用于 Range 对象的 Formula 属性返回或设置 A1 样式表示的 Range 对象的公式，语法如下：</p>
<div><pre><code>expression<span>.</span>Formula

参数expression是必需的，返回一个Range对象。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>还可以使用 FormulaR1C1 属性返回或设置以 R1C1 样式符号表示的公式，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> rngFormulaRC<span>(</span><span>)</span>
	Sheet2<span>.</span>Range<span>(</span><span>"C1:C10"</span><span>)</span><span>.</span>FormulaR1C1 <span>=</span> <span>"=SUM(RC[-2]+RC[-1])"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果需要在单元格中写入数组公式则使用 Range 对象的 FormulaArray 属性。如下面的代码所示。</p>
<div><pre><code><span>Sub</span> RngFormulaArray<span>(</span><span>)</span>
	Sheet3<span>.</span>Range<span>(</span><span>"C1"</span><span>)</span><span>.</span>FormulaArray <span>=</span> <span>"=A1:A2*B1:B2"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>Range 对象的 FormulaArray 属性返回或设置单元格区域的数组公式。</p>
<div><p>关于 R1C1 样式单元格表示方法</p>
<p>R1C1单元格引用样式，即【R+行号+C+列号】的表示方式，字母 R 表示行，字母 C 表示列。比如 R1C2 表示第 1 行第 2 列，即 <code>B1</code> 单元格。</p>
<p>RC[-2] 表示当前单元格往前两列的单元格。</p>
</div>
<h3 id="_2-检查单元格是否含有公式"> 2）检查单元格是否含有公式</h3>
<p>使用单元格的 HasFormula 属性检查单元格是否含有公式,如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> CommandButton1_Click<span>(</span><span>)</span>
	<span>Select</span> <span>Case</span> Selection<span>.</span>HasFormula
		<span>Case</span> <span>True</span>
			MsgBox <span>"公式单元格!"</span>
		<span>Case</span> <span>False</span>
			MsgBox <span>"非公式单元格!"</span>
		<span>Case</span> <span>Else</span>
		MsgBox <span>"公式区域："</span> <span>&amp;</span> Selection<span>.</span>SpecialCells<span>(</span>xlCellTypeFormulas<span>,</span> <span>23</span><span>)</span><span>.</span>Address<span>(</span><span>0</span><span>,</span> <span>0</span><span>)</span>
	<span>End</span> <span>Select</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>代码解析：</p>
<p>工作表中按钮的单击过程，检查所选择的单元格区域是否含有公式。</p>
<p>第 2 行代码返回所选择单元格区域的 HasFormula 属性值。如果区域中所有单元格均包含公式，则该值为 True；如果所有单元格均不包含公式，则该值为 False。</p>
<p>第 3、4 行代码，如果返回 True，说明区域中所有单元格均包含公式。</p>
<p>第 5、6 行代码，如果返回 False，说明区域中所有单元格均不包含公式。</p>
<p>第 7、8 行代码，如果是混合区域，则显示包含公式的单元格地址，如图 13-1 所示。</p>
<div>
<p><img src="./assets/13-1.png" alt="" loading="lazy"></p>
<p><u>图 13-1</u>	显示包含公式的单元格地址</p>
</div>
<h3 id="_3-判断单元格公式是否存在错误"> 3）判断单元格公式是否存在错误</h3>
<p>当需要获取的单元格的值由公式返回时，公式返回的结果可能是一个错误文本，包含 #NULL! 、#DIV/0! 、#VALUE! 、#REF! 、#NAME? 、#NUM! 、#N/A 等。此时，当单元格公式返回结果为错误文本时，如果试图通过 Value 属性来获得公式的返回结果，将得到类型不匹配的错误信息，如图 13-2 所示。</p>
<div>
<p><img src="./assets/13-2.png" alt="" loading="lazy"></p>
<p><u>图 13-2</u>	公式错误导致的消息</p>
</div>
<p>通过 Range 对象的 Value 属性的返回结果是否为错误类型，来判断公式是否存在错误，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> FormulaIsError<span>(</span><span>)</span>
	<span>If</span> VBA<span>.</span>IsError<span>(</span>Range<span>(</span><span>"A1"</span><span>)</span><span>.</span>Value<span>)</span> <span>=</span> <span>True</span> <span>Then</span>
		MsgBox <span>"A1单元格错误类型为:"</span> <span>&amp;</span> Range<span>(</span><span>"A1"</span><span>)</span><span>.</span>Text
	<span>Else</span>
		MsgBox <span>"A1单元格公式结果为"</span> <span>&amp;</span> Range<span>(</span><span>"A1"</span><span>)</span><span>.</span>Value
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>FormulaIsError 过程代码判断单元格 <code>A1</code> 中公式结果是否为错误，如果为错误则显示该错误类型，否则显示公式的结果，如图 13-3 所示。</p>
<p>第 2 行代码使用 IsError 函数返回 Boolean 值，指出表达式是否为一个错误值，如果表达式表示一个错误，则 IsError 函数返回 True，否则返回 False。</p>
<div>
<p><img src="./assets/13-3.png" alt="" loading="lazy"></p>
<p><u>图 13-3</u>	显示公式错误结果</p>
</div>
<h3 id="_4-取得单元格中公式的引用单元格"> 4）取得单元格中公式的引用单元格</h3>
<p>如果需要取得单元格中公式的引用单元格对象，可以使用 Range 对象的 Precedents 属性，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> RngPrecedent<span>(</span><span>)</span>
	<span>Dim</span> rng <span>As</span> Range
	<span>Set</span> rng <span>=</span> Sheet1<span>.</span>Range<span>(</span><span>"C1"</span><span>)</span><span>.</span>Precedents
	MsgBox <span>"公式所引用的单元格有："</span> <span>&amp;</span> rng<span>.</span>Address
	<span>Set</span> rng <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>代码解析：</p>
<p>在工作表的 <code>C1</code> 单元格中写有公式“SUM(“A1:B1”)”，RngPrecedent 过程使用 Range 对象的Precedents 属性取得其引用的单元格 <code>A1:B1</code>。</p>
<p>Precedents 属性返回一个 Range 对象，该对象代表单元格的所有引用单元格。如果有若干引用单元格，那么该区域可能是多个的选定区域（Range 对象的联合）。</p>
<p>运行 RngPrecedent 过程结果如图 13-4 所示。</p>
<div>
<p><img src="./assets/13-4.png" alt="" loading="lazy"></p>
<p><u>图 13-4</u>	取得引用单元格</p>
</div>
<h3 id="_5-将单元格中的公式转换为数值"> 5）将单元格中的公式转换为数值</h3>
<p>工作表中如果存在过多的公式将影响操作速度，将单元格中的函数与公式的结果转换为数值，可以提高工作表运算效率，有下面几种方法可以实现。</p>
<p>使用选择性粘贴的方法可以将函数与公式的结果转换为数值，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> SpecialPaste<span>(</span><span>)</span>
	<span>With</span> Range<span>(</span><span>"A1:A10"</span><span>)</span>
		<span>.</span>Copy
		<span>.</span>PasteSpecial Paste<span>:</span><span>=</span>xlPasteValues
	<span>End</span> <span>With</span>
	Application<span>.</span>CutCopyMode <span>=</span> <span>False</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>SpecialPaste 过程使用选择性粘贴方法将单元格区域的公式转换为数值。</p>
<p>第3行代码将单元格区域复制到剪贴板中。</p>
<p>应用于 Range 对象的 Copy 方法将单元格区域复制到指定的区域或剪贴板中，语法如下：</p>
<div><pre><code>expression<span>.</span>Copy<span>(</span>Destination<span>)</span>

参数expression是必需的，该表达式返回一个Range对象。
参数Destination是可选的，指定区域要复制到的目标区域。如果省略该参数，Microsoft Excel将把该区域复制到剪贴板中。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第 4 行代码将剪贴板中的 Range 对象仅复制值到单元格区域中。</p>
<p>应用于 Range 对象的 PasteSpecial 方法将剪贴板中的 Range 对象粘贴到指定区域中，语法如下：</p>
<div><pre><code>expression<span>.</span>PasteSpecial<span>(</span>Paste<span>,</span> Operation<span>,</span> SkipBlanks<span>,</span> Transpose<span>)</span>

参数expression是必需的，该表达式返回一个Range对象。
参数Paste是可选的，指定要粘贴的区域部分。在本例中设置为xlPasteValues，仅复制值到单元格区域中。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>使用 Value 属性可以将函数与公式的结果转换为数值，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> UseValue<span>(</span><span>)</span>
	Range<span>(</span><span>"A1:A10"</span><span>)</span><span>.</span>Value <span>=</span> Range<span>(</span><span>"A1:A10"</span><span>)</span><span>.</span>Value
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>UseValue 过程使用 Value 属性将函数与公式的结果转换为数值。</p>
<p>使用 Formula 属性可以将函数与公式的结果转换为数值，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> UseFormula<span>(</span><span>)</span>
	Range<span>(</span><span>"A1"</span><span>)</span><span>.</span>Formula <span>=</span> Range<span>(</span><span>"A1"</span><span>)</span><span>.</span>Value
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>UseFormula 过程 Formula 属性将函数与公式的结果转换为数值。当 Formula 属性值为非公式时，返回的结果与 Value 属性一致。</p>
<h2 id="_14、单元格中的批注"> 14、单元格中的批注</h2>
<h3 id="_1-判断单元格是否存在批注"> 1）判断单元格是否存在批注</h3>
<p>在 VBA 中，可以利用 Range 对象的 Comment 属性判断单元格是否存在批注，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> HasComment<span>(</span><span>)</span>
	<span>If</span> Range<span>(</span><span>"A1"</span><span>)</span><span>.</span>Comment <span>Is</span> <span>Nothing</span> <span>Then</span>
		MsgBox <span>"A1单元格中没有批注!"</span>
	<span>Else</span>
		MsgBox <span>"A1单元格中批注内容为："</span> <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>&amp;</span> Range<span>(</span><span>"A1"</span><span>)</span><span>.</span>Comment<span>.</span>Text
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>HasComment 过程判断 <code>A1</code> 单元格是否存在批注，并用消息框显示批注信息。</p>
<p>Range 对象的 Comment 属性返回一个批注对象，如果指定的单元格不存在批注，该属性返回 Nothing。</p>
<p>运行 HasComment 过程结果如图 14-1 所示。</p>
<div>
<p><img src="./assets/14-1.png" alt="" loading="lazy"></p>
<p><u>图 14-1</u>	显示批注内容</p>
</div>
<h3 id="_2-为单元格添加批注"> 2）为单元格添加批注</h3>
<p>如果希望为单元格添加批注，那么可以使用 AddComment 方法，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> Comment_Add<span>(</span><span>)</span>
	<span>With</span> Range<span>(</span><span>"A1"</span><span>)</span>
		<span>If</span> <span>.</span>Comment <span>Is</span> <span>Nothing</span> <span>Then</span>
			<span>.</span>AddComment Text<span>:</span><span>=</span><span>.</span>Value
			<span>.</span>Comment<span>.</span>Visible <span>=</span> <span>True</span>
		<span>End</span> <span>If</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>代码解析：</p>
<p>Comment_Add 判断单元格 <code>A1</code> 中是否存在批注，如果没有批注则为单元格 <code>A1</code> 添加批注并将单元格数值作为批注文本，同时显示批注对象。</p>
<p>第 4 行代码使用 Range 对象的 AddComment 方法为单元格添加批注。该方法只有一个参数 Text，代表批注文本。如果单元格已经存在批注，则该方法返回一个错误。</p>
<p>第 5 行代码显示批注对象，Visible 属性确定对象是否可视。</p>
<p>当单元格 <code>A1</code> 中不存在批注时，运行代码后的结果如图 14-2 所示。</p>
<div>
<p><img src="./assets/14-2.png" alt="" loading="lazy"></p>
<p><u>图 14-2</u>	添加批注</p>
</div>
<h3 id="_3-删除单元格中的批注"> 3）删除单元格中的批注</h3>
<p>如果需要删除单元格中的批注，那么可以使用 ClearComments 方法、ClearNotes 方法或者 Delete 方法，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> Commentdel<span>(</span><span>)</span>
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	Range<span>(</span><span>"A1"</span><span>)</span><span>.</span>ClearComments
	Range<span>(</span><span>"A2"</span><span>)</span><span>.</span>ClearNotes
	Range<span>(</span><span>"A3"</span><span>)</span><span>.</span>Comment<span>.</span>Delete
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>代码解析：</p>
<p>Notesdel 过程删除单元格中的批注。</p>
<p>第 2 行代码错误处理语句，如果单元格中没有批注，那么运行第 5 行代码时会发生错误，所以使用 On Error 语句来忽略错误</p>
<p>第 3 行代码使用 ClearComments 方法删除单元格 <code>A1</code> 中的批注。ClearComments 方法清除指定区域的所有单元格批注，语法如下：</p>
<div><pre><code>expression<span>.</span>ClearComments
</code></pre>
<div><span>1</span><br></div></div><p>第 4 行代码使用 ClearNotes 方法删除 <code>A2</code> 单元格中的批注。ClearNotes 方法清除指定区域中所有单元格的附注和语音批注，语法如下：</p>
<div><pre><code>expression<span>.</span>ClearNotes
</code></pre>
<div><span>1</span><br></div></div><p>第 5 行代码使用 Delete 方法删除删除 <code>A3</code> 单元格中的批注。Range 对象的 Comment 属性返回一个 Comment 对象，该对象代表与该区域左上角单元格相关联的批注。</p>
<h2 id="_15、合并单元格操作"> 15、合并单元格操作</h2>
<h3 id="_1-判断单元格区域是否存在合并单元格"> 1）判断单元格区域是否存在合并单元格</h3>
<p>Range 对象的 MergeCells 属性可以确定单元格区域是否包含合并单元格，如果该属性返回值为 True，则表示区域包含合并单元格。</p>
<p>下面的代码判断单元格 <code>A1</code> 是否包含合并单元格，并显示相应的提示信息。</p>
<div><pre><code><span>Sub</span> IsMergeCell<span>(</span><span>)</span>
	<span>If</span> Range<span>(</span><span>"A1"</span><span>)</span><span>.</span>MergeCells <span>=</span> <span>True</span> <span>Then</span>
		MsgBox <span>"包含合并单元格"</span>
	<span>Else</span>
		MsgBox <span>"没有包含合并单元格"</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>如果在指定区域中存在部分合并的单元格，如图 15-1 所示，区域 <code>E8:I17</code> 中包含合并单元格区域 <code>F8:G9</code>，<code>H12:I13</code>。判断这样一个单元格区域中是否包含合并单元格，可以使用下面的代码快速判断单元格区域中是否包含部分合并单元格，而不需要遍历单元格。</p>
<div>
<p><img src="./assets/15-1.png" alt="" loading="lazy"></p>
<p><u>图 15-1</u>	包含部分合并单元格的区域</p>
</div>
<div><pre><code><span>Sub</span> IsMerge<span>(</span><span>)</span>
	<span>If</span> IsNull<span>(</span>Range<span>(</span><span>"E8:I17"</span><span>)</span><span>.</span>MergeCells<span>)</span> <span>Then</span>
		MsgBox <span>"包含合并单元格"</span>
	<span>Else</span>
		MsgBox <span>"没有包含合并单元格"</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>当单元格区域中同时包含合并单元格和非合并单元格时，MergeCells 属性将返回 Null，因此第 2 行代码通过该返回结果作为判断条件。</p>
<p>运行 IsMerge 过程结果如图 15-2 所示。</p>
<div>
<p><img src="./assets/15-2.png" alt="" loading="lazy"></p>
<p><u>图 15-2</u>	提示信息</p>
</div>
<h3 id="_2-合并单元格时连接每个单元格的文本"> 2）合并单元格时连接每个单元格的文本</h3>
<p>使用 Excel 的“合并及居中”按钮合并多个单元格区域时，Excel 仅保留区域左上角单元格的内容，如果用户希望在合并如图 15-3 所示单元格区域时，将各个单元格的内容连接起来保存在合并后的单元格区域中，则可以使用下面的代码。</p>
<div>
<p><img src="./assets/15-3.png" alt="" loading="lazy"></p>
<p><u>图 15-3</u>	合并前单元格区域</p>
</div>
<div><pre><code><span>Sub</span> Mergerng<span>(</span><span>)</span>
	<span>Dim</span> StrMerge <span>As</span> <span>String</span>
	<span>Dim</span> rng <span>As</span> Range
	<span>If</span> TypeName<span>(</span>Selection<span>)</span> <span>=</span> <span>"Range"</span> <span>Then</span>
		<span>For</span> <span>Each</span> rng <span>In</span> Selection
			StrMerge <span>=</span> StrMerge <span>&amp;</span> rng<span>.</span>Value
		<span>Next</span>
		Application<span>.</span>DisplayAlerts <span>=</span> <span>False</span>
		Selection<span>.</span>Merge
		Selection<span>.</span>Value <span>=</span> StrMerge
		Application<span>.</span>DisplayAlerts <span>=</span> <span>True</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>代码解析：</p>
<p>Mergerng 过程将所选各个单元格的内容连接起来保存在合并后的单元格区域中。</p>
<p>第 4 行代码使用 TypeName 函数判断当前选定对象是否为 Range 对象，若是则继续执行代码。</p>
<p>第 5 行到第 7 行代码将当前选中区域的内容连接起来保存在字符串变量 StrMerge 中。</p>
<p>第 8 行代码将 DisplayAlerts 属性设置为 False，禁止在合并多重数值区域时，Excel 显示的警告信息，如图 15-4 所示，以避免中断代码的运行。</p>
<div>
<p><img src="./assets/15-4.png" alt="" loading="lazy"></p>
<p><u>图 15-4</u>	合并多重数值区域时警告信息</p>
</div>
<p>第 9 行代码使用 Merge 方法合并当前选定区域。应用于 Range 对象的 Merge 方法通过指定 Range 对象创建合并单元格，语法如下：</p>
<div><pre><code>expression<span>.</span>Merge<span>(</span>Across<span>)</span>

参数expression是必需的，返回一个Range对象。
参数Across是可选的，如果该值为<span>True</span>，则将指定区域内的每一行合并为一个合并单元格。默认值为<span>False</span>。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第 9 行也可以使用下面的代码：</p>
<div><pre><code>Selection<span>.</span>MergeCells <span>=</span> <span>True</span>
</code></pre>
<div><span>1</span><br></div></div><p>第 10 行代码将变量 StrMerge 的值赋给合并后的单元格。</p>
<p>运行 Mergerng 过程结果如图 15-5 所示。</p>
<div>
<p><img src="./assets/15-5.png" alt="" loading="lazy"></p>
<p><u>图 15-5</u>	合并单元格结果</p>
</div>
<h3 id="_3-合并内容相同的连续单元格"> 3）合并内容相同的连续单元格</h3>
<p>如果需要合并如图 15-6 所示的工作表中 B 列中部门相同的连续单元格，可以使用下面的代码。</p>
<div>
<p><img src="./assets/15-6.png" alt="" loading="lazy"></p>
<p><u>图 15-6</u>	需合并的工作表</p>
</div>
<div><pre><code><span>Sub</span> Mergerng<span>(</span><span>)</span>
	<span>Dim</span> IntRow <span>As</span> <span>Integer</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	Application<span>.</span>DisplayAlerts <span>=</span> <span>False</span>
	<span>With</span> Sheet1
		IntRow <span>=</span> <span>.</span>Range<span>(</span><span>"A65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row
		<span>For</span> i <span>=</span> IntRow <span>To</span> <span>2</span> <span>Step</span> <span>-</span><span>1</span>
			<span>If</span> <span>.</span>Cells<span>(</span>i<span>,</span> <span>2</span><span>)</span><span>.</span>Value <span>=</span> <span>.</span>Cells<span>(</span>i <span>-</span> <span>1</span><span>,</span> <span>2</span><span>)</span><span>.</span>Value <span>Then</span>
				<span>.</span>Range<span>(</span><span>.</span>Cells<span>(</span>i <span>-</span> <span>1</span><span>,</span> <span>2</span><span>)</span><span>,</span> <span>.</span>Cells<span>(</span>i<span>,</span> <span>2</span><span>)</span><span>)</span><span>.</span>Merge
			<span>End</span> <span>If</span>
		<span>Next</span>
	<span>End</span> <span>With</span>
	Application<span>.</span>DisplayAlerts <span>=</span> <span>True</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>代码解析：</p>
<p>第7行到第 11 行代码，从最后一行开始，向上逐个单元格判断连续两个单元格的内容是否相同，如果相同则合并。</p>
<p>运行 Mergerng 过程后，结果如图 15-7 所示。</p>
<div>
<p><img src="./assets/15-7.png" alt="" loading="lazy"></p>
<p><u>图 15-7</u>	合并内容相同的连续单元格</p>
</div>
<h3 id="_4-取消合并单元格时在每个单元格中保留内容"> 4）取消合并单元格时在每个单元格中保留内容</h3>
<p>如果需要取消如图 15-7 所示的工作表中 B 列“部门”的合并单元格，并且各个单元格均保留原合并单元格的内容，可以使用下面的代码。</p>
<div><pre><code><span>Sub</span> UnMerge<span>(</span><span>)</span>
	<span>Dim</span> StrMer <span>As</span> <span>String</span>
	<span>Dim</span> IntCot <span>As</span> <span>Integer</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>With</span> Sheet1
		<span>For</span> i <span>=</span> <span>2</span> <span>To</span> <span>.</span>Range<span>(</span><span>"B65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row
			StrMer <span>=</span> <span>.</span>Cells<span>(</span>i<span>,</span> <span>2</span><span>)</span><span>.</span>Value
			IntCot <span>=</span> <span>.</span>Cells<span>(</span>i<span>,</span> <span>2</span><span>)</span><span>.</span>MergeArea<span>.</span>Count
			<span>.</span>Cells<span>(</span>i<span>,</span> <span>2</span><span>)</span><span>.</span>UnMerge
			<span>.</span>Range<span>(</span><span>.</span>Cells<span>(</span>i<span>,</span> <span>2</span><span>)</span><span>,</span> <span>.</span>Cells<span>(</span>i <span>+</span> IntCot <span>-</span> <span>1</span><span>,</span> <span>2</span><span>)</span><span>)</span><span>.</span>Value <span>=</span> StrMer
			i <span>=</span> i <span>+</span> IntCot <span>-</span> <span>1</span>
		<span>Next</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>代码解析：</p>
<p>UnMerge 过程取消工作表中 B 列中的合并单元格，并且各个单元格均保留原合并单元格的内容。</p>
<p>第 7 行代码取得 B 列每个合并单元格的内容。</p>
<p>第 8 行代码取得合并区域的单元格数量。</p>
<p>第 9 行代码使用 UnMerge 方法取消合并单元格。UnMerge 方法将合并区域分解为独立的单元格，语法如下：</p>
<div><pre><code>expression<span>.</span>UnMerge
</code></pre>
<div><span>1</span><br></div></div><p>第 10 行代码将原合并单元格的内容赋值给取消合并单元格后的区域。</p>
<p>第 11 行代码调整循环变量 i 的值，使下一次循环从下一个单元格区域开始。</p>
<p>运行 UnMerge 过程结果如图 15-6 所示。</p>
<h2 id="_16、高亮显示单元格区域"> 16、高亮显示单元格区域</h2>
<p>如果希望以某种方式突出显示活动单元格或者指定的单元格区域，从而一目了然地获得某些信息，那么可以高亮显示活动单元格区域，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Worksheet_SelectionChange<span>(</span><span>ByVal</span> Target <span>As</span> Range<span>)</span>
	Cells<span>.</span>Interior<span>.</span>ColorIndex <span>=</span> xlColorIndexNone
	Target<span>.</span>Interior<span>.</span>ColorIndex <span>=</span> <span>8</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>代码解析：</p>
<p>设置工作表当前选定区域单元格的内部填充颜色，以高亮显示选定区域，如图 16-1 所示。</p>
<div>
<p><img src="./assets/16-1.png" alt="" loading="lazy"></p>
<p><u>图 16-1</u>	高亮显示选定区域</p>
</div>
<p>第 2 行代码将工作表中所有的单元格的内部填充颜色设置为 xlColorIndexNone，即取消单元格的内部填充颜色。</p>
<p>第 3 行代码将工作表中选定单元格的内部填充颜色设置为 8。</p>
<p>应用于 Interior 对象的 ColorIndex 属性返回或设置边框内部的颜色。该颜色可指定为当前调色板中颜色的编号（请参阅 11-1 中的图 11-1）或为 XlColorIndex 常量之一：xlColorIndexAutomatic（指定对图形对象自动填充）、xlColorIndexNone（用于指定无内部填充）。</p>
<p>还可以高亮显示指定区域内的行列，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Worksheet_SelectionChange<span>(</span><span>ByVal</span> Target <span>As</span> Range<span>)</span>
	<span>Dim</span> rng <span>As</span> Range
	Cells<span>.</span>Interior<span>.</span>ColorIndex <span>=</span> xlNone
	<span>Set</span> rng <span>=</span> Application<span>.</span>Union<span>(</span>Target<span>.</span>EntireColumn<span>,</span> Target<span>.</span>EntireRow<span>)</span>
	rng<span>.</span>Interior<span>.</span>ColorIndex <span>=</span> <span>24</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>代码解析：</p>
<p>设置工作表当前选定区域单元格内部填充颜色，高亮显示活动单元格所在的行列，如图 16-2 所示。</p>
<p>第 4 行代码使用 Union 方法将所选单元格所在的行、列连接起来成为一个区域，关于 Union 方法请参阅 1-6。</p>
<div>
<p><img src="./assets/16-2.png" alt="" loading="lazy"></p>
<p><u>图 16-2</u>	高亮显示活动单元格所在的行列</p>
</div>
<div><p>注意</p>
<p>使用此方法时，工作表中所有设置的单元格内部填充颜色将会被清除。（不包括通过条件格式设置的单元格内部填充颜色），同时无法在工作表中实现复制粘贴功能。</p>
</div>
<h2 id="_17、双击被保护单元格时不显示提示消息框"> 17、双击被保护单元格时不显示提示消息框</h2>
<p>当用户使用鼠标左键双击被保护工作表中锁定的单元格区域时，系统将显示如图 17-1 所示的消息框。</p>
<div>
<p><img src="./assets/17-1.png" alt="" loading="lazy"></p>
<p><u>图 17-1</u>	系统提示消息框</p>
</div>
<p>如果不希望显示该消息框，可以在工作表 Worksheet_BeforeDoubleClick 事件中进行设置，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Worksheet_BeforeDoubleClick<span>(</span><span>ByVal</span> Target <span>As</span> Range<span>,</span> Cancel <span>As</span> <span>Boolean</span><span>)</span>
	<span>If</span> Target<span>.</span>Locked <span>=</span> <span>True</span> <span>Then</span>
		MsgBox <span>"此单元格已保护，不能编辑!"</span>
		Cancel <span>=</span> <span>True</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>代码解析：</p>
<p>当用户使用鼠标左键双击工作表单元格时，触发 Worksheet_BeforeDoubleClick 事件。该事件中的 Target 参数代表用户双击鼠标左键的单元格区域。</p>
<p>参数 Cancel 设置是否取消该操作。如果将参数 Cancel 设置为 True，将不进行默认的双击操作。</p>
<p>第 2 行代码中判断用户双击鼠标左键的单元格区域是否已锁定（Range 对象的 Locked 属性返回或设置 Range 对象是否锁定），如果单元格区域已锁定，则设置参数 Cancel 设置为 True，不进行默认的双击操作，因而不再显示图 17-1 所示的消息框，只显示一个自定义的提示信息，如图 17-2 所示。</p>
<div>
<p><img src="./assets/17-2.png" alt="" loading="lazy"></p>
<p><u>图 17-2</u>	自定义提示信息</p>
</div>
<h2 id="_18、重新计算工作表指定区域"> 18、重新计算工作表指定区域</h2>
<p>如果在工作表中含有大量公式，那么在对工作表执行重新计算操作时，可能需要较长的时间。在实际工作中，有时希望仅对指定的区域进行重新计算，以提高计算效率，那么可以使用下面的代码。</p>
<div><pre><code><span>Sub</span> CalculationSpecialRange<span>(</span><span>)</span>
	<span>Dim</span> OldCalculation <span>As</span> XlCalculation
	OldCalculation <span>=</span> Application<span>.</span>Calculation
	Application<span>.</span>Calculation <span>=</span> xlCalculationManual
	ActiveSheet<span>.</span>Range<span>(</span><span>"A1:D10"</span><span>)</span><span>.</span>Calculate
	Application<span>.</span>Calculation <span>=</span> OldCalculation
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>CalculationSpecialRange 过程对单元格 <code>A1</code> 到 <code>B10</code> 区域进行重新计算。</p>
<p>第 3 行代码保存当前应用程序的 Calculation 属性设置。应用于 Application 对象的 Calculation 属性返回或设置当前应用程序的计算模式，可为表格 18-1 所示的 XlCalculation 常量之一。</p>
<p><u>表格 18-1</u>	XlCalculation 常量</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>xlCalculationAutomatic</td>
<td>-4105</td>
<td style="text-align:left">自动计算</td>
</tr>
<tr>
<td>xlCalculationManual</td>
<td>-4135</td>
<td style="text-align:left">手动计算</td>
</tr>
<tr>
<td>xlCalculationSemiautomatic</td>
<td>2</td>
<td style="text-align:left">除模拟运算表外自动计算</td>
</tr>
</tbody>
</table>
<p>第 4 行代码将计算模式设置为手动重算。</p>
<p>第 5 行代码重新计算活动工作表指定的单元格区域 <code>B3:D7</code>。（指定区域之外的公式将不重新计算，但包含易失性函数的公式除外）</p>
<p>第 6 行代码恢复当前应用程序的 Calculation 属性设置。</p>
<h2 id="_19、录入数据后单元格自动保护"> 19、录入数据后单元格自动保护</h2>
<p>下面的代码可以使用户在单元格录入数据后自动对已录入数据单元格进行保护，防止修改数据。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Worksheet_SelectionChange<span>(</span><span>ByVal</span> Target <span>As</span> Range<span>)</span>
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	Sheet1<span>.</span>Unprotect Password<span>:</span><span>=</span><span>"12345"</span>
	<span>If</span> Target<span>.</span>Value <span>&lt;</span><span>></span> <span>""</span> <span>Then</span>
		Target<span>.</span>Locked <span>=</span> <span>True</span>
		Sheet1<span>.</span>Protect Password<span>:</span><span>=</span><span>"12345"</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>代码解析：</p>
<p>工作表的 SelectionChange 事件，在单元格录入数据后自动对已录入数据单元格进行保护。</p>
<p>第 3 行代码使用 Unprotect 方法取消工作表的保护。应用于 Worksheet 对象的 Unprotect 方法取消工作表的保护，如果工作表不是受保护的，则此方法不起作用，语法如下：</p>
<div><pre><code>expression<span>.</span>Unprotect<span>(</span>Password<span>)</span>

参数expression是必需的，该表达式返回一个Worksheet 对象。
参数Password是可选的，指定用于解除工作表的保护的密码，此密码是区分大小写的。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第 4、5 行代码单元格录入数据后将 Locked 属性设置为 True。Locked 属性应用于 Range 对象时，如果 Range 对象被锁定，则该值为 True，当工作表有保护时 Range 对象不可被修改。</p>
<p>第 6 行代码使用 Protect 方法保护工作表。应用于 Worksheet 对象的 Protect 方法保护工作表使其不至被修改，语法如下：</p>
<div><pre><code>expression<span>.</span>Protect<span>(</span>Password<span>,</span> DrawingObjects<span>,</span> Contents<span>,</span> Scenarios<span>,</span> UserInterfaceOnly<span>,</span> AllowFormattingCells<span>,</span> AllowFormattingColumns<span>,</span> AllowFormattingRows<span>,</span> AllowInsertingColumns<span>,</span> AllowInsertingRows<span>,</span> AllowInsertingHyperlinks<span>,</span> AllowDeletingColumns<span>,</span> AllowDeletingRows<span>,</span> AllowSorting<span>,</span> AllowFiltering<span>,</span> AllowUsingPivotTables<span>)</span> 

参数expression是必需的，该表达式返回一个Worksheet对象。
参数Password是可选的，为一个字符串，该字符串为工作表指定区分大小写的密码。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>其他参数都是可选参数，其功能等同于如图 19-1 所示的工作表保护对话框中的各项选项，具体请参阅 VBA 帮助。</p>
<div>
<p><img src="./assets/19-1.png" alt="" loading="lazy"></p>
<p><u>图 19-1</u>	工作表保护对话框</p>
</div>
<h2 id="_20、工作表事件-target-参数的使用方法"> 20、工作表事件 Target 参数的使用方法</h2>
<p>在工作表的 SelectionChange 事件中，参数 Target 代表新选定的区域，在工作表的 Change 事件中参数 Target 代表更改的区域。在实际应用中可以使用 Target参 数将触发工作表事件的区域限制在一定的范围内，有以下几种方法：</p>
<h3 id="_1-使用单元格的-address-属性"> 1）使用单元格的 Address 属性</h3>
<p>使用单元格的 Address 属性可以将触发条件限制在某一个单元格中，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Worksheet_SelectionChange<span>(</span><span>ByVal</span> Target <span>As</span> Range<span>)</span>
	<span>If</span> Target<span>.</span>Address<span>(</span><span>0</span><span>,</span> <span>0</span><span>)</span> <span>=</span> <span>"A1"</span> <span>Then</span>
		MsgBox <span>"你选择了A1单元格"</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>代码解析：</p>
<p>当选择工作表 <code>A1</code> 单元格时显示一个消息框。</p>
<p>第 2 行代码使用 Address 属性返回所选单元格的区域引用，当返回的区域引用是“A1”时触发 SelectionChange 事件，显示一个消息框。</p>
<p>此方法只适用于单个单元格或者加上 OR 运算符可以适用于几个单元格，多则不方便。</p>
<h3 id="_2-使用-column-属性和-row-属性"> 2）使用 Column 属性和 Row 属性</h3>
<p>使用单元格的 Column 属性和 Row 属性可以将触发条件限制在某一区域内，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Worksheet_Change<span>(</span><span>ByVal</span> Target <span>As</span> Range<span>)</span>
	<span>If</span> Target<span>.</span>Column <span>=</span> <span>1</span> <span>And</span> Target<span>.</span>Row <span>&lt;</span> <span>11</span> <span>Then</span>
		Target<span>.</span>Offset<span>(</span><span>,</span> <span>1</span><span>)</span> <span>=</span> Val<span>(</span>Target<span>)</span> <span>*</span> <span>3</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>代码解析：</p>
<p>当改变工作表的 <code>A1</code> 到 <code>A10</code> 单元格时，如果输入的是数值则将在对应的 B 列单元格写入乘以 3 的数值。</p>
<p>第 2 行代码使用 Column 属性将触发条件限制在第 1 列，使用 Row 属性将触发条件限制在第 10 行以内，也就是 <code>A1</code> 到 <code>A10</code> 的区域范围内。</p>
<h3 id="_3-使用-intersect-方法"> 3）使用 Intersect 方法</h3>
<p>使用 Intersect 方法可以很方便的指定一个或多个区域范围，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Worksheet_SelectionChange<span>(</span><span>ByVal</span> Target <span>As</span> Range<span>)</span>
	<span>If</span> <span>Not</span> Application<span>.</span>Intersect<span>(</span>Target<span>,</span> Union<span>(</span>Range<span>(</span><span>"A1:A10"</span><span>)</span><span>,</span> Range<span>(</span><span>"C1:C10"</span><span>)</span><span>)</span><span>)</span> <span>Is</span> <span>Nothing</span> <span>Then</span>
		MsgBox <span>"你选择了"</span> <span>&amp;</span> Target<span>.</span>Address<span>(</span><span>0</span><span>,</span> <span>0</span><span>)</span> <span>&amp;</span> <span>"单元格"</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>代码解析：</p>
<p>当选择工作表 <code>A1:A10</code>，<code>C1:C10</code> 单元格时将所选的单元格地址显示在消息框中。</p>
<p>第 2 行代码使用 Intersect 方法判断所选单元格是否与 <code>A1:A10</code>，<code>C1:C10</code> 单元格重叠，如果重叠说明所选单元格在 <code>A1:A10</code>，<code>C1:C10</code> 单元格区域内。Intersect 方法返回一个 Range 对象，此对象代表两个或多个范围重叠的矩形区域，语法如下：</p>
<div><pre><code>expression<span>.</span>Intersect<span>(</span>Arg1<span>,</span> Arg2<span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span>

参数expression是可选的，返回一个Application对象。
参数Arg1<span>,</span> Arg2<span>,</span> <span>.</span><span>.</span><span>.</span>是必需的，重叠的区域。必须指定至少两个 Range对象。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-07-02T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">VBA 之 Sheet 对象</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Excel/04.VBA_Sheet/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Excel/04.VBA_Sheet/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="_21、引用工作表的方式"> 21、引用工作表的方式</h2>
<p>VBA 中，在不同的工作表之间转换或者对不同工作表中的单元格区域进行操作时，需要指定引用的工作表，通常有下面几种方法：</p>
<h3 id="_1-使用工作表的名称"> 1）使用工作表的名称</h3>
<p>工作表名称是指显示在工作表标签中的文本，工作表名称可以使用 WorkSheets 集合和 Sheets 集合两种引用方式，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> ShActivate<span>(</span><span>)</span>
	Worksheets<span>(</span><span>"sheet1"</span><span>)</span><span>.</span>Activate
	Sheets<span>(</span><span>"sheet1"</span><span>)</span><span>.</span>Activate
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第 2、3 行代码都激活工作簿中名称为“sheet1”的工作表，激活后的“sheet1”工作表将成为活动工作表。</p>
<p>WorkSheets 集合包含所有的工作表，而 Sheets 集合不仅包含工作表集合 WorkSheets，还包含图表集合 Charts、宏表集合 Excel4MacroSheets 与 MS Excel 5.0 对话框集合 DialogSheets 等。</p>
<p>任何时刻工作簿中只有一个工作表是活动工作表。</p>
<h3 id="_2-使用工作表的索引号"> 2）使用工作表的索引号</h3>
<p>工作表索引号是指工作表在工作簿中的位置，Excel 根据工作表在工作表标签中的位置以 1 开始从左向右进行编号。下面的代码选中并激活当前工作簿中第 1 个工作表：</p>
<div><pre><code><span>Sub</span> ShIndex<span>(</span><span>)</span>
	Worksheets<span>(</span><span>1</span><span>)</span><span>.</span><span>Select</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>单个 WorkSheet 对象的 Select 方法与 Activate 方法的主要区别在于 Select 方法要求工作表可视。</p>
<div><p>注意</p>
<p>当工作簿包括工作表、宏表、图表等时，使用索引号引用工作表如 Sheets(1) 与 WorkSheets(1) 引用的可能不是同一个表。</p>
</div>
<p>使用 Worksheet 对象的 Index 属性可以返回工作表的索引号，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> ShInde<span>(</span><span>)</span>
	MsgBox Worksheets<span>(</span><span>"sheet1"</span><span>)</span><span>.</span>Index
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="_3-使用工作表的代码名称"> 3）使用工作表的代码名称</h3>
<p>使用 Worksheet 对象的 CodeName 属性可以返回工作表的代码名称，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> ShCodeName<span>(</span><span>)</span>
	MsgBox Sheets<span>(</span><span>1</span><span>)</span><span>.</span>CodeName
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>工作表的代码名称显示在 VBE 工程资源管理器窗口中，在属性窗口中能够修改工作表代码名称，如图 21-1 所示。在 VBA 中能够直接使用工作表的代码名称引用工作表，即使工作表的名称被修改，代码仍然能够正常运行。</p>
<div>
<p><img src="./assets/21-1.png" alt="" loading="lazy"></p>
<p><u>图 21-1</u>	工作表的代码名称</p>
</div>
<h3 id="_4-使用-activesheet-属性引用活动工作表"> 4）使用 ActiveSheet 属性引用活动工作表</h3>
<p>使用 ActiveSheet 属性可以返回活动工作表，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> ShActive<span>(</span><span>)</span>
	MsgBox ActiveSheet<span>.</span>Name
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>ActiveSheet 属性应用于 AppActivate 对象、Window 对象和 Workbook 对象时，如果未给出对象识别符，返回活动工作簿中的活动工作表。</p>
<h2 id="_22、选择工作表的方法"> 22、选择工作表的方法</h2>
<p>在 VBA 中需要激活或者选择某个工作表时使用 Select 方法或 Activate 方法，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> SelectSh<span>(</span><span>)</span>
	Worksheets<span>(</span><span>"Sheet2"</span><span>)</span><span>.</span><span>Select</span>
<span>End</span> <span>Sub</span>
<span>Sub</span> ActivateSh<span>(</span><span>)</span>
	Worksheets<span>(</span><span>"Sheet2"</span><span>)</span><span>.</span>Activate
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>代码解析：</p>
<p>SelectSh 过程使用 Select 方法选择“Sheet2”工作表，而 ActivateSh 过程则使用 Activate 方法选择“Sheet2”工作表，从表面看两者的作用是相同的，但是如果“Sheet2”工作表是隐藏的，Activate 方法可以正常运行，而 Select 方法将会出现错误，如图 22-1 所示。</p>
<div>
<p><img src="./assets/22-1.png" alt="" loading="lazy"></p>
<p><u>图 22-1</u>	Select 方法无效提示</p>
</div>
<p>如果需要同时选中工作簿中的所有工作表，则只能使用 Select 方法而不能使用 Activate 方法，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> SelectShs<span>(</span><span>)</span>
	<span>Dim</span> Shs <span>As</span> Worksheet
	<span>For</span> <span>Each</span> Shs <span>In</span> Worksheets
		Shs<span>.</span><span>Select</span> <span>False</span>
	<span>Next</span>
<span>End</span> <span>Sub</span>
<span>Sub</span> SelectSheets<span>(</span><span>)</span>
	Worksheets<span>.</span><span>Select</span>
<span>End</span> <span>Sub</span>
<span>Sub</span> ArraySheets<span>(</span><span>)</span>
	Worksheets<span>(</span>Array<span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>)</span><span>.</span><span>Select</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>代码解析：</p>
<p>SelectShs 过程遍历工作表并使用带参数的 Select 方法选中所有工作表。应用于 Worksheet 对象的 Select 方法的语法如下：</p>
<div><pre><code><span>Select</span><span>(</span>Replace<span>)</span>

参数Replace是可选的。
如果该值为<span>True</span>，则用指定对象替代当前选定对象。
如果该值为<span>False</span>，则延伸当前选定对象以包括任何以前选定的对象。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>SelectSheets 过程使用 Worksheets 集合的 Select 方法选中集合中所有的对象。</p>
<p>ArraySheets 过程使用 Array 函数返回工作簿中的前三张工作表并使用 Worksheets 集合的 Select 方法选中前三张工作表。</p>
<h2 id="_23、遍历工作表的方法"> 23、遍历工作表的方法</h2>
<p>在 Excel 应用中经常需要遍历工作簿中所有的工作表，有以下两种方法可以实现。</p>
<h3 id="_1-使用-for-next-语句"> 1）使用 For...Next 语句</h3>
<p>使用 For...Next 语句遍历工作簿中所有的工作表，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> ShCount1<span>(</span><span>)</span>
	<span>Dim</span> c <span>As</span> <span>Integer</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>Dim</span> s <span>As</span> <span>String</span>
	c <span>=</span> Worksheets<span>.</span>Count
	<span>For</span> i <span>=</span> <span>1</span> <span>To</span> c
		s <span>=</span> s <span>&amp;</span> Worksheets<span>(</span>i<span>)</span><span>.</span>Name <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span>
	<span>Next</span>
	MsgBox <span>"工作簿中含有以下工作表:"</span> <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>&amp;</span> s
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>代码解析：</p>
<p>ShCount1 过程使用 For...Next 语句遍历工作簿中所有的工作表，并用消息框显示所有的工作表名称。
第 5 行代码根据 Worksheets 对象的 Count 属性返回工作簿中工作表的数量赋给变量 c。应用于Worksheets 对象的 Count 属性返回 Worksheets 集合中工作表的数量，语法如下：</p>
<div><pre><code>expression<span>.</span>Count
</code></pre>
<div><span>1</span><br></div></div><p>第 6 行代码开始 For...Next 语句循环。For...Next 语句以指定次数来重复执行一组语句，语法如下：</p>
<div><pre><code><span>For</span> counter <span>=</span> start <span>To</span> <span>end</span> [<span>Step</span> <span>step</span>]
	[statements]
	[<span>Exit</span> <span>For</span>]
	[statements]
<span>Next</span> [counter]

参数counter是必需的，用做循环计数器的数值变量。
参数start是必需的，循环计数器的初值。
参数<span>end</span>是必需的，循环计数器的终值。
参数<span>step</span>是可选的，环计数器的步长，缺省值为<span>1</span>。
参数statements是可选的，放在<span>For</span>和<span>Next</span>之间的一条或多条语句，它们将被执行指定的次数。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>第 7 行代码在 For...Next 循环中根据工作表的索引号取得所有工作表的名称赋给字符串变量 s。</p>
<p>运行 ShCount 过程结果如图 23-1 所示。</p>
<div>
<p><img src="./assets/23-1.png" alt="" loading="lazy"></p>
<p><u>图 23-1</u>	取得所有工作表名称</p>
</div>
<h3 id="_2-使用-for-each-next-语句"> 2）使用 For Each...Next 语句</h3>
<p>使用 For Each...Next 语句遍历工作簿中所有的工作表，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> ShCount2<span>(</span><span>)</span>
	<span>Dim</span> Sh <span>As</span> Worksheet
	<span>Dim</span> s <span>As</span> <span>String</span>
	<span>For</span> <span>Each</span> Sh <span>In</span> Worksheets
		s <span>=</span> s <span>&amp;</span> Sh<span>.</span>Name <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span>
	<span>Next</span>
	MsgBox <span>"工作簿中含有以下工作表:"</span> <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>&amp;</span> s
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>代码解析：</p>
<p>ShCount2 过程使用 For Each...Next 语句遍历工作簿中所有的工作表，并用消息框显示所有工作表名称。</p>
<p>第 4 行代码使用 For Each...Next 语句遍历 Worksheets 集合中所有元素。For Each...Next 语句针对一个数组或集合中的每个元素，重复执行一组语句，语法如下：</p>
<div><pre><code><span>For</span> <span>Each</span> element <span>In</span> Group
	[statements]
	[<span>Exit</span> <span>For</span>]
	[statements]
<span>Next</span> [element]

参数element是必需的，用来遍历集合或数组中所有元素的变量。
参数group是必需的，对象集合或数组的名称。
参数statements是可选的，针对对象集合或数组中的每一项执行的一条或多条语句。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>第 5 行代码将返回的工作表的名称赋给字符串变量s。</p>
<p>运行 ShCount2 过程结果如图 23-1 所示。</p>
<h2 id="_24、在工作表中上下翻页"> 24、在工作表中上下翻页</h2>
<p>如果需要在工作簿的工作表中进行上下翻页，可以使用下面的代码。</p>
<div><pre><code><span>Sub</span> DownSheet<span>(</span><span>)</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	i <span>=</span> Worksheets<span>.</span>Count
	<span>If</span> ActiveSheet<span>.</span>Index <span>&lt;</span> i <span>Then</span>
		Worksheets<span>(</span>ActiveSheet<span>.</span>Index <span>+</span> <span>1</span><span>)</span><span>.</span>Activate
	<span>Else</span>
		Worksheets<span>(</span><span>1</span><span>)</span><span>.</span>Activate
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
<span>Sub</span> UpSheet<span>(</span><span>)</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	i <span>=</span> Worksheets<span>.</span>Count
	<span>If</span> ActiveSheet<span>.</span>Index <span>></span> <span>1</span> <span>Then</span>
		Worksheets<span>(</span>ActiveSheet<span>.</span>Index <span>-</span> <span>1</span><span>)</span><span>.</span>Activate
	<span>Else</span>
		Worksheets<span>(</span>i<span>)</span><span>.</span>Activate
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>代码解析：</p>
<p>DownSheet 过程向下翻页，第 3、12 行代码使用 Worksheets 对象的 Count 属性取得工作表的数目，第 4 行到第 7 行代码根据 Index 属性判断活动工作表是否是工作簿中的最后一张工作表。如果活动工作表不是最后一张工作表则激活活动工作表的下一张工作表，否则激活第一张工作表。</p>
<p>UpSheet 过程向上翻页，第 13 行到第 16 行代码根据 Index 属性判断活动工作表是否是工作簿中的第一张工作表。如果活动工作表不是第一张工作表则激活活动工作表的上一张工作表，否则激活最后一张工作表。</p>
<h2 id="_25、工作表的添加与删除"> 25、工作表的添加与删除</h2>
<p>在工作簿中添加工作表使用 Add 方法，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> Addsh<span>(</span><span>)</span>
	<span>Dim</span> Sh <span>As</span> Worksheet
	<span>With</span> Worksheets
		<span>Set</span> Sh <span>=</span> <span>.</span>Add<span>(</span>after<span>:</span><span>=</span>Worksheets<span>(</span><span>.</span>Count<span>)</span><span>)</span>
		Sh<span>.</span>Name <span>=</span> <span>"数据"</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>Addsh 过程使用 Add 方法在工作簿中新建“数据”工作表。</p>
<p>第 2 行代码声明变量 Sh 为工作表对象。</p>
<p>第 4 行代码使用 Add 方法在工作簿的最后新建“数据”工作表。</p>
<p>Add 方法应用于 Sheets 和 Worksheets 对象时新建工作表、图表或宏表，语法如下：</p>
<div><pre><code>expression<span>.</span>Add<span>(</span>Before<span>,</span> After<span>,</span> Count<span>,</span> <span>Type</span><span>)</span>

参数Before是可选的，指定工作表对象，新建的工作表将置于此工作表之前。
参数After是可选的，指定工作表对象，新建的工作表将置于此工作表之后。
如果Before和After两者均省略，则新建的工作表将插入到活动工作表之前。
参数Count可选，要新建的工作表的数目。默认值为<span>1</span>。
参数<span>Type</span>可选，指定新建的工作表类型。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>第 5 行代码将添加的工作表重命名为“数据”。</p>
<p>如果需要在工作簿中批量添加工作表，可以使用下面的代码。</p>
<div><pre><code><span>Sub</span> Addsh_2<span>(</span><span>)</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>Dim</span> sh <span>As</span> Worksheet
	<span>For</span> i <span>=</span> <span>1</span> <span>To</span> <span>10</span>
		<span>Set</span> sh <span>=</span> Sheets<span>.</span>Add<span>(</span>after<span>:</span><span>=</span>Sheets<span>(</span>Sheets<span>.</span>Count<span>)</span><span>)</span>
		sh<span>.</span>Name <span>=</span> i
	<span>Next</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>代码解析：</p>
<p>Addsh_2 过程使用 For...Next 语句和 Add 方法在工作簿中添加 10 张工作表并将添加的工作表依次重命名。</p>
<p>在使用以上代码往工作簿中添加工作表时，如果工作簿中已存在相同名称的工作表，运行时会发生错误，代码中断，如图 25-1 所示。</p>
<div>
<p><img src="./assets/25-1.png" alt="" loading="lazy"></p>
<p><u>图 25-1</u>	运行错误提示</p>
</div>
<p>为了避免此错误的发生，可以在添加前先删除所有的工作表，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> Delsh<span>(</span><span>)</span>
	<span>Dim</span> sh <span>As</span> Worksheet
	<span>For</span> <span>Each</span> sh <span>In</span> ThisWorkbook<span>.</span>Sheets
		<span>If</span> sh<span>.</span>Name <span>&lt;</span><span>></span> <span>"工作表的添加与删除"</span> <span>Then</span>
			Application<span>.</span>DisplayAlerts <span>=</span> <span>False</span>
			sh<span>.</span>Delete
			Application<span>.</span>DisplayAlerts <span>=</span> <span>True</span>
		<span>End</span> <span>If</span>
	<span>Next</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>代码解析：</p>
<p>Delsh 过程使用 Delete 方法删除工作簿中除了“工作表的添加与删除”工作表以外所有的工作表。</p>
<p>第 3 行代码使用 For Each...Next 语句遍历代码所在工作簿中所有的工作表。</p>
<p>第 4 行到第 7 行代码判断工作表名称是否为“工作表的添加与删除”，如果不是则使用 Delete 方法删除。其中第 5 行代码将 Application 对象的 DisplayAlerts 属性设置为 False，使删除时不显示如图 25-2 所示系统警告对话框。</p>
<div>
<p><img src="./assets/25-2.png" alt="" loading="lazy"></p>
<p><u>图 25-2</u>	系统警告对话框</p>
</div>
<p>第 6 行代码使用 Delete 方法删除工作表，应用于工作表对象的 Delete 方法删除指定的对象，语法如下：</p>
<div><pre><code>expression<span>.</span>Delete

参数expression是必需的，该表达式返回<span>“应用于”</span>列表中的对象之一。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>在运行添加工作表代码前先删除工作簿中的工作表虽然可以避免同名错误，但也可能误删除有用的工作表，因此更为严谨的方法是在添加前先判断工作簿中是否存在相同名称的工作表，然后再进行下一步的操作。</p>
<p>对于单张工作表可以使用下面的代码。</p>
<div><pre><code><span>Sub</span> Addsh_3<span>(</span><span>)</span>
	<span>Dim</span> Sh <span>As</span> Worksheet
	<span>For</span> <span>Each</span> Sh <span>In</span> Worksheets
		<span>If</span> Sh<span>.</span>Name <span>=</span> <span>"数据"</span> <span>Then</span>
			MsgBox <span>"工作簿中已有""数据""工作表,不能重复添加!"</span>
			<span>Exit</span> <span>Sub</span>
		<span>End</span> <span>If</span>
	<span>Next</span>
	<span>With</span> Worksheets
		<span>Set</span> Sh <span>=</span> <span>.</span>Add<span>(</span>after<span>:</span><span>=</span>Worksheets<span>(</span><span>.</span>Count<span>)</span><span>)</span>
		Sh<span>.</span>Name <span>=</span> <span>"数据"</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>代码解析：</p>
<p>Addsh_3 过程在使用 Add 方法在工作簿中新建“数据”工作表时首先判断工作簿中是否存在“数据”工作表，如果已存在“数据”工作表则不运行添加工作表的代码而只显示一个消息框进行提示，如图 25-3 所示。</p>
<div>
<p><img src="./assets/25-3.png" alt="" loading="lazy"></p>
<p><u>图 25-3</u>	工作表同名提示</p>
</div>
<p>还可以使用错误处理语句来绕过错误，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> Addsh_4<span>(</span><span>)</span>
	<span>Dim</span> sh <span>As</span> Worksheet
	<span>On</span> <span>Error</span> <span>GoTo</span> line
	<span>With</span> Worksheets
		<span>Set</span> sh <span>=</span> <span>.</span>Add<span>(</span>after<span>:</span><span>=</span>Worksheets<span>(</span><span>.</span>Count<span>)</span><span>)</span>
		sh<span>.</span>Name <span>=</span> <span>"数据"</span>
	<span>End</span> <span>With</span>
	<span>Exit</span> <span>Sub</span>
line<span>:</span>
	MsgBox <span>"工作簿中已有""数据""工作表,不能重复添加!"</span>
	Application<span>.</span>DisplayAlerts <span>=</span> <span>False</span>
	Worksheets<span>(</span>Worksheets<span>.</span>Count<span>)</span><span>.</span>Delete
	Application<span>.</span>DisplayAlerts <span>=</span> <span>True</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>代码解析：</p>
<p>Addsh_4 过程是先使用 Add 方法在工作簿中新建“数据”工作表，如果工作簿中已存在同名的工作表则使用 GoTo 语句转移到指定的 line 行处进行提示并删除已添加还没有重命名的工作表，也就是工作簿中最后一张工作表。</p>
<p>如果是批量添加工作表，使用上述方法时，添加工作表和已有工作表重名时，后面即使没有重名的工作表也不能添加，所以应先使用错误处理语句忽略错误，待全部添加好以后再删除多余的工作表，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> Addsh_5<span>(</span><span>)</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span><span>,</span> arr
	<span>Dim</span> sh <span>As</span> Worksheet
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	arr <span>=</span> Array<span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>,</span> <span>10</span><span>)</span>
	<span>For</span> i <span>=</span> <span>0</span> <span>To</span> UBound<span>(</span>arr<span>)</span>
		<span>With</span> Worksheets
			<span>Set</span> sh <span>=</span> <span>.</span>Add<span>(</span>after<span>:</span><span>=</span>Sheets<span>(</span><span>.</span>Count<span>)</span><span>)</span>
			sh<span>.</span>Name <span>=</span> arr<span>(</span>i<span>)</span>
		<span>End</span> <span>With</span>
	<span>Next</span>
	Application<span>.</span>DisplayAlerts <span>=</span> <span>False</span>
	<span>For</span> <span>Each</span> sh <span>In</span> Worksheets
		<span>If</span> sh<span>.</span>Name <span>Like</span> <span>"Sheet*"</span> <span>Then</span> sh<span>.</span>Delete
	<span>Next</span>
	Application<span>.</span>DisplayAlerts <span>=</span> <span>True</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>代码解析：</p>
<p>Addsh_5 过程使用 Add 方法在工作簿中添加 10 张工作表并重新命名为 1 到 10，如果工作簿中已有相同名称的工作表则不添加。</p>
<p>第 4 行代码错误处理语句，当发生重名错误时忽略错误，继续添加工作表。</p>
<p>第 5 行到第 11 行代码在工作簿中添加 10 张工作表并重新命名为 1 到 10，如果工作簿中已有相同名称的工作表则忽略错误重命名时发生的错误，此时工作簿中添加的工作表会以系统赋与的名称命名，如“Sheet1”。</p>
<p>第 12 行到第 15 行代码使用 For Each...Next 语句遍历工作簿中所有的工作表，将工作簿中凡是以“Sheet”开头的工作表删除。</p>
<h2 id="_26、禁止删除指定工作表"> 26、禁止删除指定工作表</h2>
<p>在工作表事件中是没有工作表删除事件的，为了防止用户误删除重要的工作表，除了使用保护工作簿方法外，还可以使用下面的代码。</p>
<div><pre><code><span>Public</span> Ctl <span>As</span> CommandBarControl
<span>Sub</span> DelSht<span>(</span><span>)</span>
	<span>Set</span> Ctl <span>=</span> Application<span>.</span>CommandBars<span>.</span>FindControl<span>(</span>ID<span>:</span><span>=</span><span>847</span><span>)</span>
	Ctl<span>.</span>OnAction <span>=</span> <span>"MyDelSht"</span>
<span>End</span> <span>Sub</span>
<span>Sub</span> ResSht<span>(</span><span>)</span>
	<span>Set</span> Ctl <span>=</span> Application<span>.</span>CommandBars<span>.</span>FindControl<span>(</span>ID<span>:</span><span>=</span><span>847</span><span>)</span>
	Ctl<span>.</span>OnAction <span>=</span> <span>""</span>
<span>End</span> <span>Sub</span>
<span>Sub</span> MyDelSht<span>(</span><span>)</span>
	<span>If</span> VBA<span>.</span>UCase<span>$</span><span>(</span>ActiveSheet<span>.</span>CodeName<span>)</span> <span>=</span> <span>"SHEET2"</span> <span>Then</span>
		MsgBox <span>"禁止删除"</span> <span>&amp;</span> ActiveSheet<span>.</span>Name <span>&amp;</span> <span>"工作表!"</span>
	<span>Else</span>
		ActiveSheet<span>.</span>Delete
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>代码解析：</p>
<p>DelSht 过程将工作表标签右键菜单中的“删除工作表”菜单的 OnAction 属性设置为“MyDelSht”。</p>
<p>第 3 行代码使用 Set 语句将工作表标签右键菜单中的“删除工作表”菜单赋给变量 Ctl，并将其 OnAction 属性设置为 MyDelSht 过程，该菜单被单击时将运行“MyDelSht”过程而不是系统默认的设置。OnAction 属性返回或设置一个 VBA 的过程名，该过程在用户单击或更改某命令栏控件的值时运行。</p>
<p>ResSht 过程将工作表标签右键菜单中的“删除工作表”菜单的 OnAction 属性恢复为默认设置。</p>
<p>MyDelSht 过程判断所要删除的工作表的代码名称是否是“SHEET2”，如果是则禁止删除该表而只显示一个提示消息框。</p>
<p>为了不影响其他工作簿的使用，在 VBE 中双击 ThisWorkbook 写入下面的代码。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Workbook_Activate<span>(</span><span>)</span>
	<span>Call</span> DelSht
<span>End</span> <span>Sub</span>
<span>Private</span> <span>Sub</span> Workbook_Deactivate<span>(</span><span>)</span>
	<span>Call</span> ResSht
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>代码解析：</p>
<p>工作簿的 Activate 事件和 Deactivate 事件代码，在工作簿激活时运行 DelSht 过程，在关闭或打开其他工作簿时运行 ResSht 过程，这样只禁止删除本工作簿中“SHEET2”工作表，并不影响其他工作簿。</p>
<p>当删除本工作簿中的“SHEET2”工作表时，并不会显示如图 26-1 所示的消息框，而只会显示如图 26-2 所示的禁止删除工作表的消息框。</p>
<div>
<p><img src="./assets/26-1.png" alt="" loading="lazy"></p>
<p><u>图 26-1</u>	工作表同名提示</p>
<p><img src="./assets/26-2.png" alt="" loading="lazy"></p>
<p><u>图 26-2</u>	禁止删除工作表</p>
</div>
<h2 id="_27、自动建立工作表目录"> 27、自动建立工作表目录</h2>
<p>如果在工作簿中有许多工作表，使用时往往会建立一张目录表并插入超链接以方便选择工作表。但是如果工作簿中的工作表经常添加和删除，使用手工建立目录很不方便，此时可以使用工作表的 Activate 事件自动建立工作表的目录，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Worksheet_Activate<span>(</span><span>)</span>
	<span>Dim</span> sh <span>As</span> Worksheet
	<span>Dim</span> a <span>As</span> <span>Integer</span>
	<span>Dim</span> R <span>As</span> <span>Integer</span>
	R <span>=</span> Sheet1<span>.</span>[A65536]<span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row
	a <span>=</span> <span>2</span>
	<span>If</span> Sheet1<span>.</span>Cells<span>(</span><span>2</span><span>,</span> <span>1</span><span>)</span> <span>&lt;</span><span>></span> <span>""</span> <span>Then</span>
		Sheet1<span>.</span>Range<span>(</span><span>"A2:A"</span> <span>&amp;</span> R<span>)</span><span>.</span>ClearContents
	<span>End</span> <span>If</span>
	<span>For</span> <span>Each</span> sh <span>In</span> Worksheets
		<span>If</span> sh<span>.</span>CodeName <span>&lt;</span><span>></span> <span>"Sheet1"</span> <span>Then</span>
			Sheet1<span>.</span>Cells<span>(</span>a<span>,</span> <span>1</span><span>)</span><span>.</span>Value <span>=</span> sh<span>.</span>Name
			a <span>=</span> a <span>+</span> <span>1</span>
		<span>End</span> <span>If</span>
	<span>Next</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>代码解析：</p>
<p>工作表的 Activate 事件，在“目录”工作表激活时自动建立工作簿中除“目录”工作表外所有工作表的目录。</p>
<p>第 2、3、4 行代码声明变量类型。</p>
<p>第 5 行代码取得A列最后非空单元格的行号。</p>
<p>第 6 行代码设置变量 a 的初始值为 2，从 <code>A2</code> 单元格开始建立工作表目录。</p>
<p>第 7 行到第 9 行代码判断是否存在工作表目录，如果存在先清空原来的目录，以便更新目录。</p>
<p>第 10 行到第 15 代码遍历工作簿的所有工作表，将除“目录”工作表外所有工作表的名称写入到 A 列单元格中。</p>
<p>为了建立到各工作表的链接，使用工作表的 SelectionChange 事件，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Worksheet_SelectionChange<span>(</span><span>ByVal</span> Target <span>As</span> Range<span>)</span>
	<span>Dim</span> R <span>As</span> <span>Integer</span>
	R <span>=</span> Sheet1<span>.</span>[A65500]<span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	<span>If</span> Target<span>.</span>Count <span>=</span> <span>1</span> <span>Then</span>
		<span>If</span> Target<span>.</span>Column <span>=</span> <span>1</span> <span>Then</span>
			<span>If</span> Target<span>.</span>Row <span>></span> <span>1</span> <span>And</span> Target<span>.</span>Row <span>&lt;</span><span>=</span> R <span>Then</span>
				Sheets<span>(</span>Target<span>.</span>Value<span>)</span><span>.</span><span>Select</span>
			<span>End</span> <span>If</span>
		<span>End</span> <span>If</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>代码解析：</p>
<p>工作表的 SelectionChange 事件，当选择 A 列工作表目录中工作表名称时自动选择该单元格所对应的工作表。</p>
<p>第 5、6、7 行代码限制该事件触发的条件。</p>
<p>第 8 行代码选择单元格所对应的工作表。</p>
<p>“目录”工作表激活后自动在 A 列建立工作簿中除“目录”工作表以外所有表的目录，如图 27-1 所示。</p>
<div>
<p><img src="./assets/27-1.png" alt="" loading="lazy"></p>
<p><u>图 27-1</u>	自动建立工作表目录</p>
</div>
<h2 id="_28、工作表的深度隐藏"> 28、工作表的深度隐藏</h2>
<p>在使用 VBA 开发的工作簿文件完成交与用户使用后，我们往往希望用户在打开工作簿时启用宏，此时除了使用“禁用宏则关闭工作簿”的功能外，还可以隐藏所有有数据的工作表，如果用户在打开工作簿时禁用宏则只显示一张空白的工作表，达到强制启用宏的效果，代码如下：</p>
<div><pre><code><span>Dim</span> sh <span>As</span> Worksheet
<span>Private</span> <span>Sub</span> Workbook_BeforeClose<span>(</span>Cancel <span>As</span> <span>Boolean</span><span>)</span>
	Sheet1<span>.</span>Visible <span>=</span> <span>True</span>
	<span>For</span> <span>Each</span> sh <span>In</span> ThisWorkbook<span>.</span>Sheets
		<span>If</span> sh<span>.</span>Name <span>&lt;</span><span>></span> <span>"空白"</span> <span>Then</span>
			sh<span>.</span>Visible <span>=</span> xlSheetVeryHidden
		<span>End</span> <span>If</span>
	<span>Next</span>
	ActiveWorkbook<span>.</span>Save
<span>End</span> <span>Sub</span>
<span>Private</span> <span>Sub</span> Workbook_Open<span>(</span><span>)</span>
	<span>For</span> <span>Each</span> sh <span>In</span> ThisWorkbook<span>.</span>Sheets
		<span>If</span> sh<span>.</span>Name <span>&lt;</span><span>></span> <span>"空白"</span> <span>Then</span>
			sh<span>.</span>Visible <span>=</span> xlSheetVisible
		<span>End</span> <span>If</span>
	<span>Next</span>
	Sheet1<span>.</span>Visible <span>=</span> xlSheetVeryHidden
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>代码解析：</p>
<p>第 2 行到第 10 行代码是工作簿的 BeforeClose 事件过程，在工作簿关闭前隐藏除“空白”表以外的所有的工作表。</p>
<p>第 3 行代码将“空白”表的 Visible 属性设置为 True，使其可见。</p>
<p>应用于 Charts 和 Worksheets 对象的 Visible 属性决定对象是否可见，语法如下：</p>
<div><pre><code>expression<span>.</span>Visible

参数expression是必需的，该表达式返回上面的对象之一。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>Visible 属性可以设置为表格 28-1 所示的 XlSheetVisibility 常量之一。</p>
<p><u>表格 28-1</u>	XlSheetVisibility 常量</p>
<table>
<thead>
<tr>
<th>常量</th>
<th></th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>xlSheetHidden</td>
<td>0</td>
<td>隐藏对象，可以通过“格式”→“工作表”→“取消隐藏”菜单使对象重新可见，等同于设置为False。</td>
</tr>
<tr>
<td>xlSheetVisible</td>
<td>-1</td>
<td>使对象重新可见，等同于设置为True。</td>
</tr>
<tr>
<td>xlSheetVeryHidden</td>
<td>2</td>
<td>隐藏对象，使该对象重新可见的唯一方法是将此属性设置为True或xlSheetVisible。</td>
</tr>
</tbody>
</table>
<p>第 4 行到第 8 行代码使用 For Each...Next 语句遍历工作簿中所有的工作表，将除“空白”表以外的所有工作表的 Visible 属性设置为 xlSheetVeryHidden，使之隐藏。</p>
<p>Visible 属性设置为 xlSheetVeryHidden 后工作表不能通过“格式”→“工作表”→“取消隐藏”菜单来显示隐藏的工作表。</p>
<p>第 9 行代码使用 Save 方法保存代码所在工作簿的更改，在关闭工作簿时不显示如图 28-1 所示的消息框。</p>
<div>
<p><img src="./assets/28-1.png" alt="" loading="lazy"></p>
<p><u>图 28-1</u>	工作簿保存提示</p>
</div>
<p>第 10 行到第 18 行代码是工作簿的 Open 事件过程，在打开工作簿时将除“空白”表以外的所有工作表的 Visible 属性设置为 xlSheetVisible，取消隐藏。如果打开工作簿时禁用宏，则工作簿中除了“空白”表以外，其他的工作表还处于深度隐藏的状态，如图 28-2 所示，这样就达到强制用户启用宏的效果，当然这还需要 VBA 工程保护的配合。</p>
<div>
<p><img src="./assets/28-2.png" alt="" loading="lazy"></p>
<p><u>图 28-2</u>	工作簿保存提示</p>
</div>
<h2 id="_29、防止更改工作表的名称"> 29、防止更改工作表的名称</h2>
<p>工作表的名称显示在工作表标签上，除了在相应的功能菜单中可以对其进行重命名操作外，在工作表标签上双击鼠标也能修改工作表名称。一旦修改了工作表名称，可能就会产生一连串的问题，例如在其他工作簿中对该工作表的引用将会失效，通过工作表名称引用工作表的代码也将出错。</p>
<p>Excel 没有提供修改工作表名称的相关事件，要禁止用户修改工作表名称，需采取其他一些技巧。比如在工作表 BeforeClose 事件中检验工作表名称，如果工作表名称不是指定的字符串，则将其修改为指定字符串，即保持工作表名称不变，代码如下。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Workbook_BeforeClose<span>(</span>Cancel <span>As</span> <span>Boolean</span><span>)</span>
	<span>If</span> Sheet1<span>.</span>Name <span>&lt;</span><span>></span> <span>"Excel Home"</span> <span>Then</span> Sheet1<span>.</span>Name <span>=</span> <span>"Excel Home"</span>
	ThisWorkbook<span>.</span>Save
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>代码解析：</p>
<p>工作簿的 BeforeClose 事件过程，在关闭当前工作簿时判断 Sheet1 工作表名称，如果不是指定的字符串“Excel Home”，则将其恢复为“Excel Home”后保存工作簿，从而避免更改 Sheet1 工作表名称。</p>
<h2 id="_30、工作表中一次插入多行"> 30、工作表中一次插入多行</h2>
<p>在工作表的中插入多行空行，需要使用 Insert 方法，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> InSertRows_1<span>(</span><span>)</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>For</span> i <span>=</span> <span>1</span> <span>To</span> <span>3</span>
		Sheet1<span>.</span>Rows<span>(</span><span>3</span><span>)</span><span>.</span>Insert
	<span>Next</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>代码解析：</p>
<p>InSertRows_1 过程使用 Insert 方法在如图 30-1 所示的数据区域的第 2 行和第 3 行之间插入三行空行。</p>
<div>
<p><img src="./assets/30-1.png" alt="" loading="lazy"></p>
<p><u>图 30-1</u>	数据区域</p>
</div>
<p>Insert 方法应用于 Range 对象时在工作表或宏表中插入一个单元格或单元格区域，其他单元格作相应移位以腾出空间，语法如下：</p>
<div><pre><code>expression<span>.</span>Insert<span>(</span>Shift<span>,</span> CopyOrigin<span>)</span>

参数expression是必需的，该表达式返回一个Range对象。
参数Shift是可选的，指定单元格的移动方向。可为以下XlInsertShiftDirection常量之一：xlShiftToRight或xlShiftDown。如果省略本参数，Microsoft Excel将依据该区域的形状决定移动方向。
参数CopyOrigin是可选的，复制的起点。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>还可以使用引用多行的方法，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> InSertRows_2<span>(</span><span>)</span>
	Sheet2<span>.</span>Range<span>(</span><span>"A3"</span><span>)</span><span>.</span>EntireRow<span>.</span>Resize<span>(</span><span>3</span><span>)</span><span>.</span>Insert
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>InSertRows_2 过程通过引用多行区域的方法实现一次插入多行。</p>
<p>第 2 行代码中的 Range(“A3”).EntireRow 属性返回 Range(“A3”) 单元格所在的一整行，然后使用 Resize 属性调整行数后插入三行空行。</p>
<p>也可以直接指定相应行再调整行数后插入空行，如下面的示例代码：</p>
<div><pre><code><span>Sub</span> InSertRows_3<span>(</span><span>)</span>
	Sheet3<span>.</span>Rows<span>(</span><span>3</span><span>)</span><span>.</span>Resize<span>(</span><span>3</span><span>)</span><span>.</span>Insert
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>运行以上过程，工作表中如图 30-2 所示。</p>
<div>
<p><img src="./assets/30-2.png" alt="" loading="lazy"></p>
<p><u>图 30-2</u>	插入三行空行</p>
</div>
<h2 id="_31、删除工作表中的空行"> 31、删除工作表中的空行</h2>
<p>如果需要删除如图 31-1 所示的工作表中所有的空行，可以使用下面的代码。</p>
<div>
<p><img src="./assets/31-1.png" alt="" loading="lazy"></p>
<p><u>图 31-1</u>	需删除空行的工作表区域</p>
</div>
<div><pre><code><span>Sub</span> DelBlankRow<span>(</span><span>)</span>
	<span>Dim</span> rRow <span>As</span> <span>Long</span>
	<span>Dim</span> LRow <span>As</span> <span>Long</span>
	<span>Dim</span> i <span>As</span> <span>Long</span>
	rRow <span>=</span> Sheet1<span>.</span>UsedRange<span>.</span>Row
	LRow <span>=</span> rRow <span>+</span> Sheet1<span>.</span>UsedRange<span>.</span>Rows<span>.</span>Count <span>-</span> <span>1</span>
	<span>For</span> i <span>=</span> LRow <span>To</span> rRow <span>Step</span> <span>-</span><span>1</span>
		<span>If</span> Application<span>.</span>WorksheetFunction<span>.</span>CountA<span>(</span>Rows<span>(</span>i<span>)</span><span>)</span> <span>=</span> <span>0</span> <span>Then</span>
			Rows<span>(</span>i<span>)</span><span>.</span>Delete
		<span>End</span> <span>If</span>
	<span>Next</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>代码解析：</p>
<p>DelBlankRow 过程删除工作表中已使用的区域的所有空行。</p>
<p>第 5 行代码获得工作表中已使用区域的首行行号，其中使用 UsedRange 属性返回工作表中已使用的区域。</p>
<p>第 6 行代码获得工作表中已使用区域的最后一行行号。</p>
<p>第 7 行到第 11 行代码从最大行数至最小行数循环判断指定行是否为空行，若为空行则删除该行。</p>
<div><p>注意</p>
<p>此处一定要从最大行数至最小行数开始循环判断，因为如果工作表中存在两行及两行以上的相邻空行，从最小行数开始循环删除的话，当第一行空行被删除后，被删除行下面的一行会往上移位，而此时 For...Next 循环的计数器已经加 1，所以会出现漏删除的现象。</p>
</div>
<p>其中第 8、9 行代码使用工作表 CountA 函数判断当前行已使用单元格的数量，如果为零说明此行是空行则使用 Delete 删除。</p>
<p>应用于 Range 对象的 Delete 方法删除对象，语法如下：</p>
<div><pre><code>expression<span>.</span>Delete<span>(</span>Shift<span>)</span>

参数expression是必需的，返回一个Range对象。
参数Shift是可选的，指定删除单元格时替补单元格的移位方式。可为以下 XlDeleteShiftDirection常量之一：xlShiftToLeft或xlShiftUp。如果省略该参数，则Microsoft Excel将根据区域的图形决定移位方式。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>运行 DelBlankRow 过程工作表区域如图 31-2 所示。</p>
<div>
<p><img src="./assets/31-2.png" alt="" loading="lazy"></p>
<p><u>图 31-2</u>	删除空行的工作表区域</p>
</div>
<h2 id="_32、删除工作表的重复行"> 32、删除工作表的重复行</h2>
<p>在实际应用中，可能需要删除如图 32-1 所示的工作表中 A 列的重复内容而只保留一行，那么可以借助工作表 CountIf 函数来完成，如下面的代码所示。</p>
<div>
<p><img src="./assets/32-1.png" alt="" loading="lazy"></p>
<p><u>图 32-1</u>	需删除重复行的工作表区域</p>
</div>
<div><pre><code><span>Sub</span> DeleteRow<span>(</span><span>)</span>
	<span>Dim</span> R <span>As</span> <span>Integer</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>With</span> Sheet1
		R <span>=</span> <span>.</span>[a65536]<span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row
		<span>For</span> i <span>=</span> R <span>To</span> <span>1</span> <span>Step</span> <span>-</span><span>1</span>
			<span>If</span> WorksheetFunction<span>.</span>CountIf<span>(</span><span>.</span>Columns<span>(</span><span>1</span><span>)</span><span>,</span> <span>.</span>Cells<span>(</span>i<span>,</span> <span>1</span><span>)</span><span>)</span> <span>></span> <span>1</span> <span>Then</span>
				<span>.</span>Rows<span>(</span>i<span>)</span><span>.</span>Delete
			<span>End</span> <span>If</span>
		<span>Next</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>代码解析：</p>
<p>DeleteRow 过程删除工作表 A 列重复单元格所在的整行内容，只保留一行。</p>
<p>第 5 行代码取得工作表中 A 列的最后一个非空单元格的行号。</p>
<p>第 6 行到第 10 行代码从最大行数至最小行数循环判断A列单元格内容是否重复并删除重复单元格所在的整行。此处 For...Next 循环也要从最大行数至最小行数开始循环判断，否则可能会删除不净。其中第 7、8 行代码使用工作表 CountIf 函数判断单元格内容是否重复，如果重复则删除该单元格所在的行。</p>
<p>运行 DeleteRow 过程工作表区域如图 32-2 所示。</p>
<div>
<p><img src="./assets/32-2.png" alt="" loading="lazy"></p>
<p><u>图 32-2</u>	删除重复行的工作表区域</p>
</div>
<h2 id="_33、定位删除特定内容所在的行"> 33、定位删除特定内容所在的行</h2>
<p>如果需要删除如图 33-1 所示的工作表区域中特定内容所在的行，可以使用定位的方法快速删除，无需使用 For...Next 循环对单元格逐个进行判断。</p>
<div>
<p><img src="./assets/33-1.png" alt="" loading="lazy"></p>
<p><u>图 33-1</u>	需删除的工作表区域</p>
</div>
<p>示例代码如下：</p>
<div><pre><code><span>Sub</span> SpecialDelete<span>(</span><span>)</span>
	<span>Dim</span> R <span>As</span> <span>Integer</span>
	<span>With</span> Sheet1
		R <span>=</span> <span>.</span>Range<span>(</span><span>"a65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row
		<span>.</span>Range<span>(</span><span>"a2:a"</span> <span>&amp;</span> R<span>)</span><span>.</span>Replace <span>"Excel"</span><span>,</span> <span>""</span><span>,</span> <span>2</span>
		<span>.</span>Columns<span>(</span><span>1</span><span>)</span><span>.</span>SpecialCells<span>(</span><span>4</span><span>)</span><span>.</span>EntireRow<span>.</span>Delete
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>代码解析：</p>
<p>SpecialDelete 过程删除工作表A列单元格中显示为“Excel”的行。</p>
<p>第 5 行代码使用 Replace 方法将工作表A列中显示为“Excel”的单元格内容替换成空白。</p>
<p>第 6 行代码使用 SpecialCells 方法定位到工作表 A 列中所有的空单元格，使用 Range 对象的 EntireRow 属性返回其所在的整个行一次性删除。</p>
<p>运行 SpecialDelete 过程工作表区域如图 33-2 所示。</p>
<div>
<p><img src="./assets/33-2.png" alt="" loading="lazy"></p>
<p><u>图 33-2</u>	删除后的工作表区域</p>
</div>
<h2 id="_34、判断是否选中整行"> 34、判断是否选中整行</h2>
<p>通过当前选择的单元格区域的单元格数目与行数或列数相比较，判断用户是否选中了整行或整列，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Worksheet_SelectionChange<span>(</span><span>ByVal</span> Target <span>As</span> Range<span>)</span>
	<span>If</span> Target<span>.</span>Rows<span>.</span>Count <span>=</span> <span>1</span> <span>Then</span>
		<span>If</span> Target<span>.</span>Columns<span>.</span>Count <span>=</span> <span>256</span> <span>Then</span>
			MsgBox <span>"您选中了整行,当前行号"</span> <span>&amp;</span> Target<span>.</span>Row
		<span>End</span> <span>If</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>工作表的 SelectionChange 事件，判断用户是否选中了工作表中一整行单元格区域。</p>
<p>第 2 行代码中的 Target.Rows.Count 返回目标区域的行数，确定用户当前选择区域的总行数是否为 1。</p>
<p>第 3 行代码中的 Target.Columns.Count 返回目标区域的列数，确定用户当前选择区域总列数是否为 256。</p>
<p>第 4 行代码当用户选中一整行时显示一个消息框，提示用户当前选择的行号，如图 34-1 所示。</p>
<div>
<p><img src="./assets/34-1.png" alt="" loading="lazy"></p>
<p><u>图 34-1</u>	判断用户是否选中整行</p>
</div>
<p>如果需要判断是否选中了整列，只需将上面代码中的总行数修改为 65536，总列数修改为 1。</p>
<h2 id="_35、限制工作表的滚动区域"> 35、限制工作表的滚动区域</h2>
<p>如果希望限制工作表中滚动的区域，可以通过设置 WorkSheet 对象的 ScrollArea 属性来实现。 ScrollArea 属性使用以A1样式的区域引用形式（字符串类型）返回或设置工作表允许滚动的区域。当设置了工作表滚动区域之后，用户不能选定滚动区域之外的单元格，但仍然可以选定区域之外的其他对象（例如图形、按钮等），同时工作表的一些相应功能可能被禁止（例如工作表全选、选中整行或整列等）。</p>
<p>在 VBE 中的工程管理窗口选择相应工作表对象，然后在其属性窗口中设置 ScrollArea 属性，即可限制工作表中滚动的区域，如图 35-1 所示。</p>
<div>
<p><img src="./assets/35-1.png" alt="" loading="lazy"></p>
<p><u>图 35-1</u>	设置 ScrollArea 属性</p>
</div>
<p>但是 Excel 不会记忆该项设置，当再次打开该工作簿时，ScrollArea 属性将被重置，用户必须重新设置 ScrollArea 属性才能限制工作表中的滚动区域，解决方法是使用代码在工作簿打开时对 ScrollArea 属性进行设置，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Workbook_Open<span>(</span><span>)</span>
	Sheet1<span>.</span>ScrollArea <span>=</span> <span>"B4:H12"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>工作簿的 Open 事件，在打开该工作簿时设置 Sheet1 工作表的滚动区域为“B4:H12”单元格区域。</p>
<p>如果需要取消滚动区域的限制，可以将 ScrollArea 属性值设置为空，如下面的代码所示。</p>
<div><pre><code>Sheet1<span>.</span>ScrollArea <span>=</span> <span>""</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="_36、复制自动筛选后的数据区域"> 36、复制自动筛选后的数据区域</h2>
<p>用户在对如图 36-1 所示的数据列表进行自动筛选后，往往希望将自动筛选的结果复制到其它地方。</p>
<div>
<p><img src="./assets/36-1.png" alt="" loading="lazy"></p>
<p><u>图 36-1</u>	筛选结果</p>
</div>
<p>这时可以通过获取该列表区域中可见单元格的方法得到筛选结果的单元格区域，并复制到工作表 Sheet2 中，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> CopyFilter<span>(</span><span>)</span>
	Sheet2<span>.</span>Cells<span>.</span>Clear
	<span>With</span> Sheet1
		<span>If</span> <span>.</span>FilterMode <span>Then</span>
			<span>.</span>AutoFilter<span>.</span>Range<span>.</span>SpecialCells<span>(</span><span>12</span><span>)</span><span>.</span>Copy Sheet2<span>.</span>Cells<span>(</span><span>1</span><span>,</span> <span>1</span><span>)</span>
		<span>End</span> <span>If</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>代码解析：</p>
<p>CopyFilter 过程将 Sheet1 表中的筛选结果复制到工作表 Sheet2 中。</p>
<p>第 2 行代码清除 Sheet2 表中数据。</p>
<p>第 4 行代码判断 Sheet1 表是否处于自动筛选状态。FilterMode 属性返回工作表是否处于筛选模式，如果指定工作表中包含已筛选序列且该序列中含有隐藏行，则该值为 True。</p>
<p>第 5 行代码通过 AutoFilter 对象的 Range 属性返回工作表的自动筛选列表区域，再使用 SpecialCells 方法获取该列表区域中可见单元格，得到筛选结果的单元格区域，然后使用 Copy 方法将结果区域复制到工作表 Sheet2 中，应用于 Range 对象的 Copy 方法将单元格区域复制到指定的区域或剪贴板中，语法如下：</p>
<div><pre><code>expression<span>.</span>Copy<span>(</span>Destination<span>)</span>

参数expression是必需的，该表达式返回一个Range对象。
参数Destination是可选的，指定区域要复制到的目标区域。如果省略该参数，则将该区域复制到剪贴板中。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>运行 CopyFilter 过程工作表 Sheet2 如图 36-2 所示。</p>
<div>
<p><img src="./assets/36-2.png" alt="" loading="lazy"></p>
<p><u>图 36-2</u>	复制筛选区域</p>
</div>
<h2 id="_37、使用高级筛选获得不重复记录"> 37、使用高级筛选获得不重复记录</h2>
<p>在如图 37-1 所示的数据列表中，如果要将其中不重复的记录复制到另一工作表中，则可以通过高级筛选功能实现。</p>
<div>
<p><img src="./assets/37-1.png" alt="" loading="lazy"></p>
<p><u>图 37-1</u>	数据列表</p>
</div>
<p>示例代码如下：</p>
<div><pre><code><span>Sub</span> Filter<span>(</span><span>)</span>
	Sheet1<span>.</span>Range<span>(</span><span>"A1"</span><span>)</span><span>.</span>CurrentRegion<span>.</span>AdvancedFilter <span>_</span>
		Action<span>:</span><span>=</span>xlFilterCopy<span>,</span> Unique<span>:</span><span>=</span><span>True</span><span>,</span> <span>_</span>
		CopyToRange<span>:</span><span>=</span>Sheet2<span>.</span>Range<span>(</span><span>"A1"</span><span>)</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>代码解析：</p>
<p>Filter 过程使用 AdvancedFilter 方法对单元格 <code>A1</code> 的当前区域筛选不重复的记录，并将筛选结果复制到工作表 Sheet2 中。应用于 Range 集合的 AdvancedFilter 方法语法如下：</p>
<div><pre><code>AdvancedFilter<span>(</span>Action<span>,</span> CriteriaRange<span>,</span> CopyToRange<span>,</span> Unique<span>)</span>

参数Action是必需的，可以为表格<span>37</span><span>-</span><span>1</span>所列的XlFilterAction常量之一。
参数CriteriaRange指定高级筛选操作的条件区域，缺省时表示没有条件限制。
参数CopyToRange表示指定被复制行的目标区域，仅当Action为xlFilterCopy时有效，否则忽略本参数。
参数Unique指示是否选择不重复的记录，如果其值为<span>True</span>，则重复出现的记录仅保留一条；如果其值为<span>False</span>（默认值），则筛选出所有符合条件的记录。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>表格 37-1	XlFilterAction 常量</p>
<table>
<thead>
<tr>
<th>XlFilterAction 常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>xlFilterCopy</td>
<td>2</td>
<td>将筛选结果复制到其他位置</td>
</tr>
<tr>
<td>xlFilterInPlace</td>
<td>1</td>
<td>在原有区域显示筛选结果</td>
</tr>
</tbody>
</table>
<p>运行 FilterUnique 过程，结果如图 37-2 所示。</p>
<div>
<p><img src="./assets/37-2.png" alt="" loading="lazy"></p>
<p><u>图 37-2</u>	得到不重复记录结果</p>
</div>
<h2 id="_38、工作表的保护与解除保护"> 38、工作表的保护与解除保护</h2>
<p>在实际应用中，Excel 编制的报表、表格、程序等，往往在单元格中设置了公式、函数、自定义格式等，为了防止在使用过程中修改或无意中修改这些设置，一般使用 Excel 的工作表保护功能来保护这些设置。</p>
<p>但是程序中可能会使用代码对受保护的工作表进行操作，此时如果没有解除工作表保护，运行出现错误，如图 38-1 所示。</p>
<div>
<p><img src="./assets/38-1.png" alt="" loading="lazy"></p>
<p><u>图 38-1</u>	运行错误提示</p>
</div>
<p>解决方法是在运行操作工作表的代码前先使用代码解除工作表保护，待操作完毕后再保护工作表，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> ShProtect<span>(</span><span>)</span>
	<span>With</span> Sheet1
		<span>.</span>Unprotect Password<span>:</span><span>=</span><span>"12345"</span>
		<span>.</span>Cells<span>(</span><span>1</span><span>,</span> <span>1</span><span>)</span> <span>=</span> <span>100</span>
		<span>.</span>Protect Password<span>:</span><span>=</span><span>"12345"</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>ShProtect 过程在受保护的工作表中对单元格进行操作，其中第 3 行代码使用 Unprotect 方法解除工作表的保护。应用于 Worksheet 对象的 Unprotect 方法解除工作表的保护，如果工作表不是受保护的，则此方法不起作用，所以在解除之前无需判断工作表是否受保护，其语法如下：</p>
<div><pre><code>expression<span>.</span>Unprotect<span>(</span>Password<span>)</span>

参数expression是必需的，该表达式返回一个Worksheet 对象。
参数Password是可选的，指定用于解除工作表的保护的密码，此密码是区分大小写的。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第 4、5 行代码在单元格录入数据后使用 Protect 方法重新保护工作表。应用于 Worksheet 对象的 Protect 方法保护工作表使其不至被修改，语法如下：</p>
<div><pre><code>expression<span>.</span>Protect<span>(</span>Password<span>,</span> DrawingObjects<span>,</span> Contents<span>,</span> Scenarios<span>,</span> UserInterfaceOnly<span>,</span> AllowFormattingCells<span>,</span> AllowFormattingColumns<span>,</span> AllowFormattingRows<span>,</span> AllowInsertingColumns<span>,</span> AllowInsertingRows<span>,</span> AllowInsertingHyperlinks<span>,</span> AllowDeletingColumns<span>,</span> AllowDeletingRows<span>,</span> AllowSorting<span>,</span> AllowFiltering<span>,</span> AllowUsingPivotTables<span>)</span> 

参数expression是必需的，该表达式返回一个Worksheet对象。
参数Password是可选的，为一个字符串，该字符串为工作表指定区分大小写的密码。
其他参数都是可选参数，其功能等同于如图<span>38</span><span>-</span><span>2</span>所示的工作表保护对话框中的各项选项，具体请参阅VBA帮助。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div>
<p><img src="./assets/38-2.png" alt="" loading="lazy"></p>
<p><u>图 38-2</u>	工作表保护选项</p>
</div>
<p>如果一个 Excel 文件使用时间过长，忘记了工作表保护时设置的密码，那么也可以使用 VBA 解除工作表的保护，代码如下：</p>
<div><pre><code><span>Sub</span> RemoveShProtect<span>(</span><span>)</span>
	<span>Dim</span> i1 <span>As</span> <span>Integer</span><span>,</span> i2 <span>As</span> <span>Integer</span><span>,</span> i3 <span>As</span> <span>Integer</span>
	<span>Dim</span> i4 <span>As</span> <span>Integer</span><span>,</span> i5 <span>As</span> <span>Integer</span><span>,</span> i6 <span>As</span> <span>Integer</span>
	<span>Dim</span> i7 <span>As</span> <span>Integer</span><span>,</span> i8 <span>As</span> <span>Integer</span><span>,</span> i9 <span>As</span> <span>Integer</span>
	<span>Dim</span> i10 <span>As</span> <span>Integer</span><span>,</span> i11 <span>As</span> <span>Integer</span><span>,</span> i12 <span>As</span> <span>Integer</span>
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	<span>If</span> ActiveSheet<span>.</span>ProtectContents <span>=</span> <span>False</span> <span>Then</span>
		MsgBox <span>"该工作表没有保护密码！"</span>
		<span>Exit</span> <span>Sub</span>
	<span>End</span> <span>If</span>
	<span>For</span> i1 <span>=</span> <span>65</span> <span>To</span> <span>66</span><span>:</span> <span>For</span> i2 <span>=</span> <span>65</span> <span>To</span> <span>66</span><span>:</span> <span>For</span> i3 <span>=</span> <span>65</span> <span>To</span> <span>66</span>
	<span>For</span> i4 <span>=</span> <span>65</span> <span>To</span> <span>66</span><span>:</span> <span>For</span> i5 <span>=</span> <span>65</span> <span>To</span> <span>66</span><span>:</span> <span>For</span> i6 <span>=</span> <span>65</span> <span>To</span> <span>66</span>
	<span>For</span> i7 <span>=</span> <span>65</span> <span>To</span> <span>66</span><span>:</span> <span>For</span> i8 <span>=</span> <span>65</span> <span>To</span> <span>66</span><span>:</span> <span>For</span> i9 <span>=</span> <span>65</span> <span>To</span> <span>66</span>
	<span>For</span> i10 <span>=</span> <span>65</span> <span>To</span> <span>66</span><span>:</span> <span>For</span> i11 <span>=</span> <span>65</span> <span>To</span> <span>66</span><span>:</span> <span>For</span> i12 <span>=</span> <span>32</span> <span>To</span> <span>126</span>
		ActiveSheet<span>.</span>Unprotect Chr<span>(</span>i1<span>)</span> <span>&amp;</span> Chr<span>(</span>i2<span>)</span> <span>&amp;</span> Chr<span>(</span>i3<span>)</span> <span>&amp;</span> Chr<span>(</span>i4<span>)</span> <span>&amp;</span> Chr<span>(</span>i5<span>)</span> <span>_</span>
		<span>&amp;</span> Chr<span>(</span>i6<span>)</span> <span>&amp;</span> Chr<span>(</span>i7<span>)</span> <span>&amp;</span> Chr<span>(</span>i8<span>)</span> <span>&amp;</span> Chr<span>(</span>i9<span>)</span> <span>&amp;</span> Chr<span>(</span>i10<span>)</span> <span>&amp;</span> Chr<span>(</span>i11<span>)</span> <span>&amp;</span> Chr<span>(</span>i12<span>)</span>
		<span>If</span> ActiveSheet<span>.</span>ProtectContents <span>=</span> <span>False</span> <span>Then</span>
			MsgBox <span>"已经解除了工作表保护！"</span>
			<span>Exit</span> <span>Sub</span>
		<span>End</span> <span>If</span>
	<span>Next</span><span>:</span> <span>Next</span><span>:</span> <span>Next</span><span>:</span> <span>Next</span><span>:</span> <span>Next</span><span>:</span> <span>Next</span>
	<span>Next</span><span>:</span> <span>Next</span><span>:</span> <span>Next</span><span>:</span> <span>Next</span><span>:</span> <span>Next</span><span>:</span> <span>Next</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>代码解析：</p>
<p>RemoveShProtect 过程解除工作表的保护。</p>
<p>其中第 7 行到第 10 行代码判断工作表是否受保护，ProtectContents 属性返回工作表的保护状态，如果工作表的内容处于保护状态，则该值为 True。</p>
<p>第 11 行到第 22 行代码使用 For...Next 语句和 Chr 函数来返回指定字符码所代表的字符串组合不断地尝试解除工作表保护，一旦工作表的 ProtectContents 属性返回 False 说明已经解除工作表保护。</p>
<h2 id="_39、奇偶页打印"> 39、奇偶页打印</h2>
<p>在 Excel 中却没有提供打印奇数页和偶数页的功能，用户可以使用 VBA 在 Excel 中实现该功能，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> PrintOddPage<span>(</span><span>)</span>
	<span>Dim</span> TotalPg <span>As</span> <span>Integer</span>
	TotalPg <span>=</span> ExecuteExcel4Macro<span>(</span><span>"GET.DOCUMENT(50)"</span><span>)</span>
	<span>For</span> i <span>=</span> <span>1</span> <span>To</span> TotalPg <span>Step</span> <span>2</span>
		ActiveSheet<span>.</span>PrintOut From<span>:</span><span>=</span>i<span>,</span> <span>To</span><span>:</span><span>=</span>i
	<span>Next</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>第 3 行代码使用 Excel 4.0 宏表函数获取总页数，通过该函数获取总页数而无需判断分页符。</p>
<p>第 4 行到第 6 行代码逐页打印所有奇数页，其中第 5 行代码中的参数 From 和 To 指定打印的开始页数和结束页数。</p>
<p>将第 4 行代码中的数值改为 2，则实现偶数页的打印。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-07-02T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">VBA 之 Workbook 对象</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Excel/05.VBA_Workbook/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Excel/05.VBA_Workbook/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="_40、工作簿的引用方法"> 40、工作簿的引用方法</h2>
<p>VBA 中，在不同的工作簿之间转换需要指定引用的工作簿，通常有下面几种方法。</p>
<h3 id="_1-使用工作簿的名称"> 1）使用工作簿的名称</h3>
<p>工作簿名称是指 Excel 文件的文件名，可以使用 Workbooks 集合引用方式来引用工作簿，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> WbPath <span>(</span><span>)</span>
	MsgBox <span>"名称为："</span> <span>&amp;</span> Workbooks<span>(</span><span>"工作簿的引用方法.xls"</span><span>)</span><span>.</span>Path
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>WbPath 过程显示工作簿“工作簿的引用方法”的路径。应用于 Workbook 对象的 Path 属性将完整路径返回给应用程序，语法如下：</p>
<div><pre><code>expression<span>.</span>Path

参数expression是必需的，一个有效的对象。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>运行 WbPath 过程结果如图 40-1 所示。</p>
<div>
<p><img src="./assets/40-1.png" alt="" loading="lazy"></p>
<p><u>图 40-1</u>	返回工作簿完整路径</p>
</div>
<h3 id="_2-使用工作簿的索引号"> 2）使用工作簿的索引号</h3>
<p>工作簿索引号是指工作簿打开的顺序，Excel根据工作簿打开的顺序以1开始进行编号。下面的代码显示应用程序打开的第一个工作簿的名称。</p>
<div><pre><code><span>Sub</span> WbName<span>(</span><span>)</span>
	MsgBox <span>"第一个打开的工作簿名字为："</span> <span>&amp;</span> Workbooks<span>(</span><span>1</span><span>)</span><span>.</span>Name
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>WbName 过程显示应用程序打开的第一个工作簿的名称。应用于 Workbook 对象的 Name 属性返回对象的名称，语法如下：</p>
<div><pre><code>expression<span>.</span>Name

参数expression是必需的，一个有效的对象。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>运行 WbName 过程结果如图 40-2 所示。</p>
<div>
<p><img src="./assets/40-2.png" alt="" loading="lazy"></p>
<p><u>图 40-2</u>	返回工作簿名称</p>
</div>
<p>如果需要返回包含完整路径的工作簿名称则使用 Workbook 对象的 FullName 属性，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> WbFullName<span>(</span><span>)</span>
	MsgBox <span>"包括完整路径的工作簿名称为："</span> <span>&amp;</span> Workbooks<span>(</span><span>1</span><span>)</span><span>.</span>FullName
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>WbFullName 过程显示应用程序打开的第一个工作簿的完整路径和名称。FullName 属性返回对象的名称，包括其磁盘路径的字符串，此属性等价于在 Path 属性后加上当前文件系统的分隔符，然后加上 Name 属性。</p>
<p>运行 WbFullName 过程结果如图 40-3 所示。</p>
<div>
<p><img src="./assets/40-3.png" alt="" loading="lazy"></p>
<p><u>图 40-3</u>	返回包含完整路径的工作簿名称</p>
</div>
<h3 id="_3-使用-thisworkbook"> 3）使用 ThisWorkbook</h3>
<p>使用 ThisWorkbook 代表当前宏代码运行的工作簿，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> WbClose<span>(</span><span>)</span>
	ThisWorkbook<span>.</span>Close SaveChanges<span>:</span><span>=</span><span>False</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>WbThis 过程使用 Close 方法关闭当前宏代码运行的工作簿，不保存对工作簿的任何更改。关于应用于 Workbook 对象的 Close 方法请参阅 45-1。</p>
<div><p>注意</p>
<p>本属性仅可在 Microsoft Excel 内使用。不能使用此属性访问任何其他应用程序的工作簿。</p>
</div>
<h3 id="_4-使用-activeworkbook"> 4）使用 ActiveWorkbook</h3>
<p>使用 ActiveWorkbook 代表活动窗口（最上面的窗口）的工作簿，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> WbActive<span>(</span><span>)</span>
	MsgBox <span>"当前活动工作簿名字为："</span> <span>&amp;</span> ActiveWorkbook<span>.</span>Name
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>WbActive 过程显示活动工作簿的名称，ActiveWorkbook 属性返回一个 Workbook 对象，该对象代表活动窗口（最上面的窗口）的工作簿。如果没有打开任何窗口或者活动窗口为信息窗口或剪贴板窗口，则返回 Nothing。</p>
<p>运行 WbActive 过程结果如图 40-4 所示。</p>
<div>
<p><img src="./assets/40-4.png" alt="" loading="lazy"></p>
<p><u>图 40-4</u>	返回活动工作簿名称</p>
</div>
<h2 id="_41、新建工作簿文件"> 41、新建工作簿文件</h2>
<p>在 VBA 中使用 Add 方法新建工作簿，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> AddNowbook<span>(</span><span>)</span>
	<span>Dim</span> Nowbook <span>As</span> Workbook
	<span>Dim</span> ShName <span>As</span> <span>Variant</span>
	<span>Dim</span> Arr <span>As</span> <span>Variant</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>Dim</span> myNewWorkbook <span>As</span> <span>Integer</span>
	myNewWorkbook <span>=</span> Application<span>.</span>SheetsInNewWorkbook
	ShName <span>=</span> Array<span>(</span><span>"余额"</span><span>,</span> <span>"单价"</span><span>,</span> <span>"数量"</span><span>,</span> <span>"金额"</span><span>)</span>
	Arr <span>=</span> Array<span>(</span><span>"01月"</span><span>,</span> <span>"02月"</span><span>,</span> <span>"03月"</span><span>,</span> <span>"04月"</span><span>,</span> <span>"05月"</span><span>,</span> <span>"06月"</span><span>,</span> <span>"07月"</span><span>,</span> <span>"08月"</span><span>,</span> <span>"09月"</span><span>,</span> <span>"10月"</span><span>,</span> <span>"11月"</span><span>,</span> <span>"12月"</span><span>)</span>
	Application<span>.</span>SheetsInNewWorkbook <span>=</span> <span>4</span>
	<span>Set</span> Nowbook <span>=</span> Workbooks<span>.</span>Add
	<span>With</span> Nowbook
		<span>For</span> i <span>=</span> <span>1</span> <span>To</span> <span>4</span>
			<span>With</span> <span>.</span>Sheets<span>(</span>i<span>)</span>
				<span>.</span>Name <span>=</span> ShName<span>(</span>i <span>-</span> <span>1</span><span>)</span>
				<span>.</span>Range<span>(</span><span>"B1"</span><span>)</span><span>.</span>Resize<span>(</span><span>1</span><span>,</span> UBound<span>(</span>Arr<span>)</span> <span>+</span> <span>1</span><span>)</span> <span>=</span> Arr
				<span>.</span>Range<span>(</span><span>"A2"</span><span>)</span> <span>=</span> <span>"品名"</span>
			<span>End</span> <span>With</span>
		<span>Next</span>
		<span>.</span>SaveAs Filename<span>:</span><span>=</span>ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\"</span> <span>&amp;</span> <span>"存货明细.xls"</span>
		<span>.</span>Close Savechanges<span>:</span><span>=</span><span>True</span>
	<span>End</span> <span>With</span>
	<span>Set</span> Nowbook <span>=</span> <span>Nothing</span>
	Application<span>.</span>SheetsInNewWorkbook <span>=</span> myNewWorkbook
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>代码解析：</p>
<p>AddNowbook 过程使用 Add 方法建立新的工作簿并对新建工作簿进行操作。</p>
<p>第 2 行到第 6 行代码声明变量类型。</p>
<p>第 7 行代码保存 Excel 自动插入到新工作簿中的工作表数目。</p>
<p>第 8、9 行代码将数组元素赋值给变量。</p>
<p>第 10 行代码将 Application 对象的 SheetsInNewWorkbook 属性设置为 4，在新建工作簿时插入 4 张工作表。</p>
<p>第 11 行代码使用 Add 方法建立新的工作簿，应用于 Workbooks 对象的 Add 方法新建工作簿，新建的工作簿将成为活动工作簿。</p>
<p>第 12 行到第 22 行代码操作新建工作簿。其中第 15 行到第 17 行代码将新建工作簿的工作表进行重命名并给单元格赋值。第 20 行代码使用 SaveAs 方法将新建工作簿重命名为“存货明细.xls”保存在同一目录中。关于 SaveAs 方法请参阅 47-2。第 21 行代码使用 Close 方法关闭工作簿。关于 Close 方法请参阅 45-1。</p>
<p>第 24 行代码恢复工作簿的默认设置。</p>
<p>运行 AddNowbook 过程将在工作簿同一目录中新建“存货明细.xls”工作簿，新建工作簿格式如图 41-1 所示。</p>
<div>
<p><img src="./assets/41-1.png" alt="" loading="lazy"></p>
<p><u>图 41-1</u>	新建“存货明细.xls”工作簿格式</p>
</div>
<div><p>注意</p>
<p>本例中没有考虑工作簿同名因素，如果目录中已有“存货明细.xls”工作簿，运行时会显示如图 41-2 所示的对话框，选择“是”即可，否则将会出错。</p>
</div>
<div>
<p><img src="./assets/41-2.png" alt="" loading="lazy"></p>
<p><u>图 41-2</u>	同名提示</p>
</div>
<h2 id="_42、打开指定的工作簿"> 42、打开指定的工作簿</h2>
<p>VBA 中使用 Open 方法打开一个工作簿，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> Openfile<span>(</span><span>)</span>
	<span>Dim</span> x <span>As</span> <span>Integer</span>
	<span>For</span> x <span>=</span> <span>1</span> <span>To</span> Workbooks<span>.</span>Count
		<span>If</span> Workbooks<span>(</span>x<span>)</span><span>.</span>Name <span>=</span> <span>"123.xls"</span> <span>Then</span>
			MsgBox <span>"""123""工作簿已经打开!"</span>
			<span>Exit</span> <span>Sub</span>
		<span>End</span> <span>If</span>
	<span>Next</span>
	Workbooks<span>.</span>Open ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\123.xls"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>代码解析：</p>
<p>Openfile 过程打开同一目录中的“123”工作簿。</p>
<p>第 3 行代码利用 Workbook 对象的 Count 属性取得打开工作簿的数目，使用 For...Next 语句遍历所有打开的工作簿。遍历工作簿除了使用 For...Next 语句外还可以使用 For...Each...Next 语句来遍历 Workbook 对象集合中的所有元素。</p>
<p>第 4 行到第 8 行代码遍历所有打开的工作簿，如果 Workbook 对象集合中存在“123”工作簿，说明“123”工作簿已打开，则显示一条如图 42-1 所示的提示信息。</p>
<div>
<p><img src="./assets/42-1.png" alt="" loading="lazy"></p>
<p><u>图 42-1</u>	工作簿已打开提示</p>
</div>
<p>Open 方法应用于 Workbooks 对象时打开一个工作簿，语法如下：</p>
<div><pre><code>expression<span>.</span>Open<span>(</span>FileName<span>,</span> UpdateLinks<span>,</span> <span>ReadOnly</span><span>,</span> Format<span>,</span> Password<span>,</span> WriteResPassword<span>,</span> IgnoreReadOnlyRecommended<span>,</span> Origin<span>,</span> Delimiter<span>,</span> Editable<span>,</span> Notify<span>,</span> Converter<span>,</span> AddToMru<span>,</span> Local<span>,</span> CorruptLoad<span>)</span>

参数expression是必需的，返回一个Workbooks对象
参数FileName是必需的，要打开的工作簿的文件名。
参数UpdateLinks是可选的，指定文件中链接的更新方式。如果省略本参数，则提示用户选择链接的更新方式。否则，该参数的取值应为表格<span>42</span><span>-</span><span>1</span>中的某个值。
参数<span>ReadOnly</span>是可选的，如果该值为<span>True</span>，则以只读模式打开工作簿。
参数Format是可选的，如果Microsoft Excel正在打开一个文本文件，则该参数用于指定分隔字符，如表格<span>42</span><span>-</span><span>2</span>所示。如果省略本参数，则使用当前的分隔符。
参数Password是可选的，该字符串指定打开一个受保护工作簿的密码。如果省略该参数并且指定工作簿已设置密码，则提示用户输入密码。
参数WriteResPassword是可选的，该字符串为一个写保护工作簿的写入权密码。如果省略该参数并且指定工作簿已设置密码，则提示用户输入密码。
参数IgnoreReadOnlyRecommended是可选的，如果该值为<span>True</span>，则设置Microsoft Excel不显示建议只读消息（如果该工作簿以<span>“建议只读”</span>选项保存）。
参数Origin是可选的，如果文件为文本文件，则该参数用于指示该文件来源于何种操作系统。
参数Delimiter是可选的，如果该文件为文本文件并且Format参数为 <span>6</span>，则此参数用于指定用作分隔符的字符。
参数Editable是可选的，如果该文件为Microsoft Excel <span>4.0</span>加载宏，则该参数的值为<span>True</span>时可打开该加载宏以便在窗口中看到。如果该参数的值为<span>False</span>或者省略该参数，则该加载宏以隐藏方式打开，并且无法设为可见。
参数Notify是可选的，当该文件不能以可读写模式打开时，如果该参数的值为<span>True</span>，则可将该文件添加到文件通知列表。
参数Converter是可选的，打开文件时试用的第一个文件转换器的索引号。
参数AddToMru是可选的，如果该值为<span>True</span>，则将该工作簿添加到最近使用的文件列表中。默认值为<span>False</span>。
参数Local是可选的，如果该值为<span>True</span>，则以Microsoft Excel（包括控制面版设置）的语言保存文件。如果该值为<span>False</span>（默认值），则以 Visual Basic <span>for</span> Applications <span>(</span>VBA<span>)</span>的语言保存文件，其中Visual Basic <span>for</span> Applications <span>(</span>VBA<span>)</span>为典型安装的美国英语版本，除非VBA项目的Workbooks<span>.</span>Open来自旧的国际化的XL5<span>/</span><span>95</span> VBA项目。
参数CorruptLoad是可选的，可为以下常量之一：xlNormalLoad、xlRepairFile 和 xlExtractData。如果未指定任何值，则默认值通常为普通状态。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p><u>表格 42-1</u>	UpdateLinks 参数值</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>不更新任何引用</td>
</tr>
<tr>
<td>1</td>
<td>更新外部引用，但不更新远程引用</td>
</tr>
<tr>
<td>2</td>
<td>更新远程引用，但不更新外部引用</td>
</tr>
<tr>
<td>3</td>
<td>同时更新远程引用和外部引用</td>
</tr>
</tbody>
</table>
<p><u>表格 42-2</u>	Format 参数值</p>
<table>
<thead>
<tr>
<th>值</th>
<th>分隔符</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>制表符</td>
</tr>
<tr>
<td>2</td>
<td>逗号</td>
</tr>
<tr>
<td>3</td>
<td>空格</td>
</tr>
<tr>
<td>4</td>
<td>分号</td>
</tr>
<tr>
<td>5</td>
<td>没有分隔符</td>
</tr>
<tr>
<td>6</td>
<td>自定义字符(请参阅 Delimiter 参数)</td>
</tr>
</tbody>
</table>
<h2 id="_43、判断指定工作簿是否打开"> 43、判断指定工作簿是否打开</h2>
<h3 id="_1-遍历-workbooks-集合方法"> 1）遍历 Workbooks 集合方法</h3>
<p>通过遍历当前应用程序所有已打开的工作簿文件（Workbooks 集合），判断指定名称的工作簿是否打开，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> WorkbookIsOpen_1<span>(</span><span>)</span>
	<span>Dim</span> Wb <span>As</span> Workbook
	<span>Dim</span> myWb <span>As</span> <span>String</span>
	myWb <span>=</span> <span>"Excel Home.xls"</span>
	<span>For</span> <span>Each</span> Wb <span>In</span> Workbooks
		<span>If</span> Wb<span>.</span>Name <span>=</span> myWb <span>Then</span>
			MsgBox <span>"工作簿"</span> <span>&amp;</span> myWb <span>&amp;</span> <span>"已经被打开!"</span>
			<span>Exit</span> <span>Sub</span>
		<span>End</span> <span>If</span>
	<span>Next</span>
	MsgBox <span>"工作簿"</span> <span>&amp;</span> myWb <span>&amp;</span> <span>"没有被打开!"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>代码解析：</p>
<p>WorkbookIsOpen_1 过程通过遍历当前应用程序中所有已打开的工作簿文件（Workbooks 集合），判断“Excel Home”工作簿是否打开。</p>
<p>第 5 行代码使用 For...Each...Next 语句来遍历 Workbook 对象集合中的所有元素。</p>
<p>第 6 行到第 8 行代码如果 Workbook 对象集合包含“Excel Home.xls”工作簿名称，说明文件已打开，使用 Exit Sub 语句结束代码的运行。</p>
<p>第 11 行代码如果运行到此行代码说明“Excel Home.xls”工作簿没有被打开。</p>
<h3 id="_2-错误处理方法"> 2）错误处理方法</h3>
<p>使用错误处理程序判断指定名称的工作簿是否打开，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> WorkbookIsOpen_2<span>(</span><span>)</span>
	<span>Dim</span> Wb <span>As</span> Workbook
	<span>Dim</span> myWb <span>As</span> <span>String</span>
	myWb <span>=</span> <span>"Excel Home.xls"</span>
	Err<span>.</span>Clear
	<span>On</span> <span>Error</span> <span>GoTo</span> line
	<span>Set</span> Wb <span>=</span> Application<span>.</span>Workbooks<span>(</span>myWb<span>)</span>
	MsgBox <span>"工作簿"</span> <span>&amp;</span> myWb <span>&amp;</span> <span>"已经被打开!"</span>
	<span>Set</span> Wb <span>=</span> <span>Nothing</span>
	<span>Exit</span> <span>Sub</span>
line<span>:</span>
	MsgBox <span>"工作簿"</span> <span>&amp;</span> myWb <span>&amp;</span> <span>"没有被打开!"</span>
	<span>Set</span> Wb <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>代码解析：</p>
<p>WorkbookIsOpen_2 过程使用错误处理程序判断“Excel Home”工作簿是否打开。</p>
<p>第 5 行代码使用 Clear 方法清除 Err 对象的所有属性设置。</p>
<p>第 6 行代启动错误处理程序，如果第7行代码发生错误则执行 line 行后面的代码。</p>
<p>第 7 行代码使用 Set 语句将 Workbook 对象引用赋给变量 Wb，如果 “Excel Home.xls”工作簿没有被打开将发生下标越界错误，此时执行第 12、13 行代码，否则执行第 8、9 行代码。</p>
<h2 id="_44、禁用宏则关闭工作簿"> 44、禁用宏则关闭工作簿</h2>
<p>通常情况下，当应用程序的宏安全性的安全级别设置为“中”时，打开包含 Microsoft Excel 4.0 版的宏的工作簿，将显示如图 44-1 所示的“安全警告”对话框。</p>
<div>
<p><img src="./assets/44-1.png" alt="" loading="lazy"></p>
<p><u>图 44-1</u>	安全警告对话框</p>
</div>
<p>如果用户选择“禁用宏”按钮，则会显示如图 44-2 所示的警告消息框，当用户选择“否”时，不能打开该工作簿；用户选择“是”时，打开该工作簿，但 VBA 宏被禁止，而 Microsoft Excel 4.0 版的宏未被禁止。</p>
<div>
<p><img src="./assets/44-2.png" alt="" loading="lazy"></p>
<p><u>图 44-2</u>	Microsoft Excel 4.0 宏警告对话框</p>
</div>
<p>我们可以利用禁用 VBA 宏不能禁止 Microsoft Excel 4.0 版的宏这个特点，使用 Microsoft Excel 4.0 版的宏来实现禁用宏则关闭工作簿的功能。</p>
<ul>
<li>
<p>步骤 1	新建或打开需要添加此项功能的工作簿文件。</p>
</li>
<li>
<p>步骤 2	按 &lt;Ctrl+F11&gt; 组合键为工作簿添加一个宏表，添加的宏表名称默认为“Macro1”。</p>
</li>
<li>
<p>步骤 3	在宏表“Macro1”的 A1 至 A7 单元格中输入下面的内容。</p>
</li>
</ul>
<p>完成后的宏表如图 44-3 所示。</p>
<div>
<p><img src="./assets/44-3.png" alt="" loading="lazy"></p>
<p><u>图 44-3</u>	完成输入后的宏表</p>
</div>
<p>代码解析：</p>
<p>Microsoft Excel 4.0 宏函数以等号（=）开始，其他不是由等号开始的内容将被视作注释。通常用作定义的宏名称或者作为宏函数实现功能的注释内容设置为斜体字样以示区别，如图 44-3 中单元格 A1 所示。</p>
<p>第 2 行代码关闭错误检查功能。如果关闭错误检查，那么当宏执行遇到错误时，Microsoft Excel  将不予理会而继续执行。</p>
<p>第 3 行到第 6 行代码使用If函数与 End.If 函数构成条件判断语句。其中，第 3 行中的语句通过检查宏函数 RUN(&quot;TestMacro&quot;) 的返回错误类型是否为 4（禁用宏时的返回结果），判断工作簿是否禁用了宏功能。如果第 3 行的结果为 True，则执行下面的语句。</p>
<p>在第 4、5 行代码，插入几个空格来表示相关代码之间的层次结构。第 4 行中的代码显示一个消息框。第 5 行中的代码关闭当前活动工作簿，设置参数值为 Fasle 表示关闭时工作簿时不保存对其所作的更改。</p>
<p>第 7 行代码终止当前代码的执行。Microsoft Excel 4.0 宏要求每个宏必须使用 RETURN 或 HALT 函数结束。</p>
<ul>
<li>步骤 4	为每个表添加工作表级别的名称“Auto_Activate”，并将引用都指向宏表“Macro1”的 A2 单元格。“Auto_Activate”是一个自动宏，表被激活时自动执行。</li>
</ul>
<p>添加工作表级别的名称的方法如下：选择一张工作表，假设为表“Sheet1”，单击菜单“插入”→“名称”→“定义名称”。在“定义名称”对话框中添加名称，如图 44-4 所示。</p>
<div>
<p><img src="./assets/44-4.png" alt="" loading="lazy"></p>
<p><u>图 44-4</u>	定义工作表级别的名称</p>
</div>
<p>输入完成后单击“确定”按钮，完成一张工作表的“Auto_Activate”的定义。完成定义后的名称将在“定义名称”对话框中显示，如图 44-5 所示。依次为每个表添加“Auto_Activate”名称。</p>
<div>
<p><img src="./assets/44-5.png" alt="" loading="lazy"></p>
<p><u>图 44-5</u>	名称对话框中的工作表级名称</p>
</div>
<p>此外，使用 VBA 也可以实现同样的操作，并且使用 VBA 的好处是能够隐藏名称，以避免名称被删除或修改。代码如下：</p>
<div><pre><code><span>Sub</span> AddPrivateNames<span>(</span><span>)</span>
	<span>Dim</span> sht <span>As</span> <span>Object</span>
	<span>For</span> <span>Each</span> sht <span>In</span> Sheets
		ThisWorkbook<span>.</span>Names<span>.</span>Add sht<span>.</span>Name <span>&amp;</span> <span>"!Auto_Activate"</span><span>,</span> <span>_</span>
<span>"=Macro1!$A$2"</span><span>,</span> <span>False</span>
	<span>Next</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>
<li>步骤 5	运行下面的代码，隐藏宏表工作表：</li>
</ul>
<div><pre><code><span>Sub</span> HideMacroSheet<span>(</span><span>)</span>
	ThisWorkbook<span>.</span>Excel4MacroSheets<span>(</span><span>1</span><span>)</span><span>.</span>Visible <span>=</span> xlSheetHidden
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>步骤 6	保存工作簿。</li>
</ul>
<p>当应用程序的宏安全性的安全级设置为“中”时，如果用户打开该工作簿文件并选择“禁用宏”，将显示如图 44-2 所示的警告消息框。当用户选择“是”时，活动工作表上的自动宏“Auto_Activate”将被执行，执行结果显示如图 44-6 所示的消息框，当用户选择“确定”按钮后，将强制关闭该工作簿文件。</p>
<div>
<p><img src="./assets/44-6.png" alt="" loading="lazy"></p>
<p><u>图 44-6</u>	警告消息框</p>
</div>
<h2 id="_45、关闭工作簿不显示保存对话框"> 45、关闭工作簿不显示保存对话框</h2>
<p>当用户更改工作簿后，没有进行保存操作而直接关闭工作簿时，将显示如图 45-1 所示的消息框，提示用户是否保存对工作簿的更改，如果希望不显示该消息框而直接关闭关闭工作簿，可以在关闭时进行相应的设置。</p>
<div>
<p><img src="./assets/45-1.png" alt="" loading="lazy"></p>
<p><u>图 45-1</u>	提示保存对话框</p>
</div>
<h3 id="_1-使用-close-方法关闭工作簿"> 1）使用 Close 方法关闭工作簿</h3>
<p>使用 Close 方法关闭工作簿的，可以在 Close 方法中指定相应的参数，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> wbClose_1<span>(</span><span>)</span>
	ThisWorkbook<span>.</span>Close SaveChanges<span>:</span><span>=</span><span>False</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>wbClose_1 过程使用 Close 方法关闭工作簿，并放弃所有对工作簿的更改。</p>
<p>应用于 Workbook 对象的 Close 方法关闭对象，语法如下：</p>
<div><pre><code>expression<span>.</span>Close<span>(</span>SaveChanges<span>,</span> Filename<span>,</span> RouteWorkbook<span>)</span>

其中SaveChanges参数是可选的，如果工作簿没有改变则忽略此参数；如果工作簿发生了改变并且在另外的窗口中也打开了该工作簿，则仍然忽略此参数；如果工作簿发生了改变并且没有在另外的窗口中打开，则此参数将指定是否在工作簿中保存所发生的更改。取值与操作如表格 <span>45</span><span>1</span>所示：
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><u>表格 45-1</u>	SaveChanges 参数值的作用</p>
<table>
<thead>
<tr>
<th>值</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>True</td>
<td>将改变保存到工作簿。如果该工作簿尚未命名，则使用 FileName 指定的名称。如果省略 FileName 参数，则要求用户输入文件名。</td>
</tr>
<tr>
<td>False</td>
<td>不将改变保存到此文件。</td>
</tr>
<tr>
<td>省略</td>
<td>显示一个对话框，要求用户决定是否保存所做的更改。</td>
</tr>
</tbody>
</table>
<p>如果希望在关闭工作簿时自动保存更改，将 SaveChanges 参数值设置为 True 即可。</p>
<p>还可以在使用 Close 方法关闭工作簿时设置 Workbook 对象的 Saved 属性，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> wbClose_2<span>(</span><span>)</span>
	ThisWorkbook<span>.</span>Saved <span>=</span> <span>True</span>
	ThisWorkbook<span>.</span>Close 
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>代码解析：</p>
<p>wbClose_2 过程使用 Close 方法关闭工作簿，并放弃所有对工作簿的更改。</p>
<p>Workbook 对象的 Saved 属性指示工作簿从上次保存至今是否发生过更改，如果工作簿进行了更改，则该属性值为 False，否则为 True。应用程序在关闭工作簿之前判断该属性的值，如果其值为 False，则显示提示是否保存的消息框，询问用户是否保存对工作簿所做的更改。</p>
<p>第 2 行代码将该属性的值设置为 True，使Excel认为已经保存了对工作簿所作的更改（实际上没有保存更改），从而不再显示提示是否保存的消息框。</p>
<p>如果需要保存对工作簿所作的更改，那么应该在 Close 方法之前使用 Save 方法保存工作簿，代码如下：</p>
<div><pre><code><span>Sub</span> wbClose_3<span>(</span><span>)</span>
	ThisWorkbook<span>.</span>Save
	ThisWorkbook<span>.</span>Close 
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>代码解析：</p>
<p>wbClose_3 过程使用 Save 方法保存工作簿所做的更改，然后使用 Close 方法关闭工作簿。</p>
<h3 id="_2-单击工作簿关闭按钮关闭工作簿"> 2）单击工作簿关闭按钮关闭工作簿</h3>
<p>如果是通过单击工作簿的关闭按钮等操作关闭工作簿的，则使用 BeforeClose 事件过程来控制，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Workbook_BeforeClose<span>(</span>Cancel <span>As</span> <span>Boolean</span><span>)</span>
	<span>Me</span><span>.</span>Saved <span>=</span> <span>True</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>工作簿的 Workbook_BeforeClose 事件，将工作簿的 Saved 属性设置为 True，不保存更改而直接关闭工作簿，且不显示提示保存的消息框。</p>
<p>如果希望保存对工作簿的更改，则在 Workbook_BeforeClose 事件中使用 Save 方法保存工作簿，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Workbook_BeforeClose<span>(</span>Cancel <span>As</span> <span>Boolean</span><span>)</span>
	<span>Me</span><span>.</span>Save
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="_46、禁用工作簿的关闭按钮"> 46、禁用工作簿的关闭按钮</h2>
<p>一般情况下，用户可以通过菜单“文件”→“关闭”、工作簿窗口右上角的“关闭窗口”按钮或者任务栏中图标右键菜单中的“关闭”菜单项关闭工作簿。如果希望禁用上述关闭工作簿的功能，而只能通过代码关闭工作簿，则可以在相应的工作簿事件中实现，如下面的代码所示。</p>
<div><pre><code><span>Dim</span> BClose <span>As</span> <span>Boolean</span>
<span>Private</span> <span>Sub</span> Workbook_BeforeClose<span>(</span>Cancel <span>As</span> <span>Boolean</span><span>)</span>
	<span>If</span> BClose <span>=</span> <span>False</span> <span>Then</span>
		Cancel <span>=</span> <span>True</span>
		MsgBox <span>"此功能已经被禁止，请使用""关闭""按钮关闭工作簿!"</span><span>,</span> vbExclamation<span>,</span> <span>"提示"</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
<span>Public</span> <span>Sub</span> CloseWorkbook<span>(</span><span>)</span>
	BClose <span>=</span> <span>True</span>
	<span>Me</span><span>.</span>Close
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>代码解析：</p>
<p>第 1 行代码在模块顶部声明变量 BClose 为 Boolean 类型，默认初始值为 False。</p>
<p>第 2 行到第 7 行代码工作簿的 BeforeClose 事件过程，通过变量 BClose 的当前值决定是否能够关闭工作簿，只有当 BClose 的值为 True 时，才允许关闭工作簿。如果变量 BClose 的值为 False 时将参数 Cancel 的值设置为 True，以禁止关闭操作。</p>
<p>第 8 行到第 11 行代码 CloseWorkbook 过程，将变量 BClose 的当前值设置为 True 后使用 Close 方法关闭工作簿。关于 Close 方法请参阅 45-1。</p>
<p>在添加以上代码后，用户只能通过调用 CloseWorkbook 过程关闭工作簿。如果通过菜单“文件”→“关闭”或者单击工作簿窗口右上角的“关闭窗口”按钮关闭工作簿，将显示如图 46-1 所示的消息框。</p>
<div>
<p><img src="./assets/46-1.png" alt="" loading="lazy"></p>
<p><u>图 46-1</u>	禁用关闭按钮</p>
</div>
<h2 id="_47、保存工作簿的方法"> 47、保存工作簿的方法</h2>
<h3 id="_1-使用-save-方法"> 1）使用 Save 方法</h3>
<p>使用 Workbook 对象的 Save 方法保存工作簿的更改，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> SaveWork<span>(</span><span>)</span>
	ThisWorkbook<span>.</span>Save
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>SaveWork 过程保存代码所在的工作簿的修改。</p>
<p>Save 方法保存指定工作簿所做的更改，语法如下：</p>
<div><pre><code>expression<span>.</span>Save

参数expression是必需的，该表达式返回一个Workbook对象。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果是第一次保存工作簿，请使用 SaveAs 方法为该文件指定文件名，请参阅 47-2。</p>
<h3 id="_2-直接保存为另一文件名"> 2）直接保存为另一文件名</h3>
<p>如果需要将工作簿另存为另一个文件名，可以使用Workbook对象的 SaveAs 方法，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> SaveAsWork<span>(</span><span>)</span>
	ThisWorkbook<span>.</span>SaveAs Filename<span>:</span><span>=</span>ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\123.xls"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>SaveAsWork 过程将代码所在的工作簿保存为“123”工作簿文件。</p>
<p>Workbook 对象的 SaveAs 方法使用另外一个不同的文件名保存对工作簿所做的更改，语法如下：</p>
<div><pre><code>SaveAs<span>(</span>FileName<span>,</span>FileFormat<span>,</span>Password<span>,</span>WriteResPassword<span>,</span>ReadOnlyRecommended<span>,</span>CreateBackup<span>,</span>AccessMode<span>,</span>ConflictResolution<span>,</span>AddToMru<span>,</span>TextCodepage<span>,</span>TextVisualLayout<span>,</span>Local<span>)</span>

其中，参数Filename可选，表示要保存文件的文件名的字符串。可包含完整路径，如果不指定路径，将文件保存到当前文件夹中。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>使用 SaveAs 方法将工作簿另存为新文件后，将关闭原工作簿文件。</p>
<h3 id="_3-保存工作簿副本"> 3）保存工作簿副本</h3>
<p>如果用户希望工作簿在保存为另一文件名后，能继续编辑原工作簿，那么可以使用 SaveCopyAs 方法，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> SaveCopyWork<span>(</span><span>)</span>
	ThisWorkbook<span>.</span>SaveCopyAs ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\123.xls"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>SaveCopyWork 过程使用 SaveCopyAs 方法保存代码所在的工作簿副本，并指定其名称。</p>
<p>SaveCopyAs 方法将指定工作簿的副本保存到文件，但不修改内存中的打开工作簿，语法如下：</p>
<div><pre><code>SaveCopyAs<span>(</span>Filename<span>)</span>

参数Filename是必需的，用于指定工作簿副本的文件名。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="_48、保存指定工作表为工作簿文件"> 48、保存指定工作表为工作簿文件</h2>
<p>如果需要将工作簿中的工作表单独保存为一个工作簿文件，可以使用 Worksheet 对象的 Copy 方法，将指定的工作表复制到一个新建的工作簿，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> SheetCopy<span>(</span><span>)</span>
	<span>On</span> <span>Error</span> <span>GoTo</span> line
	ActiveSheet<span>.</span>Copy
	ActiveWorkbook<span>.</span>Close SaveChanges<span>:</span><span>=</span><span>True</span><span>,</span> Filename<span>:</span><span>=</span>ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\SheetCopy.xls"</span>
	<span>Exit</span> <span>Sub</span>
line<span>:</span>
	ActiveWorkbook<span>.</span>Close <span>False</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>代码解析：</p>
<p>SheetCopy 过程将活动工作表单独保存为一个工作簿文件。</p>
<p>第 2 行代码错误处理语句。备份过程中，如果已存在同名工作簿，会出现如所示的提示，如果选择了“否”或“取消”，此时新工作簿已经建立，在执行 4 行代码时发生错误，使程序中断，所以使用 GoTo 语句执行第 7 行代码，关闭新建立的工作簿并且不保存。</p>
<div>
<p><img src="./assets/48-1.png" alt="" loading="lazy"></p>
<p><u>图 48-1</u>	同名工作簿提示</p>
</div>
<p>第 3 行代码使用 Copy 方法新建一个工作簿，新工作簿中包含复制的工作表。应用于 Worksheet 对象的 Copy 方法将指定工作表复制到工作簿的另一位置，语法如下：</p>
<div><pre><code>Copy <span>(</span>Before<span>,</span> After<span>)</span>

其中，参数Before是可选的，用来指定工作表，复制的工作表将置于此工作表之前。参数After是可选的，用来指定工作表，复制的工作表将置于此工作表之后。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>不能同时指定 Before 参数和 After 参数。当 Copy 方法省略参数时，应用程序将新建一个空工作簿（新建工作簿将成为活动窗口），并将 Copy 方法引用的工作表复制到该空工作簿中。</p>
<p>第 4 行代码使用 Workbook 对象的 Close 方法关闭新建的工作簿。应用于 Workbooks 集合和 Workbook 对象的 Close 方法请参阅 45-1。</p>
<p>如果需要将工作簿中的几个工作表单独保存为一个工作簿文件时，可以以数组的形式指定要复制的工作表，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> ArrSheetCopy<span>(</span><span>)</span>
	<span>On</span> <span>Error</span> <span>GoTo</span> line
	Worksheets<span>(</span>Array<span>(</span><span>"Sheet1"</span><span>,</span> <span>"Sheet2"</span><span>)</span><span>)</span><span>.</span>Copy
	ActiveWorkbook<span>.</span>SaveAs Filename<span>:</span><span>=</span>ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\ArrSheetCopy.xls"</span>
	ActiveWorkbook<span>.</span>Close SaveChanges<span>:</span><span>=</span><span>True</span>
	<span>Exit</span> <span>Sub</span>
line<span>:</span>
	ActiveWorkbook<span>.</span>Close <span>False</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>代码解析：</p>
<p>ArrSheetCopy 过程将“Sheet1”和“Sheet2”工作表单独保存为一个工作簿文件。</p>
<p>第 4 行代码使用 SaveAs 方法保存活动工作簿，关于 SaveAs 方法请参阅 47-2。</p>
<h2 id="_49、打印预览时不触发事件"> 49、打印预览时不触发事件</h2>
<p>在工作表打印之前或进行打印预览时，会触发工作簿的 BeforePrint 事件。在某些情况下希望在打印预览时能禁止触发该事件，例如如图 49-1 所示的工作表中，用户在打印时使用下面的代码将流水号的数值自动加 1。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Workbook_BeforePrint<span>(</span>Cancel <span>As</span> <span>Boolean</span><span>)</span>
	Sheet1<span>.</span>Range<span>(</span><span>"J1"</span><span>)</span> <span>=</span> Sheet1<span>.</span>Range<span>(</span><span>"J1"</span><span>)</span> <span>+</span> <span>1</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div>
<p><img src="./assets/49-1.png" alt="" loading="lazy"></p>
<p><u>图 49-1</u>	自动增加流水号</p>
</div>
<p>但是在打印预览时并不希望流水号的数值自动加 1，此时，需要修改系统的打印预览功能，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Workbook_Open<span>(</span><span>)</span>
	<span>Dim</span> CmdCtrls <span>As</span> CommandBarControls
	<span>Dim</span> Cmd <span>As</span> CommandBarControl
	<span>Set</span> CmdCtrls <span>=</span> Application<span>.</span>CommandBars<span>.</span>FindControls<span>(</span>ID<span>:</span><span>=</span><span>109</span><span>)</span>
	<span>For</span> <span>Each</span> Cmd <span>In</span> CmdCtrls
		Cmd<span>.</span>OnAction <span>=</span> <span>"ThisWorkbook.MyPrint"</span>
	<span>Next</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>代码解析：</p>
<p>工作簿的 Open 事件过程，在打开工作簿时，修改系统中所有打印预览命令按钮和菜单项的动作，指定其 OnAction 属性为 ThisWorkbook 代码窗口中的公用过程 MyPrint。</p>
<p>第 4 行代码使用 FindControls 方法将所有打印预览命令按钮和菜单项赋给变量 CmdCtrls，FindControls 方法返回符合指定条件的 CommandBarControls 集合，语法如下：</p>
<div><pre><code>expression<span>.</span>FindControls<span>(</span><span>Type</span><span>,</span> Id<span>,</span> Tag<span>,</span> Visible<span>)</span>

其中参数expression是必需的，该表达式返回一个CommandBars集合。
参数Id是可选的，要查找控件的标识符。打印预览命令控件的标识符为<span>109</span>。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第 5 行到第 7 行代码遍历所有打印预览命令控件，指定其 OnAction 属性为 ThisWorkbook 代码窗口中的公用过程 MyPrint。OnAction 属性返回或设置一个 Visual Basic 的过程名，该过程在用户单击或更改某命令栏控件的值时运行。</p>
<p>MyPrint 过程代码如下：</p>
<div><pre><code><span>Public</span> <span>Sub</span> MyPrint<span>(</span><span>)</span>
	<span>With</span> Application
		<span>.</span>EnableEvents <span>=</span> <span>False</span>
		<span>.</span>ActiveSheet<span>.</span>PrintPreview EnableChanges<span>:</span><span>=</span><span>False</span>
		<span>.</span>EnableEvents <span>=</span> <span>True</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>MyPrint 过程通过禁止对象事件，使工作表打印预览时不触发工作簿的 BeforePrint 事件。</p>
<p>第 3 行代码将 Application 对象的 EnableEvents 属性设置为 False，禁用事件，使事件不能触发。</p>
<p>第 4 行代码使用 PrintPreview 方法对工作表执行打印预览。PrintPreview 方法以打印效果显示指定的对象，该方法只有一个参数 EnableChanges，用来指定是否可以修改页面设置，当其值为 False 时，禁止在打印预览时修改页面设置，默认值为 True。</p>
<p>第 5 行代码将 Application 对象的 EnableEvents 属性设置为 True，启用事件。</p>
<p>为了在工作簿时恢复默认的打印预览设置，在 ThisWorkbook 代码窗口写入以下代码：</p>
<div><pre><code><span>Private</span> <span>Sub</span> Workbook_BeforeClose<span>(</span>Cancel <span>As</span> <span>Boolean</span><span>)</span>
	<span>Dim</span> CmdCtrls <span>As</span> CommandBarControls
	<span>Dim</span> Cmd <span>As</span> CommandBarControl
	<span>Set</span> CmdCtrls <span>=</span> Application<span>.</span>CommandBars<span>.</span>FindControls<span>(</span>ID<span>:</span><span>=</span><span>109</span><span>)</span>
	<span>For</span> <span>Each</span> Cmd <span>In</span> CmdCtrls
		Cmd<span>.</span>OnAction <span>=</span> <span>""</span>
	<span>Next</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>代码解析：</p>
<p>工作簿的 BeforeClose 事件过程，关闭工作簿时将所有打印预览命令按钮和菜单项的 OnAction 属性恢复为默认的动作。</p>
<p>经过以上设置，工作表只有在进行打印时“流水号”数值才自动加 1。</p>
<h2 id="_50、设置工作簿文档属性信息"> 50、设置工作簿文档属性信息</h2>
<p>使用 DocumentProperties 集合对象的 BuiltinDocumentProperties 属性可以设置文档的属性信息，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> WbBuiltin<span>(</span><span>)</span>
	<span>With</span> ThisWorkbook
		<span>.</span>BuiltinDocumentProperties<span>(</span><span>"Title"</span><span>)</span> <span>=</span> <span>"Wordbook（工作簿）对象"</span>
		<span>.</span>BuiltinDocumentProperties<span>(</span><span>"Subject"</span><span>)</span> <span>=</span> <span>"设置工作簿的文档属性信息"</span>
		<span>.</span>BuiltinDocumentProperties<span>(</span><span>"Author"</span><span>)</span> <span>=</span> <span>"yuanzhuping"</span>
		<span>.</span>BuiltinDocumentProperties<span>(</span><span>"Company"</span><span>)</span> <span>=</span> <span>"tzzls"</span>
		<span>.</span>BuiltinDocumentProperties<span>(</span><span>"Comments"</span><span>)</span> <span>=</span> <span>"工作簿文档属性信息"</span>
		<span>.</span>BuiltinDocumentProperties<span>(</span><span>"Keywords"</span><span>)</span> <span>=</span> <span>"Excel VBA"</span>
	<span>End</span> <span>With</span>
	MsgBox <span>"工作簿文档属性信息设置完毕！"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>代码解析：</p>
<p>WbBuiltin 过程设置代码所在工作簿的属性信息，应用于 Workbook 对象的BuiltinDocumentProperties 属性返回一个 DocumentProperties 集合，该集合代表指定工作簿的所有内置文档属性，本属性返回的是内置文档属性的整个集合。通过指定属性的名称或集合中的索引号返回集合中的单个成员（一个 DocumentProperty 对象）。</p>
<p>第 3 行代码设置标题，第 4 行代码设置主题，第 5 行代码设置作者，第 6 行代码设置公司，第 7 行代码设置备注，第 8 行代码设置关键字。</p>
<p>工作簿文档属性信息设置如图 50-1 所示。</p>
<div>
<p><img src="./assets/50-1.png" alt="" loading="lazy"></p>
<p><u>图 50-1</u>	工作簿文档属性信息</p>
</div>
<h2 id="_51、不打开工作簿取得其他工作簿数据"> 51、不打开工作簿取得其他工作簿数据</h2>
<p>在 Excel 的使用过程中，经常需要引用其他工作簿的数据，而用户往往希望能在不打开工作簿或看似不打开工作簿的情况下取得其他工作簿中的数据，有以下几种方法可以实现。</p>
<h3 id="_1-使用公式"> 1）使用公式</h3>
<p>如果需要引用的数据不是太多，可以使用公式取得引用工作簿中的工作表数据，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> CopyData_1<span>(</span><span>)</span>
	<span>Dim</span> Temp <span>As</span> <span>String</span>
	Temp <span>=</span> <span>"'"</span> <span>&amp;</span> ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\[数据表.xls]Sheet1'!"</span>
	<span>With</span> Sheet1<span>.</span>Range<span>(</span><span>"A1:F22"</span><span>)</span>
		<span>.</span>FormulaR1C1 <span>=</span> <span>"="</span> <span>&amp;</span> Temp <span>&amp;</span> <span>"RC"</span>
		<span>.</span>Value <span>=</span> <span>.</span>Value
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>代码解析：</p>
<p>CopyData_1 过程在工作表中写入公式引用“数据表”中同一位置单元格中的数据。</p>
<p>第 3 行代码将引用工作簿的路径赋给变量 Temp。</p>
<p>第 5 行代码在作表中写入公式引用数据。</p>
<p>第 6 行代码将公式转换为数值。</p>
<h3 id="_2-使用-getobject-函数"> 2）使用 GetObject 函数</h3>
<p>使用 GetObject 函数来获取对指定的 Excel 工作表的引用，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> CopyData_2<span>(</span><span>)</span>
	<span>Dim</span> Wb <span>As</span> Workbook
	<span>Dim</span> Temp <span>As</span> <span>String</span>
	Application<span>.</span>ScreenUpdating <span>=</span> <span>False</span>
	Temp <span>=</span> ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\数据表.xls"</span>
	<span>Set</span> Wb <span>=</span> GetObject<span>(</span>Temp<span>)</span>
		<span>With</span> Wb<span>.</span>Sheets<span>(</span><span>1</span><span>)</span><span>.</span>Range<span>(</span><span>"A1"</span><span>)</span><span>.</span>CurrentRegion
			Range<span>(</span><span>"A1"</span><span>)</span><span>.</span>Resize<span>(</span><span>.</span>Rows<span>.</span>Count<span>,</span> <span>.</span>Columns<span>.</span>Count<span>)</span> <span>=</span> <span>.</span>Value
			Wb<span>.</span>Close <span>False</span>
		<span>End</span> <span>With</span>
	<span>Set</span> Wb <span>=</span> <span>Nothing</span>
	Application<span>.</span>ScreenUpdating <span>=</span> <span>True</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>代码解析：</p>
<p>CopyData_2 过程使用 GetObject 函数来获取“数据表”工作簿中的数据。</p>
<p>第 4 行代码关闭屏幕更新加快运行速度。</p>
<p>第 5 行代码将引用工作簿的路径赋给变量 Temp。</p>
<p>第 6 行代码使用 Set 语句将 GetObject 函数返回的对象赋给对象变量 Wb。</p>
<p>GetObject 函数返回文件中的 ActiveX 对象的引用，语法如下：</p>
<div><pre><code>GetObject<span>(</span>[pathname] [<span>,</span> <span>class</span>]<span>)</span>

参数pathname是可选的，包含待检索对象的文件的全路径和名称。如果省略，则<span>class</span>参数是必需的。
参数<span>class</span>是可选的，代表该对象的类的字符串。
<span>Class</span>参数的格式为appname<span>.</span>objecttype，语法的各个部分如表格 <span>51</span><span>1</span>所示。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><u>表格 51-1</u>	Class 参数语法的各个部分</p>
<table>
<thead>
<tr>
<th>部分</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>appname</td>
<td>必需的，提供该对象的应用程序名称。</td>
</tr>
<tr>
<td>objecttype</td>
<td>必需的，待创建对象的类型或类。</td>
</tr>
</tbody>
</table>
<p>第 7 行到第 10 行代码，当 GetObject 函数指定的对象被激活之后，就可以在代码中使用对象变量 Wb 来访问这个对象的属性和方法。</p>
<p>其中第 7、8 行代码将“数据表”工作簿中的第 1 张工作表已使用区域的数据赋给本工作表的单元格，第 9 行代码关闭“数据表”工作簿，使用 GetObject 函数返回对象的引用时，虽然在窗口中看不到对象的实例，但实际上是打开的，所以需用 Close 语句将其关闭。</p>
<p>第 12 行代码开启屏幕更新。</p>
<h3 id="_3-隐藏-application-对象"> 3）隐藏 Application 对象</h3>
<p>通过隐藏 Application 对象来模拟不打开工作簿取数，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> CopyData_3<span>(</span><span>)</span>
	<span>Dim</span> myApp <span>As</span> <span>New</span> Application
	<span>Dim</span> Sh <span>As</span> Worksheet
	<span>Dim</span> Temp <span>As</span> <span>String</span>
	Temp <span>=</span> ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\数据表.xls"</span>
	myApp<span>.</span>Visible <span>=</span> <span>False</span>
	<span>Set</span> Sh <span>=</span> myApp<span>.</span>Workbooks<span>.</span>Open<span>(</span>Temp<span>)</span><span>.</span>Sheets<span>(</span><span>1</span><span>)</span>
	<span>With</span> Sh<span>.</span>Range<span>(</span><span>"A1"</span><span>)</span><span>.</span>CurrentRegion
		Range<span>(</span><span>"A1"</span><span>)</span><span>.</span>Resize<span>(</span><span>.</span>Rows<span>.</span>Count<span>,</span> <span>.</span>Columns<span>.</span>Count<span>)</span> <span>=</span> <span>.</span>Value
	<span>End</span> <span>With</span>
	myApp<span>.</span>Quit
	<span>Set</span> Sh <span>=</span> <span>Nothing</span>
	<span>Set</span> myApp <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>代码解析：</p>
<p>CopyData_3 过程隐藏 Application 对象来模拟不打开工作簿取数。</p>
<p>第 2 行代码使用 New 关键字隐式地创建一个 Application 对象。</p>
<p>第 6 行代码将新创建的 Application 对象的 Visible 属性设置为 False，使之隐藏。</p>
<p>第 7 行代码使用 Open 方法打开“数据表”工作簿（关于 Open 方法请参阅 42 ，因为工作簿是使用新创建的、隐藏的 Application 对象打开的，所以在窗口中是不可视的。</p>
<p>第 8 行到第 10 行代码将“数据表”工作簿中的第 1 张工作表已使用区域的数据赋给本工作表的单元格。</p>
<p>第 11 行代码使用 Quit 方法退出新打开的 Excel 程序。</p>
<h3 id="_4-使用-executeexcel4macro-方法"> 4）使用 ExecuteExcel4Macro 方法</h3>
<p>使用 ExecuteExcel4Macro 方法可以做到不打开工作簿的情况下获取其他工作薄中指定工作表的数据，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> CopyData_4<span>(</span><span>)</span>
	<span>Dim</span> RCount <span>As</span> <span>Long</span>
	<span>Dim</span> CCount <span>As</span> <span>Long</span>
	<span>Dim</span> Temp <span>As</span> <span>String</span>
	<span>Dim</span> Temp1 <span>As</span> <span>String</span>
	<span>Dim</span> Temp2 <span>As</span> <span>String</span>
	<span>Dim</span> Temp3 <span>As</span> <span>String</span>
	<span>Dim</span> R <span>As</span> <span>Long</span>
	<span>Dim</span> C <span>As</span> <span>Long</span>
	<span>Dim</span> arr<span>(</span><span>)</span> <span>As</span> <span>Variant</span>
	Temp <span>=</span> <span>"'"</span> <span>&amp;</span> ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\[数据表.xls]Sheet1'!"</span>
	Temp1 <span>=</span> Temp <span>&amp;</span> Rows<span>(</span><span>1</span><span>)</span><span>.</span>Address<span>(</span><span>,</span> <span>,</span> xlR1C1<span>)</span>
	Temp1 <span>=</span> <span>"Counta("</span> <span>&amp;</span> Temp1 <span>&amp;</span> <span>")"</span>
	CCount <span>=</span> Application<span>.</span>ExecuteExcel4Macro<span>(</span>Temp1<span>)</span>
	Temp2 <span>=</span> Temp <span>&amp;</span> Columns<span>(</span><span>"A"</span><span>)</span><span>.</span>Address<span>(</span><span>,</span> <span>,</span> xlR1C1<span>)</span>
	Temp2 <span>=</span> <span>"Counta("</span> <span>&amp;</span> Temp2 <span>&amp;</span> <span>")"</span>
	RCount <span>=</span> Application<span>.</span>ExecuteExcel4Macro<span>(</span>Temp2<span>)</span>
	<span>ReDim</span> arr<span>(</span><span>1</span> <span>To</span> RCount<span>,</span> <span>1</span> <span>To</span> CCount<span>)</span>
	<span>For</span> R <span>=</span> <span>1</span> <span>To</span> RCount
		<span>For</span> C <span>=</span> <span>1</span> <span>To</span> CCount
			Temp3 <span>=</span> Temp <span>&amp;</span> Cells<span>(</span>R<span>,</span> C<span>)</span><span>.</span>Address<span>(</span><span>,</span> <span>,</span> xlR1C1<span>)</span>
			arr<span>(</span>R<span>,</span> C<span>)</span> <span>=</span> Application<span>.</span>ExecuteExcel4Macro<span>(</span>Temp3<span>)</span>
		<span>Next</span>
	<span>Next</span>
	Range<span>(</span><span>"A1"</span><span>)</span><span>.</span>Resize<span>(</span>RCount<span>,</span> CCount<span>)</span><span>.</span>Value <span>=</span> arr
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>代码解析：</p>
<p>CopyData_4 过程使用 ExecuteExcel4Macro 方法获取“数据表”工作薄中指定工作表的数据。</p>
<p>第 14、16 行代码使用 ExecuteExcel4Macro 方法执行 Counta 函数取得“数据表”工作薄中指定工作表的行数和列数合计。</p>
<p>ExecuteExcel4Macro 方法执行一个 Microsoft Excel 4.0 宏函数，然后返回此函数的结果，语法如下：</p>
<div><pre><code>expression<span>.</span>ExecuteExcel4Macro<span>(</span><span>String</span><span>)</span>

参数expression是可选的，返回一个Application对象。
参数<span>String</span>是必需的，一个不带等号的Microsoft Excel <span>4.0</span>宏语言函数，所有引用必须是像R1C1这样的字符串。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>因为 Microsoft Excel 4.0 宏不在当前工作簿或工作表的环境中求值，所有的引用都是外部引用，所以无需打开引用工作簿但是需要明确指定工作簿名称。</p>
<p>第 18 行代码使用 ReDim 语句为动态数组 arr 重新分配存储空间。</p>
<p>第 19 行到第 24 行代码循环取值，将“数据表”工作薄中指定工作表的数据赋给动态数组 arr。</p>
<p>第 25 行代码将动态数组 arr 的值赋给工作表的单元格。</p>
<h3 id="_5-使用-sql-连接"> 5）使用 SQL 连接</h3>
<p>使用 SQL 建立与工作簿的连接，查询数据记录后复制到当前工作表中，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> CopyData_5<span>(</span><span>)</span>
	<span>Dim</span> Sql <span>As</span> <span>String</span>
	<span>Dim</span> j <span>As</span> <span>Integer</span>
	<span>Dim</span> R <span>As</span> <span>Integer</span>
	<span>Dim</span> Cnn <span>As</span> ADODB<span>.</span>Connection
	<span>Dim</span> rs <span>As</span> ADODB<span>.</span>Recordset
	<span>With</span> Sheet5
		<span>.</span>Cells<span>.</span>Clear
		<span>Set</span> Cnn <span>=</span> <span>New</span> ADODB<span>.</span>Connection
		<span>With</span> Cnn
			<span>.</span>Provider <span>=</span> <span>"microsoft.jet.oledb.4.0"</span>
			<span>.</span>ConnectionString <span>=</span> <span>"Extended Properties=Excel 8.0;"</span> <span>_</span>
				<span>&amp;</span> <span>"Data Source="</span> <span>&amp;</span> ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\数据表"</span>
			<span>.</span>Open
		<span>End</span> <span>With</span>
		<span>Set</span> rs <span>=</span> <span>New</span> ADODB<span>.</span>Recordset
		Sql <span>=</span> <span>"select * from [Sheet1$]"</span>
		rs<span>.</span>Open Sql<span>,</span> Cnn<span>,</span> adOpenKeyset<span>,</span> adLockOptimistic
			<span>For</span> j <span>=</span> <span>0</span> <span>To</span> rs<span>.</span>Fields<span>.</span>Count <span>-</span> <span>1</span>
				<span>.</span>Cells<span>(</span><span>1</span><span>,</span> j <span>+</span> <span>1</span><span>)</span> <span>=</span> rs<span>.</span>Fields<span>(</span>j<span>)</span><span>.</span>Name
			<span>Next</span>
		R <span>=</span> <span>.</span>Range<span>(</span><span>"A65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row
		<span>.</span>Range<span>(</span><span>"A"</span> <span>&amp;</span> R <span>+</span> <span>1</span><span>)</span><span>.</span>CopyFromRecordset rs
	<span>End</span> <span>With</span>
	rs<span>.</span>Close
	Cnn<span>.</span>Close
	<span>Set</span> rs <span>=</span> <span>Nothing</span>
	<span>Set</span> Cnn <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>代码解析：</p>
<p>CopyData_5 过程使建立与“数据表”工作簿的连接，查询数据记录后复制到当前工作表中。</p>
<p>第 8 行代码删除当前工作表的所有数据。</p>
<p>第 9 行到第 15 行代码建立与“数据表”工作簿的连接。</p>
<p>第 16 行到第 24 行代码查询“数据表”工作簿的全部数据，并复制到工作表中。其中第 20 行代码将字段名称（标题行）复制到工作表中，第 23 行代码将查询到的数据记录复制到工作表。</p>
<h2 id="_52、返回窗口的可视区域地址"> 52、返回窗口的可视区域地址</h2>
<p>VBA 中使用 VisibleRange 属性返回当前窗口的可视区域，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> VbRange<span>(</span><span>)</span>
	<span>Dim</span> s <span>As</span> <span>String</span>
	s <span>=</span> ActiveWindow<span>.</span>VisibleRange<span>.</span>Address<span>(</span><span>0</span><span>,</span> <span>0</span><span>)</span>
	MsgBox <span>"窗口的可视区域为："</span> <span>&amp;</span> s
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>代码解析：</p>
<p>VbRange 过程使用消息框显示当前窗口的可视区域的地址。</p>
<p>应用于当前 Window 对象的 VisibleRange 属性返回一个 Range 对象，代表当前窗口的可视区域。窗口的可视区域就是用户可以在窗口或窗格中看到的单元格区域，如果行或列部分可见，该行或列也包括在可视区域中。</p>
<p>因为 VisibleRange 属性返回的是一个 Range 对象，因此可以直接使用该对象的属性和方法。</p>
<p>当窗口的大小发生变化时，返回的可视区域的地址也会不同，如图 52-1、图 52-2 所示。</p>
<div>
<p><img src="./assets/52-1.png" alt="" loading="lazy"></p>
<p><u>图 52-1</u>	自定义大小的窗口</p>
<p><img src="./assets/52-2.png" alt="" loading="lazy"></p>
<p><u>图 52-2</u>	最大化时的窗口</p>
</div>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-07-02T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">VBA 之 Shape、Chart 对象</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Excel/06.VBA_Shape_Chart/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Excel/06.VBA_Shape_Chart/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="_53、在工作表中添加图形"> 53、在工作表中添加图形</h2>
<p>如果需要在工作表中添加图形对象，可以使用 AddShape 方法，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> AddShape<span>(</span><span>)</span>
	<span>Dim</span> myShape <span>As</span> Shape
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	Sheet1<span>.</span>Shapes<span>(</span><span>"myShape"</span><span>)</span><span>.</span>Delete
	<span>Set</span> myShape <span>=</span> Sheet1<span>.</span>Shapes<span>.</span>AddShape<span>(</span>msoShapeRectangle<span>,</span> <span>40</span><span>,</span> <span>120</span><span>,</span> <span>280</span><span>,</span> <span>30</span><span>)</span>
	<span>With</span> myShape
		<span>.</span>Name <span>=</span> <span>"myShape"</span>
		<span>With</span> <span>.</span>TextFrame<span>.</span>Characters
			<span>.</span>Text <span>=</span> <span>"单击将选择Sheet2!"</span>
			<span>With</span> <span>.</span>Font
				<span>.</span>Name <span>=</span> <span>"华文行楷"</span>
				<span>.</span>FontStyle <span>=</span> <span>"常规"</span>
				<span>.</span>Size <span>=</span> <span>22</span>
				<span>.</span>ColorIndex <span>=</span> <span>7</span>
			<span>End</span> <span>With</span>
		<span>End</span> <span>With</span>
		<span>With</span> <span>.</span>TextFrame	
			<span>.</span>HorizontalAlignment <span>=</span> <span>-</span><span>4108</span>
			<span>.</span>VerticalAlignment <span>=</span> <span>-</span><span>4108</span>
		<span>End</span> <span>With</span>
		<span>.</span>Placement <span>=</span> <span>3</span>
	<span>End</span> <span>With</span>
	myShape<span>.</span><span>Select</span>
	<span>With</span> Selection<span>.</span>ShapeRange
		<span>With</span> <span>.</span>Line
			<span>.</span>Weight <span>=</span> <span>1</span>
			<span>.</span>DashStyle <span>=</span> msoLineSolid
			<span>.</span>Style <span>=</span> msoLineSingle
			<span>.</span>Transparency <span>=</span> <span>0</span>
			<span>.</span>Visible <span>=</span> msoTrue
			<span>.</span>ForeColor<span>.</span>SchemeColor <span>=</span> <span>40</span>
			<span>.</span>BackColor<span>.</span>RGB <span>=</span> RGB<span>(</span><span>255</span><span>,</span> <span>255</span><span>,</span> <span>255</span><span>)</span>
		<span>End</span> <span>With</span>
		<span>With</span> <span>.</span>Fill
			<span>.</span>Transparency <span>=</span> <span>0</span>
			<span>.</span>Visible <span>=</span> msoTrue
			<span>.</span>ForeColor<span>.</span>SchemeColor <span>=</span> <span>41</span>
			<span>.</span>OneColorGradient <span>1</span><span>,</span> <span>4</span><span>,</span> <span>0.23</span>
		<span>End</span> <span>With</span>
	<span>End</span> <span>With</span>
	Sheet1<span>.</span>Range<span>(</span><span>"A1"</span><span>)</span><span>.</span><span>Select</span>
	Sheet1<span>.</span>Hyperlinks<span>.</span>Add Anchor<span>:</span><span>=</span>myShape<span>,</span> Address<span>:</span><span>=</span><span>""</span><span>,</span> <span>_</span>
		SubAddress<span>:</span><span>=</span><span>"Sheet2!A1"</span><span>,</span> ScreenTip<span>:</span><span>=</span><span>"选择Sheet2!"</span>
	<span>Set</span> myShape <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><p>代码解析：</p>
<p>AddShape 过程在工作表中添加一个矩形并设置其外观等属性。</p>
<p>第 2 行代码声明变量 myShape 的对象类型。</p>
<p>第 3、4 行代码删除可能存在的名称为“myShape”的图形对象。</p>
<p>第 5 行代码使用 AddShape 方法在工作表中添加一个矩形。当该方法应用于 Shapes 对象时，返回一个 Shape 对象，该对象代表工作表中的新自选图形，语法如下：</p>
<div><pre><code>expression<span>.</span>AddShape<span>(</span><span>Type</span><span>,</span> Left<span>,</span> Top<span>,</span> Width<span>,</span> Height<span>)</span>

参数expression是必需的，返回一个Shapes对象。
参数<span>Type</span>是必需的，指定要创建的自选图形的类型。
参数Left和Top是必需的，以磅为单位给出自选图形边框左上角的位置。
参数Width和Height是必需的，以磅为单位给出自选图形边框的宽度和高度。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>第 7 行代码将新建图形命名为“myShape”，向 Shapes 集合添加新的图形时，将对新添加的图形赋以默认的名称，若要为图形指定更有意义的名称，可指定其 Name 属性。</p>
<p>第 8 行到第 16 行代码为矩形添加文字，并设定其格式。</p>
<p>其中第 8 行代码使用 TextFrame 属性和 Characters 方法返回该矩形的字符区域。应用于 Shape 对象的 TextFrame 属性返回一个 TextFrame 对象，该对象包含指定图形对象的对齐和定位属性；Characters 方法返回一个 Characters 对象，该对象代表某个图形的文本框中的字符区域，语法如下：</p>
<div><pre><code>expression<span>.</span>Characters<span>(</span>Start<span>,</span> Length<span>)</span>

参数expression是必需的，返回一个指定文本框内Characters对象的表达式。
参数Start是可选的，表示将要返回的第一个字符，如果此参数设置为 <span>1</span> 或被忽略，则Characters方法会返回以第一个字符为起始字符的字符区域。
参数Length是可选的，表示要返回的字符个数。如果此参数被忽略，则Characters方法会返回该字符串的剩余部分（由Start参数指定的字符以后的所有字符）。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>第 9 行代码为矩形添加文字，应用于 Characters 对象的 Text 属性返回或设置对象的文本，为可读写的 String 类型。</p>
<p>第 10 行到第 15 行代码设置矩形中文字的属性，应用于 Characters 对象 Font 属性返回一个 Font 对象，该对象代表指定对象的字体属性（字体名称、字体大小、字体颜色等），第 11 行代码设置字体名称，第 12 行代码设置字体样式，第 13 行代码设置字体大小，第 14 行代码颜色。</p>
<p>第 17 行到第 20 行代码设定矩形中文字的对齐方式。应用于 TextFrame 对象的 HorizontalAlignment 属性返回或设置指定对象的水平对齐方式，可为表格 53-1 所示的 XlHAlign常量之一。</p>
<p><u>表格 53-1</u>	HorizontalAlignment 属性的 XlHAlign 常量</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>xlHAlignCenter</td>
<td>-4108</td>
<td>居中</td>
</tr>
<tr>
<td>xlHAlignCenterAcrossSelection</td>
<td>7</td>
<td>靠左</td>
</tr>
<tr>
<td>xlHAlignDistributed</td>
<td>-4117</td>
<td>分散对齐</td>
</tr>
<tr>
<td>xlHAlignFill</td>
<td>5</td>
<td>分散对齐</td>
</tr>
<tr>
<td>xlHAlignGeneral</td>
<td>1</td>
<td>靠左</td>
</tr>
<tr>
<td>xlHAlignJustify</td>
<td>-4130</td>
<td>两端对齐</td>
</tr>
<tr>
<td>xlHAlignLeft</td>
<td>-4131</td>
<td>靠左</td>
</tr>
<tr>
<td>xlHAlignRight</td>
<td>-4152</td>
<td>靠右</td>
</tr>
</tbody>
</table>
<p>应用于 TextFrame 对象的 VerticalAlignment 属性返回或设置指定对象的垂直对齐方式，可为表格 53-2 所示的 XlHAlign 常量之一。</p>
<p><u>表格 53-2</u>	VerticalAlignment 属性的 XlHAlign 常量</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>xlVAlignCenter</td>
<td>-4108</td>
<td>居中</td>
</tr>
<tr>
<td>xlVAlignJustify</td>
<td>-4130</td>
<td>两端对齐</td>
</tr>
<tr>
<td>xlVAlignBottom</td>
<td>-4107</td>
<td>靠下</td>
</tr>
<tr>
<td>xlVAlignDistributed</td>
<td>-4117</td>
<td>分散对齐</td>
</tr>
<tr>
<td>xlVAlignTop</td>
<td>-4160</td>
<td>靠上</td>
</tr>
</tbody>
</table>
<p>第 21 行代码设置矩形大小和位置不随单元格而变，应用于 Shape 对象的 Placement 属性返回或设置对象与所在的单元格之间的附属关系，可为表格 53-3 所示的 XlPlacement 常量之一。</p>
<p><u>表格 53-3</u>	XlPlacement 常量</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>xlFreeFloating</td>
<td>3</td>
<td>大小、位置均固定</td>
</tr>
<tr>
<td>xlMove</td>
<td>2</td>
<td>大小固定、位置随单元格而变</td>
</tr>
<tr>
<td>xlMoveAndSize</td>
<td>1</td>
<td>大小、位置随单元格而变</td>
</tr>
</tbody>
</table>
<p>第 24 行到第 32 行代码设置矩形的边框线条格式，应用于 ShapeRange 集合的 Line 属性返回一个 LineFormat 对象，该对象包含指定图形的线条格式属性。</p>
<p>其中第 26 行代码设置矩形线条粗细，第 27 行代码设置矩形线条的虚线样式，第 28 行代码设置矩形填充的透明度，第 29 行代码设置矩形为可见，第 30 行代码设置矩形的前景色，第 31 行代码设置矩形填充背景的颜色。</p>
<p>第 33 行到第 38 行代码设置矩形的内部填充格式，应用于 ShapeRange 集合的 Fill 属性返回 FillFormat 对象，该对象包含指定的图表或图形的填充格式属性。</p>
<p>其中第 35 行代码设置矩形内部的透明度，第 36 行代码设置矩形内部为可见，第 37 行代码设置矩形内部的前景色，第 38 行代码将矩形内部指定填充设为单色渐变，应用于 FillFormat 对象的 OneColorGradient 方法将指定填充设为单色渐变，语法如下：</p>
<div><pre><code>expression<span>.</span>OneColorGradient<span>(</span>Style<span>,</span> <span>Variant</span><span>,</span> Degree<span>)</span>

其中参数Style是必需的，底纹样式，可为表格 <span>54</span><span>-</span><span>1</span>所示的MsoGradientStyle常量之一。
参数<span>Variant</span>是必需的，渐变变量。取值范围为 <span>1</span> 到 <span>4</span> 之间，分别与<span>“填充效果”</span>对话框中<span>“渐变”</span>选项卡的四个渐变变量相对应。如果GradientStyle 设为 msoGradientFromCenter，则<span>Variant</span>参数只能设为 <span>1</span> 或 <span>2</span>。
参数Degree是必需的，灰度。取值范围为 <span>0.0</span>（表示最深）到 <span>1.0</span>（表示最浅）之间。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><u>表格 53-4</u>	MsoGradientStyle 常量</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>msoGradientDiagonalDown</td>
<td>4</td>
<td>斜下</td>
</tr>
<tr>
<td>msoGradientDiagonalUp</td>
<td>3</td>
<td>斜上</td>
</tr>
<tr>
<td>msoGradientFromCenter</td>
<td>7</td>
<td>无</td>
</tr>
<tr>
<td>msoGradientFromCorner</td>
<td>5</td>
<td>角部幅射</td>
</tr>
<tr>
<td>msoGradientFromTitle</td>
<td>6</td>
<td>中心幅射</td>
</tr>
<tr>
<td>msoGradientHorizontal</td>
<td>1</td>
<td>水平</td>
</tr>
<tr>
<td>msoGradientMixed</td>
<td>-2</td>
<td>无</td>
</tr>
<tr>
<td>msoGradientVertical</td>
<td>2</td>
<td>垂直</td>
</tr>
</tbody>
</table>
<p>第 42、43 行代码为矩形对象添加超链接，应用于 Hyperlinks 对象的 Add 方法向指定的区域或图形添加超链接，语法如下：</p>
<div><pre><code>expression<span>.</span>Add<span>(</span>Anchor<span>,</span> Address<span>,</span> SubAddress<span>,</span> ScreenTip<span>,</span> TextToDisplay<span>)</span>

参数expression是必需的，返回一个Hyperlinks对象。
参数Anchor是必需的，超链接的位置。可为Range对象或Shape对象。
参数Address是必需的，超链接的地址。
参数SubAddress是必需的，超链接的子地址。
参数ScreenTip是可选的，当鼠标指针停留在超链接上时所显示的屏幕提示。
参数TextToDisplay是可选的，要显示的超链接的文本。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>运行 AddShape 过程结果如图 53-1 所示。</p>
<div>
<p><img src="./assets/53-1.png" alt="" loading="lazy"></p>
<p><u>图 53-1</u>	在工作表中添加图形</p>
</div>
<h2 id="_54、导出工作表中的图片"> 54、导出工作表中的图片</h2>
<p>有时需要将工作表中的图形对象保存为单独的图像文件，可以使用 Export 方法将工作表中的图片以文件形式导出，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> ExportShp<span>(</span><span>)</span>
	<span>Dim</span> Shp <span>As</span> Shape
	<span>Dim</span> FileName <span>As</span> <span>String</span>
	<span>For</span> <span>Each</span> Shp <span>In</span> Sheet1<span>.</span>Shapes
		<span>If</span> Shp<span>.</span><span>Type</span> <span>=</span> msoPicture <span>Then</span>
			FileName <span>=</span> ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\"</span> <span>&amp;</span> Shp<span>.</span>Name <span>&amp;</span> <span>".gif"</span>
			Shp<span>.</span>Copy
			<span>With</span> Sheet1<span>.</span>ChartObjects<span>.</span>Add<span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> Shp<span>.</span>Width <span>+</span> <span>28</span><span>,</span> Shp<span>.</span>Height <span>+</span> <span>30</span><span>)</span><span>.</span>Chart
				<span>.</span>Paste
				<span>.</span>Export FileName<span>,</span> <span>"gif"</span>
				<span>.</span>Parent<span>.</span>Delete
			<span>End</span> <span>With</span>
		<span>End</span> <span>If</span>
	<span>Next</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>代码解析：</p>
<p>ExportShp 过程将 Sheet1 工作表的所有图片以文件形式导出到同一目录中。</p>
<p>第 4 行代码使用 For Each...Next 语句遍历 Sheet1 工作表中的所有图形。</p>
<p>第 5 行代码判断图形的类型是否为图片，应用于 Shape 对象的 Type 属性返回或设置图形类型，可以为表格 54-1 所示的 MsoShapeType 常量之一。</p>
<p><u>表格 54-1</u>	MsoShapeType 常量</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>msoShapeTypeMixed</td>
<td>-2</td>
<td>混合型图形</td>
</tr>
<tr>
<td>msoAutoShape</td>
<td>1</td>
<td>自选图形</td>
</tr>
<tr>
<td>msoCallout</td>
<td>2</td>
<td>没有边框线的标注</td>
</tr>
<tr>
<td>msoChart</td>
<td>3</td>
<td>图表</td>
</tr>
<tr>
<td>msoComment</td>
<td>4</td>
<td>批注</td>
</tr>
<tr>
<td>msoFreeform</td>
<td>5</td>
<td>任意多边形</td>
</tr>
<tr>
<td>msoGroup</td>
<td>6</td>
<td>图形组合</td>
</tr>
<tr>
<td>msoFormControl</td>
<td>8</td>
<td>窗体控件</td>
</tr>
<tr>
<td>msoLine</td>
<td>9</td>
<td>线条</td>
</tr>
<tr>
<td>msoLinkedOLEObject</td>
<td>10</td>
<td>链接式或内嵌OLE对象</td>
</tr>
<tr>
<td>msoLinkedPicture</td>
<td>11</td>
<td>剪贴画或图片</td>
</tr>
<tr>
<td>msoOLEControlObject</td>
<td>12</td>
<td>ActiveX 控件</td>
</tr>
<tr>
<td>msoPicture</td>
<td>13</td>
<td>图片</td>
</tr>
<tr>
<td>msoTextEffect</td>
<td>15</td>
<td>艺术字</td>
</tr>
<tr>
<td>msoTextBox</td>
<td>17</td>
<td>文本框</td>
</tr>
<tr>
<td>msoDiagram</td>
<td>21</td>
<td>组织结构图或其他图示</td>
</tr>
</tbody>
</table>
<p>第 6 行代码使用字符串变量 FileName 记录需导出图形的路径和名称。</p>
<p>第 7 行代码复制图形，应用于 Shape 对象的 Copy 方法将对象复制到剪贴板。</p>
<p>第 8 行代码使用 Add 方法在工作表中添加一个图表，应用于 ChartObjects 对象的 Add 方法创建新的嵌入图表，语法如下：</p>
<div><pre><code>expression<span>.</span>Add<span>(</span>Left<span>,</span> Top<span>,</span> Width<span>,</span> Height<span>)</span>

参数expression是必需的，返回一个ChartObjects对象。
参数Left、参数Top是必需的，以磅为单位给出新对象的初始坐标，该坐标是相对于工作表上单元格A1的左上角或图表的左上角的坐标。
参数Width、参数Height是必需的，以磅为单位给出新对象的初始大小。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>第 9 行代码使用 Paste 方法将图形粘贴到新的嵌入图表中，应用于 Chart 对象的 Paste 方法将剪贴板中的图表数据粘贴到指定的图表中，语法如下：</p>
<div><pre><code>expression<span>.</span>Paste<span>(</span><span>Type</span><span>)</span>

参数expression是必需的，返回一个Chart对象。
参数<span>Type</span>是可选的的，如果剪贴板中有图表，本参数指定要粘贴的图表信息。可为以下XlPasteType常量之一：xlFormats、xlFormulas或xlAll。默认值为xlAll，如果剪贴板中是数据不是图表，则不能使用本参数。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第 10 行代码使用 Export 方法将图表导出到同一目录中，应用于 Chart 对象的 Export 方法以图形格式导出图表，语法如下：</p>
<div><pre><code>expression<span>.</span>Export<span>(</span>Filename<span>,</span> FilterName<span>,</span> Interactive<span>)</span>

其中参数Filename是必需的，被导出的文件的名称。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>第 10 行代码删除新建的图表。因为 Chart 对象是不能使用 Delete 方法直接删除的，应先使用 Parent 属性返回指定对象的父对象，然后使用 Delete 方法删除。</p>
<h2 id="_55、在工作表中添加艺术字"> 55、在工作表中添加艺术字</h2>
<p>在工作表中插入艺术字，可以使用 AddTextEffect 方法，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> TextEffect<span>(</span><span>)</span>
	<span>Dim</span> myShape <span>As</span> Shape
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	Sheet1<span>.</span>Shapes<span>(</span><span>"myShape"</span><span>)</span><span>.</span>Delete
	<span>Set</span> myShape <span>=</span> Sheet1<span>.</span>Shapes<span>.</span>AddTextEffect <span>_</span>
			<span>(</span>PresetTextEffect<span>:</span><span>=</span>msoTextEffect15<span>,</span> <span>_</span>
			Text<span>:</span><span>=</span><span>"我爱 Excel Home"</span><span>,</span> FontName<span>:</span><span>=</span><span>"宋体"</span><span>,</span> FontSize<span>:</span><span>=</span><span>36</span><span>,</span> <span>_</span>
			FontBold<span>:</span><span>=</span>msoFalse<span>,</span> FontItalic<span>:</span><span>=</span>msoFalse<span>,</span> <span>_</span>
			Left<span>:</span><span>=</span><span>100</span><span>,</span> Top<span>:</span><span>=</span><span>100</span><span>)</span>
	<span>With</span> myShape
		<span>.</span>Name <span>=</span> <span>"myShape"</span>
		<span>With</span> <span>.</span>Fill
			<span>.</span>Solid
			<span>.</span>ForeColor<span>.</span>SchemeColor <span>=</span> <span>55</span>
			<span>.</span>Transparency <span>=</span> <span>0</span>
		<span>End</span> <span>With</span>
		<span>With</span> <span>.</span>Line
			<span>.</span>Weight <span>=</span> <span>1.5</span>
			<span>.</span>DashStyle <span>=</span> msoLineSolid
			<span>.</span>Style <span>=</span> msoLineSingle
			<span>.</span>Transparency <span>=</span> <span>0</span>
			<span>.</span>ForeColor<span>.</span>SchemeColor <span>=</span> <span>12</span>
			<span>.</span>BackColor<span>.</span>RGB <span>=</span> RGB<span>(</span><span>255</span><span>,</span> <span>255</span><span>,</span> <span>255</span><span>)</span>
		<span>End</span> <span>With</span>
	<span>End</span> <span>With</span>
	<span>Set</span> myShape <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>代码解析：</p>
<p>TextEffect 过程在工作表中插入艺术字并设置其格式。</p>
<p>第 3、4 行代码删除工作表中可能存在的艺术字，以免重复添加。</p>
<p>第 5 行到第 9 行代码使用 AddTextEffect 方法在工作表中插入艺术字，AddTextEffect 方法创建艺术字对象。返回一个 Shape 对象，该对象代表新建的艺术字对象，语法如下：</p>
<div><pre><code>expression<span>.</span>AddTextEffect<span>(</span>PresetTextEffect<span>,</span> Text<span>,</span> FontName<span>,</span> FontSize<span>,</span> FontBold<span>,</span> FontItalic<span>,</span> Left<span>,</span> Top<span>)</span>

参数expression是必需的，返回一个Shapes对象。
参数PresetTextEffect是必需的，艺术字预置文本效果，可为MsoPresetTextEffect 常量之一，等同于在工作表中插入艺术字时的样式选项卡，如图<span>55</span><span>-</span><span>1</span>所示。
参数Text是必需的，艺术字对象中的文字。
参数FontName是必需的，艺术字对象中所用的字体名称。
参数FontSize是必需的，以磅为单位给出艺术字对象中所用的字体大小。
参数FontBold是必需的，在艺术字中要加粗的字体。
参数FontItalic是必需的，在艺术字中要倾斜的字体。
参数Left和参数Top是必需的，相对于文档的左上角、顶部，以磅为单位给出艺术字对象边框左上角的位置。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div>
<p><img src="./assets/55-1.png" alt="" loading="lazy"></p>
<p><u>图 55-1</u>	艺术字样式</p>
</div>
<p>第 11 行代码将艺术字对象重命名为“myShape”。</p>
<p>第 12 行到第 16 行代码设置艺术字对象的填充格式。其中第 13 行代码将填充格式设置为均一的颜色，应用于 FillFormat 对象的 Solid 方法将指定的填充格式设置为均一的颜色，可用本方法将带有渐进色、纹理、图案或背景的填充格式转换为单色的填充格式。第 14 行代码设置填充的颜色。第 15 行代码设置填充的透明度。</p>
<p>第 17 行到第 24 行代码设置艺术字对象的线条格式属性。其中第 18 行代码设置线条粗细，第 19 行代码设置线条虚线样式，第 20 行代码设置线条区域的样式，第 21 行代码设置线条的透明度，第 22 行代码设置前景色，第 23 行代码设置填充背景的颜色。</p>
<p>运行 TextEffect 过程工作表中如图 55-2 所示。</p>
<div>
<p><img src="./assets/55-2.png" alt="" loading="lazy"></p>
<p><u>图 55-2</u>	工作表中插入艺术字</p>
</div>
<h2 id="_56、遍历工作表中的图形"> 56、遍历工作表中的图形</h2>
<p>工作表中的多个图形，如果使用系统缺省名称，如“文本框1”、“文本框2”这样前面是固定的字符串，后面是序号的，可以使用 For...Next 语句遍历图形，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> ErgShapes_1<span>(</span><span>)</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>For</span> i <span>=</span> <span>1</span> <span>To</span> <span>4</span>
		Sheet1<span>.</span>Shapes<span>(</span><span>"文本框 "</span> <span>&amp;</span> i<span>)</span><span>.</span>TextFrame<span>.</span>Characters<span>.</span>Text <span>=</span> <span>""</span>
	<span>Next</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>代码解析：</p>
<p>ErgShapes_1 过程清除工作表中四个图形文本框中的文字。</p>
<p>第 3 行到第 5 行代码，使用 Shapes 属性在工作表上的三个图形文本框中循环。</p>
<p>Shapes 属性返回 Shapes 对象，代表工作表或图形工作表上的所有图形，可以使用Shapes（index）返回单个的 Shape 对象，其中index是图形的名称或索引号。</p>
<p>返回单个的 Shape 对象后使用 TextFrame 属性和 Characters 方法清除文本框中的字符，关于 Shape 对象的 TextFrame 属性和 Characters 方法请参阅 53 。</p>
<p>如果图形的名称没有规律，可以使用 For Each...Next 语句循环遍历所有图形，根据 Type 属性返回的图形类型进行相应的操作，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> ErgShapes_2<span>(</span><span>)</span>
	<span>Dim</span> myShape <span>As</span> Shape
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	i <span>=</span> <span>1</span>
	<span>For</span> <span>Each</span> myShape <span>In</span> Sheet1<span>.</span>Shapes
		<span>If</span> myShape<span>.</span><span>Type</span> <span>=</span> msoTextBox <span>Then</span>
			myShape<span>.</span>TextFrame<span>.</span>Characters<span>.</span>Text <span>=</span> <span>"这是第"</span> <span>&amp;</span> i <span>&amp;</span> <span>"个文本框"</span>
			i <span>=</span> i <span>+</span> <span>1</span>
		<span>End</span> <span>If</span>
	<span>Next</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>代码解析：</p>
<p>ErgShapes_2 过程在工作表中的所有图形文本框中写入文本。</p>
<p>第 5 行代码使用 For Each...Next 语句循环遍历工作表中所有的图形对象。</p>
<p>第 6 行到第 9 行代码如果图形对象是文本框则在文本框中写入文本。其中第 6 行代码根据 Type 属性判断图形对象是否为文本框，应用于 Shape 对象的 Type 属性返回或设置图形类型， MsoShapeType 类型，请参阅表格 54-1 。</p>
<p>第 7 行代码根据返回的 Type 属性值在所有的文本框内写入相应的文本，如图 56-1 所示。</p>
<div>
<p><img src="./assets/56-1.png" alt="" loading="lazy"></p>
<p><u>图 56-1</u>	遍历所有的文本框</p>
</div>
<h2 id="_57、移动、旋转图片"> 57、移动、旋转图片</h2>
<p>工作表中的图片可以移动、旋转，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> MoveShape<span>(</span><span>)</span>
	<span>Dim</span> i <span>As</span> <span>Long</span>
	<span>Dim</span> j <span>As</span> <span>Long</span>
	<span>With</span> Sheet1<span>.</span>Shapes<span>(</span><span>1</span><span>)</span>
		<span>For</span> i <span>=</span> <span>1</span> <span>To</span> <span>3000</span> <span>Step</span> <span>5</span>
		 <span>.</span>Top <span>=</span> Sin<span>(</span>i <span>*</span> <span>(</span><span>3.1416</span> <span>/</span> <span>180</span><span>)</span><span>)</span> <span>*</span> <span>100</span> <span>+</span> <span>100</span>
		 <span>.</span>Left <span>=</span> Cos<span>(</span>i <span>*</span> <span>(</span><span>3.1416</span> <span>/</span> <span>180</span><span>)</span><span>)</span> <span>*</span> <span>100</span> <span>+</span> <span>100</span>
		 <span>.</span>Fill<span>.</span>ForeColor<span>.</span>RGB <span>=</span> i <span>*</span> <span>100</span>
			<span>For</span> j <span>=</span> <span>1</span> <span>To</span> <span>10</span>
				<span>.</span>IncrementRotation <span>-</span><span>2</span>
				DoEvents
			<span>Next</span>
		<span>Next</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>代码解析：</p>
<p>MoveShape 过程移动、旋转工作表中的图片并不断改变其填充的前景色。</p>
<p>第 6 行代码设置图片的 Top 属性值，应用于 Shape 对象的 Top 属性设置图形的顶端到工作表顶端的距离。在循环的过程中使用 Sin 函数将 Top 属性值设置为一个圆形的弧度值。Sin 函数返回指定参数的正弦值，语法如下：</p>
<div><pre><code>Sin<span>(</span>number<span>)</span>

参数number表示一个以弧度为单位的角。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>Sin 函数取一角度为参数值，并返回角的对边长度除以斜边长度的比值，将角度除以 180 后即能角度转换为弧度。</p>
<p>第 7 行代码设置图片的 Left 属性值，应用于 Shape 对象的 Left 属性设置图形从左边界至 A 列左边界（在工作表中）或图表区左边界（在图表工作表中）的距离。在循环的过程中使用 Cos 函数将 Left 属性值设置为一个圆形的弧度值。Cos 函数返回指定一个角的余弦值，语法如下：</p>
<div><pre><code>Cos<span>(</span>number<span>)</span>

参数number表示一个以弧度为单位的角。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>Cos 函数的 number 参数为一个角，并返回直角三角形两边的比值，该比值为角的邻边长度除以斜边长度之商，将角度除以 180 后即能角度转换为弧度。</p>
<p>第 8 行代码设置图片填充的前景色随着循环的过程不断的变化。使用Fill属性返回一个 FillFormat 对象，FillFormat 对象代表图形的填充格式，其 ForeColor 属性设置对象填充的前景色。</p>
<p>第 9 行到第 11 行代码在图形移动的过程中使用 IncrementRotation 方法设置图形绕 z 轴的转角，IncrementRotation 方法以指定的度数为增量，更改指定的图形绕 z 轴的转角，语法如下：</p>
<div><pre><code>expression<span>.</span>IncrementRotation<span>(</span>Increment<span>)</span>

参数expression是必需的，返回一个Shape对象。
参数Increment是必需的，以度为单位指定图形在水平方向的旋转量，正值使图形按顺时针方向旋转，负值使图形按逆时针方向旋转。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>其中第 11 行是关键的代码，使用 DoEvents 函数转让控制权，否则达不到预计的视觉效果。</p>
<p>运行 MoveShape 过程，工作表的图形在自身进行逆时针方向旋转的同时沿着一个圆形的弧度进行移动，并不断改变其填充的颜色。</p>
<h2 id="_58、工作表中自动插入图片"> 58、工作表中自动插入图片</h2>
<p>在日常工作中经常需要在工作表中插入大量图片，比如在如图 58-1 所示的工作表中需要根据 A 列的名称在 C 列插入保存在同一目录中的相应的图片，如果使用手工插入不仅非常繁琐且极易出错，而使用 VBA 代码可以很好的完成操作。</p>
<div>
<p><img src="./assets/58-1.png" alt="" loading="lazy"></p>
<p><u>图 58-1</u>	需插入图片的工作表</p>
</div>
<p>示例代码如下：</p>
<div><pre><code><span>Sub</span> insertPic<span>(</span><span>)</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>Dim</span> FilPath <span>As</span> <span>String</span>
	<span>Dim</span> rng <span>As</span> Range
	<span>Dim</span> s <span>As</span> <span>String</span>
	<span>With</span> Sheet1
		<span>For</span> i <span>=</span> <span>3</span> <span>To</span> <span>.</span>Range<span>(</span><span>"a65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row
			FilPath <span>=</span> ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\"</span> <span>&amp;</span> <span>.</span>Cells<span>(</span>i<span>,</span> <span>1</span><span>)</span><span>.</span>Text <span>&amp;</span> <span>".jpg"</span>
			<span>If</span> Dir<span>(</span>FilPath<span>)</span> <span>&lt;</span><span>></span> <span>""</span> <span>Then</span>
				<span>.</span>Pictures<span>.</span>Insert<span>(</span>FilPath<span>)</span><span>.</span><span>Select</span>
				<span>Set</span> rng <span>=</span> <span>.</span>Cells<span>(</span>i<span>,</span> <span>3</span><span>)</span>
				<span>With</span> Selection
					<span>.</span>Top <span>=</span> rng<span>.</span>Top <span>+</span> <span>1</span>
					<span>.</span>Left <span>=</span> rng<span>.</span>Left <span>+</span> <span>1</span>
					<span>.</span>Width <span>=</span> rng<span>.</span>Width <span>-</span> <span>1</span>
					<span>.</span>Height <span>=</span> rng<span>.</span>Height <span>-</span> <span>1</span>
				<span>End</span> <span>With</span>
			<span>Else</span>
				s <span>=</span> s <span>&amp;</span> Chr<span>(</span><span>10</span><span>)</span> <span>&amp;</span> <span>.</span>Cells<span>(</span>i<span>,</span> <span>1</span><span>)</span><span>.</span>Text
			<span>End</span> <span>If</span>
		<span>Next</span>
		<span>.</span>Cells<span>(</span><span>3</span><span>,</span> <span>1</span><span>)</span><span>.</span><span>Select</span>
	<span>End</span> <span>With</span>
	<span>If</span> s <span>&lt;</span><span>></span> <span>""</span> <span>Then</span>
		MsgBox s <span>&amp;</span> Chr<span>(</span><span>10</span><span>)</span> <span>&amp;</span> <span>"没有照片!"</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>代码解析：</p>
<p>insertPic 过程使用 Insert 方法在工作表中插入图片。</p>
<p>第 7 行代码开始 For...Next 循环，循环的终值由工作表中 A 列单元格的行数所决定。</p>
<p>第 8 行代码字符串变量FilPath保存A列名称单元格所对应的图片文件的路径和文件名，本例中图片文件的文件名应和A列中的名称一致。</p>
<p>第 9 行到第 11 行代码使用 Dir 函数在同一文件夹中查找与 A 列单元格中的名称相对应的图片文件，如果对应的图片文件存在则使用 Insert 方法将图片插入到工作表中，并将 C 列的单元格赋给变量 rng。</p>
<p>Dir 函数返回一个 String，用以表示一个文件名、目录名或文件夹名称，它必须与指定的模式或文件属性、或磁盘卷标相匹配。如果已没有合乎条件的文件，则 Dir 函数会返回一个零长度字符串 （&quot;&quot;）。</p>
<p>第 12 行到第 17 行代码，当图片片插入到工作表时其实是插入到活动单元格的，此时需设置图片的 Top 属性和 Left 属性将图片移动到 C 列所对应的单元格中，并设置其 Width 属性和 Height 属性使其适应所在单元格的大小。</p>
<p>第 18、19 行代码如果在同一文件夹中没有与 A 列单元格对应的图片文件，则使用字符串变量 s 保存没有图片文件的名称。</p>
<p>第 24 行到第 26 行代码如果字符串变量s不等于空白说明文件夹中缺少图片文件，使用消息框提示。</p>
<p>运行 insertPic 过程工作表如图 58-2 所示。</p>
<div>
<p><img src="./assets/58-2.png" alt="" loading="lazy"></p>
<p><u>图 58-2</u>	插入图片后的工作表</p>
</div>
<p>如果文件夹中缺少对应的图片文件，则会进行提示，如图 58-3 所示。</p>
<div>
<p><img src="./assets/58-3.png" alt="" loading="lazy"></p>
<p><u>图 58-3</u>	缺少图片文件提示</p>
</div>
<h2 id="_59、固定工作表中图形的位置"> 59、固定工作表中图形的位置</h2>
<p>工作表中插入的图片，一般都是固定的尺寸和固定的单元格区域中的，但在实际使用中可能因一些人为的因素导致图片位置偏移或尺寸变化，此时可以使用 VBA 代码进行调整，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> ShapeAddress<span>(</span><span>)</span>
	<span>Dim</span> rng <span>As</span> Range
	<span>Set</span> rng <span>=</span> Sheet1<span>.</span>Range<span>(</span><span>"B4:E22"</span><span>)</span>
	<span>With</span> Sheet1<span>.</span>Shapes<span>(</span><span>"Picture 1"</span><span>)</span>
		<span>.</span>Rotation <span>=</span> <span>0</span>
		<span>.</span><span>Select</span>
		<span>With</span> Selection
			<span>.</span>Top <span>=</span> rng<span>(</span><span>1</span><span>)</span><span>.</span>Top <span>+</span> <span>1</span>
			<span>.</span>Left <span>=</span> rng<span>(</span><span>1</span><span>)</span><span>.</span>Left <span>+</span> <span>1</span>
			<span>.</span>Width <span>=</span> rng<span>.</span>Width <span>-</span> <span>0.5</span>
			<span>.</span>Height <span>=</span> rng<span>.</span>Height <span>-</span> <span>0.5</span>
		<span>End</span> <span>With</span>
	<span>End</span> <span>With</span>
	Range<span>(</span><span>"A1"</span><span>)</span><span>.</span><span>Select</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>代码解析：</p>
<p>ShapeAddress 过程调整指定图形在工作表中的位置。</p>
<p>第 3 行代码变量 rng 保存工作表中插入图片的单元格区域。。</p>
<p>第 5 行代码设置图片的转角，应用于 Shape 对象 Rotation 属性以度为单位返回或设置图形的转角，设置为正值向右偏转，设置为负值向左偏转，设置为零图片则保持 90 度垂直。</p>
<p>第 7 行到第 12 行代码设置图片的 Top 属性和 Left 属性将图片移动到变量 rng 所保存的单元格区域中，并设置其 Width 属性和 Height 属性使其适应所在单元格区域的大小。</p>
<p>第 14 行代码选择 <code>A1</code> 单元格，不然图片会处于选中状态。</p>
<p>经过以上设置，工作表中的图片“Picture 1”不管处于什么状态都可以一键恢复其原来的大小、位置。</p>
<h2 id="_60、使用-vba-自动生成图表"> 60、使用 VBA 自动生成图表</h2>
<p>在实际工作中我们常用图表来表现数据间的某种相对关系，一般采用手工插入的方式，而使用 VBA 代码可以在工作表中自动生成图表，如下面的示例代码。</p>
<div><pre><code><span>Sub</span> ChartAdd<span>(</span><span>)</span>
	<span>Dim</span> myRange <span>As</span> Range
	<span>Dim</span> myChart <span>As</span> ChartObject
	<span>Dim</span> R <span>As</span> <span>Integer</span>
	<span>With</span> Sheet1
		<span>.</span>ChartObjects<span>.</span>Delete
		R <span>=</span> <span>.</span>Range<span>(</span><span>"A65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row
		<span>Set</span> myRange <span>=</span> <span>.</span>Range<span>(</span><span>"A"</span> <span>&amp;</span> <span>1</span> <span>&amp;</span> <span>":B"</span> <span>&amp;</span> R<span>)</span>
		<span>Set</span> myChart <span>=</span> <span>.</span>ChartObjects<span>.</span>Add<span>(</span><span>120</span><span>,</span> <span>40</span><span>,</span> <span>400</span><span>,</span> <span>250</span><span>)</span>
		<span>With</span> myChart<span>.</span>Chart
			<span>.</span>ChartType <span>=</span> xlColumnClustered
			<span>.</span>SetSourceData Source<span>:</span><span>=</span>myRange<span>,</span> PlotBy<span>:</span><span>=</span>xlColumns
			<span>.</span>ApplyDataLabels ShowValue<span>:</span><span>=</span><span>True</span>
			<span>.</span>HasTitle <span>=</span> <span>True</span>
			<span>.</span>ChartTitle<span>.</span>Text <span>=</span> <span>"图表制作示例"</span>
			<span>With</span> <span>.</span>ChartTitle<span>.</span>Font
				<span>.</span>Size <span>=</span> <span>20</span>
				<span>.</span>ColorIndex <span>=</span> <span>3</span>
				<span>.</span>Name <span>=</span> <span>"华文新魏"</span>
			<span>End</span> <span>With</span>
			<span>With</span> <span>.</span>ChartArea<span>.</span>Interior
				<span>.</span>ColorIndex <span>=</span> <span>8</span>
				<span>.</span>PatternColorIndex <span>=</span> <span>1</span>
				<span>.</span>Pattern <span>=</span> xlSolid
			<span>End</span> <span>With</span>
			<span>With</span> <span>.</span>PlotArea<span>.</span>Interior
				<span>.</span>ColorIndex <span>=</span> <span>35</span>
				<span>.</span>PatternColorIndex <span>=</span> <span>1</span>
				<span>.</span>Pattern <span>=</span> xlSolid
			<span>End</span> <span>With</span>
			<span>.</span>SeriesCollection<span>(</span><span>1</span><span>)</span><span>.</span>DataLabels<span>.</span>Delete
			<span>With</span> <span>.</span>SeriesCollection<span>(</span><span>2</span><span>)</span><span>.</span>DataLabels<span>.</span>Font
				<span>.</span>Size <span>=</span> <span>10</span>
				<span>.</span>ColorIndex <span>=</span> <span>5</span>
			<span>End</span> <span>With</span>
		<span>End</span> <span>With</span>
	<span>End</span> <span>With</span>
	<span>Set</span> myRange <span>=</span> <span>Nothing</span>
	<span>Set</span> myChart <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><p>代码解析：</p>
<p>ChartAdd 过程在工作表中自动生成图表，图表类型为簇状柱形图。</p>
<p>第 6 行代码使用 Delete 方法删除工作表中已经存在的图表，而 ChartObjects 方法返回代表工作表中单个嵌入图表（ChartObject 对象）或所有嵌入图表的集合（ChartObjects 对象）的对象，语法如下：</p>
<div><pre><code>expression<span>.</span>ChartObjects<span>(</span>Index<span>)</span>

其中参数Index是可选的，指定图表的名称或号码。该参数可以是数组，用于指定多个图表，因为示例中只有一个图表，所以无需指定其Index参数。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>第 8 行代码指定图表的数据源。</p>
<p>第 9 行代码使用 Add 方法创建一个新图表，应用于 ChartObjects 对象的 Add 方法创建新的嵌入图表，语法如下：</p>
<div><pre><code>expression<span>.</span>Add<span>(</span>Left<span>,</span> Top<span>,</span> Width<span>,</span> Height<span>)</span>

参数Left、Top是必需的，以磅为单位给出新对象的初始坐标，该坐标是相对于工作表上单元格A1的左上角或图表的左上角的坐标。
参数Width、Height是必需，以磅为单位给出新对象的初始大小。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第 10 行代码使用 Chart 属性返回新创建的图表，应用于 ChartObject 对象的 Chart 属性返回一个 Chart 对象，该对象代表指定对象所包含的图表。</p>
<p>第 11 行代码指定新创建图表的图表类型，应用于 Chart 对象的 ChartType 属性返回或设置图表的类型，可以为 XlChartType 常量之一，具体请参阅 VBA 帮助。本例中设置为 xlColumnClustered 即图表类型为簇状柱形图。</p>
<p>第 12 行代码指定图表的数据源和绘图方式，应用于 Chart 对象的 SetSourceData 方法为指定图表设置源数据区域，语法如下：</p>
<div><pre><code>expression<span>.</span>SetSourceData<span>(</span>Source<span>,</span> PlotBy<span>)</span>

参数expression是必需的，该表达式返回一个Chart对象。
参数Source是可选的，源数据的区域。
参数PlotBy是可选的，指定数据绘制方式，可为xlColumns（系列产生在列）或xlRows（系列产生在行）。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>第 13 行代码使用 ApplyDataLabels 方法使图表显示数据标签和数据点的值，应用于 Chart 对象的 ApplyDataLabels 方法将数据标签应用于图表中的某一数据点、某一数据系列或所有数据系列，语法如下：</p>
<div><pre><code>expression<span>.</span>ApplyDataLabels<span>(</span><span>Type</span><span>,</span> LegendKey<span>,</span> AutoText<span>,</span> HasLeaderLines<span>,</span> ShowSeriesName<span>,</span> ShowCategoryName<span>,</span> ShowValue<span>,</span> ShowPercentage<span>,</span> ShowBubbleSize<span>,</span> Separator<span>)</span>

参数expression是必需的，该表达式返回一个Chart对象。
参数<span>Type</span>是可选的，要应用的数据标签的类型，可为表格 <span>60</span><span>-</span><span>1</span>所列的XlDataLabelsType 常量之一。
参数LegendKey是可选的，如果该值为<span>True</span>，则显示数据点旁的图例项标示。默认值为<span>False</span>。
参数AutoText是可选的，如果对象根据内容自动生成正确的文字，则该值为<span>True</span>。
参数HasLeaderLines是可选的，如果数据系列具有引导线，则该值为<span>True</span>。
参数ShowSeriesName是可选的，数据标签的系列名称。
参数ShowCategoryName是可选的，数据标签的分类名称。
参数ShowValue是可选的，数据标签的值。
参数ShowPercentage是可选的，数据标签的百分比。
参数ShowBubbleSize是可选的，数据标签的气泡尺寸。
参数Separator是可选的，数据标签的分隔符。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><u>表格 60-1</u>	XlDataLabelsType 常量</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>xlDataLabelsShowBubbleSizes</td>
<td>6</td>
<td>无</td>
</tr>
<tr>
<td>xlDataLabelsShowLabelAndPercent</td>
<td>5</td>
<td>占总数的百分比及数据点所属的分类。仅用于饼图或圆环图。</td>
</tr>
<tr>
<td>xlDataLabelsShowPercent</td>
<td>3</td>
<td>占总数的百分比。仅用于饼图或圆环图。</td>
</tr>
<tr>
<td>xlDataLabelsShowLabel</td>
<td>4</td>
<td>数据点所属的分类。</td>
</tr>
<tr>
<td>xlDataLabelsShowNone</td>
<td>-4142</td>
<td>无数据标签。</td>
</tr>
<tr>
<td>xlDataLabelsShowValue</td>
<td>2</td>
<td>数据点的值，若未指定本参数，默认使用此设置。</td>
</tr>
</tbody>
</table>
<p>第 14、15 行代码设置新创建的图表有可见的标题并设置图表标题的文字。应用于 Chart 对象的 HasTitle 属性，如果坐标轴或图表有可见标题，则该值为 True，而 ChartTitle 属性返回一个 ChartTitle 对象，代表指定图表的标题。</p>
<p>第 16 行到第 20 行代码设置图表标题文字的格式。</p>
<p>第 21 行到第 25 行代码设置图表区的颜色。</p>
<p>第 26 行到第 30 行代码设置绘图区的颜色。</p>
<p>第 31 行代码删除图表上第一个数据系列中的数据标签。SeriesCollection 方法返回图表或图表组中单个数据系列（Series 对象)或所有数据系列的集合（SeriesCollection 集合)的对象，语法如下：</p>
<div><pre><code>expression<span>.</span>SeriesCollection<span>(</span>Index<span>)</span>

可选的Index参数指定数据系列的名称或编号。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>而 DataLabels 方法则返回代表数据系列中的单个数据标签（DataLabel 对象）或所有数据标签的集合（DataLabels 集合）的对象，语法如下：</p>
<div><pre><code>expression<span>.</span>DataLabels<span>(</span>Index<span>)</span>

可选的Index参数指定数据系列中的数据标签的编号。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>第 32 行到第 36 行代码设置图表上第二个数据系列中的数据标签的字体格式。</p>
<p>运行 ChartAdd 过程，在工作表中创建簇状柱形图，如图 60-1 所示。</p>
<div>
<p><img src="./assets/60-1.png" alt="" loading="lazy"></p>
<p><u>图 60-1</u>	创建簇状柱形图</p>
</div>
<h2 id="_61、使用独立窗口显示图表"> 61、使用独立窗口显示图表</h2>
<p>如果需要将工作表中嵌入的图表显示在独立的窗口中，可以使用下面的代码。</p>
<div><pre><code><span>Sub</span> ChartShow<span>(</span><span>)</span>
	<span>With</span> Sheet1<span>.</span>ChartObjects<span>(</span><span>1</span><span>)</span>
		<span>.</span>Activate
		<span>.</span>Chart<span>.</span>ShowWindow <span>=</span> <span>True</span>
	<span>End</span> <span>With</span>
	<span>With</span> ActiveWindow
		<span>.</span>Top <span>=</span> <span>50</span>
		<span>.</span>Left <span>=</span> <span>50</span>
		<span>.</span>Width <span>=</span> <span>400</span>
		<span>.</span>Height <span>=</span> <span>280</span>
		<span>.</span>Caption <span>=</span> ThisWorkbook<span>.</span>Name
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>代码解析：</p>
<p>ChartShow 过程，将工作表中嵌入的图表显示在独立的窗口中。</p>
<p>第 2 行到第 5 行代码将工作表中指定图表的 ShowWindow 属性设置为 True，使用独立的窗口显示该图表。</p>
<p>第 7、8 行代码指定活动窗口显示的位置。</p>
<p>第 9、10 行代码调整活动窗口的大小使之适应图表的大小。</p>
<p>第 11 行代码指定活动窗口标题栏中显示的标题。</p>
<p>运行 ChartShow 过程结果如图 61-1 所示。</p>
<div>
<p><img src="./assets/61-1.png" alt="" loading="lazy"></p>
<p><u>图 61-1</u>	使用独立窗口显示图表</p>
</div>
<h2 id="_62、导出工作表中的图表"> 62、导出工作表中的图表</h2>
<p>如果需要将工作表中的图表保存为单独的图像文件，可以使用 Export 方法以图形文件格式导出图表，示例代码如下。</p>
<div><pre><code><span>Sub</span> ExportChart<span>(</span><span>)</span>
	<span>Dim</span> myChart <span>As</span> Chart
	<span>Dim</span> myFileName <span>As</span> <span>String</span>
	<span>Set</span> myChart <span>=</span> Sheet1<span>.</span>ChartObjects<span>(</span><span>1</span><span>)</span><span>.</span>Chart
	myFileName <span>=</span> <span>"myChart.jpg"</span>
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	Kill ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\"</span> <span>&amp;</span> myFileName
	myChart<span>.</span>Export Filename<span>:</span><span>=</span>ThisWorkbook<span>.</span>Path <span>_</span>
		<span>&amp;</span> <span>"\"</span> <span>&amp;</span> myFileName<span>,</span> Filtername<span>:</span><span>=</span><span>"JPG"</span>
	MsgBox <span>"图表已保存在["</span> <span>&amp;</span> ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"]文件夹中!"</span>
	<span>Set</span> myChart <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>代码解析：</p>
<p>ExportChart 过程使用 Export 方法将工作表中的图表以图形文件的形式导出。</p>
<p>第 4 行代码指定工作表中的图表对象。</p>
<p>第 5 行代码指定图形文件保存的文件名。</p>
<p>第 6、7 行代码使用 Kill 语句删除文件夹中原有的图形文件。当文件夹中指定删除的文件不存在时 Kill 语句会出错所以需要使用 On Error 语句忽略错误。</p>
<p>第 8、9 行代码使用 Export 方法将图表导出到同一目录中，应用于 Chart 对象的 Export 方法以图形文件格式导出图表，语法如下：</p>
<div><pre><code>expression<span>.</span>Export<span>(</span>Filename<span>,</span> FilterName<span>,</span> Interactive<span>)</span>

其中参数Filename是必需的，被导出的文件的名称，示例中加上了文件保存的路径。
参数FilterName是可选的，被导出的文件的图形格式，示例中文件以JPG文件格式保存。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="_63、多图表制作"> 63、多图表制作</h2>
<p>如果需要，我们可以为工作表中的每一个数据区域创建一张图表，在如图 63-1 所示的工作表区域中，需要为每一个员工的全年数据创建一张图表。</p>
<div>
<p><img src="./assets/63-1.png" alt="" loading="lazy"></p>
<p><u>图 63-1</u>	数据区域</p>
</div>
<p>示例代码如下：</p>
<div><pre><code><span>Sub</span> ChartsAdd<span>(</span><span>)</span>
	<span>Dim</span> myChart <span>As</span> ChartObject
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>Dim</span> R <span>As</span> <span>Integer</span>
	<span>Dim</span> m <span>As</span> <span>Integer</span>
	R <span>=</span> Sheet1<span>.</span>Range<span>(</span><span>"A65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row <span>-</span> <span>1</span>
	m <span>=</span> Abs<span>(</span>Int<span>(</span><span>-</span><span>(</span>R <span>/</span> <span>4</span><span>)</span><span>)</span><span>)</span>
	Sheet2<span>.</span>ChartObjects<span>.</span>Delete
	<span>For</span> i <span>=</span> <span>1</span> <span>To</span> R
		<span>Set</span> myChart <span>=</span> Sheet2<span>.</span>ChartObjects<span>.</span>Add <span>_</span>
			<span>(</span>Left<span>:</span><span>=</span><span>(</span><span>(</span><span>(</span>i <span>-</span> <span>1</span><span>)</span> <span>Mod</span> m<span>)</span> <span>+</span> <span>1</span><span>)</span> <span>*</span> <span>350</span> <span>-</span> <span>320</span><span>,</span> <span>_</span>
			Top<span>:</span><span>=</span><span>(</span><span>(</span>i <span>-</span> <span>1</span><span>)</span> <span>\</span> m <span>+</span> <span>1</span><span>)</span> <span>*</span> <span>220</span> <span>-</span> <span>210</span><span>,</span> <span>_</span>
			Width<span>:</span><span>=</span><span>330</span><span>,</span> Height<span>:</span><span>=</span><span>210</span><span>)</span>
		<span>With</span> myChart<span>.</span>Chart
			<span>.</span>ChartType <span>=</span> xlColumnClustered
			<span>.</span>SetSourceData Source<span>:</span><span>=</span>Sheet1<span>.</span>Range<span>(</span><span>"B2:M2"</span><span>)</span><span>.</span>Offset<span>(</span>i <span>-</span> <span>1</span><span>)</span><span>,</span> <span>_</span>
			PlotBy<span>:</span><span>=</span>xlRows
			<span>With</span> <span>.</span>SeriesCollection<span>(</span><span>1</span><span>)</span>
				<span>.</span>XValues <span>=</span> Sheet1<span>.</span>Range<span>(</span><span>"B1:M1"</span><span>)</span>
				<span>.</span>Name <span>=</span> Sheet1<span>.</span>Range<span>(</span><span>"A2"</span><span>)</span><span>.</span>Offset<span>(</span>i <span>-</span> <span>1</span><span>)</span>
				<span>.</span>ApplyDataLabels AutoText<span>:</span><span>=</span><span>True</span><span>,</span> ShowValue<span>:</span><span>=</span><span>True</span>
				<span>.</span>DataLabels<span>.</span>Font<span>.</span>Size <span>=</span> <span>10</span>
			<span>End</span> <span>With</span>
			<span>.</span>HasLegend <span>=</span> <span>False</span>
			<span>With</span> <span>.</span>ChartTitle
				<span>.</span>Left <span>=</span> <span>5</span>
				<span>.</span>Top <span>=</span> <span>1</span>
				<span>.</span>Font<span>.</span>Size <span>=</span> <span>14</span>
				<span>.</span>Font<span>.</span>Name <span>=</span> <span>"华文行楷"</span>
			<span>End</span> <span>With</span>
			<span>With</span> <span>.</span>PlotArea<span>.</span>Interior
				<span>.</span>ColorIndex <span>=</span> <span>2</span>
				<span>.</span>PatternColorIndex <span>=</span> <span>1</span>
				<span>.</span>Pattern <span>=</span> xlSolid
			<span>End</span> <span>With</span>
			<span>.</span>Axes<span>(</span>xlCategory<span>)</span><span>.</span>TickLabels<span>.</span>Font<span>.</span>Size <span>=</span> <span>10</span>
			<span>.</span>Axes<span>(</span>xlValue<span>)</span><span>.</span>TickLabels<span>.</span>Font<span>.</span>Size <span>=</span> <span>10</span>
		<span>End</span> <span>With</span>
	<span>Next</span>
	Sheet2<span>.</span><span>Select</span>
	<span>Set</span> myChart <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><p>代码解析：</p>
<p>ChartsAdd 过程根据数据工作表 A 列的人数在图表工作表中创建图表并分 4 行排列整齐。</p>
<p>第 6 行代码取得数据工作表中需要创建图表的人数。</p>
<p>第 7 行代码计算图表工作表每行需要排列的图表数目，共分 4 行排列。使用 Int 函数返回图表数目除 4 行后的整数部分，使用负值是为了向上取整数，最后使用 Abs 函数返回绝对值，将负值转化为正值。</p>
<p>第 8 行代码使用 Delete 方法删除图表工作表中存在的所有图表。</p>
<p>第 9 行代码开始 For...Next 循环，循环的终值由需要创建的图表数目决定。</p>
<p>第 10 行到第 13 行代码使用 Add 方法在图表工作表中创建嵌入的图表，关于应用于 ChartObjects 对象的 Add 方法请参阅 60 。其中第 11、12 行代码根据循环计数器的数值设置新创建图表的 Left 和 To p属性使之依次排列。第 13 行代码设置图表的大小。</p>
<p>第 15 行代码设置新创建图表的类型。</p>
<p>第 16、17 行代码根据循环计数器的数值分别设置新创建图表的数据源。</p>
<p>第 18 行到第 23 行代码设置图表第一个数据系列的名称、数据标签和字体格式。</p>
<p>第 24 行代码删除图表中的图例。</p>
<p>第 25 行到第 30 行代码设置图表的标题。</p>
<p>第 31 行到第 35 行代码设置图表的绘图区。</p>
<p>第 36、37 行代码设置图表坐标轴的字体大小。</p>
<p>关于图表的设置请参阅 60 。</p>
<p>运行 ChartsAdd 过程如图 63-2 所示。</p>
<div>
<p><img src="./assets/63-2.png" alt="" loading="lazy"></p>
<p><u>图 63-2</u>	图表工作表</p>
</div>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-07-02T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">VBA 之 Application 对象</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Excel/07.VBA_Application/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Excel/07.VBA_Application/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="_64、取得-excel-版本信息"> 64、取得 Excel 版本信息</h2>
<p>Application 对象的 Version 属性可以返回 Excel 的版本号，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> AppVersion<span>(</span><span>)</span>
  <span>Dim</span> myVersion <span>As</span> <span>String</span>
  <span>Select</span> <span>Case</span> Application<span>.</span>Version
	  <span>Case</span> <span>"8.0"</span>
		  myVersion <span>=</span> <span>"97"</span>
	  <span>Case</span> <span>"9.0"</span>
		  myVersion <span>=</span> <span>"2000"</span>
	  <span>Case</span> <span>"10.0"</span>
		  myVersion <span>=</span> <span>"2002"</span>
	  <span>Case</span> <span>"11.0"</span>
		  myVersion <span>=</span> <span>"2003"</span>
	  <span>Case</span> <span>Else</span>
		  myVersion <span>=</span> <span>"版本未知"</span>
  <span>End</span> <span>Select</span>
  MsgBox <span>"Excel 版本是： "</span> <span>&amp;</span> myVersion
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>代码解析：</p>
<p>AppVersion 过程返回 Application 对象的 Version 属性值来取得 Excel 版本号。</p>
<p>应用于 Application 对象的 Version 属性返回 Excel 版本号，语法如下：</p>
<div><pre><code>expression<span>.</span>Version

参数expression是必需的，Application对象。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>运行 AppVersion 过程结果如图 64-1 所示。</p>
<div>
<p><img src="./assets/64-1.png" alt="" loading="lazy"></p>
<p><u>图 64-1</u>	取得 Excel 版本号</p>
</div>
<h2 id="_65、取得当前用户名称"> 65、取得当前用户名称</h2>
<p>使用 Application 对象的 UserName 属性可以取得当前用户名称，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> UserName<span>(</span><span>)</span>
	MsgBox <span>"当前用户名是: "</span> <span>&amp;</span> Application<span>.</span>UserName
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>UserName 过程使用消息框显示当前用户名称。</p>
<p>Application 对象的 UserName 属性返回或设置当前用户的名称。</p>
<p>运行 UserName 过程效果如图 65-1 所示。</p>
<div>
<p><img src="./assets/65-1.png" alt="" loading="lazy"></p>
<p><u>图 65-1</u>	显示当前用户名称</p>
</div>
<h2 id="_66、excel-中的-定时器"> 66、Excel 中的“定时器“</h2>
<p>Excel VBA 并没有提供定时器控件，但是用户可以通过 Application 对象的 OnTime 方法实现简单的定时器功能，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> StartTimer<span>(</span><span>)</span>
	Sheet1<span>.</span>Cells<span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span> <span>=</span> Sheet1<span>.</span>Cells<span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span> <span>+</span> <span>1</span>
	Application<span>.</span>OnTime Now <span>+</span> TimeValue<span>(</span><span>"00:00:01"</span><span>)</span><span>,</span> <span>"StartTimer"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>代码解析：</p>
<p>StartTimer 过程，使用 Application 对象的 OnTime 方法循环调用 StartTimer 过程实现每隔一秒钟运行一次 StartTimer 过程，从而在B1单元格中不断地显示程序累计运行时间，如图 66-1 所示。</p>
<div>
<p><img src="./assets/66-1.png" alt="" loading="lazy"></p>
<p><u>图 66-1</u>	简单的定时器</p>
</div>
<p>第 2 行代码将 <code>B1</code> 单元格的值在原有的数字上加 1。</p>
<p>第 3 行代码使用 OnTime 方法在 1 秒后重新调用 StartTimer 过程，使 <code>B1</code> 单元格的值不断的加 1，从而显示程序累计运行时间。</p>
<p>应用于 Application 对象的 OnTime 方法能够安排一个过程在将来的特定时间运行，语法如下：</p>
<div><pre><code>expression<span>.</span>OnTime<span>(</span>EarliestTime<span>,</span> Procedure<span>,</span> LatestTime<span>,</span> Schedule<span>)</span>

参数expression是必需的，返回一个Application对象。
参数EarliestTime是必需的，设置指定的过程开始运行的时间。使用Now <span>+</span> TimeValue<span>(</span>time<span>)</span>可以安排从现在开始经过一段时间之后运行某个过程，使用TimeValue<span>(</span>time<span>)</span>可以安排在指定的时间运行某个过程。
参数Procedure是必需的，设置要运行的过程名称。
参数LatestTime是可选的，设置过程开始运行的最晚时间。例如将参数LatestTime设置为EarliestTime<span>+</span><span>10</span>，当时间到了EarliestTime时如果Excel不处于空闲状态，那么Excel将等待<span>10</span>秒，如果在<span>10</span>秒内Excel不能回到空闲状态，则不运行该过程。如果省略该参数，Excel将一直等待到可以运行该过程为止。
参数Schedule是可选的，如果其值为<span>True</span>（默认值），则安排一个新的OnTime过程，如果其值为<span>False</span>，则清除先前设置的过程。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>取消定时的代码如下：</p>
<div><pre><code><span>Sub</span> EndTimer<span>(</span><span>)</span>
	<span>On</span> <span>Error</span> <span>GoTo</span> Line
	Application<span>.</span>OnTime Now <span>+</span> TimeValue<span>(</span><span>"00:00:01"</span><span>)</span><span>,</span> <span>"StartTimer"</span><span>,</span> <span>,</span> <span>False</span>
	Sheet1<span>.</span>Cells<span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span> <span>=</span> <span>0</span>
	<span>Exit</span> <span>Sub</span>
Line<span>:</span>
	MsgBox <span>"请先按[开始]按钮!"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>代码解析：</p>
<p>EndTimer 过程取消 StartTimer 过程的定时。</p>
<p>第 2 行代码错误处理语句，因为如果还没有运行 StartTimer 过程而先运行 EndTimer 过程取消定时，程序会提示错误，如图 66-2 所示，因此使用 On Error GoTo Line 语句在错误发生时执行第 7 行代码显示一个如图 66-3 所示的提示消息框。</p>
<div>
<p><img src="./assets/66-2.png" alt="" loading="lazy"></p>
<p><u>图 66-2</u>	运行错误</p>
<p><img src="./assets/66-3.png" alt="" loading="lazy"></p>
<p><u>图 66-3</u>	提示消息框</p>
</div>
<p>第 3 行代码将 StartTimer 过程的 Schedule 参数设置为 False，取消定时设置。</p>
<h2 id="_67、设置活动打印机的名称"> 67、设置活动打印机的名称</h2>
<p>使用 Application 对象的 ActivePrinter 属性可以设置活动打印机的名称，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> myPrinter<span>(</span><span>)</span>
	<span>Dim</span> myPrinter <span>As</span> <span>String</span>
	myPrinter <span>=</span> <span>"HP LaserJet P1008 在 Ne04:"</span>
	Application<span>.</span>ActivePrinter <span>=</span> myPrinter
	MsgBox <span>"活动打印机为："</span> <span>&amp;</span> Left<span>(</span>myPrinter<span>,</span> InStr<span>(</span>myPrinter<span>,</span> <span>"在"</span><span>)</span> <span>-</span> <span>1</span><span>)</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>代码解析：</p>
<p>myPrinter 过程将活动打印机设置为“HP LaserJet P1008”。</p>
<p>第 3 行代码指定需要设置为活动打印机的名称，第 4 行代码通过设置 Application 对象的ActivePrinter 属性将活动打印机设置为“HP LaserJet P1008”。</p>
<p>第 5 行代码使用消息框显示活动打印机的名称及型号。</p>
<p>运行 myPrinter 过程结果如图 67-1 所示。</p>
<div>
<p><img src="./assets/67-1.png" alt="" loading="lazy"></p>
<p><u>图 67-1</u>	设置活动打印机</p>
</div>
<h2 id="_68、屏蔽、改变组合键的功能"> 68、屏蔽、改变组合键的功能</h2>
<p>使用 Application 对象的 OnKey 方法可以屏蔽或改变组合键的默认操作，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Workbook_Open<span>(</span><span>)</span>
	Application<span>.</span>OnKey <span>"^{c}"</span><span>,</span> <span>"myOnKey"</span>
<span>End</span> <span>Sub</span>
<span>Sub</span> myOnKey<span>(</span><span>)</span>
	MsgBox <span>"本工作表禁止复制数据!"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>代码解析：</p>
<p>第 1 行到第 3 行代码工作簿的 Open 事件，在工作簿打开时使用 OnKey 方法改变 &lt;Ctrl +C&gt; 组合键的功能。</p>
<p>应用于 Application 对象的 OnKey 方法指定特定键或特定的组合键运行的过程，语法如下：</p>
<div><pre><code>expression<span>.</span>OnKey<span>(</span>Key<span>,</span> Procedure<span>)</span>

参数expression是必需的，该表达式返回一个Application 对象。
参数Key是必需的，用于表示要按的键的字符串，具体请参阅VBA中的帮助。
参数Procedure是可选的，表示要运行的过程名称的字符串。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>本示例中将过程名称指定为第 4 行到第 6 行代码的“myOnKey”过程，当按下 &lt;Ctrl +C&gt; 组合键时并不会执行复制操作而只显示一个消息框。如果将 Procedure 参数指定为空文本（&quot;&quot;），则按 &lt;Ctrl +C&gt; 组合键时不发生任何操作，达到屏蔽组合键的效果。</p>
<p>如果省略 Procedure 参数，则按下 &lt;Ctrl +C&gt; 组合键时产生 Microsoft Excel 中的正常结果，同时清除先前使用 OnKey 方法所做的特殊击键设置，所以恢复 &lt;Ctrl +C&gt; 组合键的代码如下：</p>
<div><pre><code>Application.OnKey &quot;^{c}&quot;
</code></pre>
<div><span>1</span><br></div></div><p>为了不影响其他工作簿的功能，恢复代码就放在工作簿的 Deactivate 事件中，如下面的代码所示：</p>
<div><pre><code><span>Private</span> <span>Sub</span> Workbook_Deactivate<span>(</span><span>)</span>
	Application<span>.</span>OnKey <span>"^{c}"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>当工作簿从活动状态转为非活动状态时恢复 &lt;Ctrl +C&gt; 组合键的正常功能。</p>
<h2 id="_69、设置-excel-窗口标题栏"> 69、设置 Excel 窗口标题栏</h2>
<p>Excel 主窗口标题栏默认的名称是“Microsoft Excel”，通过设置 Application 对象的 Caption 属性可以改变 Excel 主窗口的标题栏，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> AppCaption<span>(</span><span>)</span>
	Application<span>.</span>Caption <span>=</span> <span>"修改标题栏名称"</span>
	MsgBox <span>"下面将恢复默认的标题栏名称!"</span>
	Application<span>.</span>Caption <span>=</span> Empty
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>代码解析：</p>
<p>第 2 行代码将 Excel 窗口标题设置为“修改标题栏名称”，如图 69-1 所示。</p>
<div>
<p><img src="./assets/69-1.png" alt="" loading="lazy"></p>
<p><u>图 69-1</u>	设置 Excel 窗口标题</p>
</div>
<p>应用于 Application 对象的 Caption 属性设置显示在 Microsoft Excel 主窗口标题栏中的名称，语法如下：</p>
<div><pre><code>expression<span>.</span>Caption
</code></pre>
<div><span>1</span><br></div></div><p>第 3 行代码恢复 Microsoft Excel 主窗口标题栏中的名称。如果未设置 Caption 属性（&quot;&quot;）或将其设置为 Empty（表示未初始化的变量值），则本属性返回默认的“Microsoft Excel”。</p>
<p>将 Caption 属性设置为常数 vbNullChar（表示值为 0 的字符）可以删除标题栏中的名称，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> DleCaption<span>(</span><span>)</span>
	Application<span>.</span>Caption <span>=</span> vbNullChar
	MsgBox <span>"下面将恢复默认的标题栏名称!"</span>
	Application<span>.</span>Caption <span>=</span>Empty
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>代码解析：</p>
<p>第 2 行代码删除 Excel 主窗口标题栏，结果如图 69-2 所示。</p>
<div>
<p><img src="./assets/69-2.png" alt="" loading="lazy"></p>
<p><u>图 69-2</u>	删除 Excel 窗口标题栏的名称</p>
</div>
<h2 id="_70、自定义-excel-状态栏"> 70、自定义 Excel 状态栏</h2>
<p>Excel 状态栏显示应用程序的当前状态（例如就绪、输入等）或上下文提示信息，通过设置 Application 对象的 Statusbar 属性可以修改状态栏，以显示用户自定义的信息，代码如下：</p>
<div><pre><code><span>Sub</span> myStatusBar<span>(</span><span>)</span>
	<span>Dim</span> rng <span>As</span> Range
	<span>For</span> <span>Each</span> rng <span>In</span> Sheet1<span>.</span>Range<span>(</span><span>"A1:D10000"</span><span>)</span>
		Application<span>.</span>StatusBar <span>=</span> <span>"正在计算单元格 "</span> <span>&amp;</span> rng<span>.</span>Address<span>(</span><span>0</span><span>,</span> <span>0</span><span>)</span> <span>&amp;</span> <span>" 的数据..."</span>
		rng <span>=</span> <span>100</span>
	<span>Next</span>
	Application<span>.</span>StatusBar <span>=</span> <span>False</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>代码解析：</p>
<p>myStatusBar 过程在给选定单元格区域赋值的同时，将 Excel 状态栏中的文字设置为正在赋值的单元格地址。</p>
<p>应用于 Application 对象的 StatusBar 属性返回或设置状态栏中的文字，如果需要恢复默认的状态栏文字，将本属性设为 False 即可。</p>
<p>运行 myStatusBar 过程 Excel 状态栏如图 70-1 所示。</p>
<div>
<p><img src="./assets/70-1.png" alt="" loading="lazy"></p>
<p><u>图 70-1</u>	自定义 Excel 状态栏</p>
</div>
<h2 id="_71、灵活退出-excel"> 71、灵活退出 Excel</h2>
<p>在使用 Close 方法关闭工作簿时，既使当前只有一个打开的工作簿，也只能关闭工作簿而不能关闭 Excel 程序，而使用 Application 对象的 Quit 方法则会关闭所有打开的工作簿，下面的代码可以做到两者兼顾。</p>
<div><pre><code><span>Sub</span> myQuit<span>(</span><span>)</span>
	<span>If</span> Workbooks<span>.</span>Count <span>></span> <span>1</span> <span>Then</span>
		ThisWorkbook<span>.</span>Close
	<span>Else</span>
		Application<span>.</span>Quit
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>myQuit 过程在关闭 Excel 程序时根据当前打开的工作簿数量决定采用何种方法关闭工作簿。</p>
<p>第 2 行代码使用 Workbook 集合的 Count 属性判断当前打开的工作簿文件数量。</p>
<p>第 3 行代码如当前打开两个或两个以上工作簿，使用 Close 方法关闭代码所在的工作簿。关于 Close 方法请参阅 45-1。</p>
<p>第 5 行代码如果当前只有一个打开的工作簿文件则使用 Quit 方法关闭 Excel 程序。应用于 Application 对象的 Quit 方法退出 Excel 程序，语法如下：</p>
<div><pre><code>expression<span>.</span>Quit

参数expression是必需的，返回一个Application对象。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>使用 Quit 方法关闭 Excel 程序时，如果有未保存的工作簿处于打开状态，则将弹出一个询问是否要保存所作更改的对话框，为避免对话框出现，可在使用 Quit 方法前保存所有的工作簿，或者将 Application 对象的 DisplayAlerts 属性设置为 False，在退出 Excel 程序时，即使有未保存的工作簿，也不会显示对话框，而且不保存就退出。</p>
<p>如果一个工作簿的 Saved 属性值为 True，但是并没有将工作簿保存到磁盘上，则 Excel 程序在退出时不会提示保存该工作簿。</p>
<h2 id="_72、隐藏-excel-主窗口"> 72、隐藏 Excel 主窗口</h2>
<p>如果希望在程序启动时或运行过程中隐藏 Excel 主窗口，有以下几种实现方法。</p>
<h3 id="_1-设置-application-对象的-visible-属性"> 1）设置 Application 对象的 Visible 属性</h3>
<p>当 Application 对象的 Visible 属性设置为 False 时，Application 对象不可见，即能隐藏 Excel 主窗口，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Workbook_Open<span>(</span><span>)</span>
	Application<span>.</span>Visible <span>=</span> <span>False</span>
	UserForm1<span>.</span>Show
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>代码解析：</p>
<p>代码工作簿的 Open 事件，在工作簿打开时将 Application 对象的 Visible 属性设置为 False 隐藏 Excel 主窗口。</p>
<p>显示 Excel 主窗口的方法是将 Application 对象的 Visible 属性重新设置为 True。</p>
<p>当工作簿文件打开时，隐藏 Excel 主窗口，只显示用户登录窗体，如图 72-1 所示。</p>
<div>
<p><img src="./assets/72-1.png" alt="" loading="lazy"></p>
<p><u>图 72-1</u>	隐藏 Excel 主窗口</p>
</div>
<h3 id="_2-将窗口移出屏幕"> 2）将窗口移出屏幕</h3>
<p>设置 Application 对象的 Left 属性（从屏幕左边界至 Microsoft Excel 主窗口左边界的距离）和 Top 属性（从屏幕顶端到 Microsoft Excel 主窗口顶端的距离）将 Application 对象移出屏幕外，实现隐藏 Excel 主窗口，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Workbook_Open<span>(</span><span>)</span>
	Application<span>.</span>WindowState <span>=</span> xlNormal
	Application<span>.</span>Left <span>=</span> <span>10000</span>
	UserForm1<span>.</span>StartUpPosition <span>=</span> <span>2</span>
	UserForm1<span>.</span>Show
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>代码解析：</p>
<p>工作簿的 Open 事件过程，设置 Application 对象的 Left 属性为一个大的数值，从而将应用程序窗口移出屏幕。</p>
<p>第 2 行代码将应用程序窗口设置为正常状态，只有当应用程序窗口正常显示时才能够设置 Application 对象的 Left 属性。</p>
<p>第 2 行代码将 Application 对象的 Left 属性设置为一个大的数值，从而隐藏 Excel 主窗口。</p>
<p>第 4 行代码设置用户窗体的 StartUpPosition 属性值为 2，使窗体显示在屏幕的中央。StartUpPosition 属性返回或设置一个值，用来指定用户窗体第一次出现时的位置，请参阅 142 。</p>
<p>重新显示 Excel 主窗口的方法是将应用程序窗口设置为最大化状态代码如下：</p>
<div><pre><code>Application<span>.</span>WindowState <span>=</span> xlMaximized
</code></pre>
<div><span>1</span><br></div></div><p>当工作簿文件打开时，隐藏 Excel 主窗口，只显示用户登录窗体，如图 72-2 所示，与通过设置 Visible 属性实现的效果不同，设置 Left 属性在任务栏中仍然会显示应用程序窗口按钮。</p>
<div>
<p><img src="./assets/72-2.png" alt="" loading="lazy"></p>
<p><u>图 72-2</u>	隐藏 Excel 主窗口</p>
</div>
<h3 id="_3-设置工作簿作为加载宏运行"> 3）设置工作簿作为加载宏运行</h3>
<p>利用加载宏不显示工作簿窗口的特点，设置工作簿作为加载宏运行来隐藏工作簿窗口，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Workbook_Open<span>(</span><span>)</span>
	ThisWorkbook<span>.</span>IsAddin <span>=</span> <span>True</span>
	UserForm1<span>.</span>Show
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>代码解析：</p>
<p>工作簿的 Open 事件，在工作簿打开时设置其 IsAddin 属性值为 True，指定工作簿作为加载宏运行。</p>
<p>当工作簿作为加载宏运行时，将有工作薄窗口不可见的特征，从而实现隐藏工作簿窗口的目的，如图 72-3 所示。</p>
<div>
<p><img src="./assets/72-3.png" alt="" loading="lazy"></p>
<p><u>图 72-3</u>	隐藏工作簿窗口</p>
</div>
<p>重新显示 Excel 主窗口的方法是将工作簿的 IsAddin 属性值设置为 False，以显示工作簿窗口。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-07-02T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">VBA 之 使用对话框</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Excel/08.VBA_dialog/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Excel/08.VBA_dialog/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="_73、使用-msgbox-函数"> 73、使用 Msgbox 函数</h2>
<h3 id="_1-显示简单的提示信息"> 1）显示简单的提示信息</h3>
<p>在使用Excel的过程中，如果需要向用户显示简单的提示信息，可以使用MsgBox函数显示一个消息框，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> mymsgbox<span>(</span><span>)</span>
	MsgBox <span>"欢迎光临Excel Home!"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>Mymsgbox 过程使用 MsgBox 函数显示一个消息框。MsgBox 函数用于显示提示信息，语法如下：</p>
<div><pre><code>MsgBox<span>(</span>prompt[<span>,</span> buttons] [<span>,</span> title] [<span>,</span> helpfile<span>,</span> context]<span>)</span>

参数prompt是必需的，代表在消息框中作为信息显示的字符或字符串，最多只能接受约<span>1024</span>个字符，取决于所使用字符的宽度。
参数buttons是可选的，用于指定消息框中显示按钮的数目及类型、使用的图标样式、缺省按钮以及消息框的强制回应等。如果省略，则buttons参数的缺省值为<span>0</span>，消息框只显示<span>“确定”</span>按钮。
参数title是可选的，代表在消息框标题栏中作为标题的字符或字符串。如果省略，则在标题栏中显示<span>“Microsoft Excel”</span>。
参数helpfile和参数context是可选的，用来为消息框提供上下文相关帮助的帮助文件和帮助主题。如果提供了其中一个参数，则必须提供另一个参数，两者缺一不可。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>运行 Mymsgbox 过程，显示如图 73-1 所示的消息框。</p>
<div>
<p><img src="./assets/73-1.png" alt="" loading="lazy"></p>
<p><u>图 73-1</u>	简单的信息提示</p>
</div>
<h3 id="_2-定制个性化的消息框"> 2）定制个性化的消息框</h3>
<p>如果希望 MsgBox 函数显示的消息框具有特定的按钮、图标和标题栏，那么可以使用 MsgBox 函数的 buttons 参数和 title 参数，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> Specialmsbox<span>(</span><span>)</span>
	MsgBox Prompt<span>:</span><span>=</span><span>"欢迎光临 Excel Home!"</span><span>,</span> <span>_</span>
	Buttons<span>:</span><span>=</span>vbOKCancel <span>+</span> vbInformation<span>,</span> <span>_</span>
	Title<span>:</span><span>=</span><span>"Excel Home"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>代码解析：</p>
<p>Specialmsbox 过程使用 MsgBox 函数显示一个具有特定的按钮、图标和标题栏的消息框。</p>
<p>第 3 行代码设置消息框的 Buttons 参数，使消息框显示时具有“确定”、“取消”按钮和信息消息图标。MsgBox 函数的 buttons 参数设置值如表格 73-1 所示。</p>
<p><u>表格 73-1</u>	MsgBox 函数的 buttons 参数值</p>
<table border="1">
<tr>
  <th>参数组</th>
  <th>常数</th>
  <th>值</th>
  <th>描述</th>
</tr>
<tr>
  <td rowspan="6">第一组设置消息框按钮数目和类型</td>
  <td>vbOKOnly</td>
  <td>0</td>
  <td>只显示“确定”按钮（默认设置）</td>
</tr>
<tr>
  <td>VbOKCancel</td>
  <td>1</td>
  <td>显示“确定”和“取消”按钮</td>
</tr>
<tr>
  <td>VbAbortRetryIgnore</td>
  <td>2</td>
  <td>显示“放弃”、“重试”、和“忽略”按钮</td>
</tr>
<tr>
  <td>VbYesNoCancel</td>
  <td>3</td>
  <td>显示“是”、“否”和“取消”按钮</td>
</tr>
<tr>
  <td>VbYesNo</td>
  <td>4</td>
  <td>显示“是”和“否”按钮</td>
</tr>
<tr>
  <td>VbRetryCancel</td>
  <td>5</td>
  <td>显示“重试”和“取消”按钮</td>
</tr>
<tr>
  <td rowspan="4">第二组设置图标的风格</td>
  <td>VbCritical</td>
  <td>16</td>
  <td>显示危险消息图标</td>
</tr>
<tr>
  <td>VbQuestion</td>
  <td>32</td>
  <td>显示警告询问图标</td>
</tr>
<tr>
  <td>VbExclamation</td>
  <td>48</td>
  <td>显示警告消息图标</td>
</tr>
<tr>
  <td>VbInformation</td>
  <td>64</td>
  <td>显示信息消息图标</td>
</tr>
<tr>
  <td rowspan="4">第三组设置默认按钮</td>
  <td>vbDefaultButton1</td>
  <td>0</td>
  <td>第一个按钮为默认按钮</td>
</tr>
<tr>
  <td>vbDefaultButton2</td>
  <td>256</td>
  <td>第二个按钮为默认按钮</td>
</tr>
<tr>
  <td>vbDefaultButton3</td>
  <td>512</td>
  <td>第三个按钮为默认按钮</td>
</tr>
<tr>
  <td>vbDefaultButton4</td>
  <td>768</td>
  <td>第四个按钮为默认按钮</td>
</tr>
<tr>
  <td rowspan="2">第四组设置消息框特征</td>
  <td>vbApplicationModal</td>
  <td>0</td>
  <td>应用程序模式：用户必须对消息框作出响应才能继续使用当前的应用程序</td>
</tr>
<tr>
  <td>vbSystemModal</td>
  <td>4096</td>
  <td>系统模式：应用程序都被挂起直至用户对消息框作出响应</td>
</tr>
<tr>
  <td rowspan="4">第五组附加选项</td>
  <td>vbMsgBoxHelpButton</td>
  <td>16384</td>
  <td>在消息框上添加“帮助”按钮</td>
</tr>
<tr>
  <td>VbMsgBoxSetForeground</td>
  <td>65536</td>
  <td>将消息框设置为前景窗口</td>
</tr>
<tr>
  <td>vbMsgBoxRight</td>
  <td>524288</td>
  <td>显示右对齐的消息框</td>
</tr>
<tr>
  <td>vbMsgBoxRtlReading</td>
  <td>1048576</td>
  <td>指定在希伯来和阿拉伯语系统中显示的文本应当从右到左阅读</td>
</tr>
</table>
<p>在设定 buttons 参数值时，这些值可以相加使用，但每一组中只能选择一个值。在程序代码中也可以使用 buttons 参数的常数名称，而不必使用实际数值。</p>
<p>第 4 行代码将消息框的 Title 参数设置为“Excel Home”，使消息框的标题栏显示“Excel Home”。</p>
<p>运行 Specialmsbox 过程后，显示一个如图 73-2 所示的消息框，该消息框具有“Excel Home”标题、信息消息图标和“确定”、“取消”按钮并以“确定”按钮作为默认按钮。</p>
<div>
<p><img src="./assets/73-2.png" alt="" loading="lazy"></p>
<p><u>图 73-2</u>	具有特定按钮、图标和标题栏的消息框</p>
</div>
<h3 id="_3-获得消息框的返回值"> 3）获得消息框的返回值</h3>
<p>如果希望能根据用户对于消息框的不同选择，进行相应的操作，可以对消息框的返回值进行判断，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Workbook_BeforeClose<span>(</span>Cancel <span>As</span> <span>Boolean</span><span>)</span>
	<span>Dim</span> iMsg <span>As</span> <span>Integer</span>
	iMsg <span>=</span> MsgBox<span>(</span><span>"文件即将关闭,是否保存?"</span><span>,</span> <span>3</span> <span>+</span> <span>32</span><span>)</span>
	<span>Select</span> <span>Case</span> iMsg
		<span>Case</span> <span>6</span>
			<span>Me</span><span>.</span>Save
		<span>Case</span> <span>7</span>
			<span>Me</span><span>.</span>Saved <span>=</span> <span>True</span>
		<span>Case</span> <span>2</span>
			Cancel <span>=</span> <span>True</span>
	<span>End</span> <span>Select</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>代码解析：</p>
<p>工作簿的 BeforeClose 过程，在关闭工作簿前使用 MsgBox 函数显示一个消息框，并根据用户的回应用进行相应的操作。</p>
<p>第 3 行代码，使用 MsgBox 函数显示一个具有“是”、“否”和“否”按钮的消息框，并把用户的回应，即消息框的返回值赋给变量 iMsg。MsgBox 是一个函数，这意味着它将返回一个值，如果希望获得返回值，可使用和第 3 行相似的代码，此时如果不使用括号将参数封闭起来，则会提示编译错误，如图 73-3 所示。</p>
<div>
<p><img src="./assets/73-3.png" alt="" loading="lazy"></p>
<p><u>图 73-3</u>	提示编译错误</p>
</div>
<p>第 4 行到第 11 行代码，Select Case 结构语句，根据变量 iMsg 的值判断用户的回应，如果变量 iMsg 的值为 6，说明用户选择了“是”按钮，则使用 Save 方法保存工作簿；如果变量 iMsg 的值为 7，说明用户选择了“否”按钮，则将工作簿的 Saved 属性设置为 True，不保存更改而直接关闭工作簿。关于 Save 方法和 Saved 属性请参阅 45-2。如果变量 iMsg 的值为 2，说明用户选择了“取消”按钮，是将 BeforeClose 过程的 Cancel 参数设置为 True，取消关闭工作簿操作。</p>
<p>MsgBox 函数的返回值如表格 73-2 所示，在程序代码中也可以使用常数名称，而不必使用实际数值。</p>
<p><u>表格 73-2</u>	MsgBox 函数的返回值</p>
<table>
<thead>
<tr>
<th>常数</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>vbOK</td>
<td>1</td>
<td>确定</td>
</tr>
<tr>
<td>vbCancel</td>
<td>2</td>
<td>取消</td>
</tr>
<tr>
<td>vbAbort</td>
<td>3</td>
<td>放弃</td>
</tr>
<tr>
<td>vbRetry</td>
<td>4</td>
<td>重试</td>
</tr>
<tr>
<td>vbIgnore</td>
<td>5</td>
<td>忽略</td>
</tr>
<tr>
<td>vbYes</td>
<td>6</td>
<td>是</td>
</tr>
<tr>
<td>vbNo</td>
<td>7</td>
<td>否</td>
</tr>
</tbody>
</table>
<p>在关闭本工作簿时将显示一个如图 73-4 所示的消息框，询问用户是否保存，并根据用户的回应用进行相应的操作。</p>
<div>
<p><img src="./assets/73-4.png" alt="" loading="lazy"></p>
<p><u>图 73-4</u>	询问消息框</p>
</div>
<h3 id="_4-在消息框中排版"> 4）在消息框中排版</h3>
<p>如果在消息框中显示的字符串很长，比如是一段多行的文字内容，为了达到美观的效果，需要首字缩进，并将各行分隔开来，如下面代码所示。</p>
<div><pre><code><span>Sub</span> Newlinemsbox<span>(</span><span>)</span>
	MsgBox Space<span>(</span><span>4</span><span>)</span> <span>&amp;</span> <span>"欢迎来到 ExcelHome 技术论坛，全球最领先的 Excel 技术论坛之一。"</span> <span>&amp;</span> Chr<span>(</span><span>10</span><span>)</span> <span>_</span>
		<span>&amp;</span> Space<span>(</span><span>4</span><span>)</span> <span>&amp;</span> <span>"在这里，我们讨论 Microsoft	Office 系列产品的应用技术，重点讨论"</span> <span>&amp;</span> Chr<span>(</span><span>10</span><span>)</span> <span>_</span>
		<span>&amp;</span> <span>"Microsoft Excel。"</span> <span>&amp;</span> Chr<span>(</span><span>10</span><span>)</span> <span>_</span>
		<span>&amp;</span> Space<span>(</span><span>4</span><span>)</span> <span>&amp;</span> <span>"本论坛从属于 Excel Home 这一全球最大的华语 Excel 技术门户，目前"</span> <span>&amp;</span> Chr<span>(</span><span>10</span><span>)</span> <span>_</span>
		<span>&amp;</span> <span>"是个人、非营利性质的网站学习平台。"</span> <span>&amp;</span> Chr<span>(</span><span>10</span><span>)</span> <span>_</span>
		<span>&amp;</span> Space<span>(</span><span>4</span><span>)</span> <span>&amp;</span> <span>"Let’s do it better! 这是 Excel Home 的口号，我们的宗旨是帮助大"</span> <span>&amp;</span> Chr<span>(</span><span>10</span><span>)</span> <span>_</span>
		<span>&amp;</span> <span>"家解决在使用Office软件中的问题，提升自己的应用技能。"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>代码解析：</p>
<p>Newlinemsbox 过程使用消息框显示一段经过排版后的文本内容。</p>
<p>代码中使用 Space 函数在每段的首字前插入 4 个空格，使首字缩进，在需要换行的地方插入换行符 &lt; Chr(10) &gt; 将各行分隔开来。也可以使用回车符 &lt; Chr(13) &gt;、或是回车与换行符的组合 &lt; Chr(13) &amp; Chr(10) &gt; 换行。</p>
<p>在程序代码中也可以使用 vbCrLf、vbNewLine 等常数，而不必使用 Chr 函数，如表格 73-3 所示。</p>
<p><u>表格 73-3</u>	回车符与换行符</p>
<table>
<thead>
<tr>
<th>常数</th>
<th>等于</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>vbCrLf</td>
<td>Chr(13) + Chr(10)</td>
<td>回车符与换行符结合</td>
</tr>
<tr>
<td>vbCr</td>
<td>Chr(13)</td>
<td>回车符</td>
</tr>
<tr>
<td>vbLf</td>
<td>Chr(10)</td>
<td>换行符</td>
</tr>
<tr>
<td>vbNewLine</td>
<td>Chr(13) + Chr(10) or, on the Macintosh, Chr(13)</td>
<td>平台指定的新行字符</td>
</tr>
</tbody>
</table>
<p>运行 Newlinemsbox 过程，用消息框显示一段经过排版后的文本内容，效果如图 73-5 所示。</p>
<div>
<p><img src="./assets/73-5.png" alt="" loading="lazy"></p>
<p><u>图 73-5</u>	在消息框中排版</p>
</div>
<h3 id="_5-对齐消息框中显示的信息"> 5）对齐消息框中显示的信息</h3>
<p>在用消息框显示如图 73-6 所示的工作表中多行多列的单元格区域时，如果只用换行符 &lt; Chr(10) &gt;等进行换行，而数据列没有对齐，会使显示的信息显得杂乱无章，缺乏可读性，如图 73-7 所示。</p>
<div>
<p><img src="./assets/73-6.png" alt="" loading="lazy"></p>
<p><u>图 73-6</u>	工作表单元格区域</p>
<p><img src="./assets/73-7.png" alt="" loading="lazy"></p>
<p><u>图 73-7</u>	没有对列进行分隔的消息框</p>
</div>
<p>为了达到消息框中显示信息各列对齐的效果，在使用换行符 &lt; Chr(10) &gt; 等进行换行的基础上，还需要使用制表符 &lt; Chr(9) &gt; 或常数 vbTab，对数据列进行分隔，使之排列整齐，如下面代码所示。</p>
<div><pre><code><span>Sub</span> Outmsbox<span>(</span><span>)</span>
	<span>Dim</span> sMsg <span>As</span> <span>String</span>
	<span>Dim</span> iRow <span>As</span> <span>Integer</span>
	<span>Dim</span> iCom <span>As</span> <span>Integer</span>
	<span>For</span> iRow <span>=</span> <span>1</span> <span>To</span> <span>11</span>
		<span>For</span> iCom <span>=</span> <span>1</span> <span>To</span> <span>5</span>
			sMsg <span>=</span> sMsg <span>&amp;</span> Cells<span>(</span>iRow<span>,</span> iCom<span>)</span> <span>&amp;</span> Chr<span>(</span><span>9</span><span>)</span>
		<span>Next</span>
		sMsg <span>=</span> sMsg <span>&amp;</span> Chr<span>(</span><span>10</span><span>)</span>
	<span>Next</span>
	MsgBox sMsg
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>代码解析：</p>
<p>Outmsbox 过程使用两层循环读取当前工作表中 <code>A1:E11</code> 单元格的内容，并用消息框显示出来。</p>
<p>第 7 行代码，iCom 循环中在把逐列读取的单元格内容赋给变量 myMsg 时插入一个制表符 &lt; Chr(9) &gt;，对列进行分隔。</p>
<p>第 9 行代码，iRow 循环中在读取下一行单元格内容赋给变量 myMsg 时插入一个换行符 &lt; Chr(10) &gt;，对行进行换行。</p>
<p>运行 Outmsbox 过程将用消息框显示当前工作表中 <code>A1:E11</code> 单元格区域中的内容，并排列整齐，如图 73-8 所示。</p>
<div>
<p><img src="./assets/73-8.png" alt="" loading="lazy"></p>
<p><u>图 73-8</u>	分列显示数据的消息框</p>
</div>
<h2 id="_74、自动关闭的消息框"> 74、自动关闭的消息框</h2>
<p>在程序执行完毕后给用户一个提示信息，但用 MsgBox 函数显示的消息框将一直保持，需要用户单击“确定”或“关闭”按钮才会关闭。如果希望显示的消息框自动关闭，那么可以使用以下方法显示消息框。</p>
<h3 id="_1-使用-wshshell-popup-方法显示消息框"> 1）使用 WshShell.Popup 方法显示消息框</h3>
<div><pre><code><span>Sub</span> WshShell<span>(</span><span>)</span>
	<span>Dim</span> WshShell <span>As</span> <span>Object</span>
	<span>Set</span> WshShell <span>=</span> CreateObject<span>(</span><span>"Wscript.Shell"</span><span>)</span>
	WshShell<span>.</span>popup <span>"执行完毕!"</span><span>,</span> <span>2</span><span>,</span> <span>"提示"</span><span>,</span> <span>64</span>
	<span>Set</span> WshShell <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>代码解析：</p>
<p>WshShell 过程使用 WshShell.Popup 方法显示消息框，2 秒后自动关闭。</p>
<p>WshShell.Popup 方法的语法如下：</p>
<div><pre><code>WshShell<span>.</span>Popup<span>(</span>strText<span>,</span> [natSecondsToWait]<span>,</span> [strTitle]<span>,</span> [natType]<span>)</span> <span>=</span> intButton

参数strText是必需的，与Msgbox的Prompt参数类似，代表在消息框中作为信息显示的字符或字符串。如果显示的内容超过一行，可以在每一行之间用换行符（Chr<span>(</span><span>10</span><span>)</span>）等将各行分隔开来。
参数natSecondsToWait是可选的，其时间单位为妙。如果提供natSecondsToWait参数且其值大于零，则消息框在natSecondsToWait 参数指定的秒数后关闭。
参数strTitle是可选的，代表在消息框标题栏中作为标题的字符或字符串，若省略，则窗口标题为<span>“Windows 脚本宿主”</span>。
参数natType是可选的，指定消息框中显示按钮的数目及类型、使用的图标样式、缺省按钮以及消息框的强制回应等，与MsgBox函数buttons参数相同，请参阅技巧<span>73</span><span>-</span><span>2</span>中的表格<span>73</span><span>-</span><span>1</span>。
参数intButton指示用户所单击的按扭编号，与MsgBox函数的返回值相同，请参阅<span>73</span><span>-</span><span>3</span>中的表格<span>73</span><span>-</span><span>2</span>。若用户在natSecondsToWait 秒之前不单击按扭，则返回值为<span>-</span><span>1</span> 。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>运行 WshShell 过程显示一个如图 74-1 所示消息框，无需点击“确定”按纽，2 秒后自动关闭。</p>
<div>
<p><img src="./assets/74-1.png" alt="" loading="lazy"></p>
<p><u>图 74-1</u>	自动关闭的消息框</p>
</div>
<h3 id="_2-使用-api-函数显示消息框"> 2）使用 API 函数显示消息框</h3>
<p>使用 API 函数也可以达到这一效果，如下面的代码所示。</p>
<div><pre><code><span>Public</span> <span>Declare</span> <span>Function</span> SetTimer <span>Lib</span> <span>"user32"</span> <span>(</span> <span>_</span>
	<span>ByVal</span> hWnd <span>As</span> <span>Long</span><span>,</span> <span>_</span>
	<span>ByVal</span> nIDEvent <span>As</span> <span>Long</span><span>,</span> <span>_</span>
	<span>ByVal</span> uElaspe <span>As</span> <span>Long</span><span>,</span> <span>_</span>
	<span>ByVal</span> lpTimerFunc <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
<span>Public</span> <span>Declare</span> <span>Function</span> KillTimer <span>Lib</span> <span>"user32"</span> <span>(</span> <span>_</span>
	<span>ByVal</span> hWnd <span>As</span> <span>Long</span><span>,</span> <span>_</span>
	<span>ByVal</span> nIDEvent <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
	<span>Dim</span> TID <span>As</span> <span>Long</span>
<span>Sub</span> Test<span>(</span><span>)</span>
	TID <span>=</span> SetTimer<span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>2000</span><span>,</span> <span>AddressOf</span> CloseTest<span>)</span>
	MsgBox <span>"执行完毕!"</span>
<span>End</span> <span>Sub</span>
<span>Sub</span> CloseTest<span>(</span><span>ByVal</span> hWnd <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> uMsg <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> idevent <span>As</span> <span>Long</span><span>,</span> <span>_</span>
	<span>ByVal</span> Systime <span>As</span> <span>Long</span><span>)</span>
	Application<span>.</span>SendKeys <span>"~"</span><span>,</span> <span>True</span>
	KillTimer <span>0</span><span>,</span> TID
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>代码解析：</p>
<p>第 1 行代码到第 9 行代码是 API 函数声明。</p>
<p>Test 过程显示一个消息框并在 3 秒钟后运行 CloseTest 过程。</p>
<p>CloseTest 过程发送一个确定键给 Excel 程序关闭显示的消息框。</p>
<p>运行 Test 过程显示一个如图 74-2 所示的消息框并在 2 秒钟后关闭。</p>
<div>
<p><img src="./assets/74-2.png" alt="" loading="lazy"></p>
<p><u>图 74-2</u>	自动关闭的消息框</p>
</div>
<h2 id="_75、使用-inputbox-函数"> 75、使用 InputBox 函数</h2>
<h3 id="_1-简单的数据输入"> 1）简单的数据输入</h3>
<p>Excel 的使用过程中，有时需要用户输入简单的数据，此时可以使用 InputBox 函数显示一个对话框，供用户在对话框中输入数据信息，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> myInputBox<span>(</span><span>)</span>
	<span>Dim</span> sInt <span>As</span> <span>String</span>
	<span>Dim</span> r <span>As</span> <span>Integer</span>
	r <span>=</span> Sheet1<span>.</span>Range<span>(</span><span>"A65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row
	sInt <span>=</span> InputBox<span>(</span><span>"请输入人员姓名："</span><span>)</span>
	<span>If</span> Len<span>(</span>Trim<span>(</span>sInt<span>)</span><span>)</span> <span>></span> <span>0</span> <span>Then</span>
		Sheet1<span>.</span>Cells<span>(</span>r <span>+</span> <span>1</span><span>,</span> <span>1</span><span>)</span> <span>=</span> sInt
	<span>Else</span>
		MsgBox <span>"您没有输入内容!"</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>代码解析：</p>
<p>myInputBox 过程使用 InputBox 函数显示一个对话框供用户在对话框中输入数据，InputBox 函数显示一个对话框，等待用户输入正文或按下按钮，并返回包含文本框内容的字符串，语法如下：</p>
<div><pre><code>InputBox<span>(</span>prompt[<span>,</span> title] [<span>,</span> <span>default</span>] [<span>,</span> xpos] [<span>,</span> ypos] [<span>,</span> helpfile<span>,</span> context]<span>)</span>

参数prompt是必需的，作为对话框消息出现的字符串表达式。
参数title是可选的，作为显示在对话框标题栏中的字符串表达式，如果省略title参数，则在标题栏中显示<span>“Microsoft Excel”</span>。
参数<span>default</span>是可选的，显示在文本框中的字符串表达式，在没有其它输入时作为缺省值，如果省略<span>default</span>参数，则文本框为空。
参数xpos是可选的，指定对话框的左边与屏幕左边的水平距离。如果省略xpos参数，则对话框会在水平方向居中。
参数ypos是可选的，指定对话框的上边与屏幕上边的距离。如果省略ypos参数，则对话框被放置在屏幕垂直方向距下边大约三分之一的位置。
参数helpfile和参数context是可选的，为对话框提供上下文相关的帮助和编号，如果提供了其中一个参数，则必须提供另一个参数，两者缺一不可。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>第 5 行代码，使用 InputBox 函数显示一个提示用户输入邮政编码的对话框，其中“请输入人员姓名：”是必需的 prompt 参数，其他参数使用缺省值。</p>
<p>第 4 行代码，使用 Len 函数和 Trim 函数判断返回的去除空格后的字符串长度。如果字符串长度大于零，说明用户单击了对话框的“确定”按钮，则将用户输入的数据写到工作表的 A 列单元格。如果返回的是长度为零的字符串，说明用户单击了对话框的“取消”按钮，则显示一条提示消息。</p>
<p>因为当用户单击对话框的“确定”按钮后，InputBox 函数返回包含文本框内容的字符串，如果用户单击对话框的“取消”按钮则返回一个长度为零的字符串（&quot;&quot;），通过返回的字符串长度可以判断用户做出的选择。</p>
<p>运行 sInput 过程将显示一个提示用户输入数据的对话框，如图 75-1 所示。</p>
<div>
<p><img src="./assets/75-1.png" alt="" loading="lazy"></p>
<p><u>图 75-1</u>	InputBox 函数显示的对话框</p>
</div>
<h3 id="_2-使用对话框输入密码"> 2）使用对话框输入密码</h3>
<p>使用 InputBox 函数显示的对话框输入密码简单方便，但有个明显的缺陷，就是输入过程中不能用占位符显示密码，不够安全。借助 API 函数可以在输入密码过程中以占位符“*”号来显示密码，如下面的代码所示。</p>
<div><pre><code><span>Public</span> <span>Declare</span> <span>Function</span> FindWindow <span>Lib</span> <span>"user32"</span> <span>Alias</span> <span>"FindWindowA"</span> <span>(</span><span>ByVal</span> lpClassName <span>As</span> <span>String</span><span>,</span> <span>ByVal</span> lpWindowName <span>As</span> <span>String</span><span>)</span> <span>As</span> <span>Long</span>
<span>Public</span> <span>Declare</span> <span>Function</span> FindWindowEx <span>Lib</span> <span>"user32"</span> <span>Alias</span> <span>"FindWindowExA"</span> <span>(</span><span>ByVal</span> hWnd1 <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> hWnd2 <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> lpsz1 <span>As</span> <span>String</span><span>,</span> <span>ByVal</span> lpsz2 <span>As</span> <span>String</span><span>)</span> <span>As</span> <span>Long</span>
<span>Public</span> <span>Declare</span> <span>Function</span> SendMessage <span>Lib</span> <span>"user32"</span> <span>Alias</span> <span>"SendMessageA"</span> <span>(</span><span>ByVal</span> hwnd <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> wMsg <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> wParam <span>As</span> <span>Long</span><span>,</span> lParam <span>As</span> Any<span>)</span> <span>As</span> <span>Long</span>
<span>Public</span> <span>Declare</span> <span>Function</span> timeSetEvent <span>Lib</span> <span>"winmm.dll"</span> <span>(</span><span>ByVal</span> uDelay <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> uResolution <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> lpFunction <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> dwUser <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> uFlags <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
<span>Public</span> <span>Declare</span> <span>Function</span> timeKillEvent <span>Lib</span> <span>"winmm.dll"</span> <span>(</span><span>ByVal</span> uID <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
<span>Public</span> <span>Declare</span> <span>Function</span> GetTickCount <span>Lib</span> <span>"kernel32"</span> <span>(</span><span>)</span> <span>As</span> <span>Long</span>
<span>Public</span> <span>Const</span> EM_SETPASSWORDCHAR <span>=</span> <span>&amp;HCC</span>
<span>Public</span> lTimeID <span>As</span> <span>Long</span>
<span>Sub</span> TimeProc<span>(</span><span>ByVal</span> uID <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> uMsg <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> dwUser <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> dw1 <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> dw2 <span>As</span> <span>Long</span><span>)</span>
	<span>Dim</span> hwd <span>As</span> <span>Long</span>
	hwd <span>=</span> FindWindow<span>(</span><span>"32770"</span><span>,</span> <span>"密码"</span><span>)</span>
	<span>If</span> hwd <span>&lt;</span><span>></span> <span>0</span> <span>Then</span>
		hwd <span>=</span> FindWindowEx<span>(</span>hwd<span>,</span> <span>0</span><span>,</span> <span>"edit"</span><span>,</span> vbNullString<span>)</span>
		SendMessage hwd<span>,</span> EM_SETPASSWORDCHAR<span>,</span> <span>42</span><span>,</span> <span>0</span>
		timeKillEvent lTimeID
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
<span>Sub</span> Password<span>(</span><span>)</span>
	<span>Dim</span> Password <span>As</span> <span>Variant</span>
	lTimeID <span>=</span> timeSetEvent<span>(</span><span>10</span><span>,</span> <span>0</span><span>,</span> <span>AddressOf</span> TimeProc<span>,</span> <span>1</span><span>,</span> <span>1</span><span>)</span>
	Password <span>=</span> InputBox<span>(</span><span>"请输入密码："</span><span>,</span> <span>"密码"</span><span>)</span>
	<span>If</span> Password <span>=</span> <span>"123456"</span> <span>Then</span>
		MsgBox <span>"密码正确!"</span>
	<span>Else</span>
		MsgBox <span>"密码错误!"</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>代码解析：</p>
<p>Password 程使用 InputBox 函数显示一个输入密码的对话框，并且以占位符“*”号显示输入的密码。</p>
<p>第 1 行到第 8 行代码，API 函数声明。</p>
<p>第 9 行到第 17 行代码，TimeProc 过程是 timeSetEvent 的回调函数，获得对话框句柄。</p>
<p>第 18 行到第 27 行代码，Password 过程显示一个提示用户输入密码的对话框。</p>
<p>运行 Password 过程将显示一个密码输入框，输入的密码以占位符“*”号代替，如图 75-2 所示。</p>
<div>
<p><img src="./assets/75-2.png" alt="" loading="lazy"></p>
<p><u>图 75-2</u>	密码输入框</p>
</div>
<h2 id="_76、使用-inputbox-方法"> 76、使用 InputBox 方法</h2>
<p>在 Excel 中输入简单的数据可以使用 InputBox 函数显示的对话框，但是如果输入的数据类型不匹配时，过程运行时会产生意外错误。为了避免此类情况发生，可以使用另一种获得用户输入的方式——InputBox 方法。</p>
<h3 id="_1-输入指定类型的数据"> 1）输入指定类型的数据</h3>
<p>使用 InputBox 方法输入数据时可以指定数据的类型，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> dInput<span>(</span><span>)</span>
	<span>Dim</span> dInput <span>As</span> <span>Double</span>
	<span>Dim</span> r <span>As</span> <span>Integer</span>
	r <span>=</span> Sheet1<span>.</span>Range<span>(</span><span>"A65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row
	dInput <span>=</span> Application<span>.</span>InputBox<span>(</span>Prompt<span>:</span><span>=</span><span>"请输入数字："</span><span>,</span> <span>Type</span><span>:</span><span>=</span><span>1</span><span>)</span>
	<span>If</span> dInput <span>&lt;</span><span>></span> <span>False</span> <span>Then</span>
		Sheet1<span>.</span>Cells<span>(</span>r <span>+</span> <span>1</span><span>,</span> <span>1</span><span>)</span><span>.</span>Value <span>=</span> dInput
	<span>Else</span>
		MsgBox <span>"你已取消了输入!"</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>代码解析：</p>
<p>dInput 过程使用 InputBox 方法显示一个提示用户输入数字的对话框。</p>
<p>InputBox 方法显示一个接收用户输入的对话框，返回此对话框中输入的信息，语法如下：</p>
<div><pre><code>expression.InputBox(Prompt, Title, Default, Left, Top, HelpFile, HelpContextId, Type)

参数expression是必需的，返回一个Application对象。
参数Prompt是必需的，作为对话框消息显示的字符串表达式。
参数Title是可选的，作为显示在对话框标题栏中的字符串表达式。如果省略Title参数，将使用默认的标题。
参数Default是可选的，在对话框显示时出现在文本框中的初始值。如果省略Default参数，则文本框为空。
参数Left是可选的，指定对话框相对于屏幕左上角的 x 坐标。
参数Top是可选的，指定对话框相对于屏幕左上角的 y 坐标。
参数HelpFile和参数HelpContextId是可选的，为对话框提供上下文相关的帮助和编号，如果提供了其中一个参数，则必须提供另一个参数，两者缺一不可。
参数Type是可选的，指定返回的数据类型。如果省略Type参数，对话框将返回文本。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>InputBox 方法的语法和 InputBox 函数的语法相似，最大的区别在于最后一个参数——Type。通过 Type 参数可以指定返回值的数据类型，表格 76-1 列出了 Type 参数可以使用的数值。</p>
<p><u>表格 76-1</u>	Type 参数的值</p>
<table>
<thead>
<tr>
<th>数值</th>
<th>期望的返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>一个公式</td>
</tr>
<tr>
<td>1</td>
<td>一个数字</td>
</tr>
<tr>
<td>2</td>
<td>文本（字符串）</td>
</tr>
<tr>
<td>4</td>
<td>一个逻辑值，例如true或false</td>
</tr>
<tr>
<td>8</td>
<td>一个单元格引用</td>
</tr>
<tr>
<td>16</td>
<td>一个错误值</td>
</tr>
<tr>
<td>64</td>
<td>一个值的数组</td>
</tr>
</tbody>
</table>
<p>这些数值可以相加使用，如果希望返回数字和文本，可以将 Type 参数设置为 1+2。</p>
<p>InputBox 方法与 InputBox 函数相比，优点是内置的出错处理。在第 5 行代码中将 Type 参数值设置为 1，这意味着对话框只能输入数值。当用户输入的不是数值时，显示一个如图 76-1 所示的消息框提示输入错误。</p>
<div>
<p><img src="./assets/76-1.png" alt="" loading="lazy"></p>
<p><u>图 76-1</u>	提示输入错误</p>
</div>
<p>第 6 行到第 10 行代码，如果用户单击对话框的“确定”按钮，将用户输入的数字写入工作表的 A 列单元格。如果用户单击对话框的“取消”按钮，则显示一条提示消息。</p>
<p>InputBox 方法和 InputBox 函数的另一个区别是，当用户单击“取消”按纽时返回 False 而不是长度为零的字符串。</p>
<p>运行 dInput 过程将显示一个提示用户输入数字的对话框，如图 76-2 所示。</p>
<div>
<p><img src="./assets/76-2.png" alt="" loading="lazy"></p>
<p><u>图 76-2</u>	InputBox 方法显示的对话框</p>
</div>
<div><p>注意</p>
<p>在 VBA 代码中，Application.InputBox 调用的是 InputBox 方法，不带对象识别符的 InputBox 调用的是 InputBox 函数。</p>
</div>
<h3 id="_2-获得单元格区域地址"> 2）获得单元格区域地址</h3>
<p>InputBox 方法很适合用户选择工作表单元格区域，并对所选择的单元格区域进行操作，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> RngInput<span>(</span><span>)</span>
	<span>Dim</span> rng <span>As</span> Range
	<span>On</span> <span>Error</span> <span>GoTo</span> line
	<span>Set</span> rng <span>=</span> Application<span>.</span>InputBox<span>(</span><span>"请使用鼠标选择单元格区域："</span><span>,</span> <span>,</span> <span>,</span> <span>,</span> <span>,</span> <span>,</span> <span>,</span> <span>8</span><span>)</span>
	rng<span>.</span>Interior<span>.</span>ColorIndex <span>=</span> <span>15</span>
line<span>:</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>RngInput 过程使用 InputBox 方法显示一个对话框，提示用户在工作表中选择一个单元格区域，并改变所选单元格区域内部的颜色。</p>
<p>第 3 行代码，错误处理语句。因为当对话框显示后，如果用户单击“取消”按钮，将显示一错误信息，如图 76-3 所示，所以必需使用 On Error GoTo 语句来绕过错误。</p>
<div>
<p><img src="./assets/76-3.png" alt="" loading="lazy"></p>
<p><u>图 76-3</u>	提示运行错误</p>
</div>
<p>第 4 行代码，使用 Set 语句将用户选择的单元格区域赋给变量 rng。当 Type 参数设置为 8 时，将返回一个 Range 对象，必须用 Set 语句将结果指定给一个 Range 对象。</p>
<p>第 5 行代码，改变用户所选单元格区域内部的颜色。</p>
<p>运行 RngInput 过程，将显示一个对话框，提示用户在工作表中选择一个单元格区域，并改变所选单元格区域内部的颜色，如图 76 4 所示。</p>
<div>
<p><img src="./assets/76-4.png" alt="" loading="lazy"></p>
<p><u>图 76-4</u>	使用 InputBox 方法获得区域地址</p>
</div>
<h2 id="_77、内置对话框"> 77、内置对话框</h2>
<h3 id="_1-调用内置的对话框"> 1）调用内置的对话框</h3>
<p>如果需要使用“打开”、“打印”等 Excel 内置对话框已经具有的功能，可以使用代码直接调用这些内置的对话框，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> DialogOpen<span>(</span><span>)</span>
	Application<span>.</span>Dialogs<span>(</span>xlDialogOpen<span>)</span><span>.</span>Show arg1<span>:</span><span>=</span>ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\*.xls"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>DialogOpen 过程显示内置的“打开”对话框并选定示例所在的文件夹。</p>
<p>显示内置对话框语法如下：</p>
<div><pre><code>Application<span>.</span>Dialogs<span>(</span>xlDialogConst<span>)</span><span>.</span>Show

Dialogs集合代表所有的内置对话框，每个Dialog对象代表一个内置对话框，不能新建内置对话框或向该集合中添加内置对话框。
参数xlDialogConst是内置对话框的内置常量，每个常量都以<span>“xlDialog”</span>开头，其后是对话框的名称，如<span>“打开”</span>对话框的常量为<span>“xlDialogOpen”</span>。常用内置对话框的内置常量如表格<span>77</span><span>-</span><span>1</span>所示。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><u>表格 77-1</u>	内置对话框的内置常量</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>xlDialogActiveCellFont</td>
<td>476</td>
<td>单元格格式(字体）</td>
</tr>
<tr>
<td>xlDialogBorder</td>
<td>45</td>
<td>单元格格式(边框）</td>
</tr>
<tr>
<td>xlDialogCellProtection</td>
<td>46</td>
<td>单元格格式(保护）</td>
</tr>
<tr>
<td>xlDialogDeleteFormat</td>
<td>111</td>
<td>单元格格式(数字）</td>
</tr>
<tr>
<td>xlDialogFormatNumber</td>
<td>42</td>
<td>单元格格式(数字）</td>
</tr>
<tr>
<td>xlDialogPatterns</td>
<td>84</td>
<td>单元格格式(图案）</td>
</tr>
<tr>
<td>xlDialogClear</td>
<td>52</td>
<td>清除</td>
</tr>
<tr>
<td>xlDialogColumnWidth</td>
<td>47</td>
<td>列宽</td>
</tr>
<tr>
<td>xlDialogRowHeight</td>
<td>127</td>
<td>行高</td>
</tr>
<tr>
<td>xlDialogConditionalFormatting</td>
<td>583</td>
<td>条件格式</td>
</tr>
<tr>
<td>xlDialogDefineName</td>
<td>61</td>
<td>定义名称</td>
</tr>
<tr>
<td>xlDialogDefineStyle</td>
<td>229</td>
<td>样式</td>
</tr>
<tr>
<td>xlDialogDisplay</td>
<td>27</td>
<td>显示选项</td>
</tr>
<tr>
<td>xlDialogFont</td>
<td>26</td>
<td>字体</td>
</tr>
<tr>
<td>xlDialogSetBackgroundPicture</td>
<td>509</td>
<td>工作表背景</td>
</tr>
<tr>
<td>xlDialogInsert</td>
<td>55</td>
<td>插入</td>
</tr>
<tr>
<td>xlDialogInsertHyperlink</td>
<td>596</td>
<td>插入超链接</td>
</tr>
<tr>
<td>xlDialogInsertPicture</td>
<td>342</td>
<td>插入图片</td>
</tr>
<tr>
<td>xlDialogNew</td>
<td>119</td>
<td>新建工作簿</td>
</tr>
<tr>
<td>xlDialogOpen</td>
<td>1</td>
<td>打开</td>
</tr>
<tr>
<td>xlDialogSaveAs</td>
<td>5</td>
<td>另存为</td>
</tr>
<tr>
<td>xlDialogWorkbookCopy</td>
<td>283</td>
<td>移动或复制工作表（建立副本）</td>
</tr>
<tr>
<td>xlDialogWorkbookInsert</td>
<td>354</td>
<td>插入工作表</td>
</tr>
<tr>
<td>xlDialogWorkbookMove</td>
<td>282</td>
<td>移动或复制工作表</td>
</tr>
<tr>
<td>xlDialogWorkbookName</td>
<td>386</td>
<td>重命名工作表</td>
</tr>
<tr>
<td>xlDialogWorkbookNew</td>
<td>302</td>
<td>新建工作表</td>
</tr>
<tr>
<td>xlDialogWorkbookProtect</td>
<td>417</td>
<td>保护工作簿</td>
</tr>
<tr>
<td>xlDialogPageSetup</td>
<td>7</td>
<td>页面设置</td>
</tr>
<tr>
<td>xlDialogPrint</td>
<td>8</td>
<td>打印内容</td>
</tr>
<tr>
<td>xlDialogPrinterSetup</td>
<td>9</td>
<td>打印机设置</td>
</tr>
<tr>
<td>xlDialogPrintPreview</td>
<td>222</td>
<td>打印预览</td>
</tr>
<tr>
<td>xlDialogSetPrintTitles</td>
<td>23</td>
<td>设置打印标题</td>
</tr>
<tr>
<td>xlDialogRun</td>
<td>17</td>
<td>宏</td>
</tr>
<tr>
<td>xlDialogTable</td>
<td>41</td>
<td>模拟运算表</td>
</tr>
<tr>
<td>xlDialogSendMail</td>
<td>189</td>
<td>发送邮件</td>
</tr>
</tbody>
</table>
<p>显示内置对话框使用 Show 方法，应用于 Dialog 对象的 Show 方法语法如下：</p>
<div><pre><code>expression<span>.</span>Show<span>(</span>Arg1<span>,</span> Arg2<span>,</span> Arg3<span>,</span> Arg4<span>,</span> Arg5<span>,</span> Arg6<span>,</span> Arg7<span>,</span> Arg8<span>,</span> Arg9<span>,</span> Arg10<span>,</span> Arg11<span>,</span> Arg12<span>,</span> Arg13<span>,</span> Arg14<span>,</span> Arg15<span>,</span> Arg16<span>,</span> Arg17<span>,</span> Arg18<span>,</span> Arg19<span>,</span> Arg20<span>,</span> Arg21<span>,</span> Arg22<span>,</span> Arg23<span>,</span> Arg24<span>,</span> Arg25<span>,</span> Arg26<span>,</span> Arg27<span>,</span> Arg28<span>,</span> Arg29<span>,</span> Arg30<span>)</span>

参数expression是必需的，返回Dialog对象之一。
参数arg1到参数arg30是可选的，仅应用于内置对话框，是命令的初始参数。若要查找要设置的参数，请在内置对话框参数列表中查找对应的对话框常量。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>运行 alogOpen 过程，显示内置的“打开”对话框，并且直接选定示例所在的文件夹，如图 77-1 所示。</p>
<div>
<p><img src="./assets/77-1.png" alt="" loading="lazy"></p>
<p><u>图 77-1</u>	使用内置对话框</p>
</div>
<h3 id="_2-获取选定文件的文件名"> 2）获取选定文件的文件名</h3>
<p>如果只希望获取用户在显示的内置 “打开”对话框中选定文件的文件名，而不想真正打开该文件，那么可以使用 GetOpenFilename 方法，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> OpenFilename<span>(</span><span>)</span>
	<span>Dim</span> Filename <span>As</span> <span>Variant</span>
	<span>Dim</span> mymsg <span>As</span> <span>Integer</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	Filename <span>=</span> Application<span>.</span>GetOpenFilename<span>(</span>Title<span>:</span><span>=</span><span>"删除文件"</span><span>,</span> MultiSelect<span>:</span><span>=</span><span>True</span><span>)</span>
	<span>If</span> IsArray<span>(</span>Filename<span>)</span> <span>Then</span>
		mymsg <span>=</span> MsgBox<span>(</span><span>"是否删除所选文件?"</span><span>,</span> vbYesNo<span>,</span> <span>"提示"</span><span>)</span>
		<span>If</span> mymsg <span>=</span> vbYes <span>Then</span>
			<span>For</span> i <span>=</span> <span>1</span> <span>To</span> UBound<span>(</span>Filename<span>)</span>
				Kill Filename<span>(</span>i<span>)</span>
			<span>Next</span>
		<span>End</span> <span>If</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>代码解析：</p>
<p>OpenFilename 过程使用 GetOpenFilename 方法显示标准的内置“打开”对话框，获取用户选定文件的文件名后使用 Kill 语句删除。</p>
<p>GetOpenFilename 方法显示标准的内置“打开”对话框，获取文件名，语法如下：</p>
<div><pre><code>expression<span>.</span>GetOpenFilename<span>(</span>FileFilter<span>,</span> FilterIndex<span>,</span> Title<span>,</span> ButtonText<span>,</span> MultiSelect<span>)</span>

参数expression是必需的，返回一个Application对象。
参数FileFilter是可选的，指定文件筛选条件的字符串。如果省略，则默认参数值为<span>“所有文件(*.*)”</span>。
参数FilterIndex是可选的，指定默认文件筛选条件的索引号，取值范围为 <span>1</span> 到由 FileFilter 所指定的筛选条件数目。如果省略，或者取值大于可用筛选数目，则采用第一个文件筛选条件。
参数Title是可选的，指定对话框的标题。如果省略，则使用<span>“打开”</span>作为标题。
参数ButtonText是可选的，仅用于Macintosh。
参数MultiSelect是可选的，如果该值为<span>True</span>，则允许选定多个文件名，如果该值为<span>False</span>，则只允许选定单个文件名。默认值为<span>False</span>。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>第 5 行代码显示标准的“打开”对话框，将对话框的标题设置为“删除文件”，将 MultiSelect 参数设置为 True，允许选定多个文件。</p>
<p>第 6 行代码，获得返回值。当用户选定文件后，返回的是选定的文件名或用户输入的文件名。因为 MultiSelect 参数已设置为 True，所以返回值将是一个包含所有选定文件名的数组（即使仅选定了一个文件名）。如果用户取消了对话框，则该值为 False。</p>
<p>第 8 行到第 12 行代码，经询问用户后使用 Kill 语句从磁盘中删除用户选定的文件。</p>
<p>运行 OpenFilename 过程，显示标准的内置“打开”对话框，删除用户选定的文件，如所图 77-2示。</p>
<div>
<p><img src="./assets/77-2.png" alt="" loading="lazy"></p>
<p><u>图 77-2</u>	使用内置对话框</p>
</div>
<div><p>注意</p>
<p>VBA 中数组下界默认从 0 开始，但使用 GetOpenFilename 方法选择多个文件时返回的包含选定文件名的数组下界是从 1 开始。</p>
</div>
<h3 id="_3-使用-另存为-对话框"> 3）使用“另存为”对话框</h3>
<p>在备份文件时可以使用 GetSaveAsFilename 方法显示标准的内置“另存为”对话框，获取备份文件的文件名和保存路径，而无须真正保存任何文件。如下面的代码所示。</p>
<div><pre><code><span>Sub</span> CopyFilename<span>(</span><span>)</span>
	<span>Dim</span> NowWorkbook <span>As</span> Workbook
	<span>Dim</span> FileName <span>As</span> <span>String</span>
	<span>On</span> <span>Error</span> <span>GoTo</span> line
	FileName <span>=</span> Application<span>.</span>GetSaveAsFilename <span>_</span>
		<span>(</span>InitialFileName<span>:</span><span>=</span><span>"D:\"</span> <span>&amp;</span> <span>Date</span> <span>&amp;</span> <span>" "</span> <span>&amp;</span> ThisWorkbook<span>.</span>Name<span>,</span> <span>_</span>
		fileFilter<span>:</span><span>=</span><span>"Excel files(*.xls),*.xls,All files (*.*),*.*"</span><span>,</span> <span>_</span>
		Title<span>:</span><span>=</span><span>"数据备份"</span><span>)</span>
	<span>If</span> FileName <span>&lt;</span><span>></span> <span>"False"</span> <span>Then</span>
		<span>Set</span> NowWorkbook <span>=</span> Workbooks<span>.</span>Add
		<span>With</span> NowWorkbook
			<span>.</span>SaveAs FileName
			ThisWorkbook<span>.</span>Sheets<span>(</span><span>"Sheet2"</span><span>)</span><span>.</span>UsedRange<span>.</span>Copy <span>_</span>
			<span>.</span>Sheets<span>(</span><span>"Sheet1"</span><span>)</span><span>.</span>Range <span>(</span><span>"A1"</span><span>)</span>
			<span>.</span>Save
		<span>End</span> <span>With</span>
		<span>GoTo</span> line
	<span>End</span> <span>If</span>
	<span>Exit</span> <span>Sub</span>
line<span>:</span>
	ActiveWorkbook<span>.</span>Close
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>代码解析：</p>
<p>CopyFilename 过程使用 GetSaveAsFilename 方法显示标准的内置“另存为”对话框，获取备份文件的文件名和保存路径，新建工作簿保存备份数据。</p>
<p>第 4 行代码，错误处理语句。备份过程中，如果已存在同名工作簿，会出现如图 77-3 所示的提示，如果选择了“否”，此时新工作簿已经建立，在执行第 12 行代码时发生错误，使程序中断，所以使用 GoTo 语句执行第 21 行代码，关闭新建立的工作簿。</p>
<div>
<p><img src="./assets/77-3.png" alt="" loading="lazy"></p>
<p><u>图 77-3</u>	文件已存在提示</p>
</div>
<p>第 5 行代码，使用 GetSaveAsFilename 方法显示标准的内置“另存为”对话框。GetSaveAsFilename 方法的语法如下：</p>
<div><pre><code>expression<span>.</span>GetSaveAsFilename<span>(</span>InitialFilename<span>,</span> FileFilter<span>,</span> FilterIndex<span>,</span> Title<span>,</span> ButtonText<span>)</span>

参数expression是必需的，返回一个Application对象。
参数InitialFilename是可选的，指定建议的文件名。如果省略，将活动工作簿的名称作为建议的文件名。
参数FileFilter是可选的，指定文件筛选条件的字符串。
参数FilterIndex是可选的，指定默认文件筛选条件的索引号，取值范围为 <span>1</span> 到 FileFilter 指定的筛选条件数目之间。如果省略，或者取值大于可用筛选数目，则采用第一个文件筛选条件。
参数Title是可选的，指定对话框标题。如果省略，则使用默认标题。
参数ButtonText是可选的，仅用于 Macintosh。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>第 6 行代码，设置对话框的保存路径为 D 盘，保存文件名为日期加工作簿名称。</p>
<p>第 7 行代码，设置对话框文件保存类型为 Excel 文件类型。如果需要设置为文本类型需设置为“文本文件(*.txt), *.txt”，而如果是图片文件则需设置为“图片文件(*.bmp;*.jpg),*.bmp;*.jpg”。</p>
<p>第 8 行代码，设置对话框的标题为“数据备份”。</p>
<p>第 9 行代码，如果用户没有取消操作。</p>
<p>第 10 行到第 16 行代码，使用 Add 方法新建工作簿保存到对话框选定的路径中，将数据备份到新工作簿中。</p>
<p>第 17 行代码，使用 GoTo 语句执行第 21 行代码，关闭新建工作簿和开启屏幕刷新。</p>
<p>运行 CopyFilename 过程，显示内置“另存为”对话框，供用户备份工作簿数据，如图 77-4 所示。</p>
<div>
<p><img src="./assets/77-4.png" alt="" loading="lazy"></p>
<p><u>图 77-4</u>	使用“另存为”对话框备份文件</p>
</div>
<h2 id="_78、调用操作系统-关于-对话框"> 78、调用操作系统“关于”对话框</h2>
<p>VBA 程序开发完成后，有时需要一个“关于”对话框，除了使用窗体外，还可以调用操作系统的“关于”对话框，显示自定义的内容，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Declare</span> <span>Function</span> ShellAbout <span>Lib</span> <span>"shell32.dll"</span> <span>Alias</span> <span>"ShellAboutA"</span> <span>(</span> <span>_</span>
		<span>ByVal</span> hwnd <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> szApp <span>As</span> <span>String</span><span>,</span> <span>_</span>
		<span>ByVal</span> szOtherStuff <span>As</span> <span>String</span><span>,</span> <span>ByVal</span> hIcon <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Declare</span> <span>Function</span> FindWindow <span>Lib</span> <span>"user32"</span> <span>Alias</span> <span>"FindWindowA"</span> <span>(</span> <span>_</span>
		<span>ByVal</span> lpClassName <span>As</span> <span>String</span><span>,</span> <span>ByVal</span> lpWindowName <span>As</span> <span>String</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Sub</span> CommandButton1_Click<span>(</span><span>)</span>
	<span>Dim</span> ApphWnd <span>As</span> <span>Long</span>
	ApphWnd <span>=</span> FindWindow<span>(</span><span>"XLMAIN"</span><span>,</span> Application<span>.</span>Caption<span>)</span>
	ShellAbout ApphWnd<span>,</span> <span>"财务处理系统"</span><span>,</span> <span>"yuanzhuping@yeah.net	0513-86548930"</span><span>,</span> <span>0</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>代码解析：</p>
<p>第 1 行到第 5 行代码是 API 函数声明。</p>
<p>第 8、9 行代码调用操作系统的“关于”对话框并显示自定义的内容。</p>
<p>代码运行后显示如图 78-1 所示的对话框。</p>
<div>
<p><img src="./assets/78-1.png" alt="" loading="lazy"></p>
<p><u>图 78-1</u>	调用操作系统的“关于”对话框</p>
</div>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-07-02T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">VBA 之 菜单和工具栏</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Excel/09.VBA_menu_toolbar/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Excel/09.VBA_menu_toolbar/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="_79、在菜单中添加菜单项"> 79、在菜单中添加菜单项</h2>
<p>在 Excel 工作表的菜单中可以添加新的菜单项和子菜单，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> myTools<span>(</span><span>)</span>
	<span>Dim</span> myTools <span>As</span> CommandBarPopup
	<span>Dim</span> myCap <span>As</span> <span>Variant</span>
	<span>Dim</span> myid <span>As</span> <span>Variant</span>
	<span>Dim</span> i <span>As</span> <span>Byte</span>
	myCap <span>=</span> Array<span>(</span><span>"基础应用"</span><span>,</span> <span>"VBA程序开发"</span><span>,</span> <span>"函数与公式"</span><span>,</span> <span>"图表与图形"</span><span>,</span> <span>"数据透视表"</span><span>)</span>
	myid <span>=</span> Array<span>(</span><span>281</span><span>,</span> <span>283</span><span>,</span> <span>285</span><span>,</span> <span>287</span><span>,</span> <span>292</span><span>)</span>
	<span>With</span> Application<span>.</span>CommandBars<span>(</span><span>"Worksheet menu bar"</span><span>)</span>
		<span>.</span>Reset
		<span>Set</span> myTools <span>=</span> <span>.</span>Controls<span>(</span><span>"帮助(&amp;H)"</span><span>)</span><span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlPopup<span>,</span> Before<span>:</span><span>=</span><span>1</span><span>)</span>
		<span>With</span> myTools
			<span>.</span>Caption <span>=</span> <span>"Excel Home 技术论坛"</span>
			<span>.</span>BeginGroup <span>=</span> <span>True</span>
			<span>For</span> i <span>=</span> <span>1</span> <span>To</span> <span>5</span>
				<span>With</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlButton<span>)</span>
					<span>.</span>Caption <span>=</span> myCap<span>(</span>i <span>-</span> <span>1</span><span>)</span>
					<span>.</span>FaceId <span>=</span> myid<span>(</span>i <span>-</span> <span>1</span><span>)</span>
					<span>.</span>OnAction <span>=</span> <span>"myC"</span>
			<span>End</span> <span>With</span>
			<span>Next</span>
		<span>End</span> <span>With</span>
	<span>End</span> <span>With</span>
	<span>Set</span> myTools <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>代码解析：</p>
<p>myTools 过程使用 Add 方法在 Excel 工作表菜单栏中的“帮助”菜单中添加一个标题为“Excel Home 技术论坛”的菜单项和 5 个子菜单。</p>
<p>第 2 行到第 5 行代码声明变量类型。</p>
<p>第 6、7 行代码使用 Array 函数创建两个数组用于保存子菜单的名称和图标 ID。</p>
<p>第 9 行代码，在添加菜单项前先使用 Reset 方法重置菜单栏以免重复添加菜单项。Reset 方法重置一个内置控件，恢复该控件原来对应的动作，并将各属性恢复成初始状态，语法如下：</p>
<div><pre><code>expression<span>.</span>Reset

参数expression 是必需的，返回一个命令栏或命令栏控件对象。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>第 10 行代码，使用 Add 方法在 Excel 工作表菜单栏中的“帮助”菜单中添加菜单项。Add 方法应用于 CommandBarControls 对象时，新建一个 CommandBarControl 对象并添加到指定命令栏上的控件集合，语法如下：</p>
<div><pre><code>expression<span>.</span>Add<span>(</span><span>Type</span><span>,</span> Id<span>,</span> Parameter<span>,</span> Before<span>,</span> Temporary<span>)</span>

参数expression 是必需的，返回一个CommandBarControls对象，代表命令栏中的所有控件。
参数<span>Type</span>是可选的，添加到指定命令栏的控件类型，可以为表格 <span>79</span><span>1</span>所列的MsoControlType常数之一。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><u>表格 79-1</u>	MsoControlType 常数</p>
<table>
<thead>
<tr>
<th>常数</th>
<th>值</th>
<th>控件类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>msoControlButton</td>
<td>1</td>
<td>命令按钮</td>
</tr>
<tr>
<td>msoControlEdit</td>
<td>2</td>
<td>文本框</td>
</tr>
<tr>
<td>msoControlDropdown</td>
<td>3</td>
<td>下拉列表控制框</td>
</tr>
<tr>
<td>msoControlComboBox</td>
<td>4</td>
<td>下拉组合控制框</td>
</tr>
<tr>
<td>msoControlPopup</td>
<td>10</td>
<td>弹出式控件</td>
</tr>
</tbody>
</table>
<p>因为在本例中将添加的是带有子菜单的菜单项，所以将参数 Type 设置为弹出式控件。</p>
<p>参数 Id 是可选的，标识整数。如果将该参数设置为 1 或者忽略，将在命令栏中添加一个空的指定类型的自定义控件。</p>
<p>参数 Parameter 是可选的，对于内置控件，该参数用于容器应用程序运行命令。对于自定义控件，可以使用该参数向 Visual Basic 过程传递信息，或用其存储控件信息。</p>
<p>参数 Before 是可选的，表示新控件在命令栏上位置的数字。新控件将插入到该位置控件之前。如果忽略该参数，控件将添加到指定命令栏的末端。本例中将 Before 参数设置为 1，菜单项添加到“帮助”菜单的顶端。</p>
<p>参数 Temporary 是可选的。设置为 True 将使添加的菜单项为临时的，在关闭应用程序时删除。默认值为 False。</p>
<p>第 12 行代码，设定新添加菜单项的 Caption 属性为“Excel Home 技术论坛”。Caption 属性返回或设置命令栏控件的标题。</p>
<p>第 13 行代码，设置新添加菜单项的 BeginGroup 属性为 True，分组显示。</p>
<p>第 14 行到第 19 行代码，在“Excel Home 技术论坛”菜单项上添加五个子菜单并设置其 Caption 属性、FaceId 属性和 OnAction 属性。</p>
<p>FaceId 属性设置出现在菜单标题左侧的图标，以数字表示，一个数字代表一个内置的图标。</p>
<p>OnAction 属性设置一个 VBA 的过程名，该过程在用户单击子菜单时运行，本例中设置为下面的过程。</p>
<div><pre><code><span>Public</span> <span>Sub</span> myC<span>(</span><span>)</span>
	MsgBox <span>"您选择了： "</span> <span>&amp;</span> Application<span>.</span>CommandBars<span>.</span>ActionControl<span>.</span>Caption
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>myC 过程是单击新添加子菜单所运行过程，为了演示方便在这里只使用 MsgBox 函数显示所其 Caption 属性。</p>
<p>删除新添加的菜单项及子菜单的代码如下所示。</p>
<div><pre><code><span>Sub</span> DelmyTools<span>(</span><span>)</span>
	Application<span>.</span>CommandBars<span>(</span><span>"Worksheet menu bar"</span><span>)</span><span>.</span>Reset
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>DelmyTools 过程使用 Reset 方法重置菜单栏，删除添加的菜单项及子菜单。</p>
<p>为了在打开工作簿时自动添加菜单项，需要在工作簿的 Activate 事件中调用 myTools 过程，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Workbook_Activate<span>(</span><span>)</span>
	<span>Call</span> myTools
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>为了在关闭工作簿时删除新添加的菜单项，还需要在工作簿的 Deactivate 事件中调用 DelmyTools 过程，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Workbook_Deactivate<span>(</span><span>)</span>
	<span>Call</span> DelmyTools
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果希望这个菜单为所有工作簿使用，那么就应该在工作簿的 Open 事件中调用 myTools 过程，在 BeforeClose 事件中调用 DelmyTools 过程。</p>
<p>运行 myTools 过程，将在 Excel 工作表菜单栏中的“帮助”菜单中添加一个名为“Excel Home 技术论坛”的菜单项及五个子菜单，如图 79-1 所示。</p>
<div>
<p><img src="./assets/79-1.png" alt="" loading="lazy"></p>
<p><u>图 79-1</u>	在“帮助”菜单中添加菜单项及子菜单</p>
</div>
<h2 id="_80、在菜单栏指定位置添加菜单"> 80、在菜单栏指定位置添加菜单</h2>
<p>除了可以在工作表菜单中添加菜单项外，还可以在工作表菜单栏的指定位置添加菜单，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> AddNewMenu<span>(</span><span>)</span>
	<span>Dim</span> HelpMenu <span>As</span> CommandBarControl
	<span>Dim</span> NewMenu <span>As</span> CommandBarPopup
	<span>With</span> Application<span>.</span>CommandBars<span>(</span><span>"Worksheet menu bar"</span><span>)</span>
		<span>.</span>Reset
		<span>Set</span> HelpMenu <span>=</span> <span>.</span>FindControl<span>(</span>ID<span>:</span><span>=</span><span>.</span>Controls<span>(</span><span>"帮助(&amp;H)"</span><span>)</span><span>.</span>ID<span>)</span>
		<span>If</span> HelpMenu <span>Is</span> <span>Nothing</span> <span>Then</span>
			<span>Set</span> NewMenu <span>=</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlPopup<span>)</span>
		<span>Else</span>
			<span>Set</span> NewMenu <span>=</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlPopup<span>,</span> <span>_</span>
				Before<span>:</span><span>=</span>HelpMenu<span>.</span>Index<span>)</span>
		<span>End</span> <span>If</span>
		<span>With</span> NewMenu
			<span>.</span>Caption <span>=</span> <span>"统计(&amp;S)"</span>
			<span>With</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlButton<span>)</span>
				<span>.</span>Caption <span>=</span> <span>"输入数据(&amp;D)"</span>
				<span>.</span>FaceId <span>=</span> <span>162</span>
				<span>.</span>OnAction <span>=</span> <span>""</span>
			<span>End</span> <span>With</span>
			<span>With</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlButton<span>)</span>
				<span>.</span>Caption <span>=</span> <span>"汇总数据(&amp;T)"</span>
				<span>.</span>FaceId <span>=</span> <span>590</span>
				<span>.</span>OnAction <span>=</span> <span>""</span>
			<span>End</span> <span>With</span>
		<span>End</span> <span>With</span>
	<span>End</span> <span>With</span>
	<span>Set</span> HelpMenu <span>=</span> <span>Nothing</span>
	<span>Set</span> NewMenu <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>代码解析：</p>
<p>AddNewMenu 过程使用 Add 方法在工作表“帮助”菜单前添加一个标题为“统计”的菜单和两个菜单项。</p>
<p>第 6 行代码，使用 FindControl 方法在工作表菜单栏中查找“帮助”菜单。应用于 CommandBars 对象的 FindControl 方法返回一个符合指定条件的 CommandBarControl 对象。语法如下：</p>
<div><pre><code>expression<span>.</span>FindControl<span>(</span><span>Type</span><span>,</span> Id<span>,</span> Tag<span>,</span> Visible<span>,</span> Recursive<span>)</span>

参数expression是必需的，返回一个CommandBars对象。
参数<span>Type</span>是可选的，要查找控件的类型。
参数Id是可选的，要查找控件的标识符。
参数Tag是可选的，要查找控件的标记值。
参数Visible是可选，如果该值为<span>True</span>，那么只查找屏幕上显示的命令栏控件。默认值为<span>False</span>。
参数Recursive是可选的，如果该值为<span>True</span>，那么将在命令栏及其全部弹出式子工具栏中查找。此参数仅应用于CommandBar对象。默认值为<span>False</span>。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>如果没有控件符合搜索条件，那么 FindControl 方法返回 Nothing。</p>
<p>第 7 行到第 12 行代码，如果工作表菜单栏中存在“帮助”菜单，将“统计”菜单添加到“帮助”菜单之前，否则添加到工作表菜单栏末尾。</p>
<p>第 12 行到第 25 行代码，在“统计”菜单中添加两个子菜单并设置其各种属性。</p>
<p>运行 AddNewMenu 过程，将在工作表菜单栏的“帮助”菜单之前添加一个“统计”菜单，如图 80-1 所示。</p>
<div>
<p><img src="./assets/80-1.png" alt="" loading="lazy"></p>
<p><u>图 80-1</u>	在工作表菜单栏中添加菜单</p>
</div>
<h2 id="_81、屏蔽和删除工作表菜单"> 81、屏蔽和删除工作表菜单</h2>
<p>如果不希望用户使用工作表菜单栏的部分功能，可以把菜单或菜单项屏蔽或删除，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> Shibar<span>(</span><span>)</span>
	<span>With</span> Application<span>.</span>CommandBars<span>(</span><span>"Worksheet menu bar"</span><span>)</span>
		<span>.</span>Reset
		<span>.</span>Controls<span>(</span><span>"工具(&amp;T)"</span><span>)</span><span>.</span>Controls<span>(</span><span>"宏(&amp;M)"</span><span>)</span><span>.</span>Enabled <span>=</span> <span>False</span>
		<span>.</span>Controls<span>(</span><span>"数据(&amp;D)"</span><span>)</span><span>.</span>Delete
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>Shibar 过程屏蔽 “工具”菜单中的“宏”菜单项，删除菜单栏中的“数据”菜单。</p>
<p>第 3 行代码，使用 Reset 方法重置工作表菜单栏。</p>
<p>第 4 行代码，将“宏”菜单项的 Enabled 属性设置为 False，使之无效。</p>
<p>Enabled 属性决定命令栏或命令栏控件是否激活，如果将该属性设置为 False，那么该菜单项将无效。</p>
<p>第 5 行代码，使用 Delete 方法将“数据”菜单从工作表菜单栏中删除。</p>
<p>Delete 方法应用于命令栏或命令栏控件时，从集合中删除指定对象，语法如下：</p>
<div><pre><code>expression<span>.</span>Delete<span>(</span>Temporary<span>)</span>

参数expression是必需的，返回命令栏或命令栏控件对象之一。
参数Temporary是可选的，设置为<span>True</span>将从当前会话中删除控件，应用程序在下次会话时将再次显示控件。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>运行 Shibar 过程，将屏蔽工作表“工具”菜单中的“宏”菜单项和删除工作表菜单栏中的“数据”菜单，如图 81-1 所示。</p>
<div>
<p><img src="./assets/81-1.png" alt="" loading="lazy"></p>
<p><u>图 81-1</u>	屏蔽和删除工作表菜单</p>
</div>
<h2 id="_82、改变系统菜单的操作"> 82、改变系统菜单的操作</h2>
<p>利用 VBA 甚至可以改变系统菜单的默认操作，使之达到自定义菜单的效果，如下面的代码所示。</p>
<div><pre><code><span>Dim</span> <span>WithEvents</span> Saveas <span>As</span> CommandBarButton
<span>Private</span> <span>Sub</span> Workbook_Open<span>(</span><span>)</span>
	<span>Set</span> Saveas <span>=</span> Application<span>.</span>CommandBars<span>(</span><span>"File"</span><span>)</span><span>.</span>Controls<span>(</span><span>"另存为(&amp;A)..."</span><span>)</span>
<span>End</span> <span>Sub</span>
<span>Private</span> <span>Sub</span> Saveas_Click<span>(</span><span>ByVal</span> Ctrl <span>As</span> Office<span>.</span>CommandBarButton<span>,</span> CancelDefault <span>As</span> <span>Boolean</span><span>)</span>
	CancelDefault <span>=</span> <span>True</span>
	MsgBox <span>"本工作簿禁止另存!"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>代码解析：</p>
<p>第 1 行代码，在模块级别中使用关键词 WithEvents 声明变量 Saveas 是用来响应由 CommandBarButton 对象触发事件的对象变量。</p>
<p>第 2 行到第 4 代码工作簿的 Open 事件过程，在工作簿打开时将变量 Saveas 赋值为系统菜单的“另存为”菜单。</p>
<p>因为在声明变量 Saveas 时使用了关键词 WithEvents，不能同时使用 New 关键词隐式地创建对象，所以在使用变量 Saveas 之前，必须使用 Set 语句将变量赋值为一个已有对象。</p>
<p>第 5 行到第 8 代码变量 Saveas 的单击事件过程，改变系统菜单“另存为”的默认操作。</p>
<p>变量 Saveas 的 Click 事件在用户单击系统菜单“另存为”时发生，语法如下：</p>
<div><pre><code><span>Private</span> <span>Sub</span> CommandBarButton_Click<span>(</span><span>ByVal</span> Ctrl <span>As</span> CommandBarButton<span>,</span><span>ByVal</span> CancelDefault <span>As</span> <span>Boolean</span><span>)</span>

参数Ctrl是必需的，指示初始化该事件的CommandBarButton控件。
参数CancelDefault是必需的，<span>Boolean</span>类型，如果执行了与CommandBarButton控件关联的默认操作，该值为<span>False</span>。除非其他过程或加载项取消了此操作。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第 6、7 行代码，将 CancelDefault 参数设置为 True，使单击“另存为”菜单时并不执行默认操作而只显示一个消息框。</p>
<p>将工作簿保存、关闭后，重新打开，单击“另存为”菜单并不执行默认操作，只显示一个消息框，如图 82-1 所示。</p>
<div>
<p><img src="./assets/82-1.png" alt="" loading="lazy"></p>
<p><u>图 82-1</u>	改变系统菜单的默认操作</p>
</div>
<h2 id="_83、定制自己的系统菜单"> 83、定制自己的系统菜单</h2>
<p>使用 VBA 开发的小型应用系统完成后，Excel 原有的菜单栏完全可以舍弃不用，只使用自定义的菜单栏，更加方便快捷，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> AddNowBar<span>(</span><span>)</span>
	<span>Dim</span> NewBar <span>As</span> CommandBar
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	<span>With</span> Application
		<span>.</span>CommandBars<span>(</span><span>"Standard"</span><span>)</span><span>.</span>Visible <span>=</span> <span>False</span> 
		<span>.</span>CommandBars<span>(</span><span>"Formatting"</span><span>)</span><span>.</span>Visible <span>=</span> <span>False</span> 
		<span>.</span>CommandBars<span>(</span><span>"Stop Recording"</span><span>)</span><span>.</span>Visible <span>=</span> <span>False</span>
		<span>.</span>CommandBars<span>(</span><span>"toolbar list"</span><span>)</span><span>.</span>Enabled <span>=</span> <span>False</span>
		<span>.</span>CommandBars<span>.</span>DisableAskAQuestionDropdown <span>=</span> <span>True</span>
		<span>.</span>DisplayFormulaBar <span>=</span> <span>False</span> 
		<span>.</span>CommandBars<span>(</span><span>"NewBar"</span><span>)</span><span>.</span>Delete
	<span>End</span> <span>With</span>
	<span>Set</span> NewBar <span>=</span> Application<span>.</span>CommandBars<span>.</span>Add<span>(</span>Name<span>:</span><span>=</span><span>"NewBar"</span><span>,</span> Position<span>:</span><span>=</span>msoBarTop<span>,</span> MenuBar<span>:</span><span>=</span><span>True</span><span>,</span> Temporary<span>:</span><span>=</span><span>True</span><span>)</span>
	<span>With</span> NewBar
		<span>.</span>Visible <span>=</span> <span>True</span>
		<span>With</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlPopup<span>)</span>
			<span>.</span>Caption <span>=</span> <span>"系统设置(&amp;X)"</span>
			<span>.</span>BeginGroup <span>=</span> <span>True</span>
			<span>With</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlButton<span>)</span>
				<span>.</span>Caption <span>=</span> <span>"保存(&amp;S)"</span>
				<span>.</span>BeginGroup <span>=</span> <span>True</span>
				<span>.</span>FaceId <span>=</span> <span>1975</span>
			<span>End</span> <span>With</span>
			<span>With</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlButton<span>)</span>
				<span>.</span>Caption <span>=</span> <span>"备份(&amp;B)"</span>
				<span>.</span>BeginGroup <span>=</span> <span>True</span>
				<span>.</span>FaceId <span>=</span> <span>747</span>
			<span>End</span> <span>With</span>
		<span>End</span> <span>With</span>
		<span>With</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlPopup<span>)</span>
			<span>.</span>Caption <span>=</span> <span>"会计凭证(&amp;P)"</span>
			<span>.</span>BeginGroup <span>=</span> <span>True</span>
			<span>With</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlButton<span>)</span>
				<span>.</span>Caption <span>=</span> <span>"录入(&amp;L)"</span>
				<span>.</span>BeginGroup <span>=</span> <span>True</span>
				<span>.</span>FaceId <span>=</span> <span>197</span>
			<span>End</span> <span>With</span>
			<span>With</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlButton<span>)</span>
				<span>.</span>Caption <span>=</span> <span>"审核(&amp;S)"</span>
				<span>.</span>BeginGroup <span>=</span> <span>True</span>
				<span>.</span>FaceId <span>=</span> <span>714</span>
			<span>End</span> <span>With</span>
		<span>End</span> <span>With</span>
		<span>With</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlPopup<span>)</span>
			<span>.</span>Caption <span>=</span> <span>"会计账簿(&amp;Z)"</span>
			<span>.</span>BeginGroup <span>=</span> <span>True</span>
			<span>With</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlButton<span>)</span>
				<span>.</span>Caption <span>=</span> <span>"记账(&amp;L)"</span>
				<span>.</span>BeginGroup <span>=</span> <span>True</span>
				<span>.</span>FaceId <span>=</span> <span>65</span>
			<span>End</span> <span>With</span>
			<span>With</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlButton<span>)</span>
				<span>.</span>Caption <span>=</span> <span>"结账(&amp;S)"</span>
				<span>.</span>BeginGroup <span>=</span> <span>True</span>
				<span>.</span>FaceId <span>=</span> <span>47</span>
			<span>End</span> <span>With</span>
		<span>End</span> <span>With</span>
		<span>With</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlPopup<span>)</span>
			<span>.</span>Caption <span>=</span> <span>"会计报表(&amp;B)"</span>
			<span>.</span>BeginGroup <span>=</span> <span>True</span>
			<span>With</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlPopup<span>)</span>
				<span>.</span>Caption <span>=</span> <span>"资产负债表(&amp;Y)"</span>
				<span>.</span>BeginGroup <span>=</span> <span>True</span>
				<span>With</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlButton<span>)</span>
					<span>.</span>Caption <span>=</span> <span>"月报(&amp;M)"</span>
					<span>.</span>BeginGroup <span>=</span> <span>True</span>
					<span>.</span>FaceId <span>=</span> <span>1180</span>
				<span>End</span> <span>With</span>
					<span>With</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlButton<span>)</span>
						<span>.</span>Caption <span>=</span> <span>"年报(&amp;Y)"</span>
						<span>.</span>BeginGroup <span>=</span> <span>True</span>
						<span>.</span>FaceId <span>=</span> <span>1188</span>
					<span>End</span> <span>With</span>
				<span>End</span> <span>With</span>
			<span>With</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlPopup<span>)</span>
				<span>.</span>Caption <span>=</span> <span>"损益表(&amp;S)"</span>
				<span>.</span>BeginGroup <span>=</span> <span>True</span>
				<span>With</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlButton<span>)</span>
					<span>.</span>Caption <span>=</span> <span>"月报(&amp;M)"</span>
					<span>.</span>BeginGroup <span>=</span> <span>True</span>
					<span>.</span>FaceId <span>=</span> <span>1180</span>
				<span>End</span> <span>With</span>
				<span>With</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlButton<span>)</span>
					<span>.</span>Caption <span>=</span> <span>"年报(&amp;Y)"</span>
					<span>.</span>BeginGroup <span>=</span> <span>True</span>
					<span>.</span>FaceId <span>=</span> <span>1188</span>
				<span>End</span> <span>With</span>
			<span>End</span> <span>With</span>
		<span>End</span> <span>With</span>
		<span>With</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlButton<span>)</span>
			<span>.</span>Caption <span>=</span> <span>"退出系统(&amp;C)"</span>
			<span>.</span>BeginGroup <span>=</span> <span>True</span>
			<span>.</span>Style <span>=</span> msoButtonCaption
		<span>End</span> <span>With</span>
	<span>End</span> <span>With</span>
	<span>Set</span> NewBar <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br></div></div><p>代码解析：</p>
<p>AddNowBar 过程使用 Add 方法创建自定义菜单栏替换工作表菜单栏。</p>
<p>第 2 行代码定义变量 NwBar 为命令栏。</p>
<p>第 3 行代码忽略错误语句，以免第 11 行代码在删除可能不存在的“NewBar”菜单栏时发生错误。</p>
<p>第 5 行代码隐藏“常用”工具栏。</p>
<p>第 6 行代码隐藏“格式”工具栏。</p>
<p>第 7 行代码隐藏“停止录制”工具栏。</p>
<p>第 8 行代码屏蔽工具栏的右键快捷菜单。</p>
<p>第 9 行代码屏蔽工具栏的“键入需要帮助的问题”下拉框。</p>
<p>第 10 行代码屏蔽工具栏的编辑栏。</p>
<p>第 11 行代码，在添加命令栏前先删除“NewBar”菜单栏，以免重复增加。</p>
<p>第 13 行代码，使用 Add 方法创建命令栏。Add 方法应用于 CommandBars 对象的语法如下：</p>
<div><pre><code>expression<span>.</span>Add<span>(</span>Name<span>,</span> Position<span>,</span> MenuBar<span>,</span> Temporary<span>)</span>

参数expression是必需的，返回一个CommandBars对象，该对象代表应用程序中的命令栏，新建命令栏的控件均以该对象为载体。
参数Name是可选的，设置新建命令栏的标题。如果忽略该参数，则为新建命令栏指定默认标题，本例中设置新建命令栏的标题为<span>“NewBar”</span>。
参数Position是可选的，设置新建命令栏的位置或类型，可以为表格 <span>83</span><span>1</span>所列的 MsoBarPosition常数之一。
参数MenuBar是可选的，设置为<span>True</span> 将以新命令栏替换活动菜单栏，默认值为<span>False</span>。
参数Temporary是可选的，设置为<span>True</span>将使新建命令栏为临时命令栏，在关闭应用程序时删除，默认值为<span>False</span>。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><u>表格 83-1</u>	MsoBarPosition 常数</p>
<table>
<thead>
<tr>
<th>常数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>msoBarLeft、msoBarTop、msoBarRight 和 msoBarBottom</td>
<td>指定新命令栏的左侧、顶部、右侧和底部坐标</td>
</tr>
<tr>
<td>msoBarFloating</td>
<td>指定新命令栏不固定</td>
</tr>
<tr>
<td>msoBarPopup</td>
<td>指定新命令栏为快捷菜单</td>
</tr>
<tr>
<td>msoBarMenuBar</td>
<td>仅适用于 Macintosh 机</td>
</tr>
</tbody>
</table>
<p>本例中设置“NewBar”命令栏的 Position 参数为 msoBarTop，使“NewBar”命令栏位于 Excel 窗口的顶部。</p>
<p>在本例中，设置“NewBar”命令栏的 MenuBar 属性为 True，以“NewBar”命令栏替换活动菜单栏。</p>
<p>在本例中，设置“NewBar”命令栏的 Temporary 属性为 True，使“NewBar”命令栏为临时命令栏，在关闭应用程序时删除。</p>
<p>第 15 行代码，设置“NewBar”命令栏为可见的。</p>
<p>第 16 行到 95 行代码，使用 Add 方法在“NewBar”命令栏中添加菜单、菜单项及子菜单并设置其各项属性，参阅 79 。</p>
<p>恢复 Excel 原有的菜单栏的代码如下：</p>
<div><pre><code><span>Sub</span> DelNowBar<span>(</span><span>)</span>
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	<span>With</span> Application
		<span>.</span>CommandBars<span>(</span><span>"Standard"</span><span>)</span><span>.</span>Visible <span>=</span> <span>True</span>
		<span>.</span>CommandBars<span>(</span><span>"Formatting"</span><span>)</span><span>.</span>Visible <span>=</span> <span>True</span>
		<span>.</span>CommandBars<span>(</span><span>"Stop Recording"</span><span>)</span><span>.</span>Visible <span>=</span> <span>True</span>
		<span>.</span>CommandBars<span>(</span><span>"toolbar list"</span><span>)</span><span>.</span>Enabled <span>=</span> <span>True</span>
		<span>.</span>CommandBars<span>.</span>DisableAskAQuestionDropdown <span>=</span> <span>False</span>
		<span>.</span>DisplayFormulaBar <span>=</span> <span>True</span>
		<span>.</span>CommandBars<span>(</span><span>"NewBar"</span><span>)</span><span>.</span>Delete
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>代码解析：</p>
<p>DelNowBar 过程取消 “常用”、“格式”和“停止录制”工具栏的的隐藏，恢复“键入需要帮助的问题”下拉框和编辑栏，删除“NewBar”命令栏。</p>
<p>运行 AddNowBar 过程，工作表菜单栏如图 83-1 所示。</p>
<div>
<p><img src="./assets/83-1.png" alt="" loading="lazy"></p>
<p><u>图 83-1</u>	定制自己的系统菜单</p>
</div>
<h2 id="_84、改变菜单按钮图标"> 84、改变菜单按钮图标</h2>
<p>利用 VBA 可以改变系统菜单的默认图标，使之达到自定义按钮图标的效果，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> myCbarCnt<span>(</span><span>)</span>
	<span>Dim</span> myCbarCnt <span>As</span> CommandBarControl
	<span>With</span> Sheet1<span>.</span>Shapes<span>.</span>AddShape<span>(</span><span>17</span><span>,</span> <span>1000</span><span>,</span> <span>1000</span><span>,</span> <span>30</span><span>,</span> <span>30</span><span>)</span>
		<span>.</span>Fill<span>.</span>ForeColor<span>.</span>SchemeColor <span>=</span> <span>29</span>
		<span>.</span>CopyPicture
		<span>.</span>Delete
	<span>End</span> <span>With</span>
	<span>Set</span> myCbarCnt <span>=</span> Application<span>.</span>CommandBars<span>(</span><span>"Standard"</span><span>)</span><span>.</span>Controls<span>(</span><span>1</span><span>)</span>
	myCbarCnt<span>.</span>PasteFace
	<span>Set</span> myCbarCnt <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
<span>Sub</span> DelmyCbarCnt<span>(</span><span>)</span>
	Application<span>.</span>CommandBars<span>(</span><span>"Standard"</span><span>)</span><span>.</span>Controls<span>(</span><span>1</span><span>)</span><span>.</span>Reset
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>代码解析：</p>
<p>myCbarCnt 过程改变系统菜单的“新建”按钮的图标。</p>
<p>第 3 行代码使用 Shape 对象的 AddShape 方法在工作表中新建一个自选图形。应用于 Shape 对象的 AddShape 方法请参阅 53 。</p>
<p>在本例中将新建图形的 Left 参数和 Top 参数设置为较大的数值使新建的自选图形不在当前窗口的可视区域内。</p>
<p>第 4 行代码设置新建自选图形的颜色。</p>
<p>第 5 行代码使用 CopyPicture 方法将新建自选图形作为图片复制到剪贴板。CopyPicture 方法的语法如下：</p>
<div><pre><code>expression<span>.</span>CopyPicture<span>(</span>Appearance<span>,</span> Format<span>)</span>

参数expression是必需的，一个有效的对象。
参数Appearance是可选的，指定图片的复制方式。
参数Format是可选的，图片的格式。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>第 6 行代码使用 Delete 方法删除新建的自选图形。</p>
<p>第 8 行代码使用 Set 语句将系统菜单的“新建”按钮赋给变量 myCbarCnt。</p>
<p>第 9 行代码 PasteFace 方法将新建的自选图形粘贴到“新建”按钮中。PasteFace 方法将“剪贴板”的内容粘贴到指定命令栏按钮控件上，语法如下：</p>
<div><pre><code>expression<span>.</span>PasteFace

参数expression是必需的，返回一个CommandBarButton对象。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>DelmyCbarCnt 过程使用 Reset 方法恢复“新建”按钮的默认图标。</p>
<p>运行 myCbarCnt 过程结果如图 84-1 所示。</p>
<div>
<p><img src="./assets/84-1.png" alt="" loading="lazy"></p>
<p><u>图 84-1</u>	定制自己的系统菜单</p>
</div>
<h2 id="_85、右键快捷菜单增加菜单项"> 85、右键快捷菜单增加菜单项</h2>
<p>在 Excel 的右键快捷菜单中可以添加新的菜单项，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> MyCmb<span>(</span><span>)</span>
	<span>Dim</span> MyCmb <span>As</span> CommandBarButton
	<span>With</span> Application<span>.</span>CommandBars<span>(</span><span>"Cell"</span><span>)</span>
		<span>.</span>Reset
		<span>Set</span> MyCmb <span>=</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlButton<span>,</span> <span>_</span>
			ID<span>:</span><span>=</span><span>2521</span><span>,</span> Before<span>:</span><span>=</span><span>.</span>Controls<span>.</span>Count<span>,</span> Temporary<span>:</span><span>=</span><span>True</span><span>)</span>
			MyCmb<span>.</span>BeginGroup <span>=</span> <span>True</span>
		<span>End</span> <span>With</span>
	<span>Set</span> MyCmb <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>代码解析：</p>
<p>MyCmb 过程使用 Add 方法在 Excel 的右键快捷菜单中添加内置的“打印”菜单项。</p>
<p>在使用 Add 方法添加菜单项时将 Id 参数设置为 2521，添加的就是内置的“打印”菜单项。将 Before 属性设置成右键快捷菜单中最后一个控件的值，使“打印”菜单项添加到右键快捷菜单中最后一个控件之前。将 Temporary 参数设置成 True，在关闭应用程序时从右键快捷菜单中删除“打印”菜单项。</p>
<p>运行 MyCmb 过程，将在 Excel 右键快捷菜单中添加 “打印”菜单项，如图 85-1 所示。</p>
<div>
<p><img src="./assets/85-1.png" alt="" loading="lazy"></p>
<p><u>图 85-1</u>	在右键快捷菜单中添加菜单项</p>
</div>
<h2 id="_86、自定义右键快捷菜单"> 86、自定义右键快捷菜单</h2>
<p>在工作表中创建自定义的右键快捷菜单替换 Excel 默认的右键快捷菜单，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> Mycell<span>(</span><span>)</span>
	<span>With</span> Application<span>.</span>CommandBars<span>.</span>Add<span>(</span><span>"Mycell"</span><span>,</span> msoBarPopup<span>)</span>
		<span>With</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlButton<span>)</span>
			<span>.</span>Caption <span>=</span> <span>"会计凭证"</span>
			<span>.</span>FaceId <span>=</span> <span>9893</span>
		<span>End</span> <span>With</span>
		<span>With</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlButton<span>)</span>
			<span>.</span>Caption <span>=</span> <span>"会计账簿"</span>
			<span>.</span>FaceId <span>=</span> <span>284</span>
		<span>End</span> <span>With</span>
		<span>With</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlPopup<span>)</span>
			<span>.</span>Caption <span>=</span> <span>"会计报表"</span>
			<span>With</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlButton<span>)</span>
				<span>.</span>Caption <span>=</span> <span>"月报"</span>
				<span>.</span>FaceId <span>=</span> <span>9590</span>
			<span>End</span> <span>With</span>
			<span>With</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlButton<span>)</span>
				<span>.</span>Caption <span>=</span> <span>"季报"</span>
				<span>.</span>FaceId <span>=</span> <span>9591</span>
			<span>End</span> <span>With</span>
			<span>With</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlButton<span>)</span>
				<span>.</span>Caption <span>=</span> <span>"年报"</span>
				<span>.</span>FaceId <span>=</span> <span>9592</span>
			<span>End</span> <span>With</span>
		<span>End</span> <span>With</span>
		<span>With</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlButton<span>)</span>
			<span>.</span>Caption <span>=</span> <span>"凭证打印"</span>
			<span>.</span>FaceId <span>=</span> <span>9614</span>
			<span>.</span>BeginGroup <span>=</span> <span>True</span>
		<span>End</span> <span>With</span>
		<span>With</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlButton<span>)</span>
			<span>.</span>Caption <span>=</span> <span>"账簿打印"</span>
			<span>.</span>FaceId <span>=</span> <span>707</span>
		<span>End</span> <span>With</span>
		<span>With</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlButton<span>)</span>
			<span>.</span>Caption <span>=</span> <span>"报表打印"</span>
			<span>.</span>FaceId <span>=</span> <span>986</span>
		<span>End</span> <span>With</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><p>代码解析：</p>
<p>Mycell 过程在 Excel 工作表中创建自定义的右键快捷菜单。</p>
<p>第 2 行代码，使用 Add 方法添加名称为“Mycell”命令栏，设置“Mycell”命令栏的 Position 属性为 msoBarPopup，使“Mycell”命令栏为快捷菜单。关于 Position 参数的 MsoBarPosition 常数请参阅 83 中的表格 83-1。</p>
<p>第 3 行到第 39 行代码，使用 Add 方法在“Mycell”命令栏中添加菜单和菜单项，并设置其各项属性。</p>
<p>为了让自定义右键快捷菜单替换 Excel 默认的右键快捷菜单，并且只在右键单击 Sheet1 工作表时显示，需要在 Sheet1 工作表的 BeforeRightClick 事件中写入下面的代码。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Worksheet_BeforeRightClick<span>(</span><span>ByVal</span> Target <span>As</span> Range<span>,</span> Cancel <span>As</span> <span>Boolean</span><span>)</span>
	Application<span>.</span>CommandBars<span>(</span><span>"Mycell"</span><span>)</span><span>.</span>ShowPopup
	Cancel <span>=</span> <span>True</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>代码解析：</p>
<p>工作表的 BeforeRightClick 事件过程，在右键单击工作表时，将“Mycell”命令栏作为右键快捷菜单，在当前光标位置显示。</p>
<p>工作表 BeforeRightClick 事件语法如下：</p>
<div><pre><code><span>Private</span> <span>Sub</span> expression_BeforeRightClick<span>(</span><span>ByVal</span> Target <span>As</span> Range<span>,</span> Cancel <span>As</span> <span>Boolean</span><span>)</span>

参数expression是必需的，Worksheet类型对象。
参数Target 是可选的，右键单击发生时最靠近鼠标指针的单元格。
参数Cancel是可选的，当事件发生时为<span>False</span>。如果在事件过程中将Cancel参数设为<span>True</span>，则该过程执行结束之后不进行默认的右键单击操作。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>第 2 行代码，使用 ShowPopup 方法将“Mycell”命令栏作为右键快捷菜单，在当前光标位置显示。</p>
<p>ShowPopup 方法的语法如下：</p>
<div><pre><code>expression<span>.</span>ShowPopup<span>(</span>x<span>,</span> y<span>)</span>

参数expression是必需的，返回一个CommandBar对象。
参数x是可选的，快捷菜单所在位置的 x 坐标。如果省略此参数，将使用当前光标位置的x坐标。
参数y是可选的，快捷菜单所在位置的y坐标。如果省略此参数，将使用当前光标位置的y坐标。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>当用鼠标右键单击工作表中任意单元格时激活 BeforeRightClick 事件，此事件先于默认的右键单击操作。在使用 ShowPopup 方法显示“Mycell”命令栏后，将 Cancel 参数设置为 True，过程执行结束之后不进行默认的右键单击操作，Excel 右键快捷菜单就不会显示。</p>
<p>运行 Mycell 过程后，右键单击 Sheet1 工作表，在工作表中显示自定义右键快捷菜单，如图 86-1 所示。</p>
<div>
<p><img src="./assets/86-1.png" alt="" loading="lazy"></p>
<p><u>图 86-1</u>	自定义右键快捷菜单</p>
</div>
<h2 id="_87、使用右键菜单制作数据有效性"> 87、使用右键菜单制作数据有效性</h2>
<p>在工作表中输入数据时可以使用自定义右键菜单制作数据有效性，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> Mycell<span>(</span><span>)</span>
	<span>Dim</span> arr <span>As</span> <span>Variant</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>Dim</span> Mycell <span>As</span> CommandBar
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	Application<span>.</span>CommandBars<span>(</span><span>"Mycell"</span><span>)</span><span>.</span>Delete
	arr <span>=</span> Array<span>(</span><span>"经理室"</span><span>,</span> <span>"办公室"</span><span>,</span> <span>"生技科"</span><span>,</span> <span>"财务科"</span><span>,</span> <span>"营业部"</span><span>)</span>
	<span>Set</span> Mycell <span>=</span> Application<span>.</span>CommandBars<span>.</span>Add<span>(</span><span>"Mycell"</span><span>,</span> <span>5</span><span>)</span>
	<span>For</span> i <span>=</span> <span>0</span> <span>To</span> <span>4</span>
		<span>With</span> Mycell<span>.</span>Controls<span>.</span>Add<span>(</span><span>1</span><span>)</span>
			<span>.</span>Caption <span>=</span> arr<span>(</span>i<span>)</span>
			<span>.</span>OnAction <span>=</span> <span>"MyOnAction"</span>
		<span>End</span> <span>With</span>
	<span>Next</span>
<span>End</span> <span>Sub</span>
<span>Sub</span> MyOnAction<span>(</span><span>)</span>
	ActiveCell <span>=</span> Application<span>.</span>CommandBars<span>.</span>ActionControl<span>.</span>Caption
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>代码解析：</p>
<p>Mycell 过程创建自定义的右键菜单，请参阅 86 。</p>
<p>MyOnAction 过程是点击自定义右键菜单所运行的过程，将所选右键菜单的名称写入活动单元格。</p>
<p>为了使自定义的右键菜单在 Sheet1 工作表的特定区域中显示，需要在 VBE 中双击 Sheet1 表后写入下面的代码。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Worksheet_BeforeRightClick<span>(</span><span>ByVal</span> Target <span>As</span> Range<span>,</span> Cancel <span>As</span> <span>Boolean</span><span>)</span>
	<span>If</span> Target<span>.</span>Column <span>=</span> <span>2</span> <span>Then</span>
		<span>Call</span> Mycell
		Application<span>.</span>CommandBars<span>(</span><span>"Mycell"</span><span>)</span><span>.</span>ShowPopup
		Cancel <span>=</span> <span>True</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>工作表的 BeforeRightClick 事件过程，在右键单击工作表时，将“Mycell”命令栏作为右键快捷菜单，在当前光标位置显示，请参阅 86 。</p>
<p>在工作表的 B 列中点击右键结果如图 87-1 所示。</p>
<div>
<p><img src="./assets/87-1.png" alt="" loading="lazy"></p>
<p><u>图 87-1</u>	使用右键菜单制作数据有效性</p>
</div>
<h2 id="_88、禁用工作表右键菜单"> 88、禁用工作表右键菜单</h2>
<p>有时并不希望用户使用工作表中的右键菜单对工作表进行操作，那么可以使用下面的代码禁用工作表右键菜单。</p>
<div><pre><code><span>Sub</span> DisBar<span>(</span><span>)</span>
	<span>Dim</span> myBar <span>As</span> CommandBar
	<span>For</span> <span>Each</span> myBar <span>In</span> CommandBars
		<span>If</span> myBar<span>.</span><span>Type</span> <span>=</span> msoBarTypePopup <span>Then</span>
			myBar<span>.</span>Enabled <span>=</span> <span>False</span>
		<span>End</span> <span>If</span>
	<span>Next</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>代码解析：</p>
<p>DisBar 过程禁用工作表中所有的右键菜单。</p>
<p>第 3 行代码使用 For Each...Next 语句遍历 CommandBars 集合。CommandBars 集合代表应用程序中所有的命令栏。</p>
<p>第 4 行代码根据命令栏的 Type 属性判断命令栏是否为右键菜单。应用于 CommandBar 对象的 Type 属性返回命令栏的类型，可以为表格 88-1 所列的 MsoBarType 常量之一。</p>
<p>表格 88-1	MsoBarType 常量</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>msoBarTypeMenuBar</td>
<td>1</td>
<td>菜单栏</td>
</tr>
<tr>
<td>msoBarTypeNormal</td>
<td>0</td>
<td>工具栏</td>
</tr>
<tr>
<td>msoBarTypePopup</td>
<td>2</td>
<td>右键快捷菜单</td>
</tr>
</tbody>
</table>
<p>第 5 行代码将 CommandBars 集合中右键快捷菜的 Enabled 属性设置为 False，使之无效。</p>
<p>运行 DisBar 过程将禁用工作表中所有的右键菜单，需要恢复时只需将其 Enabled 属性设置为 True 即可。</p>
<h2 id="_89、创建自定义工具栏"> 89、创建自定义工具栏</h2>
<p>为了方便用户操作，在 Excel 原有的的工具栏上，还可以创建自定义的工具栏，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> NowToolbar<span>(</span><span>)</span>
	<span>Dim</span> arr <span>As</span> <span>Variant</span>
	<span>Dim</span> id <span>As</span> <span>Variant</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>Dim</span> Toolbar <span>As</span> CommandBar
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	Application<span>.</span>CommandBars<span>(</span><span>"MyToolbar"</span><span>)</span><span>.</span>Delete
	arr <span>=</span> Array<span>(</span><span>"会计凭证"</span><span>,</span> <span>"会计账簿"</span><span>,</span> <span>"会计报表"</span><span>,</span> <span>"凭证打印"</span><span>,</span> <span>"账簿打印"</span><span>,</span> <span>"报表打印"</span><span>)</span>
	id <span>=</span> Array<span>(</span><span>9893</span><span>,</span> <span>284</span><span>,</span> <span>9590</span><span>,</span> <span>9614</span><span>,</span> <span>707</span><span>,</span> <span>986</span><span>)</span>
	<span>Set</span> Toolbar <span>=</span> Application<span>.</span>CommandBars<span>.</span>Add<span>(</span><span>"MyToolbar"</span><span>,</span> msoBarTop<span>)</span>
		<span>With</span> Toolbar
			<span>.</span>Protection <span>=</span> msoBarNoResize
			<span>.</span>Visible <span>=</span> <span>True</span>
			<span>For</span> i <span>=</span> <span>0</span> <span>To</span> <span>5</span>
				<span>With</span> <span>.</span>Controls<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlButton<span>)</span>
					<span>.</span>Caption <span>=</span> arr<span>(</span>i<span>)</span>
					<span>.</span>FaceId <span>=</span> id<span>(</span>i<span>)</span>
					<span>.</span>BeginGroup <span>=</span> <span>True</span>
					<span>.</span>Style <span>=</span> msoButtonIconAndCaptionBelow
				<span>End</span> <span>With</span>
			<span>Next</span>
		<span>End</span> <span>With</span>
	<span>Set</span> Toolbar <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>代码解析：</p>
<p>NowToolbar 过程使用 Add 方法在 Excel 窗口中创建自定义工具栏。应用于 CommandBars 对象的 Add 方法请参阅 83 。</p>
<p>第 10 行代码，使用 Add 方法在菜单栏上创建名称为“MyToolbar”的命令栏，创建时设置新命令栏的 Position 参数为 msoBarTop，使新命令栏位于应用程序窗口的顶部。如果将 Position 参数设置成 msoBarFloating，新命令栏为浮动工具栏，如图 89-1 所示。</p>
<div>
<p><img src="./assets/89-1.png" alt="" loading="lazy"></p>
<p><u>图 89-1</u>	浮动命令栏</p>
</div>
<p>关于 Position 参数的 MsoBarPosition 常数请参阅 83 中的表格 83-1。</p>
<p>第 12 行代码，设置“MyToolbar”命令栏的 Protection 属性为 msoBarNoResize。应用于 CommandBar 对象的 Protection 属性指定命令栏的保护类型，可以为表格 89-1 所列的 MsoBarProtection 常数之一。</p>
<p><u>表格 89-1</u>	MsoBarProtection常数</p>
<table>
<thead>
<tr>
<th>常数</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>msoBarNoProtection</td>
<td>0</td>
<td>不受保护，可自定义(缺省值)</td>
</tr>
<tr>
<td>msoBarNoCustomize</td>
<td>1</td>
<td>不能自定义</td>
</tr>
<tr>
<td>msoBarNoResize</td>
<td>2</td>
<td>不能调整大小</td>
</tr>
<tr>
<td>msoBarNoMove</td>
<td>4</td>
<td>不能移动</td>
</tr>
<tr>
<td>msoBarNoChangeVisible</td>
<td>8</td>
<td>不能更改可见状态</td>
</tr>
<tr>
<td>msoBarNoChangeDock</td>
<td>16</td>
<td>不能改变停靠的位置</td>
</tr>
<tr>
<td>msoBarNoVerticalDock</td>
<td>32</td>
<td>不能沿窗口左侧或右侧停放</td>
</tr>
<tr>
<td>msoBarNoHorizontalDock</td>
<td>64</td>
<td>不能沿窗口顶部或底部停放</td>
</tr>
</tbody>
</table>
<p>第 14 行到第 21 代码，使用 Add 方法在新命令栏中添加按钮控件，设置按钮控件的各项属性。其中第 19 行代码，设置按钮控件的 Style 属性为 msoButtonIconAndCaptionBelow，使工具栏按钮显示时包含图标和标题，且标题位于图标之下。</p>
<p>应用于 CommandBar 对象的 Style 属性返回或设置工具栏按钮的显示方式，可以为表格 89-2 所列的 MsoButtonStyle 常数之一。</p>
<p><u>表格 89-2</u>	MsoButtonStyle 常数</p>
<table>
<thead>
<tr>
<th>常数</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>msoButtonIcon</td>
<td>1</td>
<td>包含图标的按钮</td>
</tr>
<tr>
<td>msoButtonCaption</td>
<td>2</td>
<td>包含标题的按钮</td>
</tr>
<tr>
<td>ButtonIconandCaption</td>
<td>3</td>
<td>包含图标和标题的按钮</td>
</tr>
<tr>
<td>msoButtonIconAndCaptionBelow</td>
<td>11</td>
<td>包含图标和标题，且标题位于底部的按钮</td>
</tr>
<tr>
<td>msoButtonIconAndWrapCaption</td>
<td>7</td>
<td>包含图标和标题，且标题自动换行的按钮</td>
</tr>
<tr>
<td>msoButtonWrapCaption</td>
<td>14</td>
<td>包含标题，且标题自动换行的按钮</td>
</tr>
</tbody>
</table>
<p>运行 NowToolbar 过程，将在 Excel 窗口的顶部创建一个自定义的工具栏，如图 89-2 所示。</p>
<div>
<p><img src="./assets/89-2.png" alt="" loading="lazy"></p>
<p><u>图 89-2</u>	创建自定义工具栏</p>
</div>
<h2 id="_90、自定义工具栏按钮图标"> 90、自定义工具栏按钮图标</h2>
<p>在创建自定义的工具栏时，除了可以为工具栏按钮添加 Excel 内置的图标外，还能为工具栏按钮添加自定义的图标，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> AddCustomButton<span>(</span><span>)</span>
	<span>Dim</span> xBar <span>As</span> CommandBar
	<span>Dim</span> xButton <span>As</span> CommandBarButton
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	Application<span>.</span>CommandBars<span>(</span><span>"CustomBar"</span><span>)</span><span>.</span>Delete
	<span>Set</span> xBar <span>=</span> CommandBars<span>.</span>Add<span>(</span><span>"CustomBar"</span><span>,</span> msoBarTop<span>)</span>
	<span>Set</span> xButton <span>=</span> xBar<span>.</span>Controls<span>.</span>Add<span>(</span>msoControlButton<span>)</span>
	<span>With</span> xButton
		<span>.</span>Picture <span>=</span> LoadPicture<span>(</span>ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\P.BMP"</span><span>)</span>
		<span>.</span>Mask <span>=</span> LoadPicture<span>(</span>ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\M.BMP"</span><span>)</span>
		<span>.</span>TooltipText <span>=</span> <span>"Excel Home 论坛"</span>
	<span>End</span> <span>With</span>
	xBar<span>.</span>Visible <span>=</span> <span>True</span>
	<span>Set</span> xBar <span>=</span> <span>Nothing</span>
	<span>Set</span> xButton <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>代码解析：</p>
<p>AddCustomButton 过程创建自定义工具栏，并设置工具栏的按钮自定义图标。</p>
<p>第 6、7 行代码，使用 Add 方法在 Excel 窗口中添加自定义工具栏和按钮。请参阅 89 。</p>
<p>第 9 行代码，设置工具栏按钮的 Picture 属性为同一目录中的 p.bmp 图片。</p>
<p>应用于 CommandBarButton 对象的 Picture 属性返回一个 IPictureDisp 对象，表示  CommandBarButton 对象的图像，语法如下：</p>
<div><pre><code>expression<span>.</span>Picture

参数是必需的，返回一个CommandBarButton对象。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>指定对象的 Picture 属性就能设置对象的图像。</p>
<p>第 10 行代码，设置工具栏按钮的 Mask 属性为同一目录中的 m.bmp 图片。</p>
<p>为了使工具栏按钮图标透明显示，在指定对象的 Picture 属性后，还需要指定对象的 Mask 属性。</p>
<p>应用于 CommandBarButton 对象的 Mask 属性返回表示 CommandBarButton 对象的屏蔽图像的 IPictureDisp 对象，语法如下：</p>
<div><pre><code>expression<span>.</span>Mask

参数是必需的，返回一个CommandBarButton对象。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>屏蔽图像决定按钮图像透明的部分。在创建作为屏蔽图像使用的图像时，所有要透明的区域应该为白色，所有要显示的区域应该为黑色。</p>
<p>第 11 行代码，设置按钮的“屏幕提示”为“ExcelHome论坛”。</p>
<p>运行 AddCustomButton 过程，创建自定义工具栏，并设置工具栏按钮的图标，如图 90-1 所示。</p>
<div>
<p><img src="./assets/90-1.png" alt="" loading="lazy"></p>
<p><u>图 90-1</u>	自定义工具栏图标</p>
</div>
<h2 id="_91、自定义工作簿图标"> 91、自定义工作簿图标</h2>
<p>Excel 标题栏的图标是默认的，而借助 API 函数可以自定义工作簿标题栏图标，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Declare</span> <span>Function</span> FindWindow <span>Lib</span> <span>"user32"</span> <span>Alias</span> <span>"FindWindowA"</span> <span>(</span><span>ByVal</span> lpClassName <span>As</span> <span>String</span><span>,</span> <span>ByVal</span> lpWindowName <span>As</span> <span>String</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Declare</span> <span>Function</span> DrawMenuBar <span>Lib</span> <span>"user32"</span> <span>(</span><span>ByVal</span> hWnd <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Declare</span> <span>Function</span> SetFocus <span>Lib</span> <span>"user32"</span> <span>(</span><span>ByVal</span> hWnd <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Declare</span> <span>Function</span> SendMessage <span>Lib</span> <span>"user32"</span> <span>Alias</span> <span>"SendMessageA"</span> <span>(</span><span>ByVal</span> hWnd <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> wMsg <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> wParam <span>As</span> <span>Integer</span><span>,</span> <span>ByVal</span> lParam <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Declare</span> <span>Function</span> ExtractIcon <span>Lib</span> <span>"shell32.dll"</span> <span>Alias</span> <span>"ExtractIconA"</span> <span>(</span><span>ByVal</span> hInst <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> lpszExeFileName <span>As</span> <span>String</span><span>,</span> <span>ByVal</span> nIconIndex <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Const</span> WM_SETICON <span>=</span> <span>&amp;H80</span>
<span>Private</span> <span>Sub</span> Workbook_Open<span>(</span><span>)</span>
	<span>Dim</span> IStyle <span>As</span> <span>Long</span>
	<span>Dim</span> hIcon <span>As</span> <span>Long</span>
	<span>Dim</span> hWndForm <span>As</span> <span>Long</span>
	hWndForm <span>=</span> FindWindow<span>(</span>vbNullString<span>,</span> Application<span>.</span>Caption<span>)</span>
	hIcon <span>=</span> ExtractIcon<span>(</span><span>0</span><span>,</span> ActiveWorkbook<span>.</span>Path <span>&amp;</span> <span>"\p.bmp"</span><span>,</span> <span>0</span><span>)</span>
	SendMessage hWndForm<span>,</span> WM_SETICON<span>,</span> <span>True</span><span>,</span> hIcon
	SendMessage hWndForm<span>,</span> WM_SETICON<span>,</span> <span>False</span><span>,</span> hIcon
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>代码解析：</p>
<p>工作簿打开后使用 API 函数自定义工作簿标题栏的图标。</p>
<p>第 1 行到第 6 行代码，API 函数声明。</p>
<p>第 7 行到第 15 行代码，工作簿的 Open 事件过程，把工作簿标题栏默认的图标更改为同一文件夹下的 p.bmp 图片。</p>
<p>工作簿打开后标题栏如图 91-1 所示，任务栏图标如图 91-2 所示。</p>
<div>
<p><img src="./assets/91-1.png" alt="" loading="lazy"></p>
<p><u>图 91-1</u>	自定义工作簿标题和图标</p>
<p><img src="./assets/91-2.png" alt="" loading="lazy"></p>
<p><u>图 91-2</u>	任务栏图标</p>
</div>
<h2 id="_92、移除工作表的最小最大化和关闭按钮"> 92、移除工作表的最小最大化和关闭按钮</h2>
<p>如果不希望工作表的最小、最大化和关闭按钮出现在菜单栏中，可以使用以下代码去除：</p>
<div><pre><code>ActiveWorkbook<span>.</span>Protect <span>,</span> <span>,</span> <span>True</span>
</code></pre>
<div><span>1</span><br></div></div><p>代码解析：</p>
<p>使用 Protect 方法对工作簿进行保护。Protect 方法应用于 Workbook 对象的时保护工作簿使其不至被修改，语法如下：</p>
<div><pre><code>expression<span>.</span>Protect<span>(</span>Password<span>,</span> <span>Structure</span><span>,</span> Windows<span>)</span>

参数expression是必需的，该表达式返回一个Workbook对象。
参数Password是可选的，为工作表或工作簿指定区分大小写的密码。
参数<span>Structure</span>是可选的，如果为<span>True</span>，则保护工作簿结构（工作表的相对位置）。默认值为<span>False</span>。
参数Windows是可选的，如果为<span>True</span>，则保护工作簿窗口。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>恢复工作表的最大、最小化和关闭按钮的代码如下：</p>
<div><pre><code>ActiveWorkbook<span>.</span>Protect <span>,</span> <span>,</span> <span>False</span>
</code></pre>
<div><span>1</span><br></div></div><p>在本例中将 Windows 参数设置为 True，使工作簿窗口受到保护，工作表的最小、最大化和关闭按钮及图标不出现在菜单栏中，如图 92-1 所示。</p>
<div>
<p><img src="./assets/92-1.png" alt="" loading="lazy"></p>
<p><u>图 92-1</u>	移除工作表最小、最大化和关闭按钮</p>
</div>
<h2 id="_93、在工具栏上添加下拉列表框"> 93、在工具栏上添加下拉列表框</h2>
<p>如果需要在工具栏中添加类似“字体”这样的下拉列表控制框控件，那么可以使用下面的代码。</p>
<div><pre><code><span>Sub</span> AddDropdown<span>(</span><span>)</span>
	<span>Dim</span> myDropdown <span>As</span> <span>Object</span>
	<span>Dim</span> myCap <span>As</span> <span>Variant</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	myCap <span>=</span> Array<span>(</span><span>"基础应用"</span><span>,</span> <span>"VBA程序开发"</span><span>,</span> <span>"函数与公式"</span><span>)</span>
	<span>Call</span> DeleteButton
	<span>Set</span> myDropdown <span>=</span> Application<span>.</span>CommandBars<span>(</span><span>"Formatting"</span><span>)</span><span>.</span>Controls <span>_</span>
		<span>.</span>Add<span>(</span><span>Type</span><span>:</span><span>=</span>msoControlDropdown<span>,</span> Before<span>:</span><span>=</span><span>1</span><span>)</span>
	<span>With</span> myDropdown
		<span>.</span>Caption <span>=</span> <span>"请选择版块"</span>
		<span>.</span>OnAction <span>=</span> <span>"myOnA"</span>
		<span>.</span>Style <span>=</span> msoComboNormal
		<span>For</span> i <span>=</span> <span>0</span> <span>To</span> UBound<span>(</span>myCap<span>)</span>
			<span>.</span>AddItem myCap<span>(</span>i<span>)</span>
		<span>Next</span>
		<span>.</span>ListIndex <span>=</span> <span>1</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
<span>Sub</span> DeleteButton<span>(</span><span>)</span>
	<span>With</span> Application<span>.</span>CommandBars<span>(</span><span>"Formatting"</span><span>)</span><span>.</span>Controls<span>(</span><span>1</span><span>)</span>
		<span>If</span> <span>.</span>Caption <span>=</span> <span>"请选择版块"</span> <span>Then</span> <span>.</span>Delete
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
<span>Sub</span> myOnA<span>(</span><span>)</span>
	<span>Dim</span> myList <span>As</span> <span>Byte</span>
	myList <span>=</span> Application<span>.</span>CommandBars<span>(</span><span>"Formatting"</span><span>)</span> <span>_</span>
		<span>.</span>Controls<span>(</span><span>1</span><span>)</span><span>.</span>ListIndex
	ActiveWorkbook<span>.</span>FollowHyperlink <span>_</span>
	Address<span>:</span><span>=</span><span>"http://club.excelhome.net/forum-"</span> <span>&amp;</span> myList <span>&amp;</span> <span>"-1.html"</span><span>,</span> NewWindow<span>:</span><span>=</span><span>True</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>代码解析：</p>
<p>AddDropdown 过程使用 Add 方法在工具栏中添加下拉列表控制框控件。</p>
<p>第 5 行代码使用 Array 函数创建一个数组用于保存下拉列表控制框控件加载列表项所需的元素。</p>
<p>第 6 行代码先运行第 19 行到第 23 行的 DeleteButton 过程删除可能存在的下拉列表控制框控件，以免重复添加。DeleteButton 过程判断工具栏中第一个控件的 Caption 属性是否为“请选择版块”，如果是则删除该下拉列表控制框控件。</p>
<p>第 7、8 行代码使用 Add 方法在工具栏中添加下拉列表控制框控件。应用于  CommandBarControls 对象的 Add 方法请参阅 79 。示例中将其参数 Type 设置为 msoControlDropdown，添加的就是下拉列表控制框控件。</p>
<p>第 10 行代码设置下拉列表控制框控件的 Caption 属性，应用于 CommandBarControls 对象的 Caption 属性返回或设置指定命令栏控件的题注文字，也可作为默认的“屏幕提示”显示。</p>
<p>第 11 行代码设置改变下拉列表控制框控件的内容时要运行的过程为第 24 行到第 30 行代码的 myOnA 过程。myOnA 过程根据下拉列表控制框控件的 ListIndex 属性值打开 Excel Home 论坛中相应的版块。</p>
<p>第 12 行代码设置下拉列表控制框控件的样式。Style 属性返回或设置命令栏控件的显示方式，该属性值可设置为表格 93-1 所列 MsoComboStyle 常量之一。</p>
<p>表格 93-1	MsoComboStyle 常量</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>msoComboLabel</td>
<td>1</td>
<td>显示标签</td>
</tr>
<tr>
<td>msoComboNormal</td>
<td>0</td>
<td>不显示标签</td>
</tr>
</tbody>
</table>
<p>第 13 行到第 15 行代码使用 AddItem 方法将数组中的元素添加到下拉列表控制框控件的列表项中。</p>
<p>第 16 行代码将下拉列表控制框控件的 ListIndex 属性设置为 1，使其显示第一条列表项。</p>
<p>运行 AddDropdown 过程，工具栏如图 93-1 所示。</p>
<div>
<p><img src="./assets/93-1.png" alt="" loading="lazy"></p>
<p><u>图 93-1</u>	添加下拉列表控制框控件</p>
</div>
<h2 id="_94、屏蔽工作表的复制功能"> 94、屏蔽工作表的复制功能</h2>
<p>有时我们并不希望用户对工作表中的数据进行复制粘贴操作，此时可以把所有的复制功能都屏蔽，如下面的代码所示。</p>
<div><pre><code>	<span>Dim</span> CmdCtrls <span>As</span> CommandBarControls
	<span>Dim</span> Cmd <span>As</span> CommandBarControl
<span>Sub</span> ProCopy<span>(</span><span>)</span>
	<span>Set</span> CmdCtrls <span>=</span> Application<span>.</span>CommandBars<span>.</span>FindControls<span>(</span>ID<span>:</span><span>=</span><span>19</span><span>)</span>
	<span>For</span> <span>Each</span> Cmd <span>In</span> CmdCtrls
		Cmd<span>.</span>Enabled <span>=</span> <span>False</span>
	<span>Next</span>
	Application<span>.</span>CellDragAndDrop <span>=</span> <span>False</span>
	Application<span>.</span>OnKey <span>(</span><span>"^c"</span><span>)</span><span>,</span> <span>""</span>
<span>End</span> <span>Sub</span>
<span>Sub</span> StaCopy<span>(</span><span>)</span>
	<span>Set</span> CmdCtrls <span>=</span> Application<span>.</span>CommandBars<span>.</span>FindControls<span>(</span>ID<span>:</span><span>=</span><span>19</span><span>)</span>
	<span>For</span> <span>Each</span> Cmd <span>In</span> CmdCtrls
		Cmd<span>.</span>Enabled <span>=</span> <span>True</span>
	<span>Next</span>
	Application<span>.</span>CellDragAndDrop <span>=</span> <span>True</span>
	Application<span>.</span>OnKey <span>(</span><span>"^c"</span><span>)</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>代码解析：</p>
<p>第 1、2 行代码在模块顶部声明两个模块级的变量。</p>
<p>第 3 行到第 10 行代码 ProCopy 过程，屏蔽工作表中所有的复制功能。其中第 4 行到第 7 行代码使用 FindControls 方法将所有与“复制”相关的命令栏控件赋给变量 CmdCtrls 后将其 Enabled 设置为 False。关于 FindControls 方法请参阅 80 。</p>
<p>第 8 行代码屏蔽单元格拖放功能，关于应用于 Application 对象的 CellDragAndDrop 属性请参阅 10 。</p>
<p>第 9 行代码屏蔽 &lt;Ctrl+C&gt; 组合键功能，关于应用于 Application 对象的 OnKey 方法请参阅 68 。</p>
<p>第 11 行到第 18 行代码 StaCopy 过程，恢复所有的复制功能。</p>
<h2 id="_95、禁用工具栏的自定义"> 95、禁用工具栏的自定义</h2>
<p>在 Excel 中，用户可以通过依次单击菜单“视图”→“工具栏”→“自定义”，显示“自定义”选项卡来调整菜单栏和工具栏，如图 95-1、图 95-2 所示。</p>
<div>
<p><img src="./assets/95-1.png" alt="" loading="lazy"></p>
<p><u>图 95-1</u>	自定义功能</p>
<p><img src="./assets/95-2.png" alt="" loading="lazy"></p>
<p><u>图 95-2</u>	自定义选项卡</p>
</div>
<p>如果不希望用户使用“自定义”选项卡来调整菜单栏和工具栏，可以禁用工具栏的自定义功能，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> nCustomize<span>(</span><span>)</span>
	Application<span>.</span>CommandBars<span>.</span>DisableCustomize <span>=</span> <span>True</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>nCustomize 过程禁用工具栏的自定义功能，应用于 CommandBars 集合对象的DisableCustomize 属性设置是否禁用工具栏的自定义。如果禁用，返回 True，否则返回 False。</p>
<p>用于启用工具栏的自定义的代码是：</p>
<div><pre><code><span>Sub</span> yCustomize<span>(</span><span>)</span>
	Application<span>.</span>CommandBars<span>.</span>DisableCustomize <span>=</span> <span>False</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>运行 nCustomize 过程，禁用工具栏的自定义对话框，自定义菜单项消失,如图 95-3 所示。</p>
<div>
<p><img src="./assets/95-3.png" alt="" loading="lazy"></p>
<p><u>图 95-3</u>	禁用工具栏的自定义</p>
<h2 id="_96、屏蔽所有的命令栏"> 96、屏蔽所有的命令栏</h2>
<p>在使用自定义的操作界面时，需要屏蔽 Excel 中所有的命令栏，可以使用下面的代码。</p>
<div><pre><code><span>Sub</span> Shielding_1<span>(</span><span>)</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>For</span> i <span>=</span> <span>1</span> <span>To</span> Application<span>.</span>CommandBars<span>.</span>Count
		Application<span>.</span>CommandBars<span>(</span>i<span>)</span><span>.</span>Enabled <span>=</span> <span>False</span>
	<span>Next</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>代码解析：</p>
<p>Shielding_1 过程使用 For...Next 语句遍历 Excel 命令栏，并将其 Enabled 属性设置为 False，使之无效。</p>
<p>还可以使用 For Each...Next 语句遍历所有的 CommandBars 对象，代码如下：</p>
<div><pre><code><span>Sub</span> Shielding_2<span>(</span><span>)</span>
	<span>Dim</span> Cmd <span>As</span> CommandBar
	<span>For</span> <span>Each</span> Cmd <span>In</span> Application<span>.</span>CommandBars
		Cmd<span>.</span>Enabled <span>=</span> <span>False</span>
	<span>Next</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>运行 Shielding_1 或 Shielding_2 过程工作簿如图 96-1 所示。</p>
<div>
<p><img src="./assets/96-1.png" alt="" loading="lazy"></p>
<p><u>图 96-1</u>	屏蔽所有的命令栏</p>
</div>
</div>
<p>在需要恢复时只需将 Enabled 属性设置为 True 即可，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> Recovery_1<span>(</span><span>)</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>For</span> i <span>=</span> <span>1</span> <span>To</span> Application<span>.</span>CommandBars<span>.</span>Count
		Application<span>.</span>CommandBars<span>(</span>i<span>)</span><span>.</span>Enabled <span>=</span> <span>True</span>
	<span>Next</span>
<span>End</span> <span>Sub</span>
<span>Sub</span> Recover_2<span>(</span><span>)</span>
	<span>Dim</span> Cmd <span>As</span> CommandBar
	<span>For</span> <span>Each</span> Cmd <span>In</span> Application<span>.</span>CommandBars
		Cmd<span>.</span>Enabled <span>=</span> <span>True</span>
	<span>Next</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>代码解析：</p>
<p>Recovery_1 和 Recover_2 过程分别使用 For...Next 语句和 For Each...Next 语句遍历所有的 CommandBars 对象，设置其 Enabled 属性为 True，显示所有的命令栏。</p>
<h2 id="_97、恢复-excel-的命令栏"> 97、恢复 Excel 的命令栏</h2>
<p>如果用户经常添加、删除 Excel 的菜单和工具栏而又没有及时恢复的话，有时会破坏 Excel 默认的用户界面，即使用 Reset 方法也不能恢复成初始状态。</p>
<p>此时可以在电脑的本地硬盘中查找扩展名为 *.xlb 的文件，该文件在电脑中的位置会因 Excel 版本的不同而不同，在 XP 操作系统中，该文件位于系统盘的 <code>Documents and Settings\Administrator\Application Data\Microsoft\Excel</code> 文件夹，其中 Administrator 是电脑的用户名。找到它最简单的方法是使用 Windows 的搜索功能。按 &lt;Win+F&gt; 组合键调出 Windows 的搜索窗口，然后用 *.xlb 为目标在本地硬盘中进行搜索，如图 97-1 所示。</p>
<div>
<p><img src="./assets/97-1.png" alt="" loading="lazy"></p>
<p><u>图 97-1</u>	搜索 *.xlb 文件</p>
</div>
<p>如果搜索没有结果，请检查“更多高级选项”中是否选中“搜索隐藏的文件和文件夹”选项，如图 97-2 所示。</p>
<div>
<p><img src="./assets/97-2.png" alt="" loading="lazy"></p>
<p><u>图 97-2</u>	搜索隐藏的文件和文件夹</p>
</div>
<p>对 Excel 用户界面的任何修改都会保存在 *.xlb 文件中，找到后删除该文件，然后重新启动 Excel。Excel 会重新创建一个 *.xlb 文件，而菜单和工具栏也会全部恢复成初始状态。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-07-02T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">VBA 之 函数的使用</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Excel/13.VBA_function/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Excel/13.VBA_function/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="_153、调用工作表函数求和"> 153、调用工作表函数求和</h2>
<p>在对工作表的单元格区域进行求和计算时，使用工作表 Sum 函数比使用 VBA 代码遍历单元格进行累加求和效率要高得多，代码如下所示。</p>
<div><pre><code><span>Sub</span> rngSum<span>(</span><span>)</span>
	<span>Dim</span> rng <span>As</span> Range
	<span>Dim</span> d <span>As</span> <span>Double</span>
	<span>Set</span> rng <span>=</span> Range<span>(</span><span>"A1:F7"</span><span>)</span>
	d <span>=</span> Application<span>.</span>WorksheetFunction<span>.</span>Sum<span>(</span>rng<span>)</span>
	MsgBox rng<span>.</span>Address<span>(</span><span>0</span><span>,</span> <span>0</span><span>)</span> <span>&amp;</span> <span>"单元格的和为"</span> <span>&amp;</span> d
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>rngSum 过程调用工作表 Sum 函数对工作表的单元格区域进行求和计算。</p>
<p>在 VBA 中调用工作表函数需要在工作表函数前加上 WorksheetFunction 属性。应用于 Application 对象的 WorksheetFunction 属性返回 WorksheetFunction 对象，作为 VBA 中调用工作表函数的容器，在实际应用中可省略 Application 对象识别符。</p>
<h2 id="_154、查找最大、最小值"> 154、查找最大、最小值</h2>
<p>在 VBA 中没有内置的函数可以进行最大、最小值的查找，借助工作表 Max、Min 函数可以快速地在工作表区域中查找最大、最小值，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> seeks<span>(</span><span>)</span>
	<span>Dim</span> rng <span>As</span> Range
	<span>Dim</span> myRng <span>As</span> Range
	<span>Dim</span> k1 <span>As</span> <span>Integer</span><span>,</span> k2 <span>As</span> <span>Integer</span>
	<span>Dim</span> max <span>As</span> <span>Double</span><span>,</span> min <span>As</span> <span>Double</span>
	<span>Set</span> myRng <span>=</span> Sheet1<span>.</span>Range<span>(</span><span>"A1:F30"</span><span>)</span>
	<span>For</span> <span>Each</span> rng <span>In</span> myRng
		<span>If</span> rng<span>.</span>Value <span>=</span> WorksheetFunction<span>.</span>max<span>(</span>myRng<span>)</span> <span>Then</span>
			rng<span>.</span>Interior<span>.</span>ColorIndex <span>=</span> <span>3</span>
			k1 <span>=</span> k1 <span>+</span> <span>1</span>
			max <span>=</span> rng<span>.</span>Value
		<span>ElseIf</span> rng<span>.</span>Value <span>=</span> WorksheetFunction<span>.</span>min<span>(</span>myRng<span>)</span> <span>Then</span>
			rng<span>.</span>Interior<span>.</span>ColorIndex <span>=</span> <span>5</span>
			k2 <span>=</span> k2 <span>+</span> <span>1</span>
			min <span>=</span> rng<span>.</span>Value
		<span>Else</span>
			rng<span>.</span>Interior<span>.</span>ColorIndex <span>=</span> <span>0</span>
		<span>End</span> <span>If</span>
	<span>Next</span>
	MsgBox <span>"最大值是:"</span> <span>&amp;</span> max <span>&amp;</span> <span>"共有 "</span> <span>&amp;</span> k1 <span>&amp;</span> <span>"个"</span> <span>_</span>
		<span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>&amp;</span> <span>"最小值是:"</span> <span>&amp;</span> min <span>&amp;</span> <span>"共有 "</span> <span>&amp;</span> k2 <span>&amp;</span> <span>"个"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>代码解析：</p>
<p>seeks 过程在工作表单元格区域中查找最大、最小值，并将其所在的单元格底色分别设置为红色和蓝色。</p>
<p>第 2 行到第 5 行代码声明变量类型。</p>
<p>第 6 行代码使用关键字 Set 将单元格引用赋给变量 myRng。</p>
<p>第 7 行到第 19 行代码遍历单元格区域，使用工作表 Max、Min 函数判断单元格数值是否是所在区域的最大、最小值，如果是，将其所在的单元格底色设置为红色或蓝色，并保存其数值和数量。</p>
<p>第 20、21 行代码使用消息框显示最大、最小值数值和数量。</p>
<p>运行 seeks 过程后将工作表区域最大、最小值所在的单元格的底色设置为红色或蓝色并用消息框显示其数值和数量，如图 154-1 所示。</p>
<div>
<p><img src="./assets/154-1.png" alt="" loading="lazy"></p>
<p><u>图 154-1</u>	查找最大、最小值</p>
</div>
<h2 id="_155、不重复值的录入"> 155、不重复值的录入</h2>
<p>在工作表中录入数据时，有时希望能限制重复值的录入，比如在示例的 A 列单元格只能录入唯一的人员编号，此时可以利用工作表的 Change 事件结合工作表的 CountIf  函数来判断所录入的人员编号是否重复，示例代码如下。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Worksheet_Change<span>(</span><span>ByVal</span> Target <span>As</span> Range<span>)</span>
	<span>With</span> Target
		<span>If</span> <span>.</span>Column <span>&lt;</span><span>></span> <span>1</span> <span>Or</span> <span>.</span>Count <span>></span> <span>1</span> <span>Then</span> <span>Exit</span> <span>Sub</span>
		<span>If</span> Application<span>.</span>CountIf<span>(</span>Range<span>(</span><span>"A:A"</span><span>)</span><span>,</span> <span>.</span>Value<span>)</span> <span>></span> <span>1</span> <span>Then</span>
			<span>.</span><span>Select</span>
			MsgBox <span>"不能输入重复的人员编号!"</span><span>,</span> <span>64</span>
			Application<span>.</span>EnableEvents <span>=</span> <span>False</span>
			<span>.</span>Value <span>=</span> <span>""</span>
			Application<span>.</span>EnableEvents <span>=</span> <span>True</span>
		<span>End</span> <span>If</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>代码解析：</p>
<p>工作表的 Change 事件过程，使A列单元格只能录入唯一的人员编号。</p>
<p>第 4 行代码使用工作表的 CountIf 函数来判断在A列单元格输入的人员编号是否重复。工作表的 CountIf 函数计算区域中满足给定条件的单元格的个数，语法如下：</p>
<div><pre><code>COUNTIF<span>(</span>range<span>,</span> criteria<span>)</span>

参数range为需要计算其中满足条件的单元格数目的单元格区域。
参数criteria为确定哪些单元格将被计算在内的条件，其形式可以为数字、表达式、单元格引用或文本。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>在示例中以所录入的人员编号与A列单元格区域进行比较，如果 CountIf 函数的返回值大于 1，说明录入的是重复编号。</p>
<p>第 5 行代码，重新选择该单元格便于下一步清空后重新录入。</p>
<p>第 7、8、9 行代码，清除录入的重复编号，在清除前将 Application 对象的 EnableEvents 属性设置为 False，禁用事件。因为如果不禁用事件，那么在清除重复值的过程中会不断地触发工作表的 Change 事件，从而造成代码运行的死循环。</p>
<p>经过以上的设置，在工作表的A列中只能录入唯一的人员编号，如果录入重复值会进行提示，如图 155-1 所示，点击确定后自动清除录入的重复编号。</p>
<div>
<p><img src="./assets/155-1.png" alt="" loading="lazy"></p>
<p><u>图 155-1</u>	限制重复值的录入</p>
</div>
<h2 id="_156、获得当月的最后一天"> 156、获得当月的最后一天</h2>
<p>在实际工作中经常需要根据给定的日期计算其所属月份的最后一天，此时可以使用 DateSerial 函数完成计算，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> Serial<span>(</span><span>)</span>
	<span>Dim</span> DateStr <span>As</span> <span>Byte</span>
	DateStr <span>=</span> Day<span>(</span>DateSerial<span>(</span>Year<span>(</span><span>Date</span><span>)</span><span>,</span> Month<span>(</span><span>Date</span><span>)</span> <span>+</span> <span>1</span><span>,</span> <span>0</span><span>)</span><span>)</span>
	MsgBox <span>"本月的最后一天是"</span> <span>&amp;</span> Month<span>(</span><span>Date</span><span>)</span> <span>&amp;</span> <span>"月"</span> <span>&amp;</span> DateStr <span>&amp;</span> <span>"号"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>代码解析：</p>
<p>Serial 过程配合使用了 4 个 VBA 内置函数 Year、Month、Day 和 DateSerial 完成计算并使用消息框显示当月最后一天的日期。</p>
<p>Year、Month 和 Day 函数分别返回代表指定日期的年、月、日的整数，语法如下：</p>
<div><pre><code>Year<span>(</span><span>Date</span><span>)</span>
Month<span>(</span><span>Date</span><span>)</span>
Day<span>(</span><span>Date</span><span>)</span>

其中参数<span>Date</span>可以是任何能够表示日期的<span>Variant</span>、数值表达式、字符串表达式或它们的组合。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>DateSerial 函数返回包含指定的年、月、日的 Variant(Date)，语法如下：</p>
<div><pre><code>DateSerial<span>(</span>year<span>,</span> month<span>,</span> day<span>)</span>

其中参数year、 month、day分别表示指定的年、月、日。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>为了指定某个日期， DateSerial 函数中的每个参数的取值范围应该是可接受的，即日的取值范围应在 1-31 之间，而月的取值范围应在 1-12 之间。但是，当一个数值表达式表示某日之前或其后的年、月、日数时，也可以为每个使用这个数值表达式的参数指定相对日期。当任何一个参数的取值超出可接受的范围时，它会自动地在可接受的时间单位进行调整，例如本例中的 day 参数设置为 0，则被解释成 month 参数指定月的前一天，即表达式 Month(Date) + 1 指定的下一个月的前一天，也就是本月的最后一天。</p>
<p>运行 Serial 过程结果如图 156-1 所示。</p>
<div>
<p><img src="./assets/156-1.png" alt="" loading="lazy"></p>
<p><u>图 156-1</u>	获得当月的最后一天</p>
</div>
<h2 id="_157、四舍五入运算"> 157、四舍五入运算</h2>
<p>在实际工作中经常需要对数值或计算结果进行四舍五入运算，此时可以使用 VBA 内置的 Round 函数。Round 函数返回一个数值，该数值是按照指定的小数位数进行四舍五入运算的结果，语法如下：</p>
<div><pre><code>Round<span>(</span>expression [<span>,</span>numdecimalplaces]<span>)</span>

参数expression是必需的，要进行四舍五入运算的数值表达式。
参数numdecimalplaces是可选的，数字值，表示进行四舍五入运算时，小数点右边应保留的位数。如果忽略，则Round函数返回整数。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>但是 VBA 内置的 Round 函数在对数值进行四舍五入运算时实行的是 Bankre 舍入，而不是算术舍入。按 Bankre 舍入规则，如果保留位数的下一个数字正好是 5 则其后没有其他有效数字，则按保留位最后一位“偶舍奇入”的方法进行处理。比如 Round(1.5) 的保留位最后为 1，是奇数，小数位的 5 入上去，因此 Round(1.5) 的运算结果是 2；而 Round(4.5) 的保留位最后为 4，是偶数，小数位的 5 舍去，因此 Round(4.5) 的运算结果是 4 而不是 5。</p>
<p>Bankre 舍入规则虽然有其合理性，但不符合实际工作的需要。在实际应用中使用以下两种方法避免 Bankre 舍入：</p>
<h3 id="_1-极小值修正法"> 1）极小值修正法</h3>
<p>在使用 Round 函数时对需要舍入的数值先加上极小值再调用 VBA 内置的 Round 函数，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> aTestRound<span>(</span><span>)</span>
	MsgBox <span>"Round(4.5)="</span> <span>&amp;</span> Round<span>(</span><span>4.5</span><span>)</span> <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>&amp;</span> <span>"Round(4.5)="</span> <span>&amp;</span> Round<span>(</span><span>4.5</span> <span>+</span> <span>0.0000001</span><span>)</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>aTestRound 过程分别调用 VBA 内置的 Round 函数和加上极小值再调用 VBA 内置的 Round 函数在洗染店框中显示两者运算结果，如图 157-1 所示。</p>
<div>
<p><img src="./assets/157-1.png" alt="" loading="lazy"></p>
<p><u>图 157-1</u>	加上极小值进行运算结果</p>
</div>
<p>从运算结果中可以发现，加上极小值后 Round(4.5) 已正确运算为 5 而不是 4。</p>
<h3 id="_2-调用工作表函数法"> 2）调用工作表函数法</h3>
<p>还可以使用工作表函数 Round 代替 VBA 内置的 Round 函数。工作表函数 Round 和 VBA 内置的 Round 函数的用法相同，但它采用算术舍入而不是 Bankre 舍入，所以不会有“偶舍奇入”的问题，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> bTestRound<span>(</span><span>)</span>
	MsgBox <span>"Round(4.5)="</span> <span>&amp;</span> Round<span>(</span><span>4.5</span><span>)</span> <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>&amp;</span> <span>"Round(4.5)="</span> <span>&amp;</span> Application<span>.</span>Round<span>(</span><span>4.5</span><span>,</span> <span>0</span><span>)</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>bTestRound 过程分别调用 VBA 内置的 Round 函数和工作表 Round 函数在消息框中显示两者运算结果，如图 157-2 所示。</p>
<div>
<p><img src="./assets/157-2.png" alt="" loading="lazy"></p>
<p><u>图 157-2</u>	工作表函数运算结果</p>
</div>
<p>从运算结果中可以发现，使用工作表 Round 函数后 Round(4.5) 已正确运算为 5 而不是 4。</p>
<h2 id="_158、使用字符串函数"> 158、使用字符串函数</h2>
<p>使用 VBA 的字符串函数可以对字符串进行各种操作，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> StrFunctions<span>(</span><span>)</span>
	<span>Dim</span> Str <span>As</span> <span>String</span>
	Str <span>=</span> <span>"AbcD EFG hijk Lmn"</span>
	MsgBox <span>"原始字符串为："</span> <span>&amp;</span> Str <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>_</span>
		<span>&amp;</span> <span>"字符串长度为："</span> <span>&amp;</span> Len<span>(</span>Str<span>)</span> <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>_</span>
		<span>&amp;</span> <span>"左边8个字符为："</span> <span>&amp;</span> Left<span>(</span>Str<span>,</span> <span>8</span><span>)</span> <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>_</span>
		<span>&amp;</span> <span>"右边6个字符为："</span> <span>&amp;</span> Right<span>(</span>Str<span>,</span> <span>6</span><span>)</span> <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>_</span>
		<span>&amp;</span> <span>"从左边第2个开始取5个字符为："</span> <span>&amp;</span> Mid<span>(</span>Str<span>,</span> <span>2</span><span>,</span> <span>5</span><span>)</span> <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>_</span>
		<span>&amp;</span> <span>"转换为大写："</span> <span>&amp;</span> UCase<span>(</span>Str<span>)</span> <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>_</span>
		<span>&amp;</span> <span>"转换为小写："</span> <span>&amp;</span> LCase<span>(</span>Str<span>)</span> <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>代码解析：</p>
<p>StrFunctions 过程使用字符串函数对字符串进行各种操作，如计算字符数、取得一定数量的字符、大小写转换等。</p>
<p>第 5 行代码使用 Len 函数返回字符串内字符的数目，Len 函数语法如下：</p>
<div><pre><code>Len<span>(</span><span>string</span> | varname<span>)</span>

参数<span>string</span>为任何有效的字符串表达式。
参数varname为任何有效的变量名称。
两个可能的参数必须有一个，而且只能有一个参数。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>第 6 行代码使用 Left 函数从字符串左边起返回 8 个字符。</p>
<p>第 7 行代码使用 Right 函数从字符串右边起返回 6 个字符</p>
<p>Left 和 rigth 函数语法如下：</p>
<div><pre><code>Left<span>(</span><span>string</span><span>,</span> length<span>)</span>
Right<span>(</span><span>string</span><span>,</span> length<span>)</span>

参数<span>string</span>是必需的，字符串表达式。
参数length是必需的，数值表达式，将返回的字符数量。如果为<span>0</span>，返回零长度字符串 <span>(</span><span>""</span><span>)</span>；如果大于或等于参数<span>string</span>的字符数，则返回整个字符串
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>第 8 行代码使用 Mid 函数从字符串第 2 位起返回 5 个字符。Mid 函数语法如下：</p>
<div><pre><code>Mid<span>(</span><span>string</span><span>,</span> start[<span>,</span> length]<span>)</span>

参数<span>string</span>是必需的，字符串表达式。
参数start是必需的，<span>string</span>中被取出部分的字符位置。如果超过<span>string</span>的字符数，将返回零长度字符串 <span>(</span><span>""</span><span>)</span>。
参数length是可选的，要返回的字符数。如果省略或超过<span>string</span>的字符数，将返回字符串中所有字符。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>第 9 行代码使用 UCase 函数将字符串转换成大写的字符串。</p>
<p>第 10 行代码使用 LCase 函数将字符串转换成小写的字符串。</p>
<p>UCase 和 LCase 函数的语法如下：</p>
<div><pre><code>UCase<span>(</span><span>string</span><span>)</span>
LCase<span>(</span><span>string</span><span>)</span>

参数<span>string</span>是必需的，任何有效的字符串表达式。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>运行 StrFunctions 过程结果如图 158-1 所示。</p>
<div>
<p><img src="./assets/158-1.png" alt="" loading="lazy"></p>
<p><u>图 158-1</u>	使用字符串函数</p>
</div>
<h2 id="_159、使用日期函数"> 159、使用日期函数</h2>
<p>使用 VBA 的日期函数可以对日期进行各种计算，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> DatFunctions<span>(</span><span>)</span>
	<span>Dim</span> Str <span>As</span> <span>String</span>
	<span>Dim</span> Week <span>As</span> <span>String</span>
	Str <span>=</span> InputBox<span>(</span><span>"请输入日期："</span><span>)</span>
	<span>If</span> Len<span>(</span>Str<span>)</span> <span>></span> <span>0</span> <span>Then</span>
		<span>If</span> IsDate<span>(</span>Str<span>)</span> <span>Then</span>
			<span>Select</span> <span>Case</span> Weekday<span>(</span>Str<span>,</span> vbMonday<span>)</span>
				<span>Case</span> <span>1</span>
					Week <span>=</span> <span>"一"</span>
				<span>Case</span> <span>2</span>
					Week <span>=</span> <span>"二"</span>
				<span>Case</span> <span>3</span>
					Week <span>=</span> <span>"三"</span>
				<span>Case</span> <span>4</span>
					Week <span>=</span> <span>"四"</span>
				<span>Case</span> <span>5</span>
					Week <span>=</span> <span>"五"</span>
				<span>Case</span> <span>6</span>
					Week <span>=</span> <span>"六"</span>
				<span>Case</span> <span>7</span>
					Week <span>=</span> <span>"日"</span>
			<span>End</span> <span>Select</span>
			MsgBox <span>"你输入的日期是"</span> <span>&amp;</span> DateValue<span>(</span>Str<span>)</span> <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>_</span>
				<span>&amp;</span> <span>"是"</span> <span>&amp;</span> Year<span>(</span>Str<span>)</span> <span>&amp;</span> <span>"年的第"</span> <span>&amp;</span> DatePart<span>(</span><span>"q"</span><span>,</span> Str<span>)</span> <span>&amp;</span> <span>"季度"</span> <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>_</span>
				<span>&amp;</span> <span>"是星期"</span> <span>&amp;</span> Week <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>_</span>
				<span>&amp;</span> <span>"距离今天有"</span> <span>&amp;</span> Abs<span>(</span>DateDiff<span>(</span><span>"d"</span><span>,</span> <span>Date</span><span>,</span> Str<span>)</span><span>)</span> <span>&amp;</span> <span>"天"</span> <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>_</span>
				<span>&amp;</span> <span>"60天后的日期是"</span> <span>&amp;</span> DateAdd<span>(</span><span>"d"</span><span>,</span> <span>60</span><span>,</span> Str<span>)</span>
		<span>Else</span>
			MsgBox <span>"请输入正确格式的日期!"</span>
		<span>End</span> <span>If</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>代码解析：</p>
<p>DatFunctions 过程在对话框中输入日期后使用各种日期函数对其进行计算并用消息框显示。</p>
<p>第 4、5 行代码使用 InputBox 函数显示一个对话框，供用户在对话框中输入一个日期。</p>
<p>第 6 行代码使用 IsDate 函数判断输入的日期是否正确。IsDate 函数返回 Boolean 值，指出一个表达式是否可以转换成日期，语法如下：</p>
<div><pre><code>IsDate<span>(</span>expression<span>)</span>

参数expression是必需的，日期表达式或字符串表达式，如果表达式是一个日期，或者可以作为有效日期识别，则IsDate函数返回<span>True</span>，否则返回<span>False</span>。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>第 7 行到第 22 行代码使用 Weekday 函数判断所输入的日期是星期几。Weekday 函数返回一个整数，代表某个日期是星期几，语法如下：</p>
<div><pre><code>Weekday<span>(</span><span>date</span><span>,</span> [firstdayofweek]<span>)</span>

参数<span>date</span>是必需的，能够表示日期的 <span>Variant</span>、数值表达式、字符串表达式或它们的组合。
参数firstdayofweek是可选的，指定一星期第一天的常数，如表格 <span>159</span><span>-</span><span>1</span>所示。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><u>表格 159-1</u>	firstdayofweek 参数值</p>
<table>
<thead>
<tr>
<th>常数</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>vbUseSystem</td>
<td>0</td>
<td>使用 NLS API 设置</td>
</tr>
<tr>
<td>VbSunday</td>
<td>1</td>
<td>星期日（缺省值）</td>
</tr>
<tr>
<td>vbMonday</td>
<td>2</td>
<td>星期一</td>
</tr>
<tr>
<td>vbTuesday</td>
<td>3</td>
<td>星期二</td>
</tr>
<tr>
<td>vbWednesday</td>
<td>4</td>
<td>星期三</td>
</tr>
<tr>
<td>vbThursday</td>
<td>5</td>
<td>星期四</td>
</tr>
<tr>
<td>vbFriday</td>
<td>6</td>
<td>星期五</td>
</tr>
<tr>
<td>vbSaturday</td>
<td>7</td>
<td>星期六</td>
</tr>
</tbody>
</table>
<p>Weekday 函数返回一个 1 到 7 之间的整数，当 firstdayofweek 参数设置为 vbMonday（2）时，返回 1 时说明是星期一，以此类推。</p>
<p>第 23 行代码根据系统中指定的短日期格式来显示所输入的日期。DateValue 函数的语法如下：</p>
<div><pre><code>DateValue<span>(</span><span>date</span><span>)</span>

参数<span>date</span>是必需的，任何表达式，表示从 <span>100</span> 年 <span>1</span> 月 <span>1</span> 日到 <span>9999</span> 年 <span>12</span> 月 <span>31</span> 日之间的一个日期。如果是一个字符串，且其内容只有数字以及分隔数字的日期分隔符，则 DateValue函数就会根据系统中指定的短日期格式来识别月、日、年的顺序。DateValue函数也识别明确的英文月份名称，全名或缩写均可。例如，除了<span>12</span><span>/</span><span>30</span><span>/</span><span>1991</span> 和<span>12</span><span>/</span><span>30</span><span>/</span><span>91</span> 之外，DateValue函数也能识别December <span>30</span><span>,</span> <span>1991</span> 和Dec <span>30</span><span>,</span> <span>1991</span>。

如果<span>date</span>参数中略去了年这一部分，DateValue函数就会使用由计算机系统日期设置的当前年份。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>第 24 行代码判断输入的日期的季度。DatePart 函数返回一个包含已知日期的指定时间部分的值，语法如下：</p>
<div><pre><code>DatePart<span>(</span>interval<span>,</span> <span>date</span>[<span>,</span>firstdayofweek[<span>,</span> firstweekofyear]]<span>)</span>

其中参数interval是必需的，字符串表达式，是要返回的时间间隔，设定值如表格 <span>159</span><span>-</span><span>2</span>所示。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><u>表格 159-2</u>	interval 参数设定值</p>
<table>
<thead>
<tr>
<th>设置</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>yyyy</td>
<td>年</td>
</tr>
<tr>
<td>q</td>
<td>季</td>
</tr>
<tr>
<td>m</td>
<td>日</td>
</tr>
<tr>
<td>y</td>
<td>一年的日数</td>
</tr>
<tr>
<td>d</td>
<td>日</td>
</tr>
<tr>
<td>w</td>
<td>一周的日数</td>
</tr>
<tr>
<td>ww</td>
<td>周</td>
</tr>
<tr>
<td>h</td>
<td>时</td>
</tr>
<tr>
<td>n</td>
<td>分钟</td>
</tr>
<tr>
<td>s</td>
<td>秒</td>
</tr>
</tbody>
</table>
<p>第 26 行代码计算所输入的日期距当天的天数。DateDiff 函数返回两个指定日期间的时间间隔数目，语法如下：</p>
<div><pre><code>DateDiff<span>(</span>interval<span>,</span> date1<span>,</span> date2[<span>,</span> firstdayofweek[<span>,</span> firstweekofyear]]<span>)</span>

其中参数interval是必需的，字符串表达式，表示用来计算date1和date2的时间差的时间间隔，设定值如表格 <span>159</span><span>2</span>所示。
参数date1和date2是必需的，计算中要用到的两个日期。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>因为如果输入的日期是当前日期以前的日期，DateDiff 函数会返回负值，所以使用 Abs 函数返回绝对值将其转换为正值。</p>
<p>第 27 行代码计算所输入的日期距当天的天数，DateAdd 返回加上了一段时间间隔的一个日期，语法如下：</p>
<div><pre><code>DateAdd<span>(</span>interval<span>,</span> number<span>,</span> <span>date</span><span>)</span>

参数interval是必需的，字符串表达式，是所要加上去的时间间隔，设定值如表格 <span>159</span><span>-</span><span>2</span>所示。
参数number是必需的，是要加上的时间间隔的数目。其数值可以为正数（得到未来的日期），也可以为负数（得到过去的日期）。
参数<span>date</span>是必需的，需要加上时间间隔的字符串表达式。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>运行 DatFunctions 过程，在显示的对话框中输入一个日期，结果如图 159-1 所示。</p>
<div>
<p><img src="./assets/159-1.png" alt="" loading="lazy"></p>
<p><u>图 159-1</u>	使用日期函数</p>
</div>
<h2 id="_160、判断是否为数值"> 160、判断是否为数值</h2>
<p>使用 IsNumeric 函数可以判断表达式的运算结果是否为数值，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> Numeric<span>(</span><span>)</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>Dim</span> n <span>As</span> <span>String</span>
	<span>Dim</span> s <span>As</span> <span>String</span>
	<span>With</span> Sheet1
		<span>For</span> i <span>=</span> <span>1</span> <span>To</span> <span>.</span>Range<span>(</span><span>"A65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row
			<span>If</span> IsNumeric<span>(</span><span>.</span>Cells<span>(</span>i<span>,</span> <span>1</span><span>)</span><span>)</span> <span>Then</span>
				n <span>=</span> n <span>&amp;</span> <span>.</span>Cells<span>(</span>i<span>,</span> <span>1</span><span>)</span><span>.</span>Address<span>(</span><span>0</span><span>,</span> <span>0</span><span>)</span> <span>&amp;</span> Chr<span>(</span><span>9</span><span>)</span> <span>&amp;</span> <span>.</span>Cells<span>(</span>i<span>,</span> <span>1</span><span>)</span> <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span>
			<span>Else</span>
				s <span>=</span> s <span>&amp;</span> <span>.</span>Cells<span>(</span>i<span>,</span> <span>1</span><span>)</span><span>.</span>Address<span>(</span><span>0</span><span>,</span> <span>0</span><span>)</span> <span>&amp;</span> Chr<span>(</span><span>9</span><span>)</span> <span>&amp;</span> <span>.</span>Cells<span>(</span>i<span>,</span> <span>1</span><span>)</span> <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span>
			<span>End</span> <span>If</span>
		<span>Next</span>
	<span>End</span> <span>With</span>
	MsgBox <span>"A列中数值单元格："</span> <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>&amp;</span> n <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>_</span>
		<span>&amp;</span> <span>"A列中非数值单元格："</span> <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>&amp;</span> s
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>代码解析：</p>
<p>Numeric 过程使用 IsNumeric 函数判断工作表的A列单元格是否为数值，并使用消息框显示。</p>
<p>第 7 行代码判断工作表的 A 列单元格是否为数值。IsNumeric 函数返回 Boolean 值，指出表达式的运算结果是否为数，语法如下：</p>
<div><pre><code>IsNumeric<span>(</span>expression<span>)</span>

参数expression是必需的，<span>Variant</span>类型，包含数值表达式或字符串表达式。
如果参数expression的运算结果为数字，则IsNumeric返回<span>True</span>，否则返回<span>False</span>。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第 8 行代码将数值单元格的地址和数值保存在变量 e 中。</p>
<p>第 10 行代码将非数值单元格的地址和内容保存在变量 s 中。在保存时插入制表符对数据列进行分隔，使之排列整齐，请参阅 73-5。</p>
<p>运行 Numeric 过程结果如图 160-1 所示。</p>
<div>
<p><img src="./assets/160-1.png" alt="" loading="lazy"></p>
<p><u>图 160-1</u>	判断是否为数值</p>
</div>
<h2 id="_161、格式化数值、日期和时间"> 161、格式化数值、日期和时间</h2>
<p>Format 函数是 VBA 中的常用函数，可以实现数值、日期和时间格式的转变，示例代码如下：</p>
<div><pre><code><span>Sub</span> FromatCurrent<span>(</span><span>)</span>
	MsgBox Format<span>(</span><span>123456.789</span><span>,</span> <span>"0.00"</span><span>)</span> <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>_</span>
		<span>&amp;</span> Format<span>(</span><span>123456.789</span><span>,</span> <span>"0.00%"</span><span>)</span> <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>_</span>
		<span>&amp;</span> Format<span>(</span><span>123456.789</span><span>,</span> <span>"##,##0.00"</span><span>)</span> <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>_</span>
		<span>&amp;</span> Format<span>(</span><span>-</span><span>123456.789</span><span>,</span> <span>"$#,##0.00;($#,##0.00)"</span><span>)</span> <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>_</span>
		<span>&amp;</span> Format<span>(</span><span>-</span><span>123456.789</span><span>,</span> <span>"￥#,##0.00;(￥#,##0.00)"</span><span>)</span> <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>_</span>
		<span>&amp;</span> Format<span>(</span><span>Date</span><span>,</span> <span>"yyyy-mm-dd"</span><span>)</span> <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>_</span>
		<span>&amp;</span> Format<span>(</span><span>Date</span><span>,</span> <span>"yyyymmdd"</span><span>)</span> <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>_</span>
		<span>&amp;</span> Format<span>(</span><span>Date</span><span>,</span> <span>"Long Date"</span><span>)</span> <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>_</span>
		<span>&amp;</span> Format<span>(</span>Now<span>,</span> <span>"hh:mm:ss"</span><span>)</span> <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>_</span>
		<span>&amp;</span> Format<span>(</span>Now<span>,</span> <span>"hh:mm:ss AMPM"</span><span>)</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>代码解析：</p>
<p>FromatCurrent 过程使用消息框显示格式化后的数值、日期和时间。</p>
<p>Format 函数根据格式表达式中的指令来格式化的数值、日期和时间，语法如下：</p>
<div><pre><code>Format<span>(</span>expression[<span>,</span> format[<span>,</span> firstdayofweek[<span>,</span> firstweekofyear]]]<span>)</span>

其中参数expression是必需的，任何有效的表达式。
参数format是可选的，有效的命名表达式或用户自定义格式表达式。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第 2 行代码将数值格式化为两位小数格式显示。</p>
<p>第 3 行代码将数值格式化为两位小数的百分比格式显示。</p>
<p>第 4 行代码将数值格式化为千位分隔符显示。</p>
<p>第 5 行代码将数值格式化为以美元符号显示的两位小数，以千位分隔符分隔，如果是负值则以小括号显示。</p>
<p>第 6 行代码将数值格式化为以人民币符号显示的两位小数，以千位分隔符分隔，如果是负值则以小括号显示。</p>
<p>第 7 行代码将系统日期格式化为“yyyy-mm-dd”格式显示。</p>
<p>第 8 行代码将系统日期格式化为“yyyymmdd”格式显示。</p>
<p>第 9 行代码将系统日期格式化为长日期格式显示。</p>
<p>第 10 行代码将系统时间格式化为 24 小时、分钟和秒的格式显示。</p>
<p>第 11 行代码将系统时间格式化为分 12 小时、分钟和秒的格式显示。</p>
<p>运行 FromatCurrent 过程结果如图 161-1 所示。</p>
<div>
<p><img src="./assets/161-1.png" alt="" loading="lazy"></p>
<p><u>图 161-1</u>	格式化数值、日期和时间</p>
</div>
<h2 id="_162、个人所得税自定义函数"> 162、个人所得税自定义函数</h2>
<p>在财务工作中经常需要计算个人所得税，而在 Excel 中没有计算个人所得税的函数，此时可以使用自定义函数来计算，如下面的代码所示。</p>
<div><pre><code><span>Public</span> <span>Function</span> PITax<span>(</span>Income<span>,</span> <span>Optional</span> Threshold<span>)</span> <span>As</span> <span>Single</span>
	<span>Dim</span> Rate <span>As</span> <span>Single</span>
	<span>Dim</span> Debit <span>As</span> <span>Single</span>
	<span>Dim</span> Taxliability <span>As</span> <span>Single</span>
	<span>If</span> IsMissing<span>(</span>Threshold<span>)</span> <span>Then</span> Threshold <span>=</span> <span>2000</span>
	Taxliability <span>=</span> Income <span>-</span> Threshold
	<span>Select</span> <span>Case</span> Taxliability
		<span>Case</span> <span>0</span> <span>To</span> <span>500</span>
			Rate <span>=</span> <span>0.05</span>
			Debit <span>=</span> <span>0</span>
		<span>Case</span> <span>500.01</span> <span>To</span> <span>2000</span>
			Rate <span>=</span> <span>0.1</span>
			Debit <span>=</span> <span>25</span>
		<span>Case</span> <span>2000.01</span> <span>To</span> <span>5000</span>
			Rate <span>=</span> <span>0.15</span>
			Debit <span>=</span> <span>125</span>
		<span>Case</span> <span>5000.01</span> <span>To</span> <span>20000</span>
			Rate <span>=</span> <span>0.2</span>
			Debit <span>=</span> <span>375</span>
		<span>Case</span> <span>20000.01</span> <span>To</span> <span>40000</span>
			Rate <span>=</span> <span>0.25</span>
			Debit <span>=</span> <span>1375</span>
		<span>Case</span> <span>40000.01</span> <span>To</span> <span>60000</span>
			Rate <span>=</span> <span>0.3</span>
			Debit <span>=</span> <span>3375</span>
		<span>Case</span> <span>60000.01</span> <span>To</span> <span>80000</span>
			Rate <span>=</span> <span>0.35</span>
			Debit <span>=</span> <span>6375</span>
		<span>Case</span> <span>80000.01</span> <span>To</span> <span>10000</span>
			Rate <span>=</span> <span>0.4</span>
			Debit <span>=</span> <span>10375</span>
		<span>Case</span> <span>Else</span>
			Rate <span>=</span> <span>0.45</span>
			Debit <span>=</span> <span>15375</span>
	<span>End</span> <span>Select</span>
	<span>If</span> Taxliability <span>&lt;</span><span>=</span> <span>0</span> <span>Then</span>
		PITax <span>=</span> <span>0</span>
	<span>Else</span>
		PITax <span>=</span> Application<span>.</span>Round<span>(</span>Taxliability <span>*</span> Rate <span>-</span> Debit<span>,</span> <span>2</span><span>)</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Function</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><p>代码解析：</p>
<p>自定义 PITax 函数根据应纳税额计算应纳的个人所得税额。</p>
<p>第 5 行代码设置个人所得税的起征点为 2000 元，如果以后需要调整起征点，可把 2000 元改为调整后的起征点。</p>
<p>第 6 行代码设置全月应纳税所得额等于应纳税收入减去起征点。</p>
<p>第 7 行到第 35 行代码根据全月应纳税所得额取得税率和速算扣除数。税率和速算扣除数根据如表格 162-1 所示的工资、薪金所得适用个人所得税九级超额累进税率表计算。</p>
<p><u>表格 162-1</u>	个人所得税九级超额累进税率表</p>
<table>
<thead>
<tr>
<th>级数</th>
<th>全月应纳税所得额（含税所得额）</th>
<th>税率%</th>
<th>速算扣除数（元）</th>
</tr>
</thead>
<tbody>
<tr>
<td>一</td>
<td>不超过500元</td>
<td>5</td>
<td>0</td>
</tr>
<tr>
<td>二</td>
<td>超过500元至2000元</td>
<td>10</td>
<td>25</td>
</tr>
<tr>
<td>三</td>
<td>超过2000元至5000元</td>
<td>15</td>
<td>125</td>
</tr>
<tr>
<td>四</td>
<td>超过5000元至20000元</td>
<td>20</td>
<td>375</td>
</tr>
<tr>
<td>五</td>
<td>超过20000元至40000元</td>
<td>25</td>
<td>1375</td>
</tr>
<tr>
<td>六</td>
<td>超过40000元至60000元</td>
<td>30</td>
<td>3375</td>
</tr>
<tr>
<td>七</td>
<td>超过60000元至80000元</td>
<td>35</td>
<td>6375</td>
</tr>
<tr>
<td>八</td>
<td>超过80000元至100000元</td>
<td>40</td>
<td>10375</td>
</tr>
<tr>
<td>九</td>
<td>超过100000元</td>
<td>45</td>
<td>15375</td>
</tr>
</tbody>
</table>
<p>第 36 行到第 40 行代码根据应纳税所得额、税率和速算扣除数计算应纳的个人所得税额。其中第 39 行代码中使用工作表函数 Round 对计算结果进行四舍五入运算，请参阅 157-2。</p>
<p>在工作表中使用自定义 PITax 函数结果如图 162-1 所示。</p>
<div>
<p><img src="./assets/162-1.png" alt="" loading="lazy"></p>
<p><u>图 162-1</u>	工作表中使用自定义 PITax 函数</p>
</div>
<h2 id="_163、人民币大写函数"> 163、人民币大写函数</h2>
<p>在 VBA 中没有内置的函数进行人民币大写转换，此时可以编写自定义函数进行人民币大写转换，如下面的代码所示。</p>
<div><pre><code><span>Public</span> <span>Function</span> RMBDX<span>(</span>M<span>)</span>
	RMBDX <span>=</span> Replace<span>(</span>Application<span>.</span>Text<span>(</span>Round<span>(</span>M <span>+</span> <span>0.00000001</span><span>,</span> <span>2</span><span>)</span><span>,</span> <span>"[DBnum2]"</span><span>)</span><span>,</span> <span>"."</span><span>,</span> <span>"元"</span><span>)</span>
	RMBDX <span>=</span> IIf<span>(</span>Left<span>(</span>Right<span>(</span>RMBDX<span>,</span> <span>3</span><span>)</span><span>,</span> <span>1</span><span>)</span> <span>=</span> <span>"元"</span><span>,</span> Left<span>(</span>RMBDX<span>,</span> Len<span>(</span>RMBDX<span>)</span> <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> <span>"角"</span> <span>&amp;</span> Right<span>(</span>RMBDX<span>,</span> <span>1</span><span>)</span> <span>&amp;</span> <span>"分"</span><span>,</span> IIf<span>(</span>Left<span>(</span>Right<span>(</span>RMBDX<span>,</span> <span>2</span><span>)</span><span>,</span> <span>1</span><span>)</span> <span>=</span> <span>"元"</span><span>,</span> RMBDX <span>&amp;</span> <span>"角整"</span><span>,</span> IIf<span>(</span>RMBDX <span>=</span> <span>"零"</span><span>,</span> <span>""</span><span>,</span> RMBDX <span>&amp;</span> <span>"元整"</span><span>)</span><span>)</span><span>)</span>
	RMBDX <span>=</span> Replace<span>(</span>Replace<span>(</span>Replace<span>(</span>Replace<span>(</span>RMBDX<span>,</span> <span>"零元零角"</span><span>,</span> <span>""</span><span>)</span><span>,</span> <span>"零元"</span><span>,</span> <span>""</span><span>)</span><span>,</span> <span>"零角"</span><span>,</span> <span>"零"</span><span>)</span><span>,</span> <span>"-"</span><span>,</span> <span>"负"</span><span>)</span>
<span>End</span> <span>Function</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>代码解析：</p>
<p>第 2 行代码首先使用 Round 函数对小写数字加上极小值后进行四舍五入运算，关于 Round 函数请参阅 157-1。其次使用工作表 Text 函数将数值转换成人民币大写格式表示的文本。Text 函数将数值转换为按指定数字格式表示的文本，语法如下：</p>
<div><pre><code>TEXT<span>(</span>value<span>,</span>format_text<span>)</span>

Value参数为数值、计算结果为数值的公式，或对包含数值的单元格的引用。
Format_text参数为<span>“单元格格式“</span>对话框中<span>”数字“</span>选项卡上”分类框中的文本形式的数字格式。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>最后使用 Replace 函数将人民币大写格式表示的文本中的小数点替换成“元”。 Replace 函数返回一个字符串，该字符串中指定的子字符串已被替换成另一子字符串，并且替换发生的次数也是指定的，语法如下：</p>
<div><pre><code>Replace<span>(</span>expression<span>,</span> find<span>,</span> replace[<span>,</span> start[<span>,</span> count[<span>,</span> compare]]]<span>)</span>

其中参数expression是必需的，包含要替换的子字符串。
参数find是必需的，要搜索到的子字符串。
参数replace是必需的，用来替换的子字符串。
参数start是可选的，在表达式中子字符串搜索的开始位置。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>第 3 行代码使用了 IIF 函数、Left 函数、Right 函数根据第 2 行代码返回的人民币大写格式表示的文本中的“元”的位置在文本中插入正确的“元”、“角”、“分”字符，使之符合人民币大写习惯。</p>
<p>IIf 函数根据表达式的值，来返回两部分中的其中一个，语法如下：</p>
<div><pre><code>IIf<span>(</span>expr<span>,</span> truepart<span>,</span> falsepart<span>)</span>

参数expr是必需的，用来判断真伪的表达式。
参数truepart是必需的，如果expr为<span>True</span>，则返回这部分的值或表达式。
参数falsepart是必需的，如果expr为<span>False</span>，则返回这部分的值或表达式。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>Left、Right 函数请参阅 158 。</p>
<p>第 4 行代码使用 Replace 函数将人民币大写格式表示的文本中可能出现的“零元零角”、“零元”替换成空白字符；可能出现的“零角”替换成“零”。如果输入负数的话，将“-”替换成“负”。</p>
<p>在工作表中使用自定义 RMBDX 函数转换人民币大写的效果如图 163-1 所示。</p>
<div>
<p><img src="./assets/163-1.png" alt="" loading="lazy"></p>
<p><u>图 163-1</u>	人民币大写转换</p>
</div>
<h2 id="_164、列号转换为列标"> 164、列号转换为列标</h2>
<p>使用 VBA 获取单元格的列号时，只能返回一个数值。如果需要获取以字符表示的列标，可以使用下面的自定义 GetColumn 函数过程。</p>
<div><pre><code><span>001</span>  <span>Function</span> GetColumn<span>(</span>C <span>As</span> <span>Integer</span><span>)</span> <span>As</span> <span>String</span>
<span>002</span>    GetColumn <span>=</span> Split<span>(</span>Cells<span>(</span><span>1</span><span>,</span> C<span>)</span><span>.</span>Address<span>,</span> <span>"$"</span><span>)</span><span>(</span><span>1</span><span>)</span>
<span>003</span>  <span>End</span> <span>Function</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>GetColumn 函数过程代码中，将参数 iCol 作为列号传递给 Cells 属性，并获取其绝对地址字串符，然后以“$”字符为分隔符，通过Split函数返回一个一维数组。</p>
<p>Split 函数返回一个下标从零开始的一维数组，它包含指定数目的子字符串，语法如下：</p>
<div><pre><code>Split<span>(</span>expression[<span>,</span> delimiter[<span>,</span> limit[<span>,</span> compare]]]<span>)</span>

其中参数expression是必需的，包含子字符串和分隔符的字符串表达式 。如果expression是一个长度为零的字符串<span>(</span><span>""</span><span>)</span>，则返回一个空数组，即没有元素和数据的数组。
参数delimiter是可选的，用于标识子字符串边界的字符串字符。如果忽略，则使用空格字符<span>(</span><span>" "</span><span>)</span>作为分隔符。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>返回一维数组后获取该数组的第 2 个元素（下标为 1），即该列号的字符列标。</p>
<p>下面的代码使用 GetColumn 函数过程获得所选单元格的字符列标。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Worksheet_SelectionChange<span>(</span><span>ByVal</span> Target <span>As</span> Range<span>)</span>
	MsgBox GetColumn<span>(</span>Selection<span>.</span>Column<span>)</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>在工作表中选择单元格后结果如图 164-1 所示。</p>
<div>
<p><img src="./assets/164-1.png" alt="" loading="lazy"></p>
<p><u>图 164-1</u>	返回列标字符串</p>
</div>
<h2 id="_165、判断工作表是否为空表"> 165、判断工作表是否为空表</h2>
<p>VBA 中没有专门的属性或函数可以判断工作表是否为空白工作表，可以使用自定义函数返回指定工作表是否为空工作表，如下面的代码所示。</p>
<div><pre><code><span>Function</span> IsBlankSht<span>(</span>Sh <span>As</span> <span>Variant</span><span>)</span> <span>As</span> <span>Boolean</span>
	<span>If</span> TypeName<span>(</span>Sh<span>)</span> <span>=</span> <span>"String"</span> <span>Then</span> <span>Set</span> Sh <span>=</span> Worksheets<span>(</span>Sh<span>)</span>
	<span>If</span> Application<span>.</span>CountA<span>(</span>Sh<span>.</span>UsedRange<span>.</span>Cells<span>)</span> <span>=</span> <span>0</span> <span>Then</span>
		IsBlankSht <span>=</span> <span>True</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Function</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>代码解析：</p>
<p>自定义 IsBlankSht 函数包含一个 Variant 变量类型的参数，代表工作表名称或者对象名称。如果指定的工作表为空工作表，则该函数返回 True。</p>
<p>第 2 行代码使用 TypeName 函数判断参数 Sh 是否为字符串类型（“String”），如果是字符串，则将以该字符串作为名称的工作表赋值给变量 Sh。</p>
<p>第 3 行代码通过工作表函数 CountA 统计工作表已使用区域的非空单元格个数，如果统计结果为 0，则表示该工作表为空工作表。</p>
<p>现在就可以像使用 VBA 函数一样使用自定义的 IsBlankSht 函数，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> DelBlankSht<span>(</span><span>)</span>
	<span>Dim</span> Sh <span>As</span> Worksheet
	Application<span>.</span>DisplayAlerts <span>=</span> <span>False</span>
	<span>For</span> <span>Each</span> Sh <span>In</span> ThisWorkbook<span>.</span>Sheets
		<span>If</span> IsBlankSht<span>(</span>Sh<span>)</span> <span>Then</span> Sh<span>.</span>Delete
	<span>Next</span>
	Application<span>.</span>DisplayAlerts <span>=</span> <span>True</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>代码解析：</p>
<p>使用自定义的 IsBlankSht 函数删除工作簿中所有空工作表。</p>
<p>第 3 行代码将 Application 对象的 DisplayAlerts 属性设置为 False，使删除时不显示系统警告对话框。</p>
<p>第 4 行到第 6 行代码，使用 For Each...Next 语句遍历所有工作表，使用自定义的 IsBlankSht 函数判断是否为空表，如果为空表则使用 Delete 方法删除。</p>
<div><p>注意</p>
<p>自定义 IsBlankSht 函数仅仅判断工作表单元格区域内容是否为空，如果工作表中存在其它对象（如图形对象、数据有效性、单元格批注等），还需要再进一步判断。</p>
</div>
<h2 id="_166、查找指定工作表"> 166、查找指定工作表</h2>
<p>判断工作簿中是否存在指定名称的工作表，除了使用遍历工作簿中所有工作表的方法外，还可以使用自定义函数，如下面的代码所示。</p>
<div><pre><code><span>Function</span> ExistSh<span>(</span>Sh <span>As</span> <span>String</span><span>)</span> <span>As</span> <span>Boolean</span>
	<span>Dim</span> Sht <span>As</span> <span>Object</span>
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	<span>Set</span> Sht <span>=</span> Sheets<span>(</span>Sh<span>)</span>
	<span>If</span> Err<span>.</span>Number <span>=</span> <span>0</span> <span>Then</span> ExistSh <span>=</span> <span>True</span>
	<span>Set</span> Sht <span>=</span> <span>Nothing</span>
<span>End</span> <span>Function</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>自定义 ExistSh 函数包含一个 String 类型的参数，代表需要判断的工作表名称。如果该工作表存在，则返回 True。</p>
<p>第 5 行代码判断前面的代码是否出错，如果前面的代码存在错误，则表示不存在指定名称的表。</p>
<p>使用自定义 ExistSheet 函数判断工作簿中是否存在指定名称的工作表，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> NotSht<span>(</span><span>)</span>
	<span>Dim</span> Sh <span>As</span> <span>String</span>
	Sh <span>=</span> InputBox<span>(</span><span>"请输入工作表名称："</span><span>)</span>
	<span>If</span> Len<span>(</span>Sh<span>)</span> <span>></span> <span>0</span> <span>Then</span>
		<span>If</span> <span>Not</span> ExistSh<span>(</span>Sh<span>)</span> <span>Then</span>
			MsgBox <span>"对不起,"</span> <span>&amp;</span> Sh <span>&amp;</span> <span>"表不存在!"</span>
		<span>Else</span>
			Sheets<span>(</span>Sh<span>)</span><span>.</span><span>Select</span>
		<span>End</span> <span>If</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>代码解析：</p>
<p>NotSht 过程使用自定义的 ExistSh 函数判断工作簿中是否存在指定名称的工作表，如果不存在则使用消息框进行提示，如图 166-1 所示。</p>
<div>
<p><img src="./assets/166-1.png" alt="" loading="lazy"></p>
<p><u>图 166-1</u>	查找指定工作表</p>
</div>
<h2 id="_167、查找指定工作簿是否打开"> 167、查找指定工作簿是否打开</h2>
<p>如果需要判断指定名称的工作簿是否已经打开，除了使用 43 的方法外，还可以使用与 166 类似的自定义函数，如下面的代码所示。</p>
<div><pre><code><span>Function</span> ExistWorkbook<span>(</span>WbName <span>As</span> <span>String</span><span>)</span> <span>As</span> <span>Boolean</span>
	<span>Dim</span> wb <span>As</span> Workbook
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	<span>Set</span> wb <span>=</span> Workbooks<span>(</span>WbName<span>)</span>
	<span>If</span> Err<span>.</span>Number <span>=</span> <span>0</span> <span>Then</span> ExistWorkbook <span>=</span> <span>True</span>
	<span>Set</span> wb <span>=</span> <span>Nothing</span>
<span>End</span> <span>Function</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>自定义 ExistWorkbook 函数判断指定名称的工作簿是否已经打开。</p>
<p>第 5 行代码判断前面的赋值语句是否存在错误。如果没有指定名称的工作簿，则第 4 行代码会产生错误，自定义 ExistWorkbook 函数返回 False。</p>
<p>下面使用自定义 ExistWorkbook 函数判断名称为“Excel Home”的工作簿是否已经打开，如果没有打开则使用消息框进行提示，如图 167-1 所示。</p>
<div><pre><code><span>Sub</span> NotWorkbook<span>(</span><span>)</span>
	<span>If</span> <span>Not</span> <span>(</span>ExistWorkbook<span>(</span><span>"Excel Home"</span><span>)</span><span>)</span> <span>Then</span> MsgBox <span>"对不起,Excel Home工作簿没有打开!"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div>
<p><img src="./assets/167-1.png" alt="" loading="lazy"></p>
<p><u>图 167-1</u>	消息框提示</p>
</div>
<h2 id="_168、取得应用程序的安装路径"> 168、取得应用程序的安装路径</h2>
<p>使用自定义函数取得应用程序的安装路径，如下面的代码所示。</p>
<div><pre><code><span>Function</span> GetSetupPath<span>(</span>AppName <span>As</span> <span>String</span><span>)</span>
	<span>Dim</span> WSH <span>As</span> <span>Object</span>
	<span>Set</span> WSH <span>=</span> CreateObject<span>(</span><span>"Wscript.Shell"</span><span>)</span>
	GetSetupPath <span>=</span> WSH<span>.</span>RegRead<span>(</span><span>"HKEY_LOCAL_MACHINE\Software"</span> <span>_</span>
		<span>&amp;</span> <span>"\Microsoft\Windows\CurrentVersion\App Paths\"</span> <span>_</span>
		<span>&amp;</span> AppName <span>&amp;</span> <span>"\Path"</span><span>)</span>
	<span>Set</span> WSH <span>=</span> <span>Nothing</span>
<span>End</span> <span>Function</span>
<span>Sub</span> WinRARPath<span>(</span><span>)</span>
	MsgBox GetSetupPath<span>(</span><span>"WinRAR.exe"</span><span>)</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>代码解析：</p>
<p>自定义 GetSetupPath 函数取得应用程序的安装路径，其中参数 AppName 代表指定的应用程序的名称。</p>
<p>第 3 行代码使用 CreateObject 函数将 Wscript.Shell 对象的引用赋给变量 WSH。</p>
<p>CreateObject 函数创建并返回一个对 ActiveX 对象的引用，语法如下：</p>
<div><pre><code>CreateObject<span>(</span><span>class</span><span>,</span>[servername]<span>)</span>

参数<span>class</span>是必需的，<span>Variant</span> <span>(</span><span>String</span><span>)</span>，要创建的应用程序名称和类。
参数servername是可选的，<span>Variant</span> <span>(</span><span>String</span><span>)</span>，要在其上创建对象的网络服务器名称。如果servername是一个空字符串<span>(</span><span>""</span><span>)</span>，即使用本地机器。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第 4 行代码取得 AppName 参数指定的应用程序在注册表中的路径。</p>
<p>WinRARPath 过程使用消息框显示由自定义的 GetSetupPath 函数取得的应用程序“WinRAR”的安装路径。</p>
<p>运行 WinRARPath 过程结果如图 168-1 所示。</p>
<div>
<p><img src="./assets/168-1.png" alt="" loading="lazy"></p>
<p><u>图 168-1</u>	应用程序安装路径</p>
</div>
<h2 id="_169、数组的使用"> 169、数组的使用</h2>
<h3 id="_1-代码运行时创建数组"> 1）代码运行时创建数组</h3>
<p>使用 Array 函数可以在代码运行时创建数组并把一系列数据保存在数组中，示例代码如下：</p>
<div><pre><code><span>Option</span> Base <span>1</span>
<span>Sub</span> arr<span>(</span><span>)</span>
	<span>Dim</span> arr <span>As</span> <span>Variant</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	arr <span>=</span> Array<span>(</span><span>"王晓明"</span><span>,</span> <span>"吴胜玉"</span><span>,</span> <span>"周志国"</span><span>,</span> <span>"曹武伟"</span><span>,</span> <span>"张新发"</span><span>,</span> <span>"卓雪梅"</span><span>,</span> <span>"沈煜婷"</span><span>,</span> <span>"丁林平"</span><span>)</span>
	<span>For</span> i <span>=</span> LBound<span>(</span>arr<span>)</span> <span>To</span> UBound<span>(</span>arr<span>)</span>
		Cells<span>(</span>i<span>,</span> <span>1</span><span>)</span> <span>=</span> arr<span>(</span>i<span>)</span>
	<span>Next</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>代码解析：</p>
<p>Arr 过程使用 Array 函数创建一个数组用来保存数据并将其写入到工作表的单元格区域。</p>
<p>第 1 行代码使用 Option Base 语句声明数组下标的缺省下界为 1，数组下标的缺省下界默认为 0。</p>
<p>第 5 行代码使用 Array 函数创建数组用来保存数据。Array 函数返回一个包含数组的 Variant，语法如下：</p>
<div><pre><code>Array<span>(</span>arglist<span>)</span>

Arglist参数是一个用逗号隔开的值表，这些值用于给<span>Variant</span>所包含的数组的各元素赋值。如果不提供Arglist参数，则创建一个长度为 <span>0</span> 的数组。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>第 6 行代码使用 LBound 函数和 UBound 函数取得数组的最小和最大下标。</p>
<p>LBound 函数返回一个 Long 型数据，其值为指定数组维可用的最小下标，语法如下：</p>
<p>UBound 函数返回一个 Long 型数据，其值为指定数组维可用的最大下标，语法如下：</p>
<div><pre><code>LBound<span>(</span>arrayname[<span>,</span> dimension]<span>)</span>
UBound<span>(</span>arrayname[<span>,</span> dimension]<span>)</span>

参数arrayname是必需的，数组变量的名称。
参数dimension是可选的，指定返回哪一维的下界，<span>1</span>表示第一维，<span>2</span>表示第二维，如此类推。默认为<span>1</span>。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>UBound 函数与 LBound 函数一起使用，可以用来确定数组的大小。</p>
<p>第 7 行代码确定数组的大小后使用 For...Next 语句遍历数组元素并将数组元素依次写入到工作表的 A 列单元格中，如图 169-1 所示。</p>
<div>
<p><img src="./assets/169-1.png" alt="" loading="lazy"></p>
<p><u>图 169-1</u>	将数组元素写入工作表</p>
</div>
<h3 id="_2-文本转换为数组"> 2）文本转换为数组</h3>
<p>在处理字符串时可以使用 Split 函数将字符串按指定的分隔符分开并以数组返回，代码如下：</p>
<div><pre><code><span>Sub</span> Splitarr<span>(</span><span>)</span>
	<span>Dim</span> Arr <span>As</span> <span>Variant</span>
	Arr <span>=</span> Split<span>(</span>Sheet2<span>.</span>Cells<span>(</span><span>1</span><span>,</span> <span>1</span><span>)</span><span>,</span> <span>","</span><span>)</span>
	Sheet1<span>.</span>Cells<span>(</span><span>1</span><span>,</span> <span>1</span><span>)</span><span>.</span>Resize<span>(</span>UBound<span>(</span>Arr<span>)</span> <span>+</span> <span>1</span><span>,</span> <span>1</span><span>)</span> <span>=</span> Application<span>.</span>Transpose<span>(</span>Arr<span>)</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>代码解析：</p>
<p>Splitarr 过程使用 Split 函数将工作表 Sheet2 中 <code>A1</code> 单元格的姓名分别写入到工作表 Sheet1 中的 A 列单元格。</p>
<p>Split 函数返回一个下标从零开始的一维数组，包含指定数目的子字符串，语法如下：</p>
<div><pre><code>Split<span>(</span>expression[<span>,</span> delimiter[<span>,</span> limit[<span>,</span> compare]]]<span>)</span>

参数expression是必需的，包含子字符串和分隔符的字符串表达式。
参数delimiter是必需的，用来标识子字符串边界的字符串字符。如果忽略，则使用空格字符<span>(</span><span>" "</span><span>)</span>作为分隔符。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第 4 行代码，首先使用 UBound 函数取得返回数组的最大下标后调整单元格区域，因为数组下标的缺省下界默认为 0，所以在使用 Resize 属性调整单元格区域时参数 RowSize 需要在返回数组的最大下标上加一。</p>
<p>然后使用工作表 Transpose 函数将返回数组转置后写入到工作表调整后的单元格区域中。</p>
<p>工作表 Transpose 函数返回转置单元格区域，即将一行单元格区域转置成一列单元格区域，反之亦然，语法如下：</p>
<div><pre><code>TRANSPOSE<span>(</span>array<span>)</span>

参数 array 为需要进行转置的数组或工作表中的单元格区域。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>Splitarr 过程将如图 169-2 所示的工作表单元格中的字符串以逗号分隔后依次写入到工作表的 A 列单元格中，如图 169-3 所示。</p>
<div>
<p><img src="./assets/169-2.png" alt="" loading="lazy"></p>
<p><u>图 169-2</u>	工作表单元格中的字符串</p>
<p><img src="./assets/169-3.png" alt="" loading="lazy"></p>
<p><u>图 169-3</u>	文本转换为数组写入单元格</p>
</div>
<h3 id="_3-使用动态数组去除重复值"> 3）使用动态数组去除重复值</h3>
<p>在 169-2 中使用数组函数将单元格中的文本进行分隔后写入到工作表 Sheet1 中的 A 列单元格，但是如果文本中含有大量的重复值，在写入时也会将重复值写入到工作表中，此时可以使用动态数组去除文本中的重复值，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> Splitarr<span>(</span><span>)</span>
	<span>Dim</span> Splarr<span>(</span><span>)</span> <span>As</span> <span>String</span>
	<span>Dim</span> Arr<span>(</span><span>)</span> <span>As</span> <span>String</span>
	<span>Dim</span> Temp<span>(</span><span>)</span> <span>As</span> <span>String</span>
	<span>Dim</span> r <span>As</span> <span>Integer</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	Splarr <span>=</span> Split<span>(</span>Sheet2<span>.</span>Range<span>(</span><span>"a1"</span><span>)</span><span>,</span> <span>","</span><span>)</span>
	<span>For</span> i <span>=</span> <span>0</span> <span>To</span> UBound<span>(</span>Splarr<span>)</span>
		Temp <span>=</span> Filter<span>(</span>Arr<span>,</span> Splarr<span>(</span>i<span>)</span><span>)</span>
		<span>If</span> UBound<span>(</span>Temp<span>)</span> <span>&lt;</span> <span>0</span> <span>Then</span>
			r <span>=</span> r <span>+</span> <span>1</span>
			<span>ReDim</span> Preserve Arr<span>(</span><span>1</span> <span>To</span> r<span>)</span>
			Arr<span>(</span>r<span>)</span> <span>=</span> Splarr<span>(</span>i<span>)</span>
		<span>End</span> <span>If</span>
	<span>Next</span>
	Sheet1<span>.</span>Range<span>(</span><span>"a1"</span><span>)</span><span>.</span>Resize<span>(</span>r<span>,</span> <span>1</span><span>)</span> <span>=</span> Application<span>.</span>Transpose<span>(</span>Arr<span>)</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>代码解析：</p>
<p>Splitarr 过程将工作表 Sheet2 中 <code>A1</code> 单元格的文本去除重复值后写入到工作表 Sheet1 中的 A 列单元格。</p>
<p>第 2 行代码声明数组 Splarr 用来保存 Sheet2 中 <code>A1</code> 单元格的文本。</p>
<p>第 3 行代码声明数组 Arr 用来保存去除重复值后的文本。</p>
<p>第 4 行代码声明数组 Temp 用来判断文本是否重复。</p>
<p>第 5 行代码声明变量 r 用来保存去除重复值后的文本数量。</p>
<p>第 7 行代码启动错误处理程序来忽略错误，因为在程序运行到第 11 行代码会发生下标越界错误。</p>
<p>第 8 行代码使用 Split 函数以 Sheet2 中 <code>A1</code> 单元格的文本创建一个下标从零开始的一维数组。关于 Split 函数请参阅 169-2。</p>
<p>第 9 行代码使用 For...Next 语句遍历数组 Splarr 的所有元素。</p>
<p>第 10 行代码使用 Filter 函数创建一个数组 Temp 用来保存以当前 Splarr 数组的值在 Arr 数组中的搜索结果。Filter 函数返回一个下标从零开始的数组，该数组包含基于指定筛选条件的一个字符串数组的子集，语法如下：</p>
<div><pre><code>Filter<span>(</span>sourcesrray<span>,</span> match[<span>,</span> include[<span>,</span> compare]]<span>)</span>

参数sourcesrray是必需的，要执行搜索的一维字符串数组。
参数match是必需的，要搜索的字符串。
参数include是可选的，<span>Boolean</span>值，表示返回子串是否包含match字符串。如果参数include是<span>True</span>，Filter函数返回的是包含match参数子字符串的数组子集。如果参数include是<span>False</span>，Filter函数返回的是不包含match参数子字符串的数组子集。
参数compare是可选的，所使用的字符串比较类型。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>第 11 行代码根据返回的数组 Temp 的最大下标来判断当前 Splarr 数组的值是否重复。在使用使用 Filter 函数时如果没有相匹配的值，将返回一个空数组，最大下标小于 0。</p>
<p>第 12 行代码如果当前 Splarr 数组的值不重复则将变量 r 的值加 1。</p>
<p>第 13 行代码重新定义动态数组大小。ReDim 语句，在过程级别中使用，用于为动态数组变量重新分配存储空间，语法如下：</p>
<div><pre><code><span>ReDim</span> [Preserve] varname<span>(</span>subscripts<span>)</span> [<span>As</span> <span>type</span>] [<span>,</span> varname<span>(</span>subscripts<span>)</span> [<span>As</span> <span>type</span>]]

参数Preserve是可选的，关键字，当改变原有数组最末维的大小时，使用此关键字可以保持数组中原来的数据。
参数varname是必需的，变量的名称。
参数subscripts是必需的，数组变量的维数，最多可以定义 <span>60</span> 维的多维数组，使用下面的语法；

[lower <span>To</span>] upper [<span>,</span>[lower <span>To</span>] upper]
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>第 14 行代码将不重复值添加到数组 Arr 中。</p>
<p>第 15 行代码使用工作表 Transpose 函数将去除重复值的的文本转置后写入到工作表的 A 列单元格中。</p>
<p>如果需要将去除重复值的的文本写入到第一行单元格中，可以将第 15 行代码改成下面的代码：</p>
<div><pre><code>Sheet1<span>.</span>Range<span>(</span><span>"a1"</span><span>)</span><span>.</span>Resize<span>(</span><span>1</span><span>,</span> r<span>)</span> <span>=</span> Arr
</code></pre>
<div><span>1</span><br></div></div><p>如果需要将去除重复值的的文本还是以逗号作为分隔符写入到 <code>A1</code> 单元格中，可以将第 15 行代码改成下面的代码：</p>
<div><pre><code>Sheet1<span>.</span>Range<span>(</span><span>"a1"</span><span>)</span> <span>=</span> Join<span>(</span>Arr<span>,</span> <span>","</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>Join 函数返回一个字符串，该字符串是通过连接某个数组中的多个子字符串而创建的，语法如下：</p>
<div><pre><code>Join<span>(</span>sourcearray[<span>,</span> delimiter]<span>)</span>

参数sourcearray是必需的，包含被连接子字符串的一维数组。
参数delimiter是可选的，在返回字符串中用于分隔子字符串的字符，如果忽略则使用空格<span>(</span><span>" "</span><span>)</span>来分隔子字符串。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-07-02T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">VBA 之 文件操作</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Excel/14.VBA_fso/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Excel/14.VBA_fso/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="_170、导入文本文件"> 170、导入文本文件</h2>
<p>在实际应用中，我们经常从软件中将数据导出为文本文件，在需要将这些文本文件导入到 Excel 中时可以使用以下的方法。</p>
<h3 id="_1-使用查询表导入"> 1）使用查询表导入</h3>
<div><pre><code><span>Sub</span> AddQuery<span>(</span><span>)</span>
	Sheet1<span>.</span>UsedRange<span>.</span>ClearContents
	<span>With</span> Sheet1<span>.</span>QueryTables<span>.</span>Add<span>(</span> <span>_</span>
		Connection<span>:</span><span>=</span><span>"TEXT;"</span> <span>&amp;</span> ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\工资表.txt"</span><span>,</span> <span>_</span>
		Destination<span>:</span><span>=</span>Range<span>(</span><span>"A1"</span><span>)</span><span>)</span>
		<span>.</span>TextFilePlatform <span>=</span> <span>936</span>
		<span>.</span>TextFileCommaDelimiter <span>=</span> <span>True</span>
		<span>.</span>Refresh
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>代码解析：</p>
<p>AddQuery 过程使用 QueryTable 对象的 Add 方法新建查询表后将文本文件“工资表.txt”的内容导入到工作表中。</p>
<p>应用于 QueryTable 对象的 Add 方法新建一个查询表，返回 QueryTable 对象，该对象代表新建的查询表，语法如下：</p>
<div><pre><code>expression<span>.</span>Add<span>(</span>Connection<span>,</span> Destination<span>,</span> Sql<span>)</span>

参数expression是必需的，返回一个QueryTables对象。
参数Connection是必需的，查询表的数据源。如果数据源是文本文件，是<span>“TEXT;&lt;文本文件路径和名称>”</span>形式的字符串，其他数据源请参阅帮助。
参数Destination是必需的，Range类型，查询表目标区域左上角单元格用于放置生成的查询表的区域。目标区域必须在包含expression 指定的QueryTables对象的工作表上。
参数Sql是可选的，在ODBC数据源上运行的SQL查询字符串，当将QueryTable对象、文本文件、或是ADO或DAO Recordset对象指定为数据源时不能使用该参数。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>第 3 行到第 5 行代码在工作表中建立对位于同一目录中的“工资表.txt”文本文件的查询，并将查询结果放置到工作表中。</p>
<p>第 6 行代码设置导入的文本文件的原始格式，QueryTables 对象的 TextFilePlatform 属性返回或设置正向查询表中导入的文本文件的原始格式，默认值是在“文本导入向导”的“文件原始格式”选项中的当前设置。</p>
<p>第 7 行代码设置文本文件导入查询表中时，是以逗号作为分隔符。</p>
<p>第 8 行代码使用 Refresh 方法更新外部数据区域，应用于 QueryTable 对象的 Refresh 方法更新外部数据区域，语法如下：</p>
<div><pre><code>expression<span>.</span>Refresh<span>(</span>BackgroundQuery<span>)</span>

参数expression是必需的，返回一个QueryTable对象。
参数BackgroundQuery是可选的的，只用于基于SQL查询结果的QueryTable。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="_2-使用-open-语句导入"> 2）使用 Open 语句导入</h3>
<p>使用 Open 语句输入文本文件，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> OpenText<span>(</span><span>)</span>
	<span>Dim</span> Filename <span>As</span> <span>String</span>
	<span>Dim</span> myText <span>As</span> <span>String</span>
	<span>Dim</span> mArr<span>(</span><span>)</span> <span>As</span> <span>String</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>Dim</span> j <span>As</span> <span>Integer</span>
	Filename <span>=</span> ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\工资表.txt"</span>
	j <span>=</span> <span>1</span>
	Sheet1<span>.</span>UsedRange<span>.</span>ClearContents
	Open Filename <span>For</span> Input <span>As</span> <span>1</span>
	<span>Do</span> <span>While</span> <span>Not</span> EOF<span>(</span><span>1</span><span>)</span>
		Line Input <span>1</span><span>,</span> myText
		mArr <span>=</span> Split<span>(</span>myText<span>,</span> <span>","</span><span>)</span>
		<span>For</span> i <span>=</span> <span>0</span> <span>To</span> UBound<span>(</span>mArr<span>)</span>
			Sheet1<span>.</span>Cells<span>(</span>j<span>,</span> i <span>+</span> <span>1</span><span>)</span> <span>=</span> mArr<span>(</span>i<span>)</span>
		<span>Next</span>
		j <span>=</span> j <span>+</span> <span>1</span>
	<span>Loop</span>
	Close <span>1</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>代码解析：</p>
<p>OpenText 过程使用 Open 语句将文本“工资表.txt”的内容输入到工作表中。</p>
<p>第 10 行代码使用 Open 语句打开文本文件以完成对文本文件的输入。Open 语句能够对文件输入/输出（I/O），语法如下：。</p>
<div><pre><code>Open pathname For mode [Access access] [lock] As [#]filenumber [Len=reclength]

Pathname是必需的，指定文件名，该文件名可能还包括目录、文件夹及驱动器。
mode是必需的，指定文件方式，有Append、Binary、Input、Output、或Random方式。如果未指定方式，则以Random访问方式打开文件。
Access是可选的，说明打开的文件可以进行的操作，有Read、Write、或Read Write操作。
lock是可选的，说明限定于其它进程打开的文件的操作，有Shared、Lock Read、Lock Write、和Lock Read Write操作。
filenumber是必需的，一个有效的文件号，范围在 1 到 511 之间。使用FreeFile函数可得到下一个可用的文件号。
reclength是可选的，小于或等于 32，767（字节）的一个数。对于用随机访问方式打开的文件，该值就是记录长度。对于顺序文件，该值就是缓冲字符数。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>第 11 行代码使用 Do...Loop 语句重复执行第 12 行到第 17 行代码，直到文本文件的结尾。EOF 函数返回一个 Integer，它返回 Boolean 值 True，表明已经到达为 Random 或顺序 Input 打开的文件结尾，语法如下：</p>
<div><pre><code>EOF<span>(</span>filenumber<span>)</span>

参数filenumber是必需的，是一个<span>Integer</span>，包含任何有效的文件号。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>第 12 行代码使用 Line Input # 语句读入一行数据并将其赋予变量 myText。Line Input # 语句从已打开的顺序文件中读出一行并将它分配给 String 变量，语法如下：</p>
<div><pre><code>Line Input <span>#</span>filenumber<span>,</span> varname

Filenumber是必需的，任何有效的文件号。
varnamer是必需的，有效的<span>Variant</span>或<span>String</span>变量名。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第 13 行代码使用 Split 函数按逗号作为分隔符分开这行字符，赋值数组 mArr。关于 Split 函数请参阅 169-2。</p>
<p>第 14 行到第 16 行代码将数组 mArr 循环赋值给单元格，请参阅 169-1。</p>
<p>第 19 行代码关闭文本文件。Close 语句关闭 Open 语句所打开的输入/输出 (I/O) 文件，语法如下：</p>
<div><pre><code>Close [filenumberlist]

参数filenumberlist是可选的，为一个或多个文件号，如省略则将关闭所有由Open语句打开的活动文件。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="_3-使用-opentext-方法"> 3）使用 OpenText 方法</h3>
<p>使用 OpenText 方法载入一个文本文件并将其作为包含单个工作表的工作簿处理，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> OpenText<span>(</span><span>)</span>
	<span>Dim</span> myFileName <span>As</span> <span>String</span>
	myFileName <span>=</span> <span>"工资表.txt"</span>
	Sheet1<span>.</span>UsedRange<span>.</span>ClearContents
	Workbooks<span>.</span>OpenText <span>_</span>
		Filename<span>:</span><span>=</span>ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\"</span> <span>&amp;</span> myFileName<span>,</span> <span>_</span>
		StartRow<span>:</span><span>=</span><span>1</span><span>,</span> DataType<span>:</span><span>=</span>xlDelimited<span>,</span> Comma<span>:</span><span>=</span><span>True</span>
	<span>With</span> ActiveWorkbook
		<span>With</span> <span>.</span>Sheets<span>(</span><span>"工资表"</span><span>)</span><span>.</span>Range<span>(</span><span>"A1"</span><span>)</span><span>.</span>CurrentRegion
			ThisWorkbook<span>.</span>Sheets<span>(</span><span>"Sheet1"</span><span>)</span><span>.</span>Range<span>(</span><span>"A1"</span><span>)</span><span>.</span>Resize<span>(</span><span>.</span>Rows<span>.</span>Count<span>,</span> <span>.</span>Columns<span>.</span>Count<span>)</span><span>.</span>Value <span>=</span> <span>.</span>Value
		<span>End</span> <span>With</span>
		<span>.</span>Close <span>False</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>代码解析：</p>
<p>OpenText 过程使用 OpenText 方法载入“工资表.txt”文本文件并将其数据写入到工作表中。</p>
<p>第 5 行到第 7 行代码使用 OpenText 方法载入“工资表.txt”文本文件。OpenText 方法载入一个文本文件，并将其作为包含单个工作表的工作簿进行分列处理，然后在此工作表中放入经过分列处理的文本文件数据，语法如下：</p>
<div><pre><code>expression<span>.</span>OpenText<span>(</span>FileName<span>,</span> Origin<span>,</span> StartRow<span>,</span> DataType<span>,</span> TextQualifier<span>,</span> ConsecutiveDelimiter<span>,</span> Tab<span>,</span> Semicolon<span>,</span> Comma<span>,</span> Space<span>,</span> Other<span>,</span> OtherChar<span>,</span> FieldInfo<span>,</span> TextVisualLayout<span>,</span> DecimalSeparator<span>,</span> ThousandsSeparator<span>,</span> TrailingMinusNumbers<span>,</span> Local<span>)</span>

其中参数FileName是必需的，指定要载入并作分列处理的文件名称。
参数StartRow是可选的，作分列处理的起始行号，默认值为 <span>1</span>。
参数DataType是可选的，在文件中指定数据的列格式。
参数Comma是可选的，如果该值为<span>True</span>，则将分隔符设为逗号。
其他参数请参阅VBA中的帮助文档。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>第 9 行到第 11 行代码将作为工作表打开的文本文件中的数据写入到工作表中。</p>
<p>第 13 行代码使用 Close 方法关闭打开的文本文件。</p>
<h2 id="_171、将数据写入文本文件"> 171、将数据写入文本文件</h2>
<p>在需要时可以将 Excel 中的数据写入到文本文件中，有以下方法可以实现。</p>
<h3 id="_1-使用-print-语句"> 1）使用 Print # 语句</h3>
<p>使用 Print # 语句将数据写入文本文件中，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> PrintText<span>(</span><span>)</span>
	<span>Dim</span> myFileName <span>As</span> <span>String</span>
	<span>Dim</span> myDataAr<span>(</span><span>)</span> <span>As</span> <span>Variant</span>
	<span>Dim</span> myStr <span>As</span> <span>String</span>
	<span>Dim</span> myRow <span>As</span> <span>Integer</span>
	<span>Dim</span> myCol <span>As</span> <span>Integer</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>Dim</span> j <span>As</span> <span>Integer</span>
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	myFileName <span>=</span> <span>"工资表.txt"</span>
	Kill ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\"</span> <span>&amp;</span> myFileName
	<span>With</span> Sheet1
		myRow <span>=</span> <span>.</span>Range<span>(</span><span>"A65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row
		myCol <span>=</span> <span>.</span>Range<span>(</span><span>"IV1"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlToLeft<span>)</span><span>.</span>Column
		<span>ReDim</span> myDataAr<span>(</span><span>1</span> <span>To</span> myRow<span>,</span> <span>1</span> <span>To</span> myCol<span>)</span>
		<span>For</span> i <span>=</span> <span>1</span> <span>To</span> myRow
			<span>For</span> j <span>=</span> <span>1</span> <span>To</span> myCol
				myDataAr<span>(</span>i<span>,</span> j<span>)</span> <span>=</span> <span>.</span>Cells<span>(</span>i<span>,</span> j<span>)</span><span>.</span>Value
			<span>Next</span>
		<span>Next</span>
		Open ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\"</span> <span>&amp;</span> myFileName <span>For</span> Output <span>As</span> <span>1</span>
		<span>For</span> i <span>=</span> <span>1</span> <span>To</span> UBound<span>(</span>myDataAr<span>,</span> <span>1</span><span>)</span>
			myStr <span>=</span> <span>""</span>
			<span>For</span> j <span>=</span> <span>1</span> <span>To</span> UBound<span>(</span>myDataAr<span>,</span> <span>2</span><span>)</span>
				myStr <span>=</span> myStr <span>&amp;</span> <span>CStr</span><span>(</span>myDataAr<span>(</span>i<span>,</span> j<span>)</span><span>)</span> <span>&amp;</span> <span>","</span>
			<span>Next</span>
			myStr <span>=</span> Left<span>(</span>myStr<span>,</span> <span>(</span>Len<span>(</span>myStr<span>)</span> <span>-</span> <span>1</span><span>)</span><span>)</span>
			Print <span>1</span><span>,</span> myStr
		<span>Next</span>
		Close <span>1</span>
	<span>End</span> <span>With</span>
	MsgBox <span>"文件保存成功!"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>代码解析：</p>
<p>PrintText 过程将工作表中数据写入到文本文件“工资表.txt”中。</p>
<p>第 11 行代码使用 Kill 方法删除同一目录中可能存在的同名文本文件。</p>
<p>第 13、14 行使用单元格的 End 属性取得工作表中已使用数据的行、列号，关于 End 属性请参阅 3 。</p>
<p>第 15 行代码重新定义动态数组 myDataAr 的大小。关于动态数组请参阅技巧169-3。</p>
<p>第 16 行到第 20 行代码将工作表数据赋给数组 myDataAr。</p>
<p>第 21 行代码使用 Open 语句打开文本文件以完成对文本文件的输入。关于 Open 语句请参阅 170-2。</p>
<p>第 22 行到第 29 行代码使用 Print # 语句将数组 myDataAr中的所有元素写入到文本文件中。Print # 语句将格式化显示的数据写入顺序文件中，语法如下：</p>
<div><pre><code>Print <span>#</span>filenumber<span>,</span> [outputlist]

Filenumber是必需的，任何有效的文件号。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>第 30 行代码 Close 语句关闭文本文件。</p>
<h3 id="_2-另存为文本文件"> 2）另存为文本文件</h3>
<p>使用 SaveAs 方法将工作表另存为文本文件，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> SaveText<span>(</span><span>)</span>
	<span>Dim</span> myFileName <span>As</span> <span>String</span>
	myFileName <span>=</span> <span>"工资表.txt"</span>
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	Kill ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\"</span> <span>&amp;</span> myFileName
	Application<span>.</span>ScreenUpdating <span>=</span> <span>False</span>
	Worksheets<span>(</span><span>"Sheet1"</span><span>)</span><span>.</span>Copy
	ActiveWorkbook<span>.</span>SaveAs Filename<span>:</span><span>=</span>ThisWorkbook<span>.</span>Path <span>_</span>
		<span>&amp;</span> <span>"\"</span> <span>&amp;</span> myFileName<span>,</span> <span>_</span>
		FileFormat<span>:</span><span>=</span>xlCSV
	MsgBox <span>"文件保存成功!"</span>
	ActiveWorkbook<span>.</span>Close SaveChanges<span>:</span><span>=</span><span>False</span>
	Application<span>.</span>ScreenUpdating <span>=</span> <span>True</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>代码解析：</p>
<p>SaveText 过程将工作表“Sheet1”保存为文本文件。</p>
<p>第 4、5 行代码使用 Kill 方法删除同一目录中可能存在的同名文本文件。</p>
<p>第 7 行代码使用 Copy 方法复制工作表“Sheet1”。</p>
<p>第 8 行到第 10 行代码使用 SaveAs 方法将文件保存为文本文件。应用于 Workbook 对象的 SaveAs 方法保存对不同文件中的工作表的更改，语法如下：</p>
<div><pre><code>expression<span>.</span>SaveAs<span>(</span>FileName<span>,</span> FileFormat<span>,</span> Password<span>,</span> WriteResPassword<span>,</span> ReadOnlyRecommended<span>,</span> CreateBackup<span>,</span> AccessMode<span>,</span> ConflictResolution<span>,</span> AddToMru<span>,</span> TextCodepage<span>,</span> TextVisualLayout<span>,</span> Local<span>)</span>

其中参数Filename表示要保存的文件名。可包含完整路径。如果不指定路径，Microsoft Excel 将文件保存到当前文件夹中。
其中参数FileFormat指定保存文件时使用的文件格式，在本例中指定为xlCSV即保存为文本文件。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第 12 行代码使用 Close 方法关闭活动工作簿。</p>
<h2 id="_172、文件修改的日期和时间"> 172、文件修改的日期和时间</h2>
<p>在 VBA 过程中如果需要获得文件最后修改的日期和时间，可以使用 FileDateTime 函数，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> myDateTime<span>(</span><span>)</span>
	<span>Dim</span> Stmp <span>As</span> <span>String</span>
	<span>Dim</span> myDateTime <span>As</span> <span>Date</span>
	Stmp <span>=</span> ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\"</span> <span>&amp;</span> ThisWorkbook<span>.</span>Name
	myDateTime <span>=</span> FileDateTime<span>(</span>Stmp<span>)</span>
	MsgBox Stmp <span>&amp;</span> <span>"最后修改时间是："</span> <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>&amp;</span> myDateTime
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>myDateTime 过程使用消息框显示文件最后修改的日期和时间。</p>
<p>FileDateTime 函数返回一个文件被创建或最后修改后的日期和时间，语法如下：</p>
<div><pre><code>FileDateTime<span>(</span>pathname<span>)</span>

pathname 参数是必需的，用来指定文件名的字符串表达式。pathname 可以包含目录或文件夹、以及驱动器。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>第 4 行代码使用变量 Stmp 保存代码所在工作簿的路径和名称。</p>
<p>第 5 行代码使用变量 myDateTime 保存 FileDateTime 函数返回的日期和时间。</p>
<p>运行 myDateTime 过程结果如图 172-1 所示。</p>
<div>
<p><img src="./assets/172-1.png" alt="" loading="lazy"></p>
<p><u>图 172-1</u>	文件最后修改的日期和时间</p>
</div>
<h2 id="_173、查找文件或文件夹"> 173、查找文件或文件夹</h2>
<p>在磁盘中查找文件或文件夹，可以使用 Dir 函数，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> mydir<span>(</span><span>)</span>
	<span>Dim</span> mydir <span>As</span> <span>String</span>
	<span>Dim</span> b <span>As</span> <span>Byte</span>
	b <span>=</span> <span>1</span>
	Range<span>(</span><span>"A:A"</span><span>)</span><span>.</span>ClearContents
	mydir <span>=</span> Dir<span>(</span>ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\*.xls"</span><span>,</span> vbNormal<span>)</span>
	<span>Do</span> <span>While</span> mydir <span>&lt;</span><span>></span> <span>""</span>
		Cells<span>(</span>b<span>,</span> <span>1</span><span>)</span> <span>=</span> mydir
		mydir <span>=</span> Dir
		b <span>=</span> b <span>+</span> <span>1</span>
	<span>Loop</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>代码解析：</p>
<p>Mydir 过程使用 Dir 函数在代码所在工作簿的文件夹中查找所有的 Excel 文件，找到后写入到工作表的 A 列单元格中。</p>
<p>第 2 行代码声明变量 mydir 保存返回的文件名称。</p>
<p>第 3 行代码声明变量 b 保存返回的文件数目。</p>
<p>第 4 行代码设置变量 b 的初始值。</p>
<p>第 5 行代码清除 A 列所有数据。</p>
<p>第 6 行代码使用 Dir 函数在代码所在工作簿的文件夹中查找 Excel 文件。Dir 函数返回一个 String，用以表示一个文件名、目录名或文件夹名称，语法如下：</p>
<div><pre><code>Dir[<span>(</span>pathname[<span>,</span> attributes]<span>)</span>]

参数pathname是可选的，用来指定文件名的字符串表达式，可能包含目录或文件夹、以及驱动器。如果没有找到pathname，则会返回零长度字符串 <span>(</span><span>""</span><span>)</span>。
参数attributes是可选的，常数或数值表达式，其总和用来指定文件属性，如表格 <span>173</span><span>1</span>所示。如果省略，则会返回不包含属性的匹配文件。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><u>表格 173-1</u>	attributes设置值</p>
<table>
<thead>
<tr>
<th>常数</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>vbNormal</td>
<td>0</td>
<td>(缺省) 指定没有属性的文件。</td>
</tr>
<tr>
<td>vbReadOnly</td>
<td>1</td>
<td>指定无属性的只读文件。</td>
</tr>
<tr>
<td>vbHidden</td>
<td>2</td>
<td>指定无属性的隐藏文件。</td>
</tr>
<tr>
<td>VbSystem</td>
<td>4</td>
<td>指定无属性的系统文件，在Macintosh中不可用。</td>
</tr>
<tr>
<td>vbVolume</td>
<td>8</td>
<td>指定卷标文件；如果指定了其它属性，则忽略。vbVolume 在Macintosh中不可用。</td>
</tr>
<tr>
<td>vbDirectory</td>
<td>16</td>
<td>指定无属性文件及其路径和文件夹。</td>
</tr>
<tr>
<td>vbAlias</td>
<td>64</td>
<td>指定的文件名是别名，只在Macintosh上可用。</td>
</tr>
</tbody>
</table>
<div><p>注意</p>
<p>在第一次调用 Dir 函数时，必须指定 pathname，否则会产生错误。</p>
</div>
<p>第 7 行到第 11 行代码将返回的文件名称写入到 A 列单元格中。Dir 函数会返回匹配 pathname 参数的第一个文件名，若想得到其他匹配 pathname 参数的文件名，需再一次调用 Dir 函数，且不要使用参数。如果已没有合乎条件的文件，则 Dir 函数会返回一个零长度字符串 (&quot;&quot;)。</p>
<p>运行 Mydir 过程工作表中如图 173-1 所示。</p>
<div>
<p><img src="./assets/173-1.png" alt="" loading="lazy"></p>
<p><u>图 173-1</u>	使用 Dir 函数返回文件名称</p>
</div>
<h2 id="_174、获得当前文件夹的名称"> 174、获得当前文件夹的名称</h2>
<p>在处理文件时经常需要获得当前文件夹的名称，此时可以使用 CurDir 函数，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> CurFolder<span>(</span><span>)</span>
	MsgBox CurDir<span>(</span><span>"F"</span><span>)</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>CurFolder 过程使用消息框显示F盘中的当前文件夹名称。</p>
<p>CurDir 函数返回一个 Variant 类型的文件路径。如果需要返回字符串类型的文件路径则使用 CurDir$，语法如下：</p>
<div><pre><code>CurDir[<span>(</span>drive<span>)</span>]

参数drive是可选的，字符串表达式，指定一个存在的驱动器。如果没有指定驱动器，或参数drive 是零长度字符串 <span>(</span><span>""</span><span>)</span>，则CurDir函数会返回当前驱动器的路径。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>假设示例文件保存在 F 盘的“VBA常用技巧\示例文件\第10章 文件操作”文件夹中，运行 CurFolder 过程结果如图 174-1 所示。</p>
<div>
<p><img src="./assets/174-1.png" alt="" loading="lazy"></p>
<p><u>图 174-1</u>	获得当前文件夹的名称</p>
</div>
<h2 id="_175、创建和删除文件夹"> 175、创建和删除文件夹</h2>
<p>可以在程序运行时创建和删除文件夹，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> TempFolder<span>(</span><span>)</span>
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	MkDir ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\Temp"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>代码解析：</p>
<p>TempFolder 过程使用 MkDir 语句在示例所在的文件夹中创建“Temp”文件夹。MkDir 语句创建一个新的目录或文件夹，语法如下：</p>
<div><pre><code>MkDir path

参数path是必需的，指定所要创建的目录或文件夹的字符串表达式，可以包含驱动器。如果没有指定驱动器，则在当前驱动器上创建新的目录或文件夹。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>第 2 行代码启动错误处理程序，因为在创建过程中如果文件夹中已存在相同名称的“Temp”文件夹会发生 “路径未找到”错误，所以使用 On Error Resume Next 语句忽略错误。</p>
<p>第 3 行代码使用 MkDir 语句创建“Temp”文件夹。</p>
<p>如果需要删除不需要的文件夹可以使用 RmDir 语句，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> RmFolder<span>(</span><span>)</span>
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	RmDir ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\Temp"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>代码解析：</p>
<p>RmFolder 过程使用 RmDir 语句删除在示例所在的文件夹中创建“Temp”文件夹。RmDir 语句删除一个存在的目录或文件夹，语法如下：</p>
<div><pre><code>RmDir path

参数path是必需的，指定所要创建的目录或文件夹的字符串表达式，可以包含驱动器。如果没有指定驱动器，则在当前驱动器上创建新的目录或文件夹。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>第 2 行代码启动错误处理程序，因为在使用 RmDir 语句删除并不存在的文件夹或删除含有文件的文件夹时会发生 “路径未找到”错误，所以使用 On Error Resume Next 语句忽略错误。</p>
<p>第 3 行代码使用 RmDir 语句删除“Temp”文件夹。如果“Temp”文件夹中含有文件可以在删除文件夹之前，先使用 Kill 语句来删除所有文件，请参阅 178 。</p>
<h2 id="_176、重命名文件或文件夹"> 176、重命名文件或文件夹</h2>
<p>使用 Name 语句可以重命名文件或文件夹，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> Filename<span>(</span><span>)</span>
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	Name ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\123"</span> <span>As</span> ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\ABC"</span>
	Name ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\123.xls"</span> <span>As</span> ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\ABC\ABC.xls"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>Filename 过程使用 Name 语句重命名示例文件所在文件夹中的“123”文件夹和“123.xls” Excel 文件并将重命名后的 Excel 文件移动到重命名后的文件夹中。</p>
<p>Name 语句重新命名一个文件、目录、或文件夹，语法如下：</p>
<div><pre><code>Name oldpathname <span>As</span> newpathname

参数oldpathname是必需的，字符串表达式，指定已存在的文件名和位置，可以包含目录或文件夹、以及驱动器。
参数newpathname是必需的，字符串表达式，指定新的文件名和位置，可以包含目录或文件夹、以及驱动器。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第 2 行代码启动错误处理程序，因为在重命名过程中如果参数 oldpathname 指定的文件或文件夹不存在会发生 “文件未找到”错误，所以使用 On Error Resume Next 语句忽略错误。</p>
<p>第 3 行代码使用 Name 语句将示例文件所在文件夹中的“123”文件夹重命名为“ABC”文件夹。</p>
<p>第 4 行代码使用 Name 语句将示例文件所在文件夹中的“123.xls”Excel文件重命名为“ABC.xls”文件并移动到“ABC”文件夹中。</p>
<p>在运行 Filename 过程前请确认示例文件所在文件夹中包含一个“123”文件夹和一个“123.xls” Excel 文件。</p>
<h2 id="_177、复制指定的文件"> 177、复制指定的文件</h2>
<p>如果需要把文件从一个地方复制到另一个地方，可以使用 FileCopy 语句复制文件，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> CopyFile<span>(</span><span>)</span>
	<span>Dim</span> SourceFile <span>As</span> <span>String</span>
	<span>Dim</span> DestinationFile <span>As</span> <span>String</span>
	SourceFile <span>=</span> ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\123.xls"</span>
	DestinationFile <span>=</span> ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\ABC\abc.xls"</span>
	FileCopy SourceFile<span>,</span> DestinationFile
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>CopyFile 过程使用 FileCopy 语句将示例文件所在文件夹中的“123.xls”Excel文件复制到示例文件目录下的“ABC”文件夹中并重新命名为“abc.xls”。</p>
<p>FileCopy 语句复制一个文件，语法如下：</p>
<div><pre><code>FileCopy source<span>,</span> destination

Source参数是必需的，字符串表达式，用来表示要被复制的文件名。source参数可以包含目录或文件夹、以及驱动器。
destination参数是必需的，字符串表达式，用来指定要复制的目地文件名。destination参数 可以包含目录或文件夹、以及驱动器。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><p>注意</p>
<p>不能对一个已打开的文件使用 FileCopy 语句，否则会产生错误。</p>
</div>
<p>第 4 行代码指定被复制的文件名称和路径。</p>
<p>第 5 行代码指定目的文件名称和路径，如果已存在相同名称的文件则会覆盖原文件。</p>
<p>第 6 行代码使用 FileCopy 语句复制文件。</p>
<h2 id="_178、删除指定的文件"> 178、删除指定的文件</h2>
<p>使用 Kill 方法删除指定的文件，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> KillFile<span>(</span><span>)</span>
	<span>Dim</span> myFile <span>As</span> <span>String</span>
	myFile <span>=</span> ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\123.xls"</span>
	<span>If</span> Dir<span>(</span>myFile<span>)</span> <span>&lt;</span><span>></span> <span>""</span> <span>Then</span> Kill myFile
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>代码解析：</p>
<p>KillFile 过程使用 Kill 方法示例文件所在文件夹中的“123.xls”文件。</p>
<p>第 3 行代码指定所要删除文件的路径和文件名称。</p>
<p>第 4 行代码使用 Dir 函数返回指定文件名，（关于 Dir 函数请参阅 173 ）如果存在该文件则使用 Kill 语句删除。Kill 语句从磁盘中删除文件，语法如下：</p>
<div><pre><code>Kill pathname

参数pathname是必需的，用来指定一个文件名的字符串表达式，可以包含目录或文件夹、以及驱动器。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>在 Microsoft Windows 中，Kill 方法支持多字符 (*) 和单字符 (?) 的统配符来指定多重文件，如需要删除当前目录下所有 *. Xls 文件可以使用下面的代码：</p>
<div><pre><code>Kill <span>"*.xls"</span>
</code></pre>
<div><span>1</span><br></div></div><div><p>注意</p>
<p>使用 Kill 方法不能删除已打开的文件，否则会产生错误。</p>
</div>
<h2 id="_179、搜索特定的文件"> 179、搜索特定的文件</h2>
<p>如果需要对文件夹中所有的 Excel 文件进行相同的操作，那么可以使用 Execute 方法进行文件搜索，示例代码如下所示。</p>
<div><pre><code><span>Sub</span> Sort<span>(</span><span>)</span>
	<span>Dim</span> i <span>As</span> <span>Byte</span>
	Application<span>.</span>ScreenUpdating <span>=</span> <span>False</span>
	<span>With</span> Application<span>.</span>FileSearch
		<span>.</span>LookIn <span>=</span> ThisWorkbook<span>.</span>Path
		<span>.</span>FileType <span>=</span> msoFileTypeExcelWorkbooks
		<span>If</span> <span>.</span>Execute <span>></span> <span>0</span> <span>Then</span>
			<span>For</span> i <span>=</span> <span>1</span> <span>To</span> <span>.</span>FoundFiles<span>.</span>Count
				<span>If</span> <span>.</span>FoundFiles<span>(</span>i<span>)</span> <span>&lt;</span><span>></span> ThisWorkbook<span>.</span>FullName <span>Then</span>
					Workbooks<span>.</span>Open <span>.</span>FoundFiles<span>(</span>i<span>)</span>
					<span>With</span> ActiveWorkbook
						<span>.</span>Sheets<span>(</span><span>"Sheet1"</span><span>)</span><span>.</span>Range<span>(</span><span>"A1"</span><span>)</span> <span>=</span> <span>"最后打开时间："</span> <span>&amp;</span> Now
						<span>.</span>Close <span>True</span>
					<span>End</span> <span>With</span>
				<span>End</span> <span>If</span>
			<span>Next</span>
		<span>End</span> <span>If</span>
	<span>End</span> <span>With</span>
	Application<span>.</span>ScreenUpdating <span>=</span> <span>True</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>代码解析：</p>
<p>Sort 过程搜索同一目录中的所有 Excel 文件并对其进行操作。</p>
<p>第 3 行代码关闭屏幕更新功能，加快代码的运行速度。</p>
<p>第 4 行代码为文件搜索创建一个 FoundFiles 对象。</p>
<p>第 5 行代码设置要搜索的文件夹，应用于 FoundFiles 对象的 LookIn 属性返回或设置在指定的文件搜索过程中要搜索的文件夹。</p>
<p>第 6 行代码设置搜索的文件类型为 Excel 文件，应用于 FoundFiles 对象的 FileType 属性返回或设置文件搜索过程中要查找的文件类型，设置为 msoFileTypeExcelWorkbooks 返回 Excel 文件。</p>
<p>第 7 行代码开始对指定文件进行搜索，应用于 FoundFiles 对象的 Execute 方法用于搜索文件，语法如下：</p>
<div><pre><code>expression<span>.</span>Execute<span>(</span>SortBy<span>,</span> SortOrder<span>,</span> AlwaysAccurate<span>)</span>

参数expression是必需的，返回一个FoundFiles对象。
参数SortBy是可选的，用于对返回的文件进行排序。
参数SortOrder是可选的，表明所返回文件的排序顺序。
参数AlwaysAccurate是可选的，设置为<span>True</span>使文件搜索包括上次更新文件索引以来添加、修改或删除的文件。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>在使用 Execute 方法搜索文件时，如果没有找到文件，则返回零 (0)，如果找到一个或多个文件，则返回一个正数。</p>
<p>第 8 行代码使用 For...Next 语句遍历 Execute 方法返回的返回的文件列表。应用于FoundFiles对象的 FoundFiles 属性返回一个 FoundFiles 对象，代表由文件搜索过程中返回的文件列表。</p>
<p>第 9 行代码判断返回的单个 FoundFiles 对象的名称是否是示例文件的名称，如果否则执行后续代码。</p>
<p>第 10 行代码使用应用于 Workbooks 对象的 Open 方法打开由返回的单个 FoundFiles 对象代表的工作簿。</p>
<p>第 11 行到第 14 行代码在打开的活动工作簿的工作表中写入打开时间后保存、关闭活动工作簿。</p>
<p>运行 Sort 过程将打开示例所在文件夹中所有的 Excel 文件并对其进行相应的操作。</p>
<h2 id="_180、使用-wsh-处理文件"> 180、使用 WSH 处理文件</h2>
<p>Windows Scripting Hos（WSH）可以创建一些控制 Windows 操作系统和应用程序以及从操作系统中获取信息的小程序，而使用 WSH 的 FileSystemObject 对象可以用来处理文件系统。</p>
<p>在使用 WSH 处理文件时，必需使用 CreateObject 函数创建一个 ActiveX 对象（FileSystemObject 对象），用来提供访问计算机的文件系统，如下面的代码所示：</p>
<div><pre><code><span>Dim</span> MyFile <span>As</span> <span>Object</span>
<span>Set</span> MyFile <span>=</span> CreateObject<span>(</span><span>"Scripting.FileSystemObject"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面的代码首先声明一个名为 MyFile 的对象变量，然后使用 CreateObject 函数创建一个 ActiveX 对象并将该对象赋给对象变量。</p>
<p>CreateObject 函数创建并返回一个对 ActiveX 对象的引用，语法如下：</p>
<div><pre><code>CreateObject<span>(</span><span>class</span><span>,</span>[servername]<span>)</span>

其中参数<span>class</span>是必需的，要创建的应用程序名称和类，使用appname<span>.</span>objecttype这种语法，appname指定该对象的应用程序名称，objecttype指定该对象的类型或类。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>在声明了对象变量 MyFile 为 Windows Scripting 库的 FileSystemObject 对象后就能使用该对象的属性、方法来处理文件系统。</p>
<h3 id="_1-获取文件信息"> 1）获取文件信息</h3>
<p>如果需要获得指定文件的信息，可以使用 File 对象的 Getfile 方法，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> Fileinfo<span>(</span><span>)</span>
	<span>Dim</span> MyFile <span>As</span> <span>Object</span>
	<span>Dim</span> Str <span>As</span> <span>String</span>
	<span>Dim</span> StrMsg <span>As</span> <span>String</span>
	Str <span>=</span> ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\123.xls"</span>
	<span>Set</span> MyFile <span>=</span> CreateObject<span>(</span><span>"Scripting.FileSystemObject"</span><span>)</span>
	<span>With</span> MyFile<span>.</span>Getfile<span>(</span>Str<span>)</span>
		StrMsg <span>=</span> StrMsg <span>&amp;</span> <span>"文件名称："</span> <span>&amp;</span> <span>.</span>Name <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>_</span>
			<span>&amp;</span> <span>"文件创建日期："</span> <span>&amp;</span> <span>.</span>DateCreated <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>_</span>
			<span>&amp;</span> <span>"文件修改日期："</span> <span>&amp;</span> <span>.</span>DateLastModified <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>_</span>
			<span>&amp;</span> <span>"文件访问日期："</span> <span>&amp;</span> <span>.</span>DateLastAccessed <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>_</span>
			<span>&amp;</span> <span>"文件保存路径："</span> <span>&amp;</span> <span>.</span>ParentFolder
	<span>End</span> <span>With</span>
	MsgBox StrMsg
	<span>Set</span> MyFile <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>代码解析：</p>
<p>Fileinfo 过程使用 Getfile 方法获取示例所在文件夹中的“123.xls”文件的信息。</p>
<p>第 5 行代码将文件路径名称赋给变量 Str。</p>
<p>第 6 行代码使用 CreateObject 函数创建 FileSystemObject 对象并将该对象赋给变量 MyFile。</p>
<p>第 7 行代码使用 Getfile 方法返回一个 File 对象。Getfile 方法返回一个和指定路径中文件相对应的 File 对象，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>GetFile<span>(</span>filespec<span>)</span>

参数<span>object</span>是必需的，FileSystemObject对象的名称。
参数filespec是必需的，指定文件的路径。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第 8 行到第 12 行代码根据 File 对象的属性取得文件信息，File 对象的常用属性如表格 180-1 所示。</p>
<p><u>表格 180-1</u>	File 对象的常用属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Name</td>
<td>文件名称</td>
</tr>
<tr>
<td>DateCreated</td>
<td>文件创建日期</td>
</tr>
<tr>
<td>DateLastModified</td>
<td>文件最后修改日期</td>
</tr>
<tr>
<td>DateLastAccessed</td>
<td>文件最后访问日期</td>
</tr>
<tr>
<td>ParentFolder</td>
<td>文件的父文件夹</td>
</tr>
<tr>
<td>Path</td>
<td>文件的完整路径</td>
</tr>
<tr>
<td>Type</td>
<td>文件类型</td>
</tr>
<tr>
<td>Size</td>
<td>以字节表示的文件大小</td>
</tr>
</tbody>
</table>
<p>运行 Fileinfo 过程使用消息框显示“123.xls”文件的信息，如图 180-1 所示。</p>
<div>
<p><img src="./assets/180-1.png" alt="" loading="lazy"></p>
<p><u>图 180-1</u>	获取文件信息</p>
</div>
<h3 id="_2-查找文件"> 2）查找文件</h3>
<p>使用 FileSystemObject 对象的 FileExists 方法可以查找指定的文件，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> FileExis<span>(</span><span>)</span>
	<span>Dim</span> MyFile <span>As</span> <span>Object</span>
	<span>Dim</span> Str <span>As</span> <span>String</span>
	<span>Dim</span> StrMsg <span>As</span> <span>String</span>
	Str <span>=</span> ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\123.xls"</span>
	<span>Set</span> MyFile <span>=</span> CreateObject<span>(</span><span>"Scripting.FileSystemObject"</span><span>)</span>
	<span>If</span> MyFile<span>.</span>FileExists<span>(</span>Str<span>)</span> <span>Then</span>
		MsgBox <span>"文件已找到!"</span>
	<span>Else</span>
		MsgBox <span>"文件不存在!"</span>
	<span>End</span> <span>If</span>
	<span>Set</span> MyFile <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>代码解析：</p>
<p>FileExis 过程使用 FileExists 方法查找示例所在文件夹中是否存在“123.xls”文件。</p>
<p>第 6 行代码使用 CreateObject 函数创建 FileSystemObject 对象并将该对象赋给变量 MyFile。</p>
<p>第 7 行代码使用 FileExists 方法可以查找文件。应用于 FileSystemObject 对象的 FileExists 方法查找指定的文件，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>FileExists<span>(</span>filespec<span>)</span>

参数<span>object</span>是必需的，FileSystemObject对象的名称。
参数filespec是必需的，要确定是否存在的文件的名字。如果文件不在当前文件夹中，必须提供一个完整的路径说明。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>使用 FileExists 方法查找文件时如果指定的文件存在，返回 True，若不存在，则返回 False，根据返回值可以确定所要查找的文件是否存在。</p>
<h3 id="_3-移动文件"> 3）移动文件</h3>
<p>如果需要把文件从一个地方移动到另一个地方，可以使用 FileSystemObject 对象的 MoveFile 方法，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> MoveFile<span>(</span><span>)</span>
	<span>Dim</span> MyFile <span>As</span> <span>Object</span>
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	<span>Set</span> MyFile <span>=</span> CreateObject<span>(</span><span>"Scripting.FileSystemObject"</span><span>)</span>
	MyFile<span>.</span>MoveFile ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\123.xls"</span><span>,</span> ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\ABC\"</span>
	<span>Set</span> MyFile <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>MoveFile 过程使用 MoveFile 方法将示例文件所在文件夹中的“123.xls”文件移动到“ABC”文件夹中。</p>
<p>第 4 行代码使用 CreateObject 函数创建 FileSystemObject 对象并将该对象赋给变量 MyFile。</p>
<p>第 5 行代码使用 MoveFile 方法移动文件。应用于 FileSystemObject 对象的 MoveFile 方法将一个或多个文件从一个地方移动到另一个地方，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>MoveFile source<span>,</span> destination 

参数<span>object</span>是必需的， FileSystemObject对象的名称。
参数source是必需的，一个或多个要移动文件的路径，source参数字符串在路径的最后部件中可以使用通配符。
参数destinatio是必需的，一个或多个文件要移动到的目标路径，不能使用通配符。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>运行 MoveFile 过程将示例文件所在文件夹中的“123.xls”文件移动到同一目录中的“ABC”文件夹。</p>
<h3 id="_4-复制文件"> 4）复制文件</h3>
<p>如果需要把文件从一个地方复制到另一个地方，可以使用 CopyFile 方法，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> CopyFile<span>(</span><span>)</span>
	<span>Dim</span> MyFile <span>As</span> <span>Object</span>
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	<span>Set</span> MyFile <span>=</span> CreateObject<span>(</span><span>"Scripting.FileSystemObject"</span><span>)</span>
	MyFile<span>.</span>CopyFile ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\123.xls"</span><span>,</span> ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\ABC\"</span>
	<span>Set</span> MyFile <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>CopyFile 过程使用 CopyFile 方法将示例文件所在文件夹中的“123.xls”文件复制到“ABC”文件夹中。</p>
<p>第 4 行代码使用 CreateObject 函数创建 FileSystemObject 对象并将该对象赋给变量 MyFile。</p>
<p>第 5 行代码使用 CopyFile 方法复制文件。应用于 FileSystemObject 对象的 CopyFile 方法把一个或多个文件从一个地方复制到另一个地方，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>CopyFile source<span>,</span> destination[<span>,</span> overwrite]

参数<span>object</span>是必需的， FileSystemObject对象的名字。
参数source是必需的，指明一个或多个要被复制文件的字符串文件说明，可以包括通配符。
参数destination是必需的，指明参数source中的一个或多个文件要被复制到的接受端的字符串，不允许有通配符。
参数overwrite是可选的，表示存在的文件是否被覆盖。如果是<span>True</span>，文件将被覆盖；如果是<span>False</span>，它们不被覆盖，缺省值是<span>True</span>。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><p>注意</p>
<p>如果参数 destination 指定的接受端具有只读属性设置，不论参数 overwrite 的值如何设置，CopyFile 方法都将失败。</p>
</div>
<p>运行 CopyFile 过程将示例文件所在文件夹中的“123.xls”文件复制到“ABC”文件夹中。</p>
<h3 id="_5-删除文件"> 5）删除文件</h3>
<p>如果需要删除一个指定的文件，可以使用 DeleteFile 方法，如下面的代码所示</p>
<div><pre><code><span>Sub</span> DelFile<span>(</span><span>)</span>
	<span>Dim</span> MyFile <span>As</span> <span>Object</span>
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	<span>Set</span> MyFile <span>=</span> CreateObject<span>(</span><span>"Scripting.FileSystemObject"</span><span>)</span>
	MyFile<span>.</span>DeleteFile ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\123.xls"</span>
	<span>Set</span> MyFile <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>DelFile 过程使 DeleteFile 方法删除示例文件所在文件夹中的“123.xls”文件。</p>
<p>第 4 行代码使用 CreateObject 函数创建 FileSystemObject 对象并将该对象赋给变量 MyFile。</p>
<p>第 5 行代码使用 DeleteFile 方法复制文件。应用于 FileSystemObject 对象的 DeleteFile 方法删除一个指定的文件，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>DeleteFile filespec[<span>,</span> force]

参数<span>object</span>是必需的， FileSystemObject对象的名字。
参数filespec是必需的，指明要删除文件的名字，可以在最后的路径部件中包含通配符。
参数force是可选的，如果要删除具有只读属性设置的文件，其值为<span>True</span>。如果其值为<span>False</span>（缺省），则不能删除具有只读属性设置的文件。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>运行 DelFile 过程删除示例文件所在文件夹中的“123.xls”文件。</p>
<h3 id="_6-创建文件夹"> 6）创建文件夹</h3>
<p>如果需要创建一个文件夹，可以使用 CreateFolder 方法，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> CreFolder<span>(</span><span>)</span>
	<span>Dim</span> MyFile <span>As</span> <span>Object</span>
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	<span>Set</span> MyFile <span>=</span> CreateObject<span>(</span><span>"Scripting.FileSystemObject"</span><span>)</span>
	MyFile<span>.</span>CreateFolder <span>(</span>ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\ABC"</span><span>)</span>
	<span>Set</span> MyFile <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>CreFolder 过程使 CreateFolder 方法在示例文件所在文件夹中创建一个“ABC”文件夹。</p>
<p>第 4 行代码使用 CreateObject 函数创建 FileSystemObject 对象并将该对象赋给变量 MyFile。</p>
<p>第 5 行代码使用 CreateFolder 方法创建文件夹。应用于 FileSystemObject 对象的 CreateFolder 方法创建一个文件夹，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>CreateFolder<span>(</span>foldername<span>)</span>

参数<span>object</span>是必需的， FileSystemObject对象的名字。
参数foldername是必需的，字符串表达式，指明要创建文件夹的名称和路径。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>运行 CreFolder 过程将在示例文件所在文件夹中创建一个“ABC”文件夹。</p>
<h3 id="_7-复制文件夹"> 7）复制文件夹</h3>
<p>如果需要复制文件夹，可以使用 CopyFolder 方法，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> CopyFolder<span>(</span><span>)</span>
	<span>Dim</span> MyFile <span>As</span> <span>Object</span>
	<span>Set</span> MyFile <span>=</span> CreateObject<span>(</span><span>"Scripting.FileSystemObject"</span><span>)</span>
	MyFile<span>.</span>CopyFolder ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\ABC"</span><span>,</span> ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\123"</span>
	<span>Set</span> MyFile <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>代码解析：</p>
<p>CopyFolder 过程使 CopyFolder 方法将示例文件所在文件夹中的“ABC”文件夹复制并改名为“123”文件夹。</p>
<p>第 3 行代码使用 CreateObject 函数创建 FileSystemObject 对象并将该对象赋给变量 MyFile。</p>
<p>第 4 行代码使用 CopyFolder 方法复制文件夹。应用于 FileSystemObject 对象的 CreateObject 方法从一个地方递归地复制一个文件夹到另一个地方，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>CopyFolder source<span>,</span> destination[<span>,</span> overwrite]

参数<span>object</span>是必需的， FileSystemObject对象的名字。
参数source是必需的，指明一个或多个被复制文件夹的字符串文件夹说明，可以包括通配符。
参数destination是必需的，被复制文件夹和子文件夹的接受端的字符串，不允许有通配符。
参数overwrite是可选的，表示已存在的文件夹是否被覆盖。如果为<span>True</span>，文件被覆盖，如果为<span>False</span>，文件不被覆盖。缺省值为<span>True</span>。
如果参数source中包含通配符或参数destination以路径分隔符（<span>\</span>）为结尾，则认为参数destination是一个已存在的文件夹，在其中复制相匹配的文件夹和子文件夹。否则认为参数destination是一个要创建的文件夹的名字。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>运行 CopyFolder 过程将示例文件所在文件夹中的“ABC”文件夹复制并改名为“123”文件夹。</p>
<h3 id="_8-移动文件夹"> 8）移动文件夹</h3>
<p>如果需要移动文件夹，可以使用 MoveFolder 方法，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> MoveFolder<span>(</span><span>)</span>
	<span>Dim</span> MyFile <span>As</span> <span>Object</span>
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	<span>Set</span> MyFile <span>=</span> CreateObject<span>(</span><span>"Scripting.FileSystemObject"</span><span>)</span>
	MyFile<span>.</span>MoveFolder ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\123"</span><span>,</span> <span>"F:\123"</span>
	<span>Set</span> MyFile <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>MoveFolder 过程使 MoveFolder 方法将示例文件所在文件夹中的“123”文件夹移动到F盘中。</p>
<p>第 4 行代码使用 CreateObject 函数创建 FileSystemObject 对象并将该对象赋给变量 MyFile。</p>
<p>第 5 行代码使 MoveFolder 方法移动文件夹。应用于 FileSystemObject 对象的 MoveFolder 方法将一个或多个文件夹从一个地方移动到另一个地方，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>MoveFolder source<span>,</span> destination

参数<span>object</span>是必需的， FileSystemObject对象的名字。
参数source是必需的，指明一个或多个要移动文件夹的字符串文件夹说明，在路径的最后部件中可以包括通配符。
参数destination是必需的，一个或多个文件夹要移动到的目标路径，不能包含通配符。
如果参数source中包含通配符或参数destination以路径分隔符（<span>\</span>）为结尾，则认为参数destination是一个已存在的文件夹，在此文件夹中移动相匹配的文件。否则认为参数destination是一个要创建的文件夹的名字。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>运行 MoveFolder 过程将示例文件所在文件夹中的“123”文件夹移动到F盘中。</p>
<h3 id="_9-删除文件夹"> 9）删除文件夹</h3>
<p>如果需要删除一个文件夹，可以使用 DeleteFolder 方法，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> DelFolder<span>(</span><span>)</span>
	<span>Dim</span> MyFile <span>As</span> <span>Object</span>
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	<span>Set</span> MyFile <span>=</span> CreateObject<span>(</span><span>"Scripting.FileSystemObject"</span><span>)</span>
	MyFile<span>.</span>DeleteFolder ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\123"</span>
	<span>Set</span> MyFile <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>DelFolder 过程使 DeleteFolder 方法删除示例文件所在文件夹中的“123”文件夹。</p>
<p>第 4 行代码使用 CreateObject 函数创建 FileSystemObject 对象并将该对象赋给变量 MyFile。</p>
<p>第 5 行代码使用 DeleteFolder 方法删除文件。应用于 FileSystemObject 对象的 DeleteFolder 方法删除一个指定的文件夹和其中的内容，语法如下：</p>
<div><pre><code>object.DeleteFolder folderspec[, force]

参数object是必需的， FileSystemObject对象的名字。
参数filespec是必需的，指明要删除的文件夹的名称，可以在最后的路径部件中包含通配符。
参数force是可选的，如果要删除具有只读属性设置的文件夹，其值为True。如果其值为False（缺省），则不能删除具有只读属性设置的文件夹。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>运行 DelFolder 过程删除示例文件所在文件夹中的“123.xls”文件夹。</p>
<h3 id="_10-导入文本文件"> 10）导入文本文件</h3>
<p>如果需要从文本文件中导入数据，可以使用 OpenTextFile 方法，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> OpenText<span>(</span><span>)</span>
	<span>Dim</span> MyFile <span>As</span> <span>Object</span>
	<span>Dim</span> mArr<span>(</span><span>)</span> <span>As</span> <span>String</span>
	<span>Dim</span> j <span>As</span> <span>Integer</span><span>,</span> i <span>As</span> <span>Integer</span>
	j <span>=</span> <span>1</span>
	Sheet1<span>.</span>UsedRange<span>.</span>ClearContents
	<span>Set</span> MyFile <span>=</span> CreateObject<span>(</span><span>"Scripting.FileSystemObject"</span><span>)</span> <span>_</span>
		<span>.</span>OpenTextFile<span>(</span>ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\"</span> <span>&amp;</span> <span>"工资表.txt"</span><span>)</span>
	<span>Do</span> <span>While</span> <span>Not</span> MyFile<span>.</span>AtEndOfStream
		mArr <span>=</span> Split<span>(</span>MyFile<span>.</span>ReadLine<span>,</span> <span>","</span><span>)</span>
		<span>For</span> i <span>=</span> <span>0</span> <span>To</span> UBound<span>(</span>mArr<span>)</span>
			Sheet1<span>.</span>Cells<span>(</span>j<span>,</span> i <span>+</span> <span>1</span><span>)</span> <span>=</span> mArr<span>(</span>i<span>)</span>
		<span>Next</span>
		j <span>=</span> j <span>+</span> <span>1</span>
	<span>Loop</span>
	MyFile<span>.</span>Close
	<span>Set</span> MyFile <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>代码解析：</p>
<p>OpenText 过程使用 OpenTextFile 方法打开示例文件所在文件夹中的“工资表.txt”文件并将数据导入到工作表中。</p>
<p>第 7、8 行代码使用 OpenTextFile 方法打开文本文件。应用于 FileSystemObject 对象的 OpenTextFile 方法打开一个指定的文件并返回一个 TextStream 对象，该对象可用于对文件进行读操作或追加操作，语法如下：</p>
<div><pre><code>object.OpenTextFile(filename[, iomode[, create[, format]]])

参数object是必需的，FileSystemObject对象的名字。
参数filename是必需的，需要打开的文件名称。
参数iomode是可选的，表示输入/输出方式，设置值如表格180-2所示。
参数create是可选的，它表示如果指定的参数filename不存在是否可以创建一个新文件。如果创建新文件，其值为True。若不创建文件其值为False。缺省值为False。
参数format是可选的，打开文件的格式，设置值如表格180-3所示。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><u>表格 180-2</u>	iomode 参数设置值</p>
<table>
<thead>
<tr>
<th>常数</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ForReading</td>
<td>1</td>
<td>打开一个只读文件，不能对此文件进行写操作。</td>
</tr>
<tr>
<td>ForAppending</td>
<td>8</td>
<td>打开一个文件并写到文件的尾部。</td>
</tr>
</tbody>
</table>
<p><u>表格 180-3</u>	format 参数设置值</p>
<table>
<thead>
<tr>
<th>常数</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>TristateUseDefault</td>
<td>-2</td>
<td>使用系统缺省打开文件</td>
</tr>
<tr>
<td>TristateTrue</td>
<td>-1</td>
<td>以 Unicode 格式打开文件</td>
</tr>
<tr>
<td>TristateFalse</td>
<td>0</td>
<td>以 ASCII 格式打开文件</td>
</tr>
</tbody>
</table>
<p>第 9 行代码开始对文本文件进行读操作。应用于 TextStream 对象的 AtEndOfStream 属性指示文件指针是否位于 TextStream 文件中的结尾，如果是返回 True，否则返回 False。</p>
<p>第 10 行代码使用 Split 函数将逐行读取的字符串以逗号进行分隔后赋给数组 mArr。关于 Split 函数请参阅 169-2。</p>
<p>应用于 TextStream 对象的 ReadLine 方法从一个 TextStream 文件读取一整行（到换行符但不包括换行符）并返回得到的字符串，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>ReadLine

参数<span>object</span>是必需的，TextStream对象的名字。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>第 11 行到第 14 行代码将数组元素写入到工作表的单元格。</p>
<p>第 15 行代码重新读取下一行数据。</p>
<p>第 16 行使用 Close 方法关闭打开的文本文件。</p>
<p>运行 OpenText 过程将“工资表.txt”文件的数据导入到工作表中。</p>
<h3 id="_11-创建文本文件"> 11）创建文本文件</h3>
<p>如果需要将工作表中的数据保存为文本文件，可以创建一个文本文件用于保存数据。</p>
<p>使用 CreateTextFile 方法创建文本文件，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> CreText<span>(</span><span>)</span>
	<span>Dim</span> MyFile <span>As</span> <span>Object</span>
	<span>Dim</span> myStr <span>As</span> <span>String</span>
	<span>Dim</span> j <span>As</span> <span>Integer</span><span>,</span> i <span>As</span> <span>Integer</span>
	<span>Set</span> MyFile <span>=</span> CreateObject<span>(</span><span>"Scripting.FileSystemObject"</span><span>)</span> <span>_</span>
		<span>.</span>CreateTextFile<span>(</span>ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\"</span> <span>&amp;</span> <span>"工资表.txt"</span><span>,</span> <span>True</span><span>)</span>
		<span>For</span> i <span>=</span> <span>1</span> <span>To</span> Range<span>(</span><span>"A65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row
			myStr <span>=</span> <span>""</span>
			<span>For</span> j <span>=</span> <span>1</span> <span>To</span> Range<span>(</span><span>"IV"</span><span>&amp;</span> i<span>)</span><span>.</span><span>End</span><span>(</span>xlToLeft<span>)</span><span>.</span>Column
				myStr <span>=</span> myStr <span>&amp;</span> Cells<span>(</span>i<span>,</span> j<span>)</span> <span>&amp;</span> <span>","</span>
			<span>Next</span>
			myStr <span>=</span> Left<span>(</span>myStr<span>,</span> <span>(</span>Len<span>(</span>myStr<span>)</span> <span>-</span> <span>1</span><span>)</span><span>)</span>
			MyFile<span>.</span>WriteLine <span>(</span>myStr<span>)</span>
		<span>Next</span>
	MyFile<span>.</span>Close
	<span>Set</span> MyFile <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>代码解析：</p>
<p>CreText 过程使 CreateTextFile 方法创建一个指定名称的文本文件并将工作表数据写入到文件内。</p>
<p>第 5、6 行代码使用 CreateObject 函数创建 FileSystemObject 对象并将该对象赋给变量 MyFile 后使用 CreateTextFile 方法创建一个指定名称的文本文件。</p>
<p>应用于 FileSystemObject 对象的 CreateTextFile 方法创建一个指定的文件并且返回一个用于该文件读写的 TextStream 对象，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>CreateTextFile<span>(</span>filename[<span>,</span> overwrite[<span>,</span> unicode]]<span>)</span>

参数<span>object</span>是必需的，FileSystemObject对象的名字。
参数filename是必需的，需要创建的文件名称。
参数overwrite是可选的，表示是否覆盖已存在文件。如果可被覆盖其值为<span>True</span>，其值为<span>False</span>时不能覆盖，如果省略，则已存在文件不能覆盖。
参数unicode是可选的，表示文件是作为一个Unicode文件创建的还是作为一个ASCII文件创建的。如果作为一个Unicode文件创建，其值为<span>True</span>，作为一个ASCII文件创建，其值为<span>False</span>，如果省略，则认为是一个ASCII文件。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>第 7 行代码逐行读取工作表数据。</p>
<p>第 8 行代码清空字符串变量 myStr 的内容，用来保存下一行的数据。</p>
<p>第 9 行代码遍历当前行的所有单元格。</p>
<p>第 10 行代码将当前行的所有单元格保存到字符串变量 myStr 中并以逗号进行分隔。</p>
<p>第 12 行代码去除保存在字符串变量 myStr 中当前行数据的最后一个逗号。</p>
<p>第 13 行代码使用 WriteLine 方法将当前行数据写入到创建的文本文件。</p>
<p>应用于 TextStream 对象的 WriteLine 方法写入一个指定的字符串和换行符到一个 TextStream 文件中，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>WriteLine<span>(</span>[<span>string</span>]<span>)</span>

参数<span>object</span>是必需的，TextStream对象的名字。
参数<span>string</span>是可选的，要写入文件的正文。如果省略，写入一个换行符。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第 15 行使用 Close 方法关闭打开的文本文件。</p>
<p>还可以使用 OpenTextFile 方法创建文本文件，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> OpenText<span>(</span><span>)</span>
	<span>Dim</span> MyFile <span>As</span> <span>Object</span>
	<span>Dim</span> myStr <span>As</span> <span>String</span>
	<span>Dim</span> j <span>As</span> <span>Integer</span><span>,</span> i <span>As</span> <span>Integer</span>
	<span>Set</span> MyFile <span>=</span> CreateObject<span>(</span><span>"Scripting.FileSystemObject"</span><span>)</span> <span>_</span>
		<span>.</span>OpenTextFile<span>(</span>ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\"</span> <span>&amp;</span> <span>"工资表.txt"</span><span>,</span> <span>8</span><span>,</span> <span>True</span><span>)</span>
		<span>For</span> i <span>=</span> <span>1</span> <span>To</span> Range<span>(</span><span>"A65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row
			myStr <span>=</span> <span>""</span>
			<span>For</span> j <span>=</span> <span>1</span> <span>To</span> Range<span>(</span><span>"IV"</span> <span>&amp;</span> i<span>)</span><span>.</span><span>End</span><span>(</span>xlToLeft<span>)</span><span>.</span>Column
				myStr <span>=</span> myStr <span>&amp;</span> Cells<span>(</span>i<span>,</span> j<span>)</span> <span>&amp;</span> <span>","</span>
			<span>Next</span>
			myStr <span>=</span> Left<span>(</span>myStr<span>,</span> <span>(</span>Len<span>(</span>myStr<span>)</span> <span>-</span> <span>1</span><span>)</span><span>)</span>
			MyFile<span>.</span>WriteLine <span>(</span>myStr<span>)</span>
		<span>Next</span>
	MyFile<span>.</span>Close
	<span>Set</span> MyFile <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>代码解析：</p>
<p>OpenText 过程使 OpenTextFile 方法创建一个指定名称的文本文件并将工作表数据写入到文件内。</p>
<p>应用于 FileSystemObject 对象的 OpenTextFile 方法打开一个指定的文件并返回一个  TextStream 对象，该对象可用于对文件进行读操作或追加操作，请参阅 180-10。</p>
<p>示例中将 OpenTextFile 方法的 iomode 参数设置为 8，打开文本文件后在文件的尾部进行追加操作；将 create 参数设置为 True，如果指定的文本文件不存在则创建一个新文件。</p>
<div><p>注意</p>
<p>如果重复运行 OpenText 过程将在文本文件中重复写入工作表数据，所以 OpenTextFile 方法更适用于对文本文件进行追加操作。</p>
</div>
<p>OpenText 过程的其他代码请参阅 CreText 过程的代码解析。</p>
<p>运行 CreText 过程和 OpenText 过程将在示例所在的文件夹中创建一个名称为“工资表”的文本文件并将工作表数据读入到文件内。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-07-02T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Excel 笔记介绍</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Excel/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Excel/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>Excel 是平时大家最长用的办公软件之一。Excel 是一个电子表格处理软件，可以用来制作电子表格，完成许多复杂的数据运算，进行数据的分析和预测，并且具有强大的制作图表的功能。</p>
<p>它的基本功能就不一一介绍了，长时不用，难免会忘了，于是，抽了些时间，把曾经的学习笔记整理一下，以便日后的翻越查找。</p>
<p>整理的笔记主要分为 3 块：</p>
<ul>
<li>快捷键</li>
<li>函数</li>
<li>VBA</li>
</ul>
<p>常用的 Excel 的使用方法可以参考<a href="https://support.microsoft.com/zh-cn/excel" target="_blank" rel="noopener noreferrer">官方文档</a>。</p>
<p>如下图所示，可以在搜索框中搜索关键词获得帮助，或者可以在下图红框中选择相对应的模块查找相关帮助信息。</p>
<p><img src="./assets/Excel_help.png" alt="Excel_help" loading="lazy"></p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-07-02T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Git安装</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Git/01.Git_install/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Git/01.Git_install/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>在使用Git前我们需要先安装 Git。Git 目前支持 Linux/Unix、Solaris、Mac 和 Windows 平台上运行。</p>
<p>Git 各平台安装包下载地址为：<a href="http://git-scm.com/downloads" target="_blank" rel="noopener noreferrer">http://git-scm.com/downloads</a></p>
<h2 id="linux-平台安装"> Linux 平台安装</h2>
<p>Git 的工作需要调用 curl，zlib，openssl，expat，libiconv 等库的代码，所以需要先安装这些依赖工具。</p>
<p>各 Linux 系统可以使用其安装包管理工具（apt-get、yum 等）进行安装：</p>
<h3 id="debian-ubuntu"> Debian/Ubuntu</h3>
<p>如果你使用的系统是 Debian/Ubuntu， Git 安装命令为：</p>
<div><pre><code>$ <span>apt-get</span> <span>install</span> libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-dev
$ <span>apt-get</span> <span>install</span> <span>git</span>
$ <span>git</span> --version
<span>git</span> version <span>1.8</span>.1.2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="centos-redhat"> Centos/RedHat</h3>
<p>如果你使用的系统是 Centos/RedHat， Git 安装命令为：</p>
<div><pre><code>$ yum <span>install</span> curl-devel expat-devel gettext-devel openssl-devel zlib-devel
$ yum -y <span>install</span> git-core
$ <span>git</span> --version
<span>git</span> version <span>1.7</span>.1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="源码安装"> 源码安装</h3>
<p>我们也可以在官网下载源码包来安装，最新源码包下载地址：<a href="https://git-scm.com/download" target="_blank" rel="noopener noreferrer">https://git-scm.com/download</a></p>
<p>安装指定系统的依赖包：</p>
<div><pre><code><span>########## Centos/RedHat ##########</span>
$ yum <span>install</span> curl-devel expat-devel gettext-devel openssl-devel zlib-devel

<span>########## Debian/Ubuntu ##########</span>
$ <span>apt-get</span> <span>install</span> libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-dev
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>解压安装下载的源码包：</p>
<div><pre><code>$ <span>tar</span> -zxf git-1.7.2.2.tar.gz
$ <span>cd</span> git-1.7.2.2
$ <span>make</span> <span>prefix</span><span>=</span>/usr/local all
$ <span>sudo</span> <span>make</span> <span>prefix</span><span>=</span>/usr/local <span>install</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="windows-平台安装"> Windows 平台安装</h2>
<p>在 Windows 平台上安装 Git 同样轻松，有个叫做 msysGit 的项目提供了安装包，可以到 GitHub 的页面上下载 exe 安装文件并运行：</p>
<p>安装包下载地址：<a href="https://git-scm.com/download/win" target="_blank" rel="noopener noreferrer">https://git-scm.com/download/win</a></p>
<p>官网慢，可以用国内的镜像：<a href="https://npm.taobao.org/mirrors/git-for-windows/" target="_blank" rel="noopener noreferrer">https://npm.taobao.org/mirrors/git-for-windows/</a></p>
<p><img src="./assets/git_win.png" alt="git win" loading="lazy"></p>
<p>一直默认下一步，直到安装完成。</p>
<p>完成安装之后，就可以使用命令行的 git 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。</p>
<p>在开始菜单里找到&quot;Git&quot;-&gt;&quot;Git Bash&quot;，会弹出 Git 命令窗口，你可以在该窗口进行 Git 操作。</p>
<h2 id="mac-平台上安装"> Mac 平台上安装</h2>
<p>在 Mac 平台上安装 Git 最容易的当属使用图形化的 Git 安装工具，下载地址为：</p>
<p><a href="https://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="noopener noreferrer">https://sourceforge.net/projects/git-osx-installer/</a></p>
<p>安装界面如下所示：</p>
<p><img src="./assets/git_mac.png" alt="git mac" loading="lazy"></p>
<p>当然，你也可以其他方法安装。</p>
<p><a href="https://git-scm.com/download/mac" target="_blank" rel="noopener noreferrer">https://git-scm.com/download/mac</a></p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-05-12T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Git配置</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Git/02.Git_config/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Git/02.Git_config/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="git-配置"> Git 配置</h2>
<p>Git 提供了一个叫做 <code>git config</code> 的工具，专门用来配置或读取相应的工作环境变量。</p>
<p>这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：</p>
<ul>
<li><code>/etc/gitconfig</code> 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 --system 选项，读写的就是这个文件。</li>
<li><code>~/.gitconfig</code> 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 --global 选项，读写的就是这个文件。</li>
<li>当前项目的 Git 目录中的配置文件（也就是工作目录中的 <code>.git/config</code> 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 <code>.git/config</code> 里的配置会覆盖 <code>/etc/gitconfig</code> 中的同名变量。</li>
</ul>
<p>此外，Git 还会尝试找寻 <code>/etc/gitconfig</code> 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。</p>
<h3 id="用户信息"> 用户信息</h3>
<p>配置个人的用户名称和电子邮件地址：</p>
<div><pre><code>$ <span>git</span> config --global user.name <span>"runoob"</span>
$ <span>git</span> config --global user.email test@runoob.com
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果用了 <strong>--global</strong> 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。</p>
<p>如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 --global 选项重新配置即可，新的设定保存在当前项目的 <code>.git/config</code> 文件里。</p>
<h3 id="文本编辑器"> 文本编辑器</h3>
<p>设置Git默认使用的文本编辑器，一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置：</p>
<div><pre><code>$ <span>git</span> config --global core.editor emacs
</code></pre>
<div><span>1</span><br></div></div><h3 id="差异分析工具"> 差异分析工具</h3>
<p>还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话：</p>
<div><pre><code>$ <span>git</span> config --global merge.tool vimdiff
</code></pre>
<div><span>1</span><br></div></div><p>Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。</p>
<p>当然，你也可以指定使用自己开发的工具。</p>
<h3 id="查看配置信息"> 查看配置信息</h3>
<p>要检查已有的配置信息，可以使用 <code>git config --list</code> 命令：</p>
<div><pre><code>$ <span>git</span> config --list
http.postbuffer<span>=</span>2M
user.name<span>=</span>runoob
user.email<span>=</span>test@runoob.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 <code>/etc/gitconfig</code> 和 <code>~/.gitconfig</code>），不过最终 Git 实际采用的是最后一个。</p>
<p>这些配置我们也可以在 <code>~/.gitconfig</code> 或 <code>/etc/gitconfig</code> 看到，如下所示：</p>
<div><pre><code><span>vim</span> ~/.gitconfig 
</code></pre>
<div><span>1</span><br></div></div><p>显示内容如下所示：</p>
<div><pre><code><span>[</span>http<span>]</span>
    postBuffer <span>=</span> 2M
<span>[</span>user<span>]</span>
    name <span>=</span> runoob
    email <span>=</span> test@runoob.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样：</p>
<div><pre><code>$ <span>git</span> config user.name
runoob
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-05-12T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Git工作流程</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Git/03.Git_workfllow/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Git/03.Git_workfllow/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="git-工作流程"> Git 工作流程</h2>
<p>一般工作流程如下：</p>
<ul>
<li>克隆 Git 资源作为工作目录。</li>
<li>在克隆的资源上添加或修改文件。</li>
<li>如果其他人修改了，你可以更新资源。</li>
<li>在提交前查看修改。</li>
<li>提交修改。</li>
<li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</li>
</ul>
<p>下图展示了 Git 的工作流程：</p>
<p><img src="./assets/git-process.png" alt="git-process" loading="lazy"></p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-05-12T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Git工作区、暂存区和版本库</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Git/04.Git_work_stage_git/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Git/04.Git_work_stage_git/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="git-工作区、暂存区和版本库"> Git 工作区、暂存区和版本库</h2>
<h3 id="基本概念"> 基本概念</h3>
<p>我们先来理解下 Git 工作区、暂存区和版本库概念：</p>
<ul>
<li>
<p><strong>工作区</strong>：就是你在电脑里能看到的目录。</p>
</li>
<li>
<p><strong>暂存区</strong>：英文叫 stage 或 index。一般存放在<code>.git</code> 目录下的 index 文件（<code>.git/index</code>）中，所以我们把暂存区有时也叫作索引（index）。</p>
</li>
<li>
<p><strong>版本库</strong>：工作区有一个隐藏目录 <code>.git</code>，这个不算工作区，而是 Git 的版本库。</p>
</li>
</ul>
<p>下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系：</p>
<p><img src="./assets/git_wsb.jpg" alt="git_wsb" loading="lazy"></p>
<div><p>图解</p>
<ul>
<li>图中左侧为工作区，右侧为版本库。在版本库中标记为 &quot;index&quot; 的区域是暂存区（stage/index），标记为 &quot;master&quot; 的是 master 分支所代表的目录树。</li>
<li>图中我们可以看出此时 &quot;HEAD&quot; 实际是指向 master 分支的一个&quot;游标&quot;。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。</li>
<li>图中的 objects 标识的区域为 Git 的对象库，实际位于 &quot;.git/objects&quot; 目录下，里面包含了创建的各种对象及内容。</li>
<li>当对工作区修改（或新增）的文件执行 <code>git add</code> 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</li>
<li>当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</li>
<li>当执行 <code>git reset HEAD</code> 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</li>
<li>当执行 <code>git rm --cached &lt;file&gt;</code> 命令时，会直接从暂存区删除文件，工作区则不做出改变。</li>
<li>当执行 <code>git checkout .</code> 或者 <code>git checkout -- &lt;file&gt;</code> 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</li>
<li>当执行 <code>git checkout HEAD .</code> 或者 <code>git checkout HEAD &lt;file&gt;</code> 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</li>
</ul>
</div>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-05-12T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Git创建仓库</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Git/05.Git_init_repo/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Git/05.Git_init_repo/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="git-创建仓库"> Git 创建仓库</h2>
<p>本章节我们将为大家介绍如何创建一个 Git 仓库。</p>
<p>你可以使用一个已经存在的目录作为 Git 仓库。</p>
<h3 id="git-init"> git init</h3>
<p>Git 使用 <code>git init</code> 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 <code>git init</code> 是使用 Git 的第一个命令。</p>
<p>在执行完成 <code>git init</code> 命令后，Git 仓库会生成一个 <code>.git</code> 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变。</p>
<ul>
<li>使用方法</li>
</ul>
<p>使用当前目录作为Git仓库，我们只需使它初始化。</p>
<div><pre><code><span>git</span> init
</code></pre>
<div><span>1</span><br></div></div><p>该命令执行完后会在当前目录生成一个 .git 目录。</p>
<p>使用我们指定目录作为 Git 仓库。</p>
<div><pre><code><span>git</span> init newrepo
</code></pre>
<div><span>1</span><br></div></div><p>初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。</p>
<p>如果当前目录下有几个文件想要纳入版本控制，需要先用 <code>git add</code> 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p>
<div><pre><code>$ <span>git</span> <span>add</span> *.c
$ <span>git</span> <span>add</span> README
$ <span>git</span> commit -m <span>'初始化项目版本'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>以上命令将目录下以 .c 结尾及 README 文件提交到仓库中。</p>
<div><p>注</p>
<p>在 Linux 系统中，commit 信息使用单引号 <strong>'</strong>，Windows 系统，commit 信息使用双引号 <strong>&quot;</strong>。</p>
<p>所以在 git bash 中 <code>git commit -m '提交说明'</code> 这样是可以的，在 Windows 命令行中就要使用双引号 <code>git commit -m &quot;提交说明&quot;</code>。</p>
</div>
<h3 id="git-clone"> git clone</h3>
<p>我们使用 <code>git clone</code> 从现有 Git 仓库中拷贝项目。</p>
<p>克隆仓库的命令格式为：</p>
<div><pre><code><span>git</span> clone <span>&lt;</span>repo<span>></span>
</code></pre>
<div><span>1</span><br></div></div><p>如果我们需要克隆到指定的目录，可以使用以下命令格式：</p>
<div><pre><code><span>git</span> clone <span>&lt;</span>repo<span>></span> <span>&lt;</span>directory<span>></span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>参数说明：</strong></p>
<ul>
<li><strong>repo</strong>：Git 仓库。</li>
<li><strong>directory</strong>：本地目录。</li>
</ul>
<p>比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：</p>
<div><pre><code>$ <span>git</span> clone git://github.com/schacon/grit.git
</code></pre>
<div><span>1</span><br></div></div><p>执行该命令后，会在当前目录下创建一个名为 <code>grit</code> 的目录，其中包含一个 <code>.git</code> 的目录，用于保存下载下来的所有版本记录。</p>
<p>如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：</p>
<div><pre><code>$ <span>git</span> clone git://github.com/schacon/grit.git mygrit
</code></pre>
<div><span>1</span><br></div></div><h3 id="配置"> 配置</h3>
<p>git 的设置使用 <code>git config</code> 命令。</p>
<p>显示当前的 git 配置信息：</p>
<div><pre><code>$ <span>git</span> config --list
credential.helper<span>=</span>osxkeychain
core.repositoryformatversion<span>=</span><span>0</span>
core.filemode<span>=</span>true
core.bare<span>=</span>false
core.logallrefupdates<span>=</span>true
core.ignorecase<span>=</span>true
core.precomposeunicode<span>=</span>true
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>编辑 git 配置文件:</p>
<div><pre><code>$ <span>git</span> config -e
<span># 针对当前仓库 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>或者：</p>
<div><pre><code>$ <span>git</span> config -e --global
<span># 针对系统上所有仓库</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>设置提交代码时的用户信息：</p>
<div><pre><code>$ <span>git</span> config --global user.name <span>"runoob"</span>
$ <span>git</span> config --global user.email test@runoob.com
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果去掉 <strong>--global</strong> 参数只对当前仓库有效。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-05-12T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Git基本操作</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Git/06.Git_basic_opera/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Git/06.Git_basic_opera/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="git-基本操作"> Git 基本操作</h2>
<p>Git 的工作就是创建和保存你项目的快照及与之后的快照进行对比。</p>
<p>本节将对有关创建与提交你的项目快照的命令作介绍。</p>
<p>Git 常用的是以下 6 个命令：<code>git clone</code>、<code>git push</code>、<code>git add</code>、<code>git commit</code>、<code>git checkout</code>、<code>git pull</code>，后面我们会详细介绍。</p>
<p><img src="./assets/git-command.jpg" alt="git_command" loading="lazy"></p>
<div><p>说明</p>
<ul>
<li>workspace：工作区</li>
<li>staging area：暂存区/缓存区</li>
<li>local repository：版本库或本地仓库</li>
<li>remote repository：远程仓库</li>
</ul>
</div>
<p>一个简单的操作步骤：</p>
<div><pre><code>$ <span>git</span> init
$ <span>git</span> <span>add</span> <span>.</span>
$ <span>git</span> commit
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li><code>git init</code> ：初始化仓库。</li>
<li><code>git add .</code> ：添加文件到暂存区。</li>
<li><code>git commit</code> ：将暂存区内容添加到仓库中。</li>
</ul>
<h3 id="创建仓库命令"> 创建仓库命令</h3>
<p>下表列出了 git 创建仓库的命令：</p>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>git init</code></td>
<td style="text-align:left">初始化仓库</td>
</tr>
<tr>
<td style="text-align:left"><code>git clone</code></td>
<td style="text-align:left">拷贝一份远程仓库，也就是下载一个项目。</td>
</tr>
</tbody>
</table>
<h3 id="提交与修改"> 提交与修改</h3>
<p>Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。</p>
<p>下表列出了有关创建与提交你的项目的快照的命令：</p>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>git add</code></td>
<td style="text-align:left">添加文件到仓库</td>
</tr>
<tr>
<td style="text-align:left"><code>git status</code></td>
<td style="text-align:left">查看仓库当前的状态，显示有变更的文件。</td>
</tr>
<tr>
<td style="text-align:left"><code>git diff</code></td>
<td style="text-align:left">比较文件的不同，即暂存区和工作区的差异。</td>
</tr>
<tr>
<td style="text-align:left"><code>git commit</code></td>
<td style="text-align:left">提交暂存区到本地仓库。</td>
</tr>
<tr>
<td style="text-align:left"><code>git reset</code></td>
<td style="text-align:left">回退版本。</td>
</tr>
<tr>
<td style="text-align:left"><code>git rm</code></td>
<td style="text-align:left">删除工作区文件。</td>
</tr>
<tr>
<td style="text-align:left"><code>git mv</code></td>
<td style="text-align:left">移动或重命名工作区文件。</td>
</tr>
</tbody>
</table>
<h3 id="提交日志"> 提交日志</h3>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>git log</code></td>
<td style="text-align:left">查看历史提交记录</td>
</tr>
<tr>
<td style="text-align:left"><code>git blame &lt;file&gt;</code></td>
<td style="text-align:left">以列表形式查看指定文件的历史修改记录</td>
</tr>
</tbody>
</table>
<h3 id="远程操作"> 远程操作</h3>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>git remote</code></td>
<td style="text-align:left">远程仓库操作</td>
</tr>
<tr>
<td style="text-align:left"><code>git fetch</code></td>
<td style="text-align:left">从远程获取代码库</td>
</tr>
<tr>
<td style="text-align:left"><code>git pull</code></td>
<td style="text-align:left">下载远程代码并合并</td>
</tr>
<tr>
<td style="text-align:left"><code>git push</code></td>
<td style="text-align:left">上传远程代码并合并</td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-05-12T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Git分支管理</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Git/07.Git_branch_manage/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Git/07.Git_branch_manage/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="git-分支管理"> Git 分支管理</h2>
<p>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。</p>
<p>有人把 Git 的分支模型称为<strong>必杀技特性</strong>，而正是因为它，将 <strong>Git</strong> 从版本控制系统家族里区分出来。</p>
<p>创建分支命令：</p>
<div><pre><code><span>git</span> branch <span>(</span>branchname<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>切换分支命令:</p>
<div><pre><code><span>git</span> checkout <span>(</span>branchname<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。</p>
<p>合并分支命令:</p>
<div><pre><code><span>git</span> merge 
</code></pre>
<div><span>1</span><br></div></div><p>你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。</p>
<p>开始前我们先创建一个测试目录：</p>
<div><pre><code>$ <span>mkdir</span> gitdemo
$ <span>cd</span> gitdemo/
$ <span>git</span> init
Initialized empty Git repository<span>..</span>.
$ <span>touch</span> README
$ <span>git</span> <span>add</span> README
$ <span>git</span> commit -m <span>'第一次版本提交'</span>
<span>[</span>master <span>(</span>root-commit<span>)</span> 3b58100<span>]</span> 第一次版本提交
 <span>1</span> <span>file</span> changed, <span>0</span> insertions<span>(</span>+<span>)</span>, <span>0</span> deletions<span>(</span>-<span>)</span>
 create mode <span>100644</span> README
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="列出分支"> 列出分支</h3>
<p>列出分支基本命令：</p>
<div><pre><code><span>git</span> branch
</code></pre>
<div><span>1</span><br></div></div><p>没有参数时，<code>git branch</code> 会列出你在本地的分支。</p>
<div><pre><code>$ <span>git</span> branch
* master
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>此例的意思就是，我们有一个叫做 <strong>master</strong> 的分支，并且该分支是当前分支。</p>
<p>当你执行 <code>git init</code> 的时候，默认情况下 Git 就会为你创建 <strong>master</strong> 分支。</p>
<p>如果我们要手动创建一个分支。执行 <code>git branch (branchname)</code> 即可。</p>
<div><pre><code>$ <span>git</span> branch testing
$ <span>git</span> branch
* master
  testing
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>现在我们可以看到，有了一个新分支 <strong>testing</strong>。</p>
<p>当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了 <strong>testing</strong> 分支，Git 将还原你的工作目录到你创建分支时候的样子。</p>
<p>接下来我们将演示如何切换分支，我们用 <code>git checkout (branch)</code> 切换到我们要修改的分支。</p>
<div><pre><code>$ <span>ls</span>
README
$ <span>echo</span> <span>'runoob.com'</span> <span>></span> test.txt
$ <span>git</span> <span>add</span> <span>.</span>
$ <span>git</span> commit -m <span>'add test.txt'</span>
<span>[</span>master 3e92c19<span>]</span> <span>add</span> test.txt
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
 create mode <span>100644</span> test.txt
$ <span>ls</span>
README        test.txt
$ <span>git</span> checkout testing
Switched to branch <span>'testing'</span>
$ <span>ls</span>
README
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>当我们切换到 <strong>testing</strong> 分支的时候，我们添加的新文件 test.txt 被移除了。切换回 <strong>master</strong> 分支的时候，它们有重新出现了。</p>
<div><pre><code>$ <span>git</span> checkout master
Switched to branch <span>'master'</span>
$ <span>ls</span>
README        test.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>我们也可以使用 <code>git checkout -b (branchname)</code> 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。</p>
<div><pre><code>$ <span>git</span> checkout -b newtest
Switched to a new branch <span>'newtest'</span>
$ <span>git</span> <span>rm</span> test.txt 
<span>rm</span> <span>'test.txt'</span>
$ <span>ls</span>
README
$ <span>touch</span> runoob.php
$ <span>git</span> <span>add</span> <span>.</span>
$ <span>git</span> commit -am <span>'removed test.txt、add runoob.php'</span>
<span>[</span>newtest c1501a2<span>]</span> removed test.txt、add runoob.php
 <span>2</span> files changed, <span>1</span> deletion<span>(</span>-<span>)</span>
 create mode <span>100644</span> runoob.php
 delete mode <span>100644</span> test.txt
$ <span>ls</span>
README        runoob.php
$ <span>git</span> checkout master
Switched to branch <span>'master'</span>
$ <span>ls</span>
README        test.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>如你所见，我们创建了一个分支，在该分支的上移除了一些文件 test.txt，并添加了 runoob.php 文件，然后切换回我们的主分支，删除的 test.txt 文件又回来了，且新增加的 runoob.php 不存在主分支中。</p>
<p>使用分支将工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换。</p>
<h3 id="删除分支"> 删除分支</h3>
<p>删除分支命令：</p>
<div><pre><code><span>git</span> branch -d <span>(</span>branchname<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>例如我们要删除 testing 分支：</p>
<div><pre><code>$ <span>git</span> branch
* master
  testing
$ <span>git</span> branch -d testing
Deleted branch testing <span>(</span>was 85fc7e7<span>)</span>.
$ <span>git</span> branch
* master
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="分支合并"> 分支合并</h3>
<p>一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去：</p>
<div><pre><code><span>git</span> merge
$ <span>git</span> branch
* master
  newtest
$ <span>ls</span>
README        test.txt
$ <span>git</span> merge newtest
Updating 3e92c19<span>..</span>c1501a2
Fast-forward
 runoob.php <span>|</span> <span>0</span>
 test.txt   <span>|</span> <span>1</span> -
 <span>2</span> files changed, <span>1</span> deletion<span>(</span>-<span>)</span>
 create mode <span>100644</span> runoob.php
 delete mode <span>100644</span> test.txt
$ <span>ls</span>
README        runoob.php
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>以上实例中我们将 newtest 分支合并到主分支去，test.txt 文件被删除。</p>
<p>合并完后就可以删除分支:</p>
<div><pre><code>$ <span>git</span> branch -d newtest
Deleted branch newtest <span>(</span>was c1501a2<span>)</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>删除后， 就只剩下 master 分支了：</p>
<div><pre><code>$ <span>git</span> branch
* master
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="合并冲突"> 合并冲突</h3>
<p>合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。</p>
<div><pre><code>$ <span>git</span> branch
* master
$ <span>cat</span> runoob.php
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>首先，我们创建一个叫做 change_site 的分支，切换过去，我们将 runoob.php 内容改为:</p>
<div><pre><code><span>&lt;</span>?php
<span>echo</span> <span>'runoob'</span><span>;</span>
?<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>创建 change_site 分支：</p>
<div><pre><code>$ <span>git</span> checkout -b change_site
Switched to a new branch <span>'change_site'</span>
$ <span>vim</span> runoob.php
$ <span>head</span> -3 runoob.php
<span>&lt;</span>?php
<span>echo</span> <span>'runoob'</span><span>;</span>
?<span>></span>
$ <span>git</span> commit -am <span>'changed the runoob.php'</span>
<span>[</span>change_site <span>7774248</span><span>]</span> changed the runoob.php
 <span>1</span> <span>file</span> changed, <span>3</span> insertions<span>(</span>+<span>)</span>
 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>将修改的内容提交到 change_site 分支中。 现在，假如切换回 master 分支我们可以看内容恢复到我们修改前的(空文件，没有代码)，我们再次修改 runoob.php 文件。</p>
<div><pre><code>$ <span>git</span> checkout master
Switched to branch <span>'master'</span>
$ <span>cat</span> runoob.php
$ <span>vim</span> runoob.php    <span># 修改内容如下</span>
$ <span>cat</span> runoob.php
<span>&lt;</span>?php
<span>echo</span> <span>1</span><span>;</span>
?<span>></span>
$ <span>git</span> <span>diff</span>
<span>diff</span> --git a/runoob.php b/runoob.php
index e69de29<span>..</span>ac60739 <span>100644</span>
--- a/runoob.php
+++ b/runoob.php
@@ -0,0 +1,3 @@
+<span>&lt;</span>?php
+echo <span>1</span><span>;</span>
+?<span>></span>
$ <span>git</span> commit -am <span>'修改代码'</span>
<span>[</span>master c68142b<span>]</span> 修改代码
 <span>1</span> <span>file</span> changed, <span>3</span> insertions<span>(</span>+<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>现在这些改变已经记录到我的 &quot;master&quot; 分支了。接下来我们将 &quot;change_site&quot; 分支合并过来。</p>
<div><pre><code>$ <span>git</span> merge change_site
Auto-merging runoob.php
CONFLICT <span>(</span>content<span>)</span>: Merge conflict <span>in</span> runoob.php
Automatic merge failed<span>;</span> fix conflicts and <span>then</span> commit the result.

$ <span>cat</span> runoob.php     <span># 代开文件，看到冲突内容</span>
<span>&lt;</span>?php
<span>&lt;&lt;&lt;</span><span>&lt;&lt;&lt;</span><span>&lt;</span> HEAD
<span>echo</span> <span>1</span><span>;</span>
<span>==</span><span>==</span><span>==</span><span>=</span>
<span>echo</span> <span>'runoob'</span><span>;</span>
<span>>></span><span>>></span><span>>></span><span>></span> change_site
?<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>我们将前一个分支合并到 master 分支，一个合并冲突就出现了，接下来我们需要手动去修改它。</p>
<div><pre><code>$ <span>vim</span> runoob.php 
$ <span>cat</span> runoob.php
<span>&lt;</span>?php
<span>echo</span> <span>1</span><span>;</span>
<span>echo</span> <span>'runoob'</span><span>;</span>
?<span>></span>
$ <span>git</span> <span>diff</span>
<span>diff</span> --cc runoob.php
index ac60739,b63d7d7<span>..</span>0000000
--- a/runoob.php
+++ b/runoob.php
@@@ -1,3 -1,3 +1,4 @@@
  <span>&lt;</span>?php
 +echo <span>1</span><span>;</span>
+ <span>echo</span> <span>'runoob'</span><span>;</span>
  ?<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决</p>
<div><pre><code>$ <span>git</span> status -s
UU runoob.php
$ <span>git</span> <span>add</span> runoob.php
$ <span>git</span> status -s
M  runoob.php
$ <span>git</span> commit
<span>[</span>master 88afe0e<span>]</span> Merge branch <span>'change_site'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>现在我们成功解决了合并中的冲突，并提交了结果。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-05-12T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Git查看提交历史</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Git/08.Git_log/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Git/08.Git_log/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="git-查看提交历史"> Git 查看提交历史</h2>
<p>Git 提交历史一般常用两个命令：</p>
<ul>
<li><code>git log</code>：查看历史提交记录。</li>
<li><code>git blame &lt;file&gt;</code>：以列表形式查看指定文件的历史修改记录。</li>
</ul>
<h3 id="git-log"> git log</h3>
<p>在使用 Git 提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用 <code>git log</code> 命令查看。</p>
<p>针对我们前一章节的操作，使用 <code>git log</code> 命令列出历史提交记录如下：</p>
<div><pre><code>$ <span>git</span> log
commit d5e9fc2c811e0ca2b2d28506ef7dc14171a207d9 <span>(</span>HEAD -<span>></span> master<span>)</span>
Merge: c68142b <span>7774248</span>
Author: runoob <span>&lt;</span>test@runoob.com<span>></span>
Date:   Fri May <span>3</span> <span>15</span>:55:58 <span>2019</span> +0800
  
    Merge branch <span>'change_site'</span>
  
commit c68142b562c260c3071754623b08e2657b4c6d5b
Author: runoob <span>&lt;</span>test@runoob.com<span>></span>
Date:   Fri May <span>3</span> <span>15</span>:52:12 <span>2019</span> +0800
  
    修改代码
  
commit 777424832e714cf65d3be79b50a4717aea51ab69 <span>(</span>change_site<span>)</span>
Author: runoob <span>&lt;</span>test@runoob.com<span>></span>
Date:   Fri May <span>3</span> <span>15</span>:49:26 <span>2019</span> +0800
  
    changed the runoob.php
  
commit c1501a244676ff55e7cccac1ecac0e18cbf6cb00
Author: runoob <span>&lt;</span>test@runoob.com<span>></span>
Date:   Fri May <span>3</span> <span>15</span>:35:32 <span>2019</span> +0800
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>我们可以用 <strong>--oneline</strong> 选项来查看历史记录的简洁的版本。</p>
<div><pre><code>$ <span>git</span> log --oneline
d5e9fc2 <span>(</span>HEAD -<span>></span> master<span>)</span> Merge branch <span>'change_site'</span>
c68142b 修改代码
<span>7774248</span> <span>(</span>change_site<span>)</span> changed the runoob.php
c1501a2 removed test.txt、add runoob.php
3e92c19 <span>add</span> test.txt
3b58100 第一次版本提交
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这告诉我们的是，此项目的开发历史。</p>
<p>我们还可以用 <strong>--graph</strong> 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项：</p>
<div><pre><code>$ <span>git</span> log --graph
*   d5e9fc2 <span>(</span>HEAD -<span>></span> master<span>)</span> Merge branch <span>'change_site'</span>
<span>|</span><span>\</span>  
<span>|</span> * <span>7774248</span> <span>(</span>change_site<span>)</span> changed the runoob.php
* <span>|</span> c68142b 修改代码
<span>|</span>/  
* c1501a2 removed test.txt、add runoob.php
* 3e92c19 <span>add</span> test.txt
* 3b58100 第一次版本提交
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>现在我们可以更清楚明了地看到何时工作分叉、又何时归并。</p>
<p>你也可以用 <strong>--reverse</strong> 参数来逆向显示所有日志。</p>
<div><pre><code>$ <span>git</span> log --reverse --oneline
3b58100 第一次版本提交
3e92c19 <span>add</span> test.txt
c1501a2 removed test.txt、add runoob.php
<span>7774248</span> <span>(</span>change_site<span>)</span> changed the runoob.php
c68142b 修改代码
d5e9fc2 <span>(</span>HEAD -<span>></span> master<span>)</span> Merge branch <span>'change_site'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>如果只想查找指定用户的提交日志可以使用命令：<code>git log --author</code> , 例如，比方说我们要找 Git 源码中 Linus 提交的部分：</p>
<div><pre><code>$ <span>git</span> log --author<span>=</span>Linus --oneline -5
81b50f3 Move <span>'builtin-*'</span> into a <span>'builtin/'</span> subdirectory
3bb7256 <span>make</span> <span>"index-pack"</span> a built-in
377d027 <span>make</span> <span>"git pack-redundant"</span> a built-in
b532581 <span>make</span> <span>"git unpack-file"</span> a built-in
112dd51 <span>make</span> <span>"mktag"</span> a built-in
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>如果你要指定日期，可以执行几个选项：<strong>--since</strong> 和 <strong>--before</strong>，但是你也可以用 <strong>--until</strong> 和 <strong>--after</strong>。</p>
<p>例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 <strong>--no-merges</strong> 选项以隐藏合并提交）：</p>
<div><pre><code>$ <span>git</span> log --oneline --before<span>=</span><span>{</span><span>3</span>.weeks.ago<span>}</span> --after<span>=</span><span>{</span><span>2010</span>-04-18<span>}</span> --no-merges
5469e2d Git <span>1.7</span>.1-rc2
d43427d Documentation/remote-helpers: Fix typos and improve language
272a36b Fixup: Second argument may be any arbitrary string
b6c8d2d Documentation/remote-helpers: Add invocation section
5ce4f4e Documentation/urls: Rewrite to accomodate transport::address
00b84e9 Documentation/remote-helpers: Rewrite description
03aa87e Documentation: Describe other situations where -z affects <span>git</span> <span>diff</span>
77bc694 rebase-interactive: silence warning when no commits rewritten
636db2c t3301: <span>add</span> tests to use --format<span>=</span><span>"%N"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>更多 git log 命令可查看：http://git-scm.com/docs/git-log</p>
<h3 id="git-blame"> git blame</h3>
<p>如果要查看指定文件的修改记录可以使用 <code>git blame</code> 命令，格式如下：</p>
<div><pre><code><span>git</span> blame <span>&lt;</span>file<span>></span>
</code></pre>
<div><span>1</span><br></div></div><p>git blame 命令是以列表形式显示修改记录，如下实例：</p>
<div><pre><code>$ <span>git</span> blame README 
^d2097aa <span>(</span>tianqixin <span>2020</span>-08-25 <span>14</span>:59:25 +0800 <span>1</span><span>)</span> <span># Runoob Git 测试</span>
db9315b0 <span>(</span>runoob    <span>2020</span>-08-25 <span>16</span>:00:23 +0800 <span>2</span><span>)</span> <span># 菜鸟教程 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-05-12T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Git标签</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Git/09.Git_tag/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Git/09.Git_tag/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="git-标签"> Git 标签</h2>
<p>如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 <code>git tag</code> 给它打上标签。</p>
<p>比如说，我们想为我们的 runoob 项目发布一个&quot;1.0&quot;版本。 我们可以用 <code>git tag -a v1.0</code> 命令给最新一次提交打上（HEAD）&quot;v1.0&quot;的标签。</p>
<p><strong>-a</strong> 选项意为&quot;创建一个带注解的标签&quot;。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。</p>
<div><pre><code>$ <span>git</span> tag -a v1.0 
</code></pre>
<div><span>1</span><br></div></div><p>当你执行 <code>git tag -a</code> 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。</p>
<p>现在，注意当我们执行 <code>git log --decorate</code> 时，我们可以看到我们的标签了：</p>
<div><pre><code>$ <span>git</span> log --decorate
*   d5e9fc2 <span>(</span>HEAD -<span>></span> master<span>)</span> Merge branch <span>'change_site'</span>
<span>|</span><span>\</span>  
<span>|</span> * <span>7774248</span> <span>(</span>change_site<span>)</span> changed the runoob.php
* <span>|</span> c68142b 修改代码
<span>|</span>/  
* c1501a2 removed test.txt、add runoob.php
* 3e92c19 <span>add</span> test.txt
* 3b58100 第一次版本提交
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。</p>
<p>例如，假设我们发布了提交 85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。 我们现在也可以：</p>
<div><pre><code>$ <span>git</span> tag -a v0.9 85fc7e7
$ <span>git</span> log --oneline --decorate --graph
*   d5e9fc2 <span>(</span>HEAD -<span>></span> master<span>)</span> Merge branch <span>'change_site'</span>
<span>|</span><span>\</span>  
<span>|</span> * <span>7774248</span> <span>(</span>change_site<span>)</span> changed the runoob.php
* <span>|</span> c68142b 修改代码
<span>|</span>/  
* c1501a2 removed test.txt、add runoob.php
* 3e92c19 <span>add</span> test.txt
* 3b58100 <span>(</span>tag: v0.9<span>)</span> 第一次版本提交
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>如果我们要查看所有标签可以使用以下命令：</p>
<div><pre><code>$ git tag
v0.9
v1.0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>指定标签信息命令：</p>
<div><pre><code>git tag -a &lt;tagname&gt; -m &quot;runoob.com标签&quot;
</code></pre>
<div><span>1</span><br></div></div><p>PGP签名标签命令：</p>
<div><pre><code>git tag -s &lt;tagname&gt; -m &quot;runoob.com标签&quot;
</code></pre>
<div><span>1</span><br></div></div><h2 id=""> </h2>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-05-12T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Git远程仓库（GitHub）</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Git/10.Git_remote/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Git/10.Git_remote/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="git-远程仓库-github"> Git 远程仓库（GitHub）</h2>
<p>目前我们使用到的 Git 命令都是在本地执行，如果你想通过 Git 分享你的代码或者与其他开发人员合作。 你就需要将数据放到一台其他开发人员能够连接的服务器上。</p>
<p>本例使用了 Github 作为远程仓库，你可以先阅读的 <a href="https://www.runoob.com/w3cnote/git-guide.html" target="_blank" rel="noopener noreferrer">Github 简明教程。</a></p>
<p><img src="./assets/Git-push-command.jpg" alt="Git-push-command" loading="lazy"></p>
<h3 id="添加远程库"> 添加远程库</h3>
<p>要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用,命令格式如下：</p>
<div><pre><code><span>git</span> remote <span>add</span> <span>[</span>shortname<span>]</span> <span>[</span>url<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>本例以 Github 为例作为远程仓库，如果你没有 Github 可以在官网 https://github.com/注册。</p>
<p>由于你的本地 Git 仓库和 GitHub 仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息：</p>
<p>使用以下命令生成 SSH Key：</p>
<div><pre><code>$ ssh-keygen -t rsa -C <span>"youremail@example.com"</span>
</code></pre>
<div><span>1</span><br></div></div><p>后面的 <em>your_email@youremail.com</em> 改为你在 Github 上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。</p>
<p>成功的话会生成 <code>~/.ssh/id_rsa.pub</code>，打开复制里面的 <strong>key</strong>。</p>
<div><pre><code>$ ssh-keygen -t rsa -C <span>"429240967@qq.com"</span>
Generating public/private rsa key pair.
Enter <span>file</span> <span>in</span> <span>which</span> to save the key <span>(</span>/Users/tianqixin/.ssh/id_rsa<span>)</span>: 
Enter passphrase <span>(</span>empty <span>for</span> no passphrase<span>)</span>:    <span># 直接回车</span>
Enter same passphrase again:                   <span># 直接回车</span>
Your identification has been saved <span>in</span> ~/.ssh/id_rsa.
Your public key has been saved <span>in</span> ~/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:MDKVidPTDXIQoJwoqUmI4LBAsg5XByBlrOEzkxrwARI <span>429240967</span>@qq.com
The key's randomart image is:
+---<span>[</span>RSA <span>3072</span><span>]</span>----+
<span>|</span>E*+.<span>+=</span>**oo       <span>|</span>
<span>|</span>%Oo+oo<span>=</span>o. <span>.</span>      <span>|</span>
<span>|</span>%**.o.o.         <span>|</span>
<span>|</span>OO.  o o         <span>|</span>
<span>|</span>+o+     S        <span>|</span>
<span>|</span><span>.</span>                <span>|</span>
<span>|</span>                 <span>|</span>
<span>|</span>                 <span>|</span>
<span>|</span>                 <span>|</span>
+----<span>[</span>SHA256<span>]</span>-----+
$ <span>cat</span> ~/.ssh/id_rsa.pub
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>回到 github 上，进入 <strong>Account =&gt; Settings</strong>（账户配置）。</p>
<p><img src="./assets/Account_settings.png" alt="Account_settings" loading="lazy"></p>
<p>左边选择 <strong>SSH and GPG keys</strong>，然后点击 <strong>New SSH key</strong> 按钮。</p>
<p><img src="./assets/SSH_and_PGP_keys.png" alt="SSH and GPG keys" loading="lazy"></p>
<p><em>title</em> 设置标题，可以随便填，<em>key</em> 粘贴在你电脑上生成的 <strong>key</strong>（ 上面生成的<code>~/.ssh/id_rsa.pub</code>文件内容），最后点击<strong>Add SSH key</strong>按钮添加。</p>
<p><img src="./assets/add_key.png" alt="add_key" loading="lazy"></p>
<p>添加成功后界面如下所示</p>
<p><img src="./assets/SSH_and_PGP_keys.png" alt="SSH and GPG keys" loading="lazy"></p>
<p>为了验证是否成功，输入以下命令：</p>
<div><pre><code>$ <span>ssh</span> -T git@github.com
The authenticity of <span>host</span> <span>'github.com (52.74.223.119)'</span> can<span>'t be established.
RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes                   # 输入 yes
Warning: Permanently added '</span>github.com,52.74.223.119<span>' (RSA) to the list of known hosts.
Hi tianqixin! You'</span>ve successfully authenticated, but GitHub does not provide shell access. <span># 成功信息</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>以上命令说明我们已成功连上 Github。</p>
<p>之后点击 <strong>New repository</strong> 如下图所示：</p>
<p><img src="./assets/New_repository.png" alt="New_repository" loading="lazy"></p>
<p>之后在在 <strong>Repository name</strong> 填入 myblog（远程仓库名） ，其他保持默认设置，点击<strong>Create repository</strong>按钮，就成功地创建了一个新的Git仓库：</p>
<p><img src="./assets/repository_name.png" alt="repository_name" loading="lazy"></p>
<p>创建成功后，显示如下信息：</p>
<p><img src="./assets/created_repository.png" alt="created_repository" loading="lazy"></p>
<p>以上信息告诉我们可以从这个仓库克隆出新的仓库，也可以把本地仓库的内容推送到 GitHub 仓库。</p>
<p>现在，我们根据 GitHub 的提示，在本地的仓库下运行命令：</p>
<div><pre><code>$ <span>mkdir</span> myblog		                        <span># 创建测试目录</span>
$ <span>cd</span> myblog/                    		    <span># 进入测试目录</span>
$ <span>echo</span> <span>"# Git 测试"</span> <span>>></span> README.md     <span># 创建 README.md 文件并写入内容</span>
$ <span>ls</span>                                        <span># 查看目录下的文件</span>
README
$ <span>git</span> init                                  <span># 初始化</span>
$ <span>git</span> <span>add</span> README.md                         <span># 添加文件</span>
$ <span>git</span> commit -m <span>"添加 README.md 文件"</span>        <span># 提交并备注信息</span>
<span>[</span>master <span>(</span>root-commit<span>)</span> 0205aab<span>]</span> 添加 README.md 文件
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
 create mode <span>100644</span> README.md

<span># 提交到 Github</span>
$ <span>git</span> remote <span>add</span> origin git@github.com:Ryukarin/myblog.git
$ <span>git</span> push -u origin master
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>以下命令请根据你在 Github 成功创建新仓库的地方复制，而不是根据我提供的命令，因为我们的 Github 用户名不一样，仓库名也不一样。</p>
<p>接下来我们返回 Github 创建的仓库，就可以看到文件已上传到 Github上：</p>
<p><img src="./assets/push.png" alt="push" loading="lazy"></p>
<h3 id="查看当前的远程库"> 查看当前的远程库</h3>
<p>要查看当前配置有哪些远程仓库，可以用命令：</p>
<div><pre><code><span>git</span> remote
</code></pre>
<div><span>1</span><br></div></div><p>实例</p>
<div><pre><code>$ <span>git</span> remote
origin
$ <span>git</span> remote -v
origin	git@github.com:Ryukarin/myblog.git <span>(</span>fetch<span>)</span>
origin	git@github.com:Ryukarin/myblog.git <span>(</span>push<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>执行时加上 <strong>-v</strong> 参数，你还可以看到每个别名的实际链接地址。</p>
<h3 id="提取远程仓库"> 提取远程仓库</h3>
<p>Git 有两个命令用来提取远程仓库的更新。</p>
<ol>
<li>从远程仓库下载新分支与数据：</li>
</ol>
<div><pre><code><span>git</span> fetch
</code></pre>
<div><span>1</span><br></div></div><p>该命令执行完后需要执行 <code>git merge</code> 远程分支到你所在的分支。</p>
<ol start="2">
<li>从远端仓库提取数据并尝试合并到当前分支：</li>
</ol>
<div><pre><code><span>git</span> merge
</code></pre>
<div><span>1</span><br></div></div><p>该命令就是在执行 <code>git fetch</code> 之后紧接着执行 <code>git merge</code> 远程分支到你所在的任意分支。</p>
<p>假设你配置好了一个远程仓库，并且你想要提取更新的数据，你可以首先执行 <code>git fetch [alias]</code> 告诉 Git 去获取它有你没有的数据，然后你可以执行 <code>git merge [alias]/[branch]</code> 以将服务器上的任何更新（假设有人这时候推送到服务器了）合并到你的当前分支。</p>
<p>接下来我们在 Github 上点击 <strong>README.md</strong> 并在线修改它:</p>
<p><img src="./assets/edit_readme.png" alt="edit readme" loading="lazy"></p>
<p>修改好 <strong>README.md</strong> 之后，点击底部的 <strong>Commit changes</strong> 按钮。</p>
<p><img src="./assets/Commit_changes.png" alt="Commit changes" loading="lazy"></p>
<p>然后我们在本地更新修改。</p>
<div><pre><code>$ <span>git</span> fetch origin
remote: Counting objects: <span>3</span>, done.
remote: Compressing objects: <span>100</span>% <span>(</span><span>2</span>/2<span>)</span>, done.
remote: Total <span>3</span> <span>(</span>delta <span>0</span><span>)</span>, reused <span>0</span> <span>(</span>delta <span>0</span><span>)</span>, pack-reused <span>0</span>
Unpacking objects: <span>100</span>% <span>(</span><span>3</span>/3<span>)</span>, done.
From github.com:Ryukarin/myblog
   0205aab<span>..</span>febd8ed  master     -<span>></span> origin/main
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>以上信息&quot;0205aab..febd8ed master -&gt; origin/master&quot; 说明 main 分支已被更新，我们可以使用以下命令将更新同步到本地：</p>
<div><pre><code>$ <span>git</span> merge origin/main
Updating 0205aab<span>..</span>febd8ed
Fast-forward
 README.md <span>|</span> <span>1</span> +
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>查看 README.md 文件内容：</p>
<div><pre><code>$ <span>cat</span> README.md 
<span># Git 测试</span>
---
<span>## 第一次修改内容（二级标题）</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="推送到远程仓库"> 推送到远程仓库</h3>
<p>推送你的新分支与数据到某个远端仓库命令：</p>
<div><pre><code><span>git</span> push <span>[</span>alias<span>]</span> <span>[</span>branch<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>以上命令将你的 [branch] 分支推送成为 [alias] 远程仓库上的 [branch] 分支，实例如下。</p>
<div><pre><code>$ <span>touch</span> test.txt      <span># 添加文件</span>
$ <span>git</span> <span>add</span> test.txt 
$ <span>git</span> commit -m <span>"添加到远程"</span>
master 69e702d<span>]</span> 添加到远程
 <span>1</span> <span>file</span> changed, <span>0</span> insertions<span>(</span>+<span>)</span>, <span>0</span> deletions<span>(</span>-<span>)</span>
 create mode <span>100644</span> test.txt

$ <span>git</span> push origin master    <span># 推送到 Github</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>重新回到我们的 Github 仓库，可以看到文件已经提交上来了：</p>
<p><img src="./assets/add_remote.png" alt="add remote" loading="lazy"></p>
<h3 id="删除远程仓库"> 删除远程仓库</h3>
<p>删除远程仓库你可以使用命令：</p>
<div><pre><code><span>git</span> remote <span>rm</span> <span>[</span>别名<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>实例</p>
<div><pre><code>$ <span>git</span> remote -v
origin    git@github.com:Ryukarin/myblog.git <span>(</span>fetch<span>)</span>
origin    git@github.com:Ryukarin/myblog.git <span>(</span>push<span>)</span>

<span># 添加仓库 origin2</span>
$ <span>git</span> remote <span>add</span> origin2 git@github.com:Ryukarin/myblog.git

$ <span>git</span> remote -v
origin    git@github.com:Ryukarin/myblog.git <span>(</span>fetch<span>)</span>
origin    git@github.com:Ryukarin/myblog.git <span>(</span>push<span>)</span>
origin2    git@github.com:Ryukarin/myblog.git <span>(</span>fetch<span>)</span>
origin2    git@github.com:Ryukarin/myblog.git <span>(</span>push<span>)</span>

<span># 删除仓库 origin2</span>
$ <span>git</span> remote <span>rm</span> origin2
$ <span>git</span> remote -v
origin    git@github.com:Ryukarin/myblog.git <span>(</span>fetch<span>)</span>
origin    git@github.com:Ryukarin/myblog.git <span>(</span>push<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><div><p>码云（Gitee）</p>
<p>大家都知道国内访问 Github 速度比较慢，很影响我们的使用。</p>
<p>如果你希望体验到 Git 飞一般的速度，可以使用国内的 Git 托管服务——<a href="https://gitee.com/?utm_source=remote_blog_cnjc" target="_blank" rel="noopener noreferrer">Gitee（gitee.com）</a>。</p>
<p>Gitee 提供免费的 Git 仓库，还集成了代码质量检测、项目演示等功能。对于团队协作开发，Gitee 还提供了项目管理、代码托管、文档管理的服务，5 人以下小团队免费。</p>
<p>使用方法和  Github 大同小异，具体就不展开说了。</p>
</div>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-05-12T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Git服务器搭建</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Git/11.Git_server/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Git/11.Git_server/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="git-服务器搭建"> Git 服务器搭建</h2>
<p>前面我们远程仓库使用了 Github，Github 公开的项目是免费的，2019 年开始 Github 私有存储库也可以无限制使用。</p>
<p>这当然我们也可以自己搭建一台 Git 服务器作为私有仓库使用。</p>
<p>接下来我们将以 Centos 为例搭建 Git 服务器。</p>
<h3 id="安装git"> 安装Git</h3>
<div><pre><code>$ yum <span>install</span> curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel
$ yum <span>install</span> <span>git</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>接下来我们 创建一个git用户组和用户，用来运行git服务：</p>
<div><pre><code>$ <span>groupadd</span> <span>git</span>
$ <span>useradd</span> <span>git</span> -g <span>git</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="创建证书登录"> 创建证书登录</h3>
<p>收集所有需要登录的用户的公钥，公钥位于id_rsa.pub文件中，把我们的公钥导入到<code>/home/git/.ssh/authorized_keys</code>文件里，一行一个。</p>
<p>如果没有该文件创建它：</p>
<div><pre><code>$ <span>cd</span> /home/git/
$ <span>mkdir</span> .ssh
$ <span>chmod</span> <span>755</span> .ssh
$ <span>touch</span> .ssh/authorized_keys
$ <span>chmod</span> <span>644</span> .ssh/authorized_keys
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="初始化git仓库"> 初始化Git仓库</h3>
<p>首先我们选定一个目录作为 Git 仓库，假定是 <code>/home/gitrepo/runoob.git</code>，在 <code>/home/gitrepo</code> 目录下输入命令：</p>
<div><pre><code>$ <span>cd</span> /home
$ <span>mkdir</span> gitrepo
$ <span>chown</span> git:git gitrepo/
$ <span>cd</span> gitrepo

$ <span>git</span> init --bare runoob.git
Initialized empty Git repository <span>in</span> /home/gitrepo/runoob.git/
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>以上命令 Git 创建一个空仓库，服务器上的Git仓库通常都以 .git 结尾。然后，把仓库所属用户改为git：</p>
<div><pre><code>$ <span>chown</span> -R git:git runoob.git
</code></pre>
<div><span>1</span><br></div></div><h3 id="克隆仓库"> 克隆仓库</h3>
<div><pre><code>$ <span>git</span> clone git@192.168.45.4:/home/gitrepo/runoob.git
Cloning into <span>'runoob'</span><span>..</span>.
warning: You appear to have cloned an empty repository.
Checking connectivity<span>..</span>. done.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>192.168.45.4 为 Git 所在服务器 ip ，你需要将其修改为你自己的 Git 服务 ip。</p>
<p>这样我们的 Git 服务器安装就完成。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-05-12T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Git介绍</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Git/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Git/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="git-是什么"> Git 是什么</h2>
<p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p>
<p>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p>
<p>Git 与常用的版本控制工具 CVS，Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。</p>
<p>Git 不仅仅是个版本控制系统，它也是个内容管理系统（CMS），工作管理系统等。</p>
<p><img src="./assets/dvcs.png" alt="dvcs" loading="lazy"></p>
<h2 id="git-的诞生"> Git 的诞生</h2>
<p>很多人都知道，Linus Torvalds 在 1991 年创建了开源的 Linux，从此，Linux 系统不断发展，已经成为最大的服务器系统软件了。</p>
<p>Linus Torvalds 虽然创建了 Linux，但 Linux 的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为 Linux 编写代码，那 Linux 的代码是如何管理的呢？</p>
<p>事实是，在 2002 年以前，世界各地的志愿者把源代码文件通过 diff 的方式发给 Linus Torvalds，然后由 Linus Torvalds 本人通过手工方式合并代码！</p>
<p>你也许会想，为什么 Linus Torvalds 不把 Linux 代码放到版本控制系统里呢？不是有 CVS、SVN 这些免费的版本控制系统吗？因为Linus Torvalds坚定地反对 CVS 和 SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比 CVS、SVN 好用，但那是付费的，和 Linux 的开源精神不符。</p>
<p>不过，到了 2002 年，Linux 系统已经发展了十年了，代码库之大让 Linus Torvalds 很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是 Linus Torvalds 选择了一个商业的版本控制系统 BitKeeper，BitKeeper 的东家BitMover 公司出于人道主义精神，授权 Linux 社区免费使用这个版本控制系统。</p>
<p>安定团结的大好局面在 2005 年就被打破了，原因是 Linux 社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发 Samba 的 Andrew 试图破解 BitKeeper 的协议（这么干的其实也不只他一个），被 BitMover 公司发现了（监控工作做得不错！），于是 BitMover 公司怒了，要收回 Linux 社区的免费使用权。</p>
<p>Linus Torvalds 可以向 BitMover 公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：</p>
<p>Linus Torvalds 花了两周时间自己用 C 写了一个分布式版本控制系统，这就是 Git！一个月之内，Linux 系统的源码已经由 Git 管理了！牛是怎么定义的呢？大家可以体会一下。</p>
<p>Git 迅速成为最流行的分布式版本控制系统，尤其是 2008 年，GitHub 网站上线了，它为开源项目免费提供 Git 存储，无数开源项目开始迁移至 GitHub，包括 jQuery，PHP，Ruby 等等。</p>
<p>历史就是这么偶然，如果不是当年 BitMover 公司威胁 Linux 社区，可能现在我们就没有免费而超级好用的 Git 了。</p>
<h2 id="gitub-是什么"> Gitub 是什么</h2>
<p>GitHub 是一个面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。</p>
<p>GitHub 于 2008 年 4 月 10 日正式上线，除了 Git 代码仓库托管及基本的 Web 管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。目前，其注册用户已经超过 350 万，托管版本数量也是非常之多，其中不乏知名开源项目 Ruby on Rails、jQuery、python 等。
2018 年 6 月 4 日，微软宣布，通过 75 亿美元的股票交易收购代码托管平台 GitHub。</p>
<div><p>了解</p>
<p>GitHub 使用 git 分布式版本控制系统，而 git 最初是 LinusTorvalds 为帮助 Linux 开发而创造的，它针对的是 Linux 平台，因此 git 和 Windows 从来不是最好的朋友，因为它一点也不像 Windows。GitHub 发布了 GitHub for Windows，为 Windows 平台开发者提供了一个易于使用的 Git 图形客户端。
GitHub for Windows 是一个 Metro 风格应用程序，集成了自包含版本的 Git，bash 命令行 shell，PowerShell 的 posh-git 扩展。GitHub 为 Windows 用户提供了一个基本的图形前端去处理大部分常用版本控制任务，可以创建版本库，向本地版本库递交补丁，在本地和远程版本库之间同步。微软也通过 CodePlex 向开发者提供 git 版本控制系统，而 GitHub 创造了一个更具有吸引力的 Windows 版本。</p>
</div>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-05-12T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">linux的管理建议</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_basic/01.linux_atten/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_basic/01.linux_atten/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="学习-linux-的注意事项"> 学习 Linux 的注意事项</h2>
<p>对于初学者来说几个容易混淆的问题，便于让大家对 Linux 有一个初步了解。</p>
<h3 id="linux-严格区分大小写"> Linux 严格区分大小写</h3>
<p>Linux 是严格区分大小写的，这一点和 Windows 不一样，所以操作时要注意区分大小写的不同，包括文件名和目录名、命令、命令选项、配置文件设置选项等。</p>
<h3 id="linux-中所有内容以文件形式保存-包括硬件设备"> Linux 中所有内容以文件形式保存，包括硬件设备</h3>
<p>Linux 中所有内容都是以文件的形式保存和管理的，硬件设备也是文件，这和 Windows 完全不同，Windows 是通过设备管理器来管理硬件的。Linux 的设备文件保存在 <code>/dev/</code> 目录中， 硬盘文件是 <code>/dev/sd[a-p]</code>，光盘文件是 <code>/dev/hdc</code>  等。</p>
<h3 id="linux-不靠扩展名区分文件类型"> Linux 不靠扩展名区分文件类型</h3>
<p>Windows 是依赖扩展名区分文件类型的，比如，“.txt”是文本文件、“.exe”是执行文件、 “.ini”是配置文件、“.mp4”是小电影等。但 Linux 不是靠扩展名区分文件类型的，而是靠权限位标识来确定文件类型的，而且文件类型的种类也不像 Windows 下那么多，常见的文件类型只有普通文件、目录、链接文件、块设备文件、字符设备文件等几种。Linux 的可执行文件不过就是普通文件被赋予了可执行权限而已。
但 Linux 中的一些特殊文件还是要求写“扩展名”的，但是大家小心，并不是 Linux一定要靠扩展名来识别文件类型，写这些扩展名是为了帮助管理员来区分不同的文件类型。这样的文件扩展名主要有以下几种。</p>
<ul>
<li>
<p>压缩包：Linux 下常见的压缩文件名有 <strong>*.gz、*.bz2、*.zip、*.tar.gz、*.tar.bz2、*.tgz</strong> 等。 为什么压缩包一定要写扩展名呢？其实很好理解，如果不写清楚扩展名，那么管理员不容易判断压缩包的格式，虽然有命令可以帮助判断，但是直观一点更加方便。另外，就算没写扩展名，在 Linux 中一样可以解压缩，不影响使用。</p>
</li>
<li>
<p>二进制软件包：CentOS 中所使用的二进制安装包是 RPM 包，所有的 RPM 包都用 <strong>*.rpm</strong> 扩展名结尾，目的同样是让管理员一目了然。</p>
</li>
<li>
<p>程序文件：Shell 脚本一般用 <strong>*.sh</strong> 扩展名结尾，其他还有用 <strong>*.c</strong> 扩展名结尾的 C 语言文件等。</p>
</li>
<li>
<p>网页文件：网页文件一般使用 <strong>*.html、*.php</strong> 等结尾，不过这是网页服务器的要求，而不是 Linux 的要求。 在此不一一列举了，还有如日常使用较多的图片文件、视频文件、Office 文件等，也 是如此。</p>
</li>
</ul>
<h3 id="linux-中所有的存储设备都必须在挂载之后才能使用"> Linux 中所有的存储设备都必须在挂载之后才能使用</h3>
<p>Limux 中所有的存储设备都有自己的设备文件名，这些设备文件必须在挂载之后才能使用，包括硬盘、U 盘和光盘。挂载其实就是给这些存储设备分配盘符，只不过 Windows 中的盘符用英文字母表示，而 Linux 中的盘符则是一个已经建立的空目录。我们把这些空目录叫作挂载点（可以理解为 Windows 的盘符），把设备文件（如 <code>/dev/sdb</code>）和挂载点（已经建立的空目录）连接的过程叫作挂载。这个过程是通过挂载命令实现的。</p>
<h3 id="windows-下的程序不能直接在-linux-中使用"> Windows 下的程序不能直接在 Linux 中使用</h3>
<p>Linux 和 Windows 是不同的操作系统，可以安装和使用的软件也是不同的，所以能够在 Windows 中安装的软件是不能在 Linux 中安装的。有好处吗？当然有，那就是能够感染 Windows 的病毒和木马都对 Linux 无效。有坏处吗？也有，那就是所有的软件要想在 Linux 中安装，必须单独开发针对 Linux 的版本，或者依赖模拟器软件运行。很多软件也会同时推出针对 Windows 和 Linux 的版本，如大家熟悉的即时通信软件 QQ。</p>
<h2 id="服务器的管理和维护建议"> 服务器的管理和维护建议</h2>
<p>下面这些服务器操作规范和建议初学者可能不容易看懂，因为我们还没有完整地学习一遍 Linux，但是这些经验之谈对服务器的管理和维护都非常重要，大家可以在系统学习之后，再回过头来阅读这部分内容，一定会有新的体验。当然，限于我们的知识和能力，这些地方也可能有疏漏和不足。</p>
<h3 id="了解-linux-目录结构"> 了解 Linux 目录结构</h3>
<p>Linux 是一个非常严谨的操作系统，每个目录存放何种文件都有明确的要求。作为管理员，首先要了解这些目录的作用，然后严格按照目录要求进行操作。</p>
<p>Linux 中的目录有很多，了解根目录下主要的一级目录和几个常见的二级目录的作用。</p>
<p>详见《Linux文件系统结构》一章内容</p>
<h3 id="远程服务器关机及重启的注意事项"> 远程服务器关机及重启的注意事项</h3>
<p>为什么远程服务器不能关机呢？很简单，远程服务器没有放置在本地，关机后，谁可以帮你按开机电源键启动服务器？虽然计算机技术日新月异，但是像插入电源和开机这样的工作还是需要手工进行的。如果服务器在远程，一旦关机，就只能求助托管机房的管理人员帮你为机了。</p>
<p>远程服务器重启时需要注意两点。</p>
<ol>
<li><strong>远程服务器在重启前，要中止正在执行的服务</strong></li>
</ol>
<p>计算机的硬盘最怕在高速存储时断电或重启，非常容易造成硬盘损坏。所以，在重启前先中止你的服务，甚至可以考虑暂时断开对外提供服务的网络。可能你会觉得服务器有这么娇贵吗？我的笔记本电脑经常强行关机,也没有发现硬盘损坏啊？这是因为你的个人计算机没有的很多人访问，强制断电时硬盘并没有进行数据交换。小心驶得万年船！</p>
<ol start="2">
<li><strong>重启命令的选用</strong></li>
</ol>
<p>Linux 可以识别的重启命令有很多条，但是建议大家使用 <code>shutdown -r now</code> 命令重启，这条命令在重启时会正常保存和中止服务器中正在运行的程序，是安全重启命令。而且最好在重启前执行几次 <code>sync</code> 命令，这条命令是数据同步命令，可以让暂时保存在内存中的数据向步到硬盘上。</p>
<p>总之，重启和关机也是服务器需要注意的操作规范，因为不正确的重启和关机造成服务器故障的不在少数。</p>
<h3 id="不要在服务器访问高峰运行高负载命令"> 不要在服务器访问高峰运行高负载命令</h3>
<p>这一点大家很好理解，在服务器访问高峰，如果使用一些对服务器压力较大的命令，则有可能会造成服务器响应缓慢甚至死机。</p>
<p>哪些命令是高负载命令呢？其实，如果大家使用过 Windows 操作系统，则也会留意到一些操作会给计算机带来较大的运算压力，道理都是一样的，如复制大量的数据、压缩或者解压缩大文件、大范围的硬盘搜索等。</p>
<p>什么时间算作访问高峰期呢？我们一般认为 17:00—24:00 算作访问高峰期。当然，每台服务器具体提供的服务不同，访问高峰期有时也会有所出入。比如，服务器主要是供美国人民访问的，那就要考虑时差的问题；或者服务器提供的服务很特殊，访问高峰期可能也不同。</p>
<p>一般我们建议在凌晨 4:00—5:00 执行这些命令。那是不是说我们需要在凌晨上班？当然不是，这谁受得了啊？我们可以使用系统的计划任务，让操作自动在指定的时间段执行。</p>
<h3 id="远程配置防火墙时不要把自己踢出服务器"> 远程配置防火墙时不要把自己踢出服务器</h3>
<p>先要说明一下防火墙是什么、有什么具体的作用。防火墙是指将内网和外网分开，并依照数据包的 IP 地址、端口号和数据包中的数据来判断是否允许数据包通过的网络设备。防火墙可以是硬件防火墙设备，也可以是服务器上安装的防火墙软件。</p>
<p>简单来讲，防火墙就是根据数据包自身的参数来判断是否允许数据包通过的网络设备。我们的服务器要想在公网中安全地使用，就需要使用防火墙过滤有害的数据包。但是在配置防火墙时，如果管理员对防火墙不是很熟悉，则有可能把自己的正常访问数据包和有害数据包全部过滤掉，导致自己也无法正常登录服务器，如防火墙关闭了远程连接的 SSH 服务的端口。</p>
<p>防火墙配置完全是靠手工命令完成的，配置规则和配置命令相对也比较复杂，万一设置的时候心不在焉，悲剧就发生了。</p>
<p>如何避免这种尴尬的情况发生呢？最好的方法当然是在服务器本地配置防火墙，这样就算不小心把自己的远程登录给过滤了，还可以通过本机登录来进行恢复。如果服务器已经在远程登录了，要配置防火墙，那么最好在本地测试完善后再进行上传，这样会把发生故障的概率降到最低。虽然在本地测试好了，但是传到远程服务器上时仍有可能发生问题。有一个笨办法：如果需要远程配置防火墙，那么先写一个系统定时任务，让它每 5 分钟清空一下防火墙规则，就算写错了也还有反悔的机会，等测试没有问题了再删除这个系统定时任务。总之，大家可以使用各种方法，只要留意不要在配置防火墙时把自己踢出服务器就好了。</p>
<h3 id="指定合理的密码规范并定期更新"> 指定合理的密码规范并定期更新</h3>
<p>设置密码需要遵守 <strong><u>复杂性</u>、<u>易记性</u></strong> 和 <strong><u>时效性</u></strong> 的三原则。</p>
<ul>
<li>复杂性：是指密码要包含大小写字母、数字、特殊符号中的最少三种</li>
<li>易记性：是指密码要容易记忆</li>
<li>时效性：是指密码不能长时间使用，定期更换，一般每三个月更换一次</li>
</ul>
<p><strong><u>复杂性</u></strong> 和 <strong><u>时效性</u></strong> 其实都很容易实现，但是什么样的密码是 <strong><u>易记性</u></strong> 的呢？我们可以拿一个英文单词、一个你喜欢的外国影星名字、一句唐诗或名言、一首你喜欢的歌曲的歌词等进行变形后生成。比如密码“Am@ni3ln”是由“American”衍生而来的，e 替换为@，密码出现 abcd 统一替换为 1234；如果是程序员，则可以用变态骨灰级密码“wr!know(xdl)shit!say(hero)&quot;，由“为人不识兄弟连，便称英雄也枉然”衍生而来。关于密码设置的详细说明，后面会有详细说明。</p>
<p>另外，需要注意密码的保存。日常使用的密码，我们最简单的原则是不要写下来。但是我们的服务器可能有很多，不可能所有的服务器都使用同样的密码，最好每台服务器的密码都不尽相同，但是在实际的工作中也不现实。一般的做法是给服务器分类，每类服务器的密码一致，这样可以有效地减少密码的数量。但是在有大量服务器的情况下，密码的数量还是很可怕的。比如，有人从事游戏运维的时候，有超过 2000 台服务器，再加上交换机和路由器等网络设备，虽然采用了每类服务器相同密码的方法，但是密码的总数量还是超过了 100 个……  这时把密码一次性记忆下来基本上是一项不可能完成的任务。那么，该如何保存这些密码呢？只能通过文档来保存了，当然这些文档不能是明文保存的，而是要加密的。</p>
<p>总之，合理的密码还要有合适的保存方式，这些在构建服务器架构的时候都是必须考虑的内容。</p>
<h3 id="合理分配权限"> 合理分配权限</h3>
<p>服务器管理有一个最简单的原则：给予用户最小的权限。初次接触服务器的人会很迷惑，我们所有同事都使用管理员 root 账户登录多好，省得还要学习如何添加用户、设置权限。这样操作，如果是对个人计算机来讲问题不大，如日常使用的 Windows 桌面系统，但如果是服务器，就会出现重大的安全隐患。在实际的工作中，因为给内部员工分配的权限不合理而导致数据泄密甚至触犯法律的情况屡见不鲜。所以，在服务器上，合理的权限规划必不可少！而且就算只有你是这台服务器的 root，我们也建议在管理服务器时，能使用普通用户完成的操作都使用普通用户，确实完成不了的操作要么进行授权，要么再切换到 root 执行。因为 Linux 上的 root 用户权限实在过大，一旦误操作，后果是严重的，下场是惨淡的。</p>
<p>在实际的工作中，越是重要的服务器，对权限的管理越严格。原则上，在能够完成工作的前提下，分配的权限越小越安全。当然，权限越小，你需要做的规划和权限分配任务就越多，但是服务器也越可靠。</p>
<h3 id="定期备份重要数据和日志"> 定期备份重要数据和日志</h3>
<blockquote>
<p>没有备份的服务器，就是在作死！<br>
没有备份的服务器，就是在作死！<br>
没有备份的服务器，就是在作死！</p>
</blockquote>
<p>重要的事说三遍！有的年轻人，手机坏了或丢了，通讯录就没了；自己电脑的硬盘坏了，上面的资料就再也找不到了，一点备份的意识也没有。个人的损失往往可以承受，但是公司服务器的损失可能会非常惊人。有的人知道备份重要，但是因为懒惰或忘记，结果后悔莫及。很多事情都是知易行难的，备份来不得半点侥幸心理。如果公司的主要盈利项目是在互联网上的业务，那么数据的丢失就有可能造成公司的直接利益损失。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-05-06T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">linux文件系统结构</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_basic/02.linux_dir/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_basic/02.linux_dir/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="目录结构"> 目录结构</h2>
<p>学习 Linux，不仅限于学习各种命令，了解整个 Linux 文件系统的目录结构以及各个目录的功能同样至关重要。</p>
<p>使用 Linux 时，通过命令行输入 <code>ls -l /</code> 可以看到，在 Linux 根目录 <code>/</code> 下包含很多的子目录（称为一级目录），例如 <code>bin</code>、<code>boot</code>、<code>usr</code> 等。同时，各一级目录下还含有很多子目录（称为二级目录），比如 <code>/usr/bin</code>、<code>/usr/lib</code> 等。Linux 文件系统目录总体呈现树形结构，<code>/</code> 根目录就相当于树根。如图3-1 所示。</p>
<div>
<p><img src="./assets/dir.png" alt="dir" loading="lazy"></p>
<p><strong>图3-1	<u>Linux 系统目录结构示意图</u></strong></p>
</div>
<p>由于 Linux 系统免费开源，使得 Linux 发行版本有很多，利用 Linux 开发产品的团队也有很多，如果任由每个人都按照自己的想法来配置 Linux 系统文件目录，后期可能会产生诸多的管理问题。试想，如果您进入一家公司，所用 Linux 系统的文件目录结构与所学的完全不同，实在令人头疼。</p>
<p>为了避免诸多使用者对 Linux 系统目录结构天马行空，Linux 基金会发布了 FHS 标准。多数 Linux 发行版系统都遵循这一标准。</p>
<div><p>提示</p>
<p>FHS（Filesystem Hierarchy Standard），文件系统层次化标准，该标准规定了 Linux 系统中所有一级目录以及部分二级目录（<code>/usr</code> 和 <code>/var</code>）的用途。发布此标准的主要目的就是为了让用户清楚地了解每个目录应该存放什么类型的文件。</p>
</div>
<h3 id="根目录"> / 根目录</h3>
<p>FHS 认为，Linux 系统的根目录 <code>/</code>  最为重要（没有之一），其原因有以下 2 点：</p>
<ul>
<li>所有目录都是由根目录衍生出来的；</li>
<li>根目录与系统的开机、修复、还原密切相关；</li>
</ul>
<p>因此，根目录必须包含开机软件、核心文件、开机所需程序、函数库、修复系统程序等文件。常见的一级目录如表3-1 所示。</p>
<p><strong>表3-1	<u>常见一级目录及作用</u></strong></p>
<table>
<thead>
<tr>
<th>一级目录</th>
<th>功能（作用）</th>
</tr>
</thead>
<tbody>
<tr>
<td>/bin/</td>
<td>存放系统命令，普通用户和 root 都可以执行。放在 <code>/bin</code> 下的命令在单用户模式下也可以执行。</td>
</tr>
<tr>
<td>/boot/</td>
<td>系统启动目录，保存与系统启动相关的文件，如内核文件和启动引导程序（grub）文件等。</td>
</tr>
<tr>
<td>/dev/</td>
<td>设备文件保存位置。</td>
</tr>
<tr>
<td>/etc/</td>
<td>配置文件保存位置。系统内所有采用默认安装方式的服务配置文件全部保存在此目录中。<br />如用户信息、服务的启动脚本、常用服务的配置文件等。</td>
</tr>
<tr>
<td>/home/</td>
<td>普通用户的主目录（也称为家目录）。<br />在创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的主目录，<br />所有普通用户的主目录是在 <code>/home/</code> 下建立一个和用户名相同的目录。</td>
</tr>
<tr>
<td>/lib/</td>
<td>系统调用的函数库保存位置。</td>
</tr>
<tr>
<td>/media/</td>
<td>挂载目录。系统建议用来挂载媒体设备，如软盘和光盘。</td>
</tr>
<tr>
<td>/mnt/</td>
<td>挂载目录。早期 Linux 中只有这一个挂载目录，并没有细分。<br />系统建议这个目录用来挂载额外的设备，如 U盘、移动硬盘和其他操作系统的分区。</td>
</tr>
<tr>
<td>/misc/</td>
<td>挂载目录。系统建议用来挂载 NFS 服务的共享目录。<br />虽然系统准备了三个默认挂载目录 <code>/media/</code>、<code>/mnt/</code>、<code>/misc/</code>，<br />但是到底在哪个目录中挂载什么设备可以由管理员自己决定。</td>
</tr>
<tr>
<td>/opt/</td>
<td>第三方安装的软件保存位置。<br />这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中。<br />也有人习惯把软件放到 <code>/usr/local/</code> 目录中，也就是说，<code>/usr/local/</code> 目录也可以用来安装软件。</td>
</tr>
<tr>
<td>/root/</td>
<td>root 的主目录。普通用户主目录在 <code>/home/</code> 下，root 主目录直接在 <code>/</code> 下。</td>
</tr>
<tr>
<td>/sbin/</td>
<td>保存与系统环境设置相关的命令，只有 root 可以使用这些命令进行系统环境设置，<br />但也有些命令可以允许普通用户查看。</td>
</tr>
<tr>
<td>/srv/</td>
<td>服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据。</td>
</tr>
<tr>
<td>/tmp/</td>
<td>临时目录。系统存放临时文件的目录，在该目录下，所有用户都可以访问和写入。<br />此目录中不能保存重要数据，最好每次开机都把该目录清空。</td>
</tr>
<tr>
<td>/var/</td>
<td>用于存储动态数据，例如缓存、日志文件、软件运行过程中产生的文件等。</td>
</tr>
</tbody>
</table>
<p>FHS 针对根目录中包含的子目录仅限于上表，但除此之外，Linux 系统根目录下通常还包含表3-2 中的几个一级目录。</p>
<p><strong>表3-2	<u>特殊一级目录及作用</u></strong></p>
<table>
<thead>
<tr>
<th>一级目录</th>
<th>功能（作用）</th>
</tr>
</thead>
<tbody>
<tr>
<td>/lost+found/</td>
<td>当系统意外崩溃或意外关机时，产生的一些文件碎片会存放在这里。<br />在系统启动的过程中，<code>fsck</code> 工具会检查这里，并修复已经损坏的文件系统。<br />这个目录只在每个分区中出现，例如，<code>/lost+found</code> 就是根分区的备份恢复目录，<code>/boot/lost+found</code> 就是 <code>/boot</code> 分区的备份恢复目录。</td>
</tr>
<tr>
<td>/proc/</td>
<td>虚拟文件系统。该目录中的数据并不保存在硬盘上，而是保存到内存中。主要保存系统的内核、进程、外部设备状态和网络状态等。<br />如 <code>/proc/cpuinfo</code> 是保存 CPU 信息的，<code>/proc/devices</code> 是保存设备驱动的列表的，<code>/proc/filesystems</code> 是保存文件系统列表的，<code>/proc/net</code> 是保存网络协议信息的......</td>
</tr>
<tr>
<td>/sys/</td>
<td>虚拟文件系统。<br />和 <code>/proc/</code> 目录相似，该目录中的数据都保存在内存中，主要保存与内核相关的信息。</td>
</tr>
</tbody>
</table>
<h3 id="usr-目录"> /usr 目录</h3>
<p>usr（注意不是 user），全称为 Unix Software Resource，此目录用于存储系统软件资源。FHS 建议所有开发者，应把软件产品的数据合理的放置在 <code>/usr</code> 目录下的各子目录中，而不是为他们的产品创建单独的目录。</p>
<p>Linux 系统中，所有系统默认的软件都存储在 <code>/usr</code> 目录下，<code>/usr</code> 目录类似 Windows 系统中 <code>C:\Windows\</code> + <code>C:\Program files\</code> 两个目录的综合体。</p>
<p>FHS 建议，<code>/usr</code> 目录应具备表3-3 所示的子目录。</p>
<p><strong>表3-3	<u>常见二级 /usr 目录及作用</u></strong></p>
<table>
<thead>
<tr>
<th>二级目录</th>
<th>功能（作用）</th>
</tr>
</thead>
<tbody>
<tr>
<td>/usr/bin/</td>
<td>存放系统命令，普通用户和超级用户都可以执行。<br />这些命令和系统启动无关，在单用户模式下不能执行。</td>
</tr>
<tr>
<td>/usr/sbin/</td>
<td>存放根文件系统不必要的系统管理命令，如多数服务程序，只有 root 可以使用。</td>
</tr>
<tr>
<td>/usr/lib/</td>
<td>应用程序调用的函数库保存位置。</td>
</tr>
<tr>
<td>/usr/XllR6/</td>
<td>图形界面系统保存位置。</td>
</tr>
<tr>
<td>/usr/local/</td>
<td>手工安装的软件保存位置。我们一般建议源码包软件安装在这个位置。</td>
</tr>
<tr>
<td>/usr/share/</td>
<td>应用程序的资源文件保存位置，如帮助文档、说明文档和字体目录。</td>
</tr>
<tr>
<td>/usr/src/</td>
<td>源码包保存位置。我们手工下载的源码包和内核源码包都可以保存到这里。<br />不过笔者更习惯把手工下载的源码包保存到 <code>/usr/local/src/</code> 目录中，<br />把内核源码保存到 <code>/usr/src/linux/</code> 目录中。</td>
</tr>
<tr>
<td>/usr/include</td>
<td>C/C++ 等编程语言头文件的放置目录。</td>
</tr>
</tbody>
</table>
<h3 id="var-目录"> /var 目录</h3>
<p><code>/var</code> 目录用于存储动态数据，例如缓存、日志文件、软件运行过程中产生的文件等。通常，此目录下建议包含如表3-4 所示的这些子目录。</p>
<p><strong>表3-4	<u>常见二级目录 /var 及作用</u></strong></p>
<table>
<thead>
<tr>
<th>二级目录</th>
<th>功能（作用）</th>
</tr>
</thead>
<tbody>
<tr>
<td>/var/lib/</td>
<td>程序运行中需要调用或改变的数据保存位置。<br />如 MySQL 的数据库保存在 <code>/var/lib/mysql/</code> 目录中</td>
</tr>
<tr>
<td>/var/log/</td>
<td>登陆文件放置的目录，其中所包含比较重要的文件如 <code>/var/log/messages</code>, <code>/var/log/wtmp</code> 等。</td>
</tr>
<tr>
<td>/var/run/</td>
<td>一些服务和程序运行后，它们的 PID（进程 ID）保存位置</td>
</tr>
<tr>
<td>/var/spool/</td>
<td>里面主要都是一些临时存放，随时会被用户所调用的数据，<br />例如 <code>/var/spool/mail/</code> 存放新收到的邮件，<code>/var/spool/cron/</code> 存放系统定时任务。</td>
</tr>
<tr>
<td>/var/www/</td>
<td>RPM 包安装的 Apache 的网页主目录</td>
</tr>
<tr>
<td>/var/nis <br />/var/yp</td>
<td>NIS 服务机制所使用的目录，nis 主要记录所有网络中每一个 client 的连接信息；<br />yp 是 linux 的 nis 服务的日志文件存放的目录。</td>
</tr>
<tr>
<td>/var/tmp</td>
<td>一些应用程序在安装或执行时，需要在重启后使用的某些文件，<br />此目录能将该类文件暂时存放起来，完成后再行删除</td>
</tr>
</tbody>
</table>
<p>根据以上各表列举的各目录及作用，如果我们要做一些实验和练习，需要创建一些临时文件，应该保存在哪里呢？</p>
<p>答案是用户的主目录或 <code>/tmp/</code> 临时目录。但是要小心有些目录中不能直接修改和保存数据，比如 <code>/proc/fn/sys/</code> 目录，因为它们是保存在内存中的，如果在这里写入数据，那么您的内存会越来越小，直至死机；<code>/boot/</code> 目录也不能保存额外数据，因为 <code>/boot/</code> 目录会单独分区作为启动分区，如果没有空闲空间，则会导致系统不能正常启动。</p>
<p>总之，Linux 要在合理的目录下进行操作和修改。</p>
<div><p>注意</p>
<p>目录名或文件名都是区分大小写的，如 dog、DOG 和 Dog 为 3 个不同的目录或文件。完整的目录或文件路径是由一连串的目录名所组成的，其中每一个目录由 <code>/</code> 来分隔。如 cat 的完整路径是 <code>/home/cat</code>。</p>
</div>
<h3 id="硬件设备名称"> 硬件设备名称</h3>
<p><strong>表3-5	<u>常见硬件设备及命名</u></strong></p>
<table>
<thead>
<tr>
<th>硬件设备</th>
<th>文件名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>IDE 设备</td>
<td><code>/dev/hd[a-d]</code>，现在的 IDE 设备已经很少见了，因此一般的硬盘设备会以 <code>/dev/sd</code> 开头。</td>
</tr>
<tr>
<td>SCSI/SATA/U盘</td>
<td><code>/dev/sd[a-p]</code>，一台主机可以有多块硬盘，因此系统采用 a~p 代表 16 块不同的硬盘。</td>
</tr>
<tr>
<td>软驱</td>
<td><code>/dev/fd[0-1]</code></td>
</tr>
<tr>
<td>打印机</td>
<td><code>/dev/lp[0-15]</code></td>
</tr>
<tr>
<td>光驱</td>
<td><code>/dev/cdrom</code></td>
</tr>
<tr>
<td>鼠标</td>
<td><code>/dev/mouse</code></td>
</tr>
<tr>
<td>磁带机</td>
<td><code>/dev/st0</code> 或 <code>/dev/ht0</code></td>
</tr>
</tbody>
</table>
<h2 id="文件系统"> 文件系统</h2>
<p>目录就相当于 Windows 中的文件夹，目录中存放的既可以是文件，也可以是其他的子目录，而文件中存储的是真正的信息。</p>
<p>文件系统的最顶层是由根目录开始的，系统使用“<code>/</code>”来表示根目录，在根目录之下的既可以是目录，也可以是文件，而每一个目录中又可以包含（子）目录或文件。如此反复就可以构成一个庞大的文件系统。
其实，使用这种树状、具有层次的文件结构主要目的是方便文件系统的管理和维护，想象一下，如果所有的文件都放在一个目录下，其文件系统的管理和维护将变成一场噩梦。</p>
<p>现实中也有许多类似的例子，例如在整个行政管理体制中，村民就相当于文件，他们住在一个村庄中，村庄就是存储村民的目录。许多村又组成了个乡，这个乡就相当于存储村的目录，依此类推，最终就构建出了一个庞大的行政区域管理结构图。</p>
<p>注意，目录名或文件名都是区分大小写的，如 dog、DOG 和 Dog 为 3 个不同的目录或文件。完整的目录或文件路径是由一连串的目录名所组成的，其中每一个目录由“<code>/</code>”来分隔。如 cat 的完整路径是 <code>/home/cat</code>。</p>
<p>在文件系统中，有两个特殊的目录，一个是用户所在的工作目录，即当前目录，可用一个点“<code>.</code>”表示；另一个是当前目录的上一层目录，也叫父目录，用两个点“<code>..</code>”表示。</p>
<p>如果一个目录或文件名是以一个点开始，就表示这个目录或文件是一个隐藏目录或文件。即以默认方式査找（后续会讲查找命令）时，不显示该目录或文件。</p>
<p>为了方便管理和维护，Linux 系统采用了文件系统层次标准，也称为 FHS 标准，它规定了根目录下各个目录应该存在哪些类型的文件（或子目录），比如说，在 <code>/bin</code> 和 <code>/sbin</code> 目录中存放的应该是可执行文件，有关各个目录存放文件的类型，前面已经稍微作了介绍，这里不再过多赘述。</p>
<h3 id="文件"> 文件</h3>
<p>虽然从名称上不容易分辨，但是可以从颜色上进行区分。一般情况下，Linux 用蓝色代表目录，其他颜色则表示是文件。</p>
<p>和 Linux 不同，Windows 下带有 <code>&lt;DIR&gt;</code> 标记的行或使用中括号 <code>[ ]</code> 括起来的名称就是目录，其他的则是文件。</p>
<p>不仅如此，Linux 中还可以用不同的颜色来区分不同种类的文件，例如绿色代表可执行文件、红色代表压缩文件、浅绿色代表链接文件、白色代表其他文件、黄色代表设备文件等。</p>
<p>但是，不同颜色所代表的文件类型不一定是这样，更准确的对应方式还取决于配置文件 <code>/etc/DIR_COLORS</code> 中的规定。因此，如果想详细了解不同文件类型所对应的颜色，可以使用 <code>man</code> 命令，例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>man</span> dir_colors</span></span>
</code></pre>
<div><span>1</span><br></div></div><p>注意，有些 Linux 发行版单独使用 <code>ls</code> 命令，无法显示出带有不同颜色的文件和目录，此时就需要使用 <code>ls --color=auto</code> 命令，明确令其使用颜色来区分文件类型。</p>
<p>在此基础上，如果不想每次使用 <code>ls</code> 命令时，都显式附带 <code>--color=auto</code>，可以执行如下命令:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>alias</span> <span>ls</span> <span>=</span> <span>'ls --color=auto'</span></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>通过给 <code>ls --color==auto</code> 这个整体设置一个别名 <code>ls</code>，这样当后续使用 <code>ls</code> 命令时，就等同于执行 <code>ls --color=auto</code> 命令。</p>
<p>同时，如果想使这个设置永远生效，还需要将其添加到 <code>/etc/bashrc</code> 或 <code>/home/&lt;user&gt;/.bashrc</code> 文件中，前者对所有用户有效，而后者仅对用户 <code>&lt;user&gt;</code> 有效。</p>
<p>其实，那些默认提供颜色功能的 Linux 发行版，也是通过这个方法开启的功能。</p>
<p>当然，通过颜色来区分文件类型，难免有些牵强，对于颜色不太敏感的读者来说，很容易搞错。Linux 中精确判断文件类型的方法，是通过文件本身所具有的属性进行判断。</p>
<p>通过 <code>ls -l</code> 命令，我们就可以查看当前目录下所有文件和目录各自的属性</p>
<p>例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls -l</span>
总用量 <span>620</span>
-rwxrw-r--    <span>1</span> root root    <span>493</span> <span>4</span>月  <span>27</span> <span>14</span>:29 deploy.sh
drwxr-xr-x   <span>16</span> root root   <span>4096</span> <span>5</span>月   <span>4</span> <span>16</span>:52 dist
drwxr-xr-x    <span>7</span> root root   <span>4096</span> <span>5</span>月   <span>4</span> 09:10 docs
drwxr-xr-x <span>1002</span> root root  <span>36864</span> <span>5</span>月   <span>4</span> 09:16 node_modules
-rw-r--r--    <span>1</span> root root    <span>386</span> <span>5</span>月   <span>4</span> 08:16 package.json
-rw-r--r--    <span>1</span> root root <span>577009</span> <span>5</span>月   <span>4</span> 08:17 package-lock.json
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="命名规则"> 命名规则</h3>
<ul>
<li>除了字符“/”之外，所有的字符都可以使用，但是要注意，在目录名或文件名中，使用某些特殊字符并不是明智之举。例如，在命名时应避免使用 <code>&lt;</code>、<code>&gt;</code>、<code>?</code>、<code>*</code> 和<code>非打印字符</code>等。如果一个文件名中包含了特殊字符，例如空格，那么在访问这个文件时就需要使用引号将文件名括起来。</li>
<li>目录名或文件名的长度不能超过 255 个字符。</li>
<li>目录名或文件名是区分大小写的。如 DOG、dog、Dog 和 DOg ，是互不相同的目录名或文件名，但使用字符大小写来区分不同的文件或目录，也是不明智的。</li>
</ul>
<h3 id="不同字符对应的文件类型"> 不同字符对应的文件类型</h3>
<p><strong>表3-6	<u>常见的文件类型</u></strong></p>
<table>
<thead>
<tr>
<th>第一个字符</th>
<th>文件类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>普通文件，包括纯文本文件、二进制文件、各种压缩文件等。</td>
</tr>
<tr>
<td>d</td>
<td>目录，类似 Windows 系统中的文件夹。</td>
</tr>
<tr>
<td>b</td>
<td>块设备文件，就是保存大块数据的设备，比如最常见的硬盘。</td>
</tr>
<tr>
<td>c</td>
<td>字符设备文件，例如键盘、鼠标等。</td>
</tr>
<tr>
<td>s</td>
<td>套接字文件，通常用在网络数据连接，<br />可以启动一个程序开监听用户的要求，用户可以通过套接字进行数据通信。</td>
</tr>
<tr>
<td>p</td>
<td>管道文件，其主要作用是解决多个程序同时存取一个文件所造成的错误。</td>
</tr>
<tr>
<td>l</td>
<td>链接文件，类似 Windows 系统中的快捷方式。</td>
</tr>
</tbody>
</table>
<h2 id="linux-挂载"> Linux 挂载</h2>
<p>前面讲过，Linux 系统中“一切皆文件”，所有文件都放置在以根目录为树根的树形目录结构中。在 Linux 看来，任何硬件设备也都是文件，它们各有自己的一套文件系统（文件目录结构）。</p>
<p>因此产生的问题是，当在 Linux 系统中使用这些硬件设备时，只有将 Linux 本身的文件目录与硬件设备的文件目录合二为一，硬件设备才能为我们所用。合二为一的过程称为“挂载”。</p>
<p>如果不挂载，通过 Linux 系统中的图形界面系统可以查看找到硬件设备，但命令行方式无法找到。</p>
<p>挂载，指的就是将设备文件中的顶级目录连接到 Linux 根目录下的某一目录（最好是空目录），访问此目录就等同于访问设备文件。</p>
<p>纠正一个误区，并不是根目录下任何一个目录都可以作为挂载点，由于挂载操作会使得原有目录中文件被隐藏，因此根目录以及系统原有目录都不要作为挂载点，会造成系统异常甚至崩溃，挂载点最好是新建的空目录。</p>
<p>举个例子，我们想通过命令行访问某个 U盘中的数据，我们要在根目录下新建一个目录 <code>/sdb-u</code>，通过挂载命令将 U盘文件系统挂载到此目录，前面讲过，根目录下的 <code>/dev/</code> 目录文件负责所有的硬件设备文件，事实上，当 U盘插入 Linux 后，系统也确实会给 U盘分配一个目录文件（比如 sdb1），就位于 <code>/dev/</code> 目录下 （<code>/dev/sdb1</code>），但无法通过 <code>/dev/sdb1/</code> 直接访问 U 盘数据，访问此目录只会提供给您此设备的一些基本信息（比如容量）。</p>
<p>总之，Linux 系统使用任何硬件设备，都必须将设备文件与已有目录文件进行挂载。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-05-05T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">linux基本操作命令</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_basic/03.linux_basic/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_basic/03.linux_basic/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="命令的基本格式"> 命令的基本格式</h2>
<h3 id="命令提示符"> 命令提示符</h3>
<p>登录系统后，第一眼看到的内容是：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span>#</span>
</code></pre>
<div><span>1</span><br></div></div><p>这就是 Linux 系统的命令提示符。那么，这个提示符的含义是什么呢？</p>
<ul>
<li><code>[]</code>：这是提示符的分隔符号，没有特殊含义。</li>
<li><code>root</code>：显示的是当前的登录用户，笔者现在使用的是 root 用户登录。</li>
<li><code>@</code>：分隔符号，没有特殊含义。</li>
<li><code>localhost</code>：当前系统的简写主机名（完整主机名是 <code>localhost.localdomain</code>）。</li>
<li><code>~</code>：代表用户当前所在的目录，此例中用户当前所在的目录是家目录。</li>
<li><code>#</code>：命令提示符，Linux 用这个符号标识登录的用户权限等级。如果是超级用户，提示符就是 <code>#</code>；如果是普通用户，提示符就是 <code>$</code>。</li>
</ul>
<p>家目录（又称主目录）是什么？ Linux 系统是纯字符界面，用户登录后，要有一个初始登录的位置，这个初始登录位置就称为用户的家：</p>
<ul>
<li>超级用户的家目录： <code>/root</code></li>
<li>普通用户的家目录： <code>/home/&lt;user&gt;</code></li>
</ul>
<p>用户在自己的家目录中拥有完整权限，所以我们也建议操作实验可以放在家目录中进行。我们切换一下用户所在目录，看看有什么效果。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cd /usr/local</span>
<span>[</span>root@localhost local<span>]</span><span>#</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>仔细看，如果切换用户所在目录，那么命令提示符中的会变成用户当前所在目录的最后一个目录（不显示完整的所在目录 <code>/usr/local</code>，只显示最后一个目录 <code>local</code>）。</p>
<h3 id="命令的基本格式-2"> 命令的基本格式</h3>
<p>接下来看看 Linux 命令的基本格式：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># 命令 [选项] [参数]</span>
</code></pre>
<div><span>1</span><br></div></div><p>命令格式中的 <code>[]</code> 代表可选项，也就是有些命令可以不写选项或参数，也能执行。那么，我们就用 Linux 中最常见的 <code>ls</code> 命令来解释一下命令的格式（有关 <code>ls</code> 命令的具体用法，后续章节会详细介绍）。如果按照命令的分类，那么 <code>ls</code> 命令应该属于目录操作命令。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls</span>
anaconda-ks.cfg	install.log	install.log.syslog
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="选项的作用"> 选项的作用</h3>
<p>选项的作用是调整命令功能。如果没有选项，那么命令只能执行最基本的功能；而一旦有选项，则可以显示更加丰富的数据。</p>
<p>Linux 的选项又分为短格式选项（<code>-l</code>）和长格式选项（<code>--all</code>）。短格式选项是英文的简写，用一个减号调用，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls -l</span>
</code></pre>
<div><span>1</span><br></div></div><p>而长格式选项是英文完整单词，一般用两个减号调用，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls --all</span>
</code></pre>
<div><span>1</span><br></div></div><p>一般情况下，短格式选项是长格式选项的缩写，也就是一个短格式选项会有对应的长格式选项。当然也有例外，比如 <code>ls</code> 命令的短格式选项 -l 就没有对应的长格式选项。所以具体的命令选项可以通过后面我们要学习的帮助命令来进行査询。</p>
<h3 id="参数的作用"> 参数的作用</h3>
<p>参数是命令的操作对象，一般文件、目录、用户和进程等可以作为参数被命令操作。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls -l anaconda-ks.cfg</span>
-rw------- <span>1</span> root root <span>1207</span> <span>1</span> 月 <span>14</span> <span>18</span>:18 anaconda-ks.cfg
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>但是为什么一开始 <code>ls</code> 命令可以省略参数？ 那是因为有默认参数。命令一般都需要加入参数，用于指定命令操作的对象是谁。如果可以省略参数，则一般都有默认参数。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls</span>
anaconda-ks.cfg install.log install.log.syslog
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这个 <code>ls</code> 命令后面没有指定参数，默认参数是当前所在位置，所以会显示当前目录下的文件名。</p>
<div><p>总结</p>
<p><strong>命令的选项用于调整命令功能，而命令的参数是这个命令的操作对象。</strong></p>
</div>
<h2 id="目录操作命令"> 目录操作命令</h2>
<h3 id="ls-命令"> ls 命令</h3>
<p><u><code>ls</code> 命令，是最常见的目录操作命令，其主要功能是显示当前目录下的内容。</u></p>
<p>英文原意：list directory contents</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls [选项] [文件名或目录名]</span>
选项 ：
	-a	：显示全部的文件，包括隐藏文件（开头为 <span>.</span> 的文件）也一起罗列出来，这是最常用的选项之一。
	-A	：显示全部的文件，连同隐藏文件，但不包括 <span>.</span> 与 <span>..</span> 这两个目录。
	-d	：仅列出目录本身，而不是列出目录内的文件数据。 
	-h	：以人们易读的方式显示文件或目录大小，如 1KB、234MB、2GB 等。
	-i	：显示 inode 节点信息。
	-l	：使用长格式列出文件和目录信息。
	-r	：将排序结果反向输出，比如，若原本文件名由小到大，反向则为由大到小。
	-R	：连同子目录内容一起列出来，等于将该目录下的所有文件都显示出来。
	-S	：以文件容量大小排序，而不是以文件名排序。
	-t	：以时间排序，而不是以文件名排序。
	--color<span>=</span>auto	：auto表示让系统自行依据配置来判断是否给予颜色。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><p>提示</p>
<p>当 <code>ls</code> 命令不使用任何选项时，默认只会显示非隐藏文件的名称，并以文件名进行排序，同时会根据文件的具体类型给文件名配色（蓝色显示目录，白色显示一般文件）。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls -l</span>
-rw-------.   <span>1</span> root root     <span>1423</span> <span>3</span>月  <span>23</span> 01:54 anaconda-ks.cfg
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>ls</code> 命令使用了“-l”选项，显示出文件的详细信息，此选项显示的这 7 列的含义分别是：</p>
<blockquote>
<ul>
<li>第一列：规定了不同的用户对文件所拥有的权限，具体权限的含义将在后续章节中讲解。</li>
<li>第二列：引用计数，文件的引用计数代表该文件的硬链接个数，而目录的引用计数代表该目录有多少个一级子目录。</li>
<li>第三列：所有者，也就是这个文件属于哪个用户。默认所有者是文件的建立用户。</li>
<li>第四列：所属组，默认所属组是文件建立用户的有效组，一般情况下就是建立用户的所在组。</li>
<li>第五列：大小，默认单位是字节。</li>
<li>第六列：文件修改时间，文件状态修改时间或文件数据修改时间都会更改这个时间，注意这个时间不是文件的创建时间。</li>
<li>第七列：文件名或目录名。</li>
</ul>
</blockquote>
</div>
<h3 id="cd-命令"> cd 命令</h3>
<p><u><code>cd</code> 命令，用来切换工作目录。</u></p>
<p>英文原意：Change Directory</p>
<p>Linux 命令按照来源方式，可分为两种，分别是 Shell 内置命令和外部命令。所谓 Shell 内置命令，就是 Shell 自带的命令，这些命令是没有执行文件的；而外部命令就是由程序员单独开发的，所以会有命令的执行文件。Linux 中的绝大多数命令是外部命令，而 <code>cd</code> 命令是一个典型的 Shell 内置命令，所以 <code>cd</code> 命令没有执行文件所在路径。</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cd [相对路径或绝对路径]</span>
</code></pre>
<div><span>1</span><br></div></div><p>除此之外，<code>cd</code> 命令后面可以跟一些特殊符号，表达固定的含义。如表4-1 所示。</p>
<p><strong>表4-1	<u>特殊符号的含义</u></strong></p>
<table>
<thead>
<tr>
<th>特殊符号</th>
<th>作 用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>~</code></td>
<td>代表当前登录用户的主目录</td>
</tr>
<tr>
<td><code>~&lt;user&gt;</code></td>
<td>表示切换至指定用户的主目录</td>
</tr>
<tr>
<td><code>-</code></td>
<td>代表上次所在目录</td>
</tr>
<tr>
<td><code>.</code></td>
<td>代表当前目录</td>
</tr>
<tr>
<td><code>..</code></td>
<td>代表上级目录</td>
</tr>
</tbody>
</table>
<div><p>提示</p>
<p>在 Linux 系统中，根目录确实存在 <code>.</code>（当前目录）以及 <code>..</code>（当前目录的父目录）两个目录，但由于根目录是最顶级目录，因此根目录的 <code>..</code> 和 <code>.</code> 的属性和权限完全一致，也就是说，根目录的父目录是自身。</p>
</div>
<h3 id="mkdir-命令"> mkdir 命令</h3>
<p><u><code>mkdir</code> 命令，用于创建新目录。</u></p>
<p>英文原意：make directories</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mkdir [选项] 目录名</span>
选项：
	-m	：用于手动配置所创建目录的权限，而不再使用默认权限。
	-p	：递归创建所有目录。

<span>#以创建 /home/test/demo 为例，在默认情况下，您需要一层一层的创建各个目录，而使用 -p 选项，则系统会自动帮您创建 home、/home/test 以及 home/test/demo。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="rmdir-命令"> rmdir 命令</h3>
<p><u><code>rmdir</code> 命令，命令用于<strong>删除空目录</strong>，和 <code>mkdir</code> 命令相反。</u></p>
<p>英文原意：remove empty directories</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># rmdir [选项] 目录名</span>
选项：
	-p	：选项用于递归删除空目录。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><p>提示</p>
<p><strong><code>rmdir</code> 命令的作用十分有限，因为只能刪除空目录，所以一旦目录中有内容，就会报错。</strong></p>
</div>
<h3 id="pwd-命令"> pwd 命令</h3>
<p><u><code>pwd</code> 命令，功能是显示用户当前所处的工作目录。</u></p>
<p>英文原意：Print Working Directory</p>
<p>由于 Linux 文件系统中有许多目录，当用户执行一条 Linux 命令又没有指定该命令或参数所在的目录时，Linux 系统就会首先在当前目录搜寻这个命令或它的参数。因此，用户在执行命令之前，常常需要确定目前所在的工作目录，即当前目录。</p>
<p>当用户登陆 Linux 系统之后，其当前目录就是它的主目录。那么，如何确定当前目录呢？可以使用 Linux 系统的 <code>pwd</code> 命令来显示当前目录的绝对路径。</p>
<p>命令格如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># pwd</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="tree-命令"> tree 命令</h3>
<p><code>tree</code> 命令，用于以树状图列出目录的内容。</p>
<p>英文原意：list contents of directories in a tree-like format</p>
<p>执行 <code>tree</code> 命令，它会列出指定目录下的所有文件，包括子目录里的文件。</p>
<p>命令格如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># tree 目录名</span>
</code></pre>
<div><span>1</span><br></div></div><p>用法比较单一，就是显示目录树。</p>
<div><pre><code><span># 例子：</span>
<span>[</span>root@localhost ~<span>]</span><span># tree ./share/</span>
./share/
├── doc
│   └── <span>node</span>
│       ├── gdbinit
│       └── lldb_commands.py
├── <span>man</span>
│   └── man1
│       └── node.1
└── systemtap
    └── tapset
        └── node.stp

<span>6</span> directories, <span>4</span> files
<span>[</span>root@localhost ~<span>]</span><span># </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="文件操作命令"> 文件操作命令</h2>
<p>其实计算机的基本操作大多数可以归纳为“增删改查”四个字，文件操作也不例外。只是修改文件数据需要使用文件编辑器，如 <code>vim</code>、<code>nano</code> 等。而编辑器操作不是一句两句就可以说明白的，所以暂且不说。</p>
<h3 id="touch-命令"> touch 命令</h3>
<p><code>touch</code> 命令，如果文件不存在，则会建立空文件；如果文件已经存在，则会修改文件的时间戳（访问时间、数据修改时间、状态修改时间都会改变)。千万不要把 <code>touch</code> 命令当成新建文件的命令，牢牢记住这是触摸的意思。</p>
<p>英文原意：change file timestamps</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># touch [选项] 文件名</span>
选项：
	-a	：只修改文件的访问时间。
	-c	：仅修改文件的时间参数（3 个时间参数都改变），如果文件不存在，则不建立新文件。
	-d	：后面可以跟欲修订的日期，而不用当前的日期，即把文件的 atime 和 mtime 时间改为指定的时间。
	-m	：只修改文件的数据修改时间。
	-t	：命令后面可以跟欲修订的时间，而不用目前的时间，时间书写格式为 YYMMDDhhmm。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><code>touch</code> 命令可以只修改文件的访问时间，也可以只修改文件的数据修改时间，但是不能只修改文件的状态修改时间。因为，不论是修改访问时间，还是修改文件的数据时间，对文件来讲，状态都会发生改变，即状态修改时间会随之改变（更新为操作当前文件的真正时间）。</p>
<div><p>说明</p>
<p>Linux 系统中，文件没有创建时间，文件主要拥有 3 个时间参数（通过 <code>stat</code> 命令进行查看），分别是文件的访问时间、数据修改时间以及状态修改时间：</p>
<blockquote>
<ul>
<li>访问时间 （Access Time，简称 atime）：只要文件的内容被读取，访问时间就会更新。例如，使用 <code>cat</code> 命令可以查看文件的内容，此时文件的访问时间就会发生改变。</li>
<li>数据修改时间 （Modify Time，简称 mtime）：当文件的内容数据发生改变，此文件的数据修改时间就会跟着相应改变。</li>
<li>状态修改时间 （Change Time，简称 ctime）：当文件的状态发生变化，就会相应改变这个时间。比如说，如果文件的权限或者属性发生改变，此时间就会相应改变。</li>
</ul>
</blockquote>
</div>
<h3 id="stat-命令"> stat 命令</h3>
<p><code>stat</code> 命令，用于显示文件的状态信息。以文字的格式来显示 inode 的内容。</p>
<p>英文原意：display file or file system status</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># stat [选项] 文件或目录</span>
选项：
	-f	：显示文件系统状态而非文件状态。
	-t	：以简洁方式输出信息。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>例子：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># stat anaconda-ks.cfg</span>
  文件：<span>"anaconda-ks.cfg"</span>
  大小：1423      	块：8          IO 块：4096   普通文件
设备：fd00h/64768d	Inode：8409167     硬链接：1
权限：<span>(</span>0600/-rw-------<span>)</span>  Uid：<span>(</span>    <span>0</span>/    root<span>)</span>   Gid：<span>(</span>    <span>0</span>/    root<span>)</span>
环境：system_u:object_r:admin_home_t:s0
最近访问：2021-03-23 01:54:45.054000000 -0400
最近更改：2021-03-23 01:54:45.059000000 -0400
最近改动：2021-03-23 01:54:45.059000000 -0400
创建时间：-
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><p>提示</p>
<p>事实上，<code>stat</code> 命令显示的是文件的 i节点信息。Linux 文件系统以块为单位存储信息，为了找到某一个文件所在存储空间的位置，用 i节点对每个文件进行索引。所谓的 i节点，是文件系统管理的一个数据结构，是一个 64 字节长的表，包含了描述文件所必要的全部信息，其中包含了文件的大小、类型、存取权限、文件的所有者等等。</p>
</div>
<h3 id="cat-命令"> cat 命令</h3>
<p><code>cat</code> 命令，用于查看文件内容。不论文件内容有多少，都会一次性显示。</p>
<p>如果文件非常大，那么文件开头的内容就看不到了。不过 Linux 可以使用 <kbd>PgUp</kbd>+<kbd>上箭头</kbd> 向上翻页，但是这种翻页是有极限的，如果文件足够长，那么还是无法看全文件的内容。所以 <code>cat</code> 命令适合查看不太大的文件。</p>
<p>英文原意：concatenate files and print on the standard output</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cat [选项] 文件名</span>
选项：
	-n	：由 <span>1</span> 开始对所有输出的行数编号。
	-b	：和 -n 相似，只不过对于空白行不编号。
	-v	：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。
	-E	：在每行结束处显示 $。
	-T	：将 TAB 字符显示为 ^I。
	-A	：等价于 -vET。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="more-命令"> more 命令</h3>
<p><code>more</code> 命令，用于分屏显示文件内容。</p>
<p>如果文件过大，则 <code>cat</code> 命令会有心无力，这时 <code>more</code> 命令的作用更加明显。</p>
<p>英文原意：file perusal filter for crt viewing</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># more 文件名</span>
</code></pre>
<div><span>1</span><br></div></div><div><p>提示</p>
<p>more命令比较简单，一般不用什么选项，命令会打开一个交互界面。常用交互命令如下：</p>
<blockquote>
<p><strong>空格：向下翻页。</strong></p>
<p><strong>b键：向上翻页。</strong></p>
<p><strong>回车：向下滚一行。</strong></p>
<p><strong>/字符串：搜索指定的字符串。</strong></p>
<p><strong>q键：退出。</strong></p>
</blockquote>
</div>
<h3 id="less-命令"> less 命令</h3>
<p><code>less</code> 命令，用于分行显示文件内容。</p>
<p>和 <code>more</code> 命令类似，只是 <code>more</code> 是分屏显示命令，而 <code>less</code> 是分行显示命令.</p>
<p>英文原意：opposite of more</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># less 文件名</span>
</code></pre>
<div><span>1</span><br></div></div><div><p>提示</p>
<p><code>less</code> 命令可以使用上、下箭头，用于分行查看文件内容。</p>
</div>
<h3 id="head-命令"> head 命令</h3>
<p><code>head</code> 命令，用来显示文件开头内容。</p>
<p>英文原意：output the first part of files</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># head [选项] 文件名</span>
选项：
	-n	：行数，从文件头开始，显示指定行数。
	-v	：显示文件名。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><p>提示</p>
<p>也可以直接使用 <code>head -行数 文件名</code> 显示文件开头的行数内容。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># head -20 anaconda-ks.cfg</span>
<span>#显示文件 anaconda-ks.cfg 的开头前 20 行的内容</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></div>
<h3 id="tail-命令"> tail 命令</h3>
<p><code>tail</code> 命令，用来显示文件末尾内容。</p>
<p>既然有显示文件开头的命令，就会有显示文件末尾的命令。<code>tail</code> 命令就是显示文件末尾内容的命令。</p>
<p>英文原意：output the last part of files</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># tail [选项] 文件名</span>
选项：
	-n	：行数，从文件结尾开始，显示指定行数。
	-f	：监听文件的新增内容。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong><code>tail</code> 的特殊用法，监听文件的新增内容。</strong></p>
<div><pre><code><span># 例子：</span>
<span>[</span>root@localnost ~<span>]</span><span># tail -f anaconda-ks.cfg</span>
@server-platform
@server-policy
pax
oddjob
sgpio
certmonger
pam_krb5
krb5-workstation
per1-DBD-SQLite
%end
<span>#光标不会退出文件，而会一直监听在文件的结尾处</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>这条命令会显示文件的最后 10 行内容，而且光标不会退出命令，而会一直监听在文件的结尾处，等待显示新增内容。这时如果向文件中追加一些数据（需要开启一个新终端），那么上面的末尾的 <strong>%<u>end</u></strong> 后面紧接着会显示追加的内容。退出监听状态，可使用 <kbd>Ctrl</kbd>+<kbd>Z</kbd> 或者  <kbd>Ctrl</kbd>+<kbd>C</kbd> 。</p>
<div><p>提示</p>
<p>也可以直接使用 <code>tail -行数 文件名</code> 显示文件末尾的行数内容。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># tail -20 anaconda-ks.cfg</span>
<span>#显示文件 anaconda-ks.cfg 的末尾的 20 行的内容</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></div>
<h3 id="ln-命令"> ln 命令</h3>
<p>如果要想说清楚 <code>ln</code> 命令，则必须先解释下 ext 文件系统（ Linux 文件系统）是如何工作的。我们的 Linux 目前使用的是 ext4 文件系统。</p>
<h4 id="ext4-文件系统"> ext4 文件系统</h4>
<p>ext4 文件系统把分区主要分为两大部分（暂时不提超级块）：小部分用于保存文件的 inode（ i节点）信息；剩余的大部分用于保存 block 信息。如图4-1 所示。</p>
<div>
<p><img src="./assets/ext4.jpg" alt="ext4" loading="lazy"></p>
<p><strong>图4-1	<u>ext4 文件系统示意图</u></strong></p>
</div>
<p>inode 的默认大小为 128 Byte，用来记录文件的权限（ r、w、x ）、文件的所有者和属组、文件的大小、文件的状态改变时间（ ctime ）、文件的最近一次读取时间（ atime ）、文件的最近一次修改时间（ mtime ）、文件的数据真正保存的 block 编号。每个文件需要占用一个 inode。大家如果仔细查看，就会发现 inode 中是不记录文件名的，那是因为文件名记录在文件所在目录的 block 中。</p>
<p>block 的大小可以是 1KB、2KB、4KB，默认为 4KB。block 用于实际的数据存储，如果一个 block 放不下数据，则可以占用多个 block。例如，有一个 10KB 的文件需要存储，则会占用 3 个 block，虽然最后一个 block 不能占满，但也不能再放入其他文件的数据。这 3 个 block 有可能是连续的，也有可能是分散的。</p>
<p>由此，我们可以知道以下 2 个重要的信息：</p>
<ol>
<li>每个文件都独自占用一个 inode，文件内容由 inode 的记录来指向；</li>
<li>如果想要读取文件内容，就必须借助目录中记录的文件名找到该文件的 inode，才能成功找到文件内容所在的 block 块；</li>
</ol>
<p>了解了 Linux 系统底层文件的存储状态后，接下来学习 <code>ln</code> 命令。</p>
<h4 id="ln-命令用法"> ln 命令用法</h4>
<p><code>ln</code> 命令，用于给文件创建链接，根据 Linux 系统存储文件的特点，链接的方式分为以下 2 种：</p>
<ul>
<li>软链接：类似于 Windows 系统中给文件创建快捷方式，即产生一个特殊的文件，该文件用来指向另一个文件，此链接方式同样适用于目录。</li>
<li>硬链接：我们知道，文件的基本信息都存储在 inode 中，而硬链接指的就是给一个文件的 inode 分配多个文件名，通过任何一个文件名，都可以找到此文件的 inode，从而读取该文件的数据信息。</li>
</ul>
<p>英文原意：make links between files</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ln [选项] 源文件 目标文件</span>
选项：
	-s	：建立软链接文件。如果不加 -s 选项，则建立硬链接文件。
	-f	：强制。如果目标文件已经存在，则删除目标文件后再建立链接文件。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>建立硬链接和软链接非常简单，那这两种链接有什么区别？它们都有什么作用？这才是链接文件最不容易理解的地方，我们分别来讲讲。</p>
<h4 id="ln-创建硬链接"> ln 创建硬链接</h4>
<p>我们再来建立一个硬链接文件，然后看看这两个文件的特点。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># touch test</span>
<span>#建立源文件</span>
<span>[</span>root@localhost ~<span>]</span><span># ln /root/test /tmp/test-hard</span>
<span>#给源文件建立硬链接文件 /tmp/test-hard</span>
<span>[</span>root@localhost ~<span>]</span><span># ll -i /root/test /tmp/test-hard</span>
<span>262147</span> -rw-r--r-- <span>2</span> root root <span>0</span> <span>6</span>月 <span>19</span> <span>10</span>:06 /root/test
<span>262147</span> -rw-r--r-- <span>2</span> root root <span>0</span> <span>6</span>月 <span>19</span> <span>10</span>:06 /tmp/test-hard
<span>#查看两个文件的详细信息，可以发现这两个文件的 inode 号是一样的，"ll"等同于"ls -l"。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>这里有一件很奇怪的事情，我们之前在讲 inode 号的时候说过，每个文件的 inode 号都应该是不一样的。inode 号就相当于文件 ID，我们在查找文件的时候，要先查找 inode 号，才能读取到文件的内容。</p>
<p>但是这里源文件和硬链接文件的 inode 号居然是一样的，那我们在查找文件的时候，到底找到的是哪一个文件呢？我们来画一张示意图，如图4-2 所示。</p>
<div>
<p><img src="./assets/hardlink.jpg" alt="Hardlink" loading="lazy"></p>
<p><strong>图4-2	<u>硬链接示意图</u></strong></p>
</div>
<p>在 inode 信息中，是不会记录文件名称的，而是把文件名记录在上级目录的 block 中。也就是说，目录的 block 中记录的是这个目录下所有一级子文件和子目录的文件名及 inode 的对应；而文件的 block 中记录的才是文件实际的数据。</p>
<p>当我们查找一个文件，比如 <code>/root/test</code> 时，要经过以下步骤:</p>
<blockquote>
<ul>
<li>首先找到根目录的 inode（根目录的 inode 是系统已知的，inode 号是 2），然后判断用户是否有权限访问根目录的 block。</li>
<li>如果有权限，则可以在根目录的 block 中访问到 <code>/root</code> 的文件名及对应的 inode 号。</li>
<li>通过 <code>/root/</code> 目录的 inode 号，可以查找到 <code>/root/</code> 目录的 inode 信息，接着判断用户是否有权限访问 <code>/root/</code> 目录的 block。</li>
<li>如果有权限，则可以从 <code>/root/</code> 目录的 block 中读取到 test 文件的文件名及对应的 inode 号。</li>
<li>通过 test 文件的 inode 号，就可以找到 test 文件的 inode 信息，接着判断用户是否有权限访问 test 文件的 block。</li>
<li>如果有权限，则可以读取 block 中的数据，这样就完成了 <code>/root/test</code> 文件的读取与访问。</li>
</ul>
</blockquote>
<p>按照这个步骤，在给源文件 <code>/root/test</code> 建立了硬链接文件 <code>/tmp/test-hard</code> 之后，在 <code>/root/</code> 目录和 <code>/tmp/</code> 目录的 block 中就会建立 test 和 test-hard 的信息，这个信息主要就是文件名和对应的 inode 号。但是我们会发现 test 和 test-hard 的 inode 信息居然是一样的，那么，我们无论访问哪个文件，最终都会访问 inode 号是 262147 的文件信息。</p>
<p>这就是硬链接的原理。<strong>硬链接的特点</strong>如下：</p>
<ul>
<li>不论是修改源文件（test 文件），还是修改硬链接文件（test-hard 文件），另一个文件中的数据都会发生改变。</li>
<li>不论是删除源文件，还是删除硬链接文件，只要还有一个文件存在，这个文件（inode 号是 262147 的文件）都可以被访问。</li>
<li>硬链接不会建立新的 inode 信息，也不会更改 inode 的总数。</li>
<li>硬链接不能跨文件系统（分区）建立，因为在不同的文件系统中，inode 号是重新计算的。</li>
<li>硬链接不能链接目录，因为如果给目录建立硬链接，那么不仅目录本身需要重新建立，目录下所有的子文件，包括子目录中的所有子文件都需要建立硬链接，这对当前的 Linux 来讲过于复杂。</li>
</ul>
<p>硬链接的限制比较多，既不能跨文件系统，也不能链接目录，而且源文件和硬链接文件之间除 inode 号是一样的之外，没有其他明显的特征。这些特征都使得硬链接并不常用，大家有所了解就好。</p>
<h4 id="ln-创建软链接"> ln 创建软链接</h4>
<p>软链接也称作符号链接，相比硬链接来讲，软链接就要常用多了。我们先建立一个软链接，再来看看软链接的特点。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># touch check</span>
<span>#建立源文件</span>
<span>[</span>root@localhost ~<span>]</span><span># ln -s /root/check /tmp/check-soft</span>
<span>#建立软链接文件</span>
<span>[</span>root@localhost ~<span>]</span><span># ll -id /root/check /tmp/check-soft</span>
<span>262154</span> -rw-r--r-- <span>1</span> root root <span>0</span> <span>6</span>月 <span>19</span> <span>11</span>:30 /root/check
<span>917507</span> lrwxrwxrwx <span>1</span> root root <span>11</span> <span>6</span>月 <span>19</span> <span>11</span>:31 /tmp/ check-soft -<span>></span> /root/check
<span>#软链接和源文件的 inode 号不一致，软链接通过 -> 明显地标识出源文件的位置</span>
<span>#在软链接的权限位 lrwxrwxrwx 中，l 就代表软链接文件</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>再强调一下，<strong>软链接的源文件必须写绝对路径</strong>，否则建立的软链接文件就会报错，无法正常使用。</p>
<p>软链接的标志非常明显，首先，权限位中&quot;l&quot;表示这是一个软链接文件；其次，在文件的后面通过 &quot;-&gt;&quot; 显示出源文件的完整名字。所以软链接比硬链接的标志要明显得多，而且软链接也不像硬链接的限制那样多，比如软链接可以链接目录，也可以跨分区来建立软链接。</p>
<p>软链接完全可以当作 Windows 的快捷方式来对待，它的特点和快捷方式一样，我们更推荐大家使用软链接，而不是硬链接。</p>
<p>大家在学习软链接的时候会有一些疑问：Windows 的快捷方式是由于源文件放置的位置过深，不容易找到，建立一个快捷方式放在桌面，方便查找，那 Linux 的软链接的作用是什么呢？</p>
<p>软链接主要是为了照顾管理员的使用习惯。比如，有些系统的自启动文件 <code>/etc/rc.local</code> 放置在 <code>/etc</code> 目录中，而有些系统却将其放置在 <code>/etc/rc.d/rc.local</code> 中，那么干脆对这两个文件建立软链接，不论您习惯操作哪一个文件，结果都是一样的。</p>
<p>如果您比较细心，则应该已经发现软链接和源文件的 inode 号是不一致的，我们也画一张示意图来看看软链接的原理，如图4-3 所示。</p>
<div>
<p><img src="./assets/softlink.jpg" alt="软链接示意图" loading="lazy"></p>
<p><strong>图4-3	<u>软链接示意图</u></strong></p>
</div>
<p>软链接和硬链接在原理上最主要的不同在于：硬链接不会建立自己的 inode 索引和 block（数据块），而是直接指向源文件的 inode 信息和 block，所以硬链接和源文件的 inode 号是一致的；而软链接会真正建立自己的 inode 索引和 block，所以软链接和源文件的 inode 号是不一致的，而且在软链接的 block 中，写的不是真正的数据，而仅仅是源文件的文件名及 inode 号。</p>
<p>我们来看看访问软链接的步骤和访问硬链接的步骤有什么不同。</p>
<blockquote>
<ul>
<li>首先找到根目录的 inode 索引信息，然后判断用户是否有权限访问根目录的 block。</li>
<li>如果有权限访问根目录的 block，就会在 block 中查找到 <code>/tmp/</code> 目录的 inode 号。</li>
<li>接着访问 <code>/tmp/</code> 目录的 inode 信息，判断用户是否有权限访问 <code>/tmp/</code> 目录的 block。</li>
<li>如果有权限，就会在 block 中读取到软链接文件 check-soft 的 inode 号。因为软链接文件会真正建立自己的 inode 索引和 block，所以软链接文件和源文件的 inode 号是不一样的。</li>
<li>通过软链接文件的 inode 号，找到了 check-soft 文件 inode 信息，判断用户是否有权限访问 block。</li>
<li>如果有权限，就会发现 check-soft 文件的 block 中没有实际数据，仅有源文件 check 的 inode 号。</li>
<li>接着通过源文件的 inode 号，访问到源文件 check 的 inode 信息，判断用户是否有权限访问 block。</li>
<li>如果有权限，就会在 check 文件的 block 中读取到真正的数据，从而完成数据访问。</li>
</ul>
</blockquote>
<p>通过这个过程，我们就可以总结出<strong>软链接的特点</strong>（软链接的特点和 Windows 中的快捷方式完全一致）。</p>
<ul>
<li>不论是修改源文件（check），还是修改硬链接文件（check-soft），另一个文件中的数据都会发生改变。</li>
<li>删除软链接文件，源文件不受影响。而删除源文件，软链接文件将找不到实际的数据，从而显示文件不存在。</li>
<li>软链接会新建自己的 inode 信息和 block，只是在 block 中不存储实际文件数据，而存储的是源文件的文件名及 inode 号。</li>
<li>软链接可以链接目录。</li>
<li>软链接可以跨分区。</li>
</ul>
<h2 id="文件目录皆可操作的命令"> 文件目录皆可操作的命令</h2>
<h3 id="rm-命令"> rm 命令</h3>
<p><code>rm</code> 命令，是强大的删除命令，不仅可以删除文件，也可以删除目录。</p>
<p>英文原意：remove files or directories</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># rm [选项] 文件或目录</span>
选项：
	-f	：强制删除
	-r	：第归删除，可以删除目录
	-i	：交互删除，在删除之前会询问用户
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ol>
<li><strong>基本用法</strong></li>
</ol>
<p><code>rm</code> 命令如果任何选项都不加，则默认执行的是 <code>rm -i 文件名</code>，也就是在删除一个文件之前会先询问是否删除。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># touch cangls</span>
<span>[</span>root@localhost ~<span>]</span><span># rm cangls</span>
rm:是否删除普通空文件<span>"cangls"</span>?y
<span>#删除前会询问是否删除</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ol start="2">
<li><strong>删除目录</strong></li>
</ol>
<p>如果需要删除目录，则需要使用 <code>-r</code> 选项。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mkdir -p /test/lm/movie/jp</span>
<span>#递归建立测试目录</span>
<span>[</span>root@localhost ~<span>]</span><span># rm /test</span>
rm:无法删除<span>"/test/"</span>：是一个目录
<span>#如果不加"-r"选项，则会报错</span>
<span>[</span>root@localhost ~<span>]</span><span># rm -r /test</span>
rm:是否进入目录<span>"/test"</span>?y
rm:是否进入目录<span>"/test/lm/movie"</span>?y
rm:是否删除目录<span>"/test/lm/movie/jp"</span>?y
rm:是否删除目录<span>"/test/lm/movie"</span>?y
rm:是否删除目录<span>"/test/lm"</span>?y
rm:是否删除目录<span>"/test"</span>?y
<span>#会分别询问是否进入子目录、是否删除子目录</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>大家会发现，如果每级目录和每个文件都需要确认，那么在实际使用中简直是灾难!</p>
<ol start="3">
<li><strong>强制删除</strong></li>
</ol>
<p>如果要删除的目录中有 1 万个子目录或子文件，那么普通的 <code>rm</code> 删除最少需要确认 1 万次。所以，在真正删除文件的时候，我们会选择强制删除。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mkdir -p /test/lm/movie/jp</span>
<span>#重新建立测试目录</span>
<span>[</span>root@localhost ~<span>]</span><span># rm -rf /test</span>
<span>#强制删除，一了百了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>加入了强制功能之后，删除就会变得很简单，但是需要注意，数据强制删除之后无法恢复，除非依赖第三方的数据恢复工具，如 extundelete 等。但要注意，数据恢复很难恢复完整的数据，一般能恢复 70%~80% 就很难得了。所以，与其把宝压在数据恢复上，不如养成良好的操作习惯。</p>
<p>虽然 -rf 选项是用来删除目录的，但是删除文件也不会报错。所以，为了使用方便，一般不论是删除文件还是删除目录，都会直接使用 -rf 选项。</p>
<h3 id="cp-命令"> cp 命令</h3>
<p><code>cp</code> 命令，既可以复制文件，也可以复制目录。</p>
<p>英文原意：copy files and directories</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cp [选项] 源文件 目标文件</span>
选项：
	-a	：相当于 -dpr 选项的集合，这几个选项我们一一介绍。
	-d	：如果源文件为软链接（对硬链接无效），则复制出的目标文件也为软链接。
	-i	：询问，如果目标文件已经存在，则会询问是否覆盖。
	-l	：把目标文件建立为源文件的硬链接文件，而不是复制源文件。
	-s	：把目标文件建立为源文件的软链接文件，而不是复制源文件。
	-p	：复制后目标文件保留源文件的属性（包括所有者、所属组、权限和时间）。
	-r	：递归复制，用于复制目录。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ol>
<li><strong>基本用法</strong></li>
</ol>
<p><code>cp</code> 命令既可以复制文件，也可以复制目录。我们先来看看如何复制文件，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># touch cangls</span>
<span>#建立源文件</span>
<span>[</span>root@localhost ~<span>]</span><span># cp cangls /tmp/</span>
<span>#把源文件不改名复制到 /tmp/ 目录下</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果需要改名复制，则命令如下:</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cp cangls /tmp/bols</span>
<span>#改名复制</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果复制的目标位置已经存在同名的文件，则会提示是否覆盖，因为 <code>cp</code> 命令默认执行的是 <code>cp -i</code> 的别名，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cp cangls /tmp/</span>
cp:是否覆盖<span>"/tmp/cangls"</span>?y
<span>#目标位置有同名文件，所以会提示是否覆盖</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>接下来我们看看如何复制目录，其实复制目录只需使用 -r 选项即可，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mkdir movie</span>
<span>#建立测试目录</span>
<span>[</span>root@localhost ~<span>]</span><span># cp -r /root/movie/ /tmp/</span>
<span>#目录原名复制</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ol start="2">
<li><strong>复制软链接文件</strong></li>
</ol>
<p>如果源文件不是一个普通文件，而是一个软链接文件，那么是否可以复制软链接的属性呢？我们试试：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ln -s /root/cangls /tmp/cangls_slink</span>
<span>#建立一个测试软链接文件 /tmp/cangls_slink</span>
<span>[</span>root@localhost ~<span>]</span><span># ll /tmp/cangls_slink</span>
lrwxrwxrwx <span>1</span> root root <span>12</span> <span>6</span> 月 <span>14</span> 05:53 /tmp/cangls_slink -<span>></span> /root/cangls
<span>#源文件本身就是一个软链接文件</span>
<span>[</span>root@localhost ~<span>]</span><span># cp /tmp/cangls_slink /tmp/cangls_t1</span>
<span>#复制软链接文件，但是不加"-d"选项</span>
<span>[</span>root@localhost ~<span>]</span><span># cp -d /tmp/cangls_slink /tmp/cangls_t2</span>
<span>#复制软链接文件，加入"-d"选项</span>
<span>[</span>root@localhost ~<span>]</span><span># ll /tmp/cangls_t1 /tmp/cangls_t2</span>
-rw-r--r-- <span>1</span> root root <span>0</span> <span>6</span>月 <span>14</span> 05:56 /tmp/cangls_t1
<span>#会发现不加"-d"选项，实际复制的是软链接的源文件，而不是软链接文件</span>
lrwxrwxrwx <span>1</span> root root <span>12</span> <span>6</span> 月 <span>14</span> 05:56/tmp/ cangls_t2-<span>></span> /root/cangls
<span>#而如果加入了"-d"选项，则会复制软链接文件</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>这个例子说明，如果在复制软链接文件时不使用 -d 选项，则 <code>cp</code> 命令复制的是源文件，而不是软链接文件；只有加入了 -d 选项，才会复制软链接文件。请大家注意，-d 选项对硬链接是无效的。</p>
<ol start="3">
<li><strong>保留源文件属性复制</strong></li>
</ol>
<p>我们发现，在执行复制命令后，目标文件的时间会变成复制命令的执行时间，而不是源文件的时间。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cp /var/lib/mlocate/mlocate.db /tmp/</span>
<span>[</span>root@localhost ~<span>]</span><span># ll /var/lib/mlocate/mlocate.db</span>
-rw-r-----1 root <span>slocate</span> <span>2328027</span> <span>6</span>月 <span>14</span> 02:08/var/lib/mlocate/mlocate.db
<span>#注意源文件的时间和所属组</span>
<span>[</span>root@localhost ~<span>]</span><span>#ll /tmp/mlocate.db</span>
-rw-r----- <span>1</span> root root <span>2328027</span> <span>6</span> 月 <span>14</span> 06:05/tmp/mlocate.db
<span>#由于复制命令由root用户执行，所以目标文件的所属组为了root，而且时间也变成了复制命令的执行时间</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>而当我们执行备份、曰志备份的时候，这些文件的时间可能是一个重要的参数，这就需执行 -p 选项了。这个选项会保留源文件的属性，包括所有者、所属组和时间。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cp -p /var/lib/mlocate/mlocate.db /tmp/mlocate.db_2</span>
<span>#使用"-p"选项</span>
<span>[</span>root@localhost ~<span>]</span><span># ll /var/lib/mlocate/mlocate.db /tmp/mlocate.db_2</span>
-rw-r----- root <span>slocate</span> <span>2328027</span> <span>6</span>月 <span>14</span> 02:08 /tmp/mlocate.db_2
-rw-r----- root <span>slocate</span> <span>2328027</span> <span>6</span>月 <span>14</span> 02:08 /var/lib/mlocate/mlocate.db
<span>#源文件和目标文件的所有属性都一致，包括时间</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>我们之前讲过，-a 选项相当于 -dpr 选项，这几个选项我们已经分别讲过了。所以，当我们使用 -a 选项时，目标文件和源文件的所有属性都一致，包括源文件的所有者，所属组、时间和软链接性。使用 -a 选项来取代 -dpr 选项更加方便。</p>
<h3 id="mv-命令"> mv 命令</h3>
<p><code>mv</code> 命令，既可以在不同的目录之间移动文件或目录，也可以对文件和目录进行重命名。</p>
<p>英文原意：move (rename) files</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mv [选项] 源文件 目标文件</span>
选项：
	-f	：强制覆盖，如果目标文件已经存在，则不询问，直接强制覆盖。
	-i	：交互移动，如果目标文件已经存在，则询问用户是否覆盖（默认选项）。
	-n	：如果目标文件已经存在，则不会覆盖移动，而且不询问用户。
	-v	：显示文件或目录的移动过程。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><p>注意</p>
<p>同 <code>rm</code> 命令类似，<code>mv</code> 命令也是一个具有破坏性的命令，如果使用不当，很可能给系统带来灾难性的后果。</p>
</div>
<ol>
<li><strong>基本用法</strong></li>
</ol>
<p>移动文件或目录。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mv cangls /tmp</span>
<span>#移动之后，源文件会被删除，类似剪切</span>
<span>[</span>root@localhost ~<span>]</span><span># mkdir movie</span>
<span>[</span>root@localhost ~<span>]</span><span># mv movie/ /tmp</span>
<span>#也可以移动目录。和 rm、cp 不同的是，mv 移动目录不需要加入 "-r" 选项</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>如果移动的目标位置已经存在同名的文件，则同样会提示是否覆盖，因为 <code>mv</code> 命令默认执行的也是 <code>mv -i</code> 的别名，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># touch cangls</span>
<span>#重新建立文件</span>
<span>[</span>root@localhost ~<span>]</span><span># mv cangls /tmp</span>
mv:县否覆盖<span>"tmp/cangls"</span>? y
<span>#由于 /tmp 目录下已经存在 cangls 文件，所以会提示是否覆盖，需要手工输入 y 覆盖移动</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ol start="2">
<li><strong>强制移动</strong></li>
</ol>
<p>之前说过，如果目标目录下已经存在同名文件，则会提示是否覆盖，需要手工确认。这时如果移动的同名文件较多，则需要一个一个文件进行确认，很不方便。</p>
<p>如果我们确认需要覆盖已经存在的同名文件，则可以使用 -f 选项进行强制移动，这就不再需要用户手工确认了。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># touch cangls</span>
<span>#重新建立文件</span>
<span>[</span>root@localhost ~<span>]</span><span># mv -f cangls /tmp</span>
<span>#就算 /tmp/ 目录下已经存在同名的文件，由于"-f"选项的作用，所以会强制覆盖</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ol start="3">
<li><strong>不覆盖移动</strong></li>
</ol>
<p>既然可以强制覆盖移动，那也有可能需要不覆盖的移动。如果需要移动几百个同名文件，但是不想覆盖，这时就需要 -n 选项的帮助了。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls /tmp</span>
/tmp/bols /tmp/cangls
<span>#在/tmp/目录下已经存在bols、cangls文件了</span>
<span>[</span>root@localhost ~<span>]</span><span># mv -vn bols cangls lmls /tmp/</span>
<span>"lmls"</span>-<span>></span><span>"/tmp/lmls"</span>
<span>#再向 /tmp/ 目录中移动同名文件，如果使用了 "-n" 选项，则可以看到只移动了 lmls，而同名的 bols 和 cangls 并没有移动（"-v" 选项用于显示移动过程）</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ol start="4">
<li><strong>改名</strong></li>
</ol>
<p>如果源文件和目标文件在同一目录中，那就是改名。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mv bols lmls</span>
<span>#把 bols 改名为 lmls</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>目录也可以按照同样的方法改名。</p>
<ol start="5">
<li><strong>显示移动过程</strong></li>
</ol>
<p>如果我们想要知道在移动过程中到底有哪些文件进行了移动，则可以使用 -v 选项来查看详细的移动信息。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># touch test1.txt test2.txt test3.txt</span>
<span>#建立三个测试文件</span>
<span>[</span>root@localhost ~<span>]</span><span># mv -v *.txt /tmp</span>
<span>"test1.txt"</span> -<span>></span> <span>"/tmp/test1.txt"</span>
<span>"test2.txt"</span> -<span>></span> <span>"/tmp/test2.txt"</span>
<span>"test3.txt"</span> -<span>></span> <span>"/tmp/test3.txt"</span>
<span>#加入"-v"选项，可以看到有哪些文件进行了移动</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-05-05T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">linux权限管理命令</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_basic/04.linux_authority/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_basic/04.linux_authority/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="权限介绍"> 权限介绍</h2>
<h3 id="为什么需要权限"> 为什么需要权限</h3>
<p>我们发现，初学者并不是不能理解权限命令，而是不能理解为什么需要设定不同的权限。所有的人都直接使用管理员身份，不可以吗？这是由于绝大多数用户使用的是个人计算机，而使用个人计算机的用户一般都是被信任的用户（如家人、朋友等）。在这种情况下，大家都可 以使用管理员身份直接登录。又因为管理员拥有最大权限，所以给我们带来了错觉，以为在计算机中不需要分配权限等级，不需要使用不同的账户。但是在服务器上就不是这种情况了，在服务器上运行的数据越重要（如游戏数据），价值越高（如电子商城数据、银行数据），那么对权限的设定就要越详细，用户的分级也要越明确。所以，在服务器上，绝对不是所有的用户都使用 root 身份登录，而要根据不同的工作需要和职位需要，合理分配用户等级和权限等级。</p>
<h3 id="所有者、所属组和其他人"> 所有者、所属组和其他人</h3>
<p>前面讲 <code>ls</code> 命令的 -l 选项时，简单解释过所有者和所属组以及其他人，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls -l install.log</span>
-rw-r--r--.   <span>1</span> root root    <span>24772</span> <span>1</span>月  <span>14</span> <span>18</span>:17 install.log
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>命令的第三列 root 用户就是文件的所有者，第四列 root 组就是文件的所属组。而且我们也介绍过，文件的所有者一般就是这个文件的建立者，而系统中绝大多数系统文件都是由 root 建立的，所以绝大多数系统文件的所有者都是 root。 接下来我们解释一下所属组，首先讲解一下用户组的概念。用户组就是一组用户的集合，类似于大学里的各种社团。那为什么要把用户放入一个用户组中呢？当然是为了方便管理。大家想想，如果我有 100 位用户，而这 100 位用户对同一个文件的权限是一致的，那我是一位用户一位用户地分配权限方便，还是把 100 位用户加入一个用户组中，然后给这个用户组分配权限方便呢？不言而喻，一定是给一个用户组分配权限更加方便。综上所述，给一个文件区分所有者、所属组和其他人，就是为了分配权限方便。就像你买了一台电脑，那你当然是这台电脑的所有者，可以把你的朋友加入一个用户组，其他不认识的路人当然就是其他人了。分配完了用户身份，就可以分配权限了，所有者当然对这台电脑拥有所有的权限，而位于所属组中的这些朋友可以借用你的电脑，而其他人则完全不能碰你的电脑。</p>
<h3 id="权限位的含义"> 权限位的含义</h3>
<p>前面讲解 <code>ls</code> 命令时，我们长格式显示的第一列就是文件的权限，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls -l install.log</span>
-rw-r--r--    <span>1</span> root root    <span>24772</span> <span>1</span>月  <span>14</span> <span>18</span>:17 install.log
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>第一列的权限位共有 10 位，这 10 位权限位的含义如图5-1 所示。</p>
<div>
<p><img src="./assets/per.png" alt="权限位" loading="lazy"></p>
<p><strong>图5-1	<u>权限位的含义</u></strong></p>
</div>
<ul>
<li>第 1 位代表文件类型</li>
</ul>
<blockquote>
<p>-：普通文件</p>
<p>b：块设备文件。这是一种特殊设备文件，存储设备都是这样的文件，如分区文件/dev/sda1就是这种文件。</p>
<p>c：字符设备文件。也是特殊设备文件，输入设备一般都是这种文件，如鼠标、键盘等。</p>
<p>d：目录文件。linux中一切皆文件，所以目录也是文件的一种。</p>
<p>l：软链接文件。相当于快捷方式。</p>
<p>p：管道符文件。这是一种非常少见的特殊设备文件。</p>
<p>s：套接字文件。这也是一种特殊设备文件，一些服务支持 Socket 访问，就会产生这样的文件。</p>
<p>?：其他文件</p>
</blockquote>
<ul>
<li>第 2～4 位代表文件所有者的权限。</li>
</ul>
<blockquote>
<p>-r：代表 read，是读取限。</p>
<p>-w：代表 write，是写权限。</p>
<p>-x：代表 execute，是执行权限。</p>
<p>如果有字母，代表对应的权限；如果是“-”，则代表没有对应的权限。</p>
</blockquote>
<ul>
<li>第 5～7 位代表文件所属组的权限。</li>
</ul>
<blockquote>
<p>同样拥有 rwx 权限</p>
</blockquote>
<ul>
<li>第 8～10 位代表文件的其他人权限。</li>
</ul>
<blockquote>
<p>同样拥有 rwx 权限</p>
</blockquote>
<div><p>提示</p>
<p>有的文件拥有第 11 位权限位“.”，这个“.”是什么意思呢？这就不得要提到 SELinux 了。</p>
<p>SELinux（Security-Enhanced Linux）是美国国家安全局（NSA）对于强制访问控制的实现，是 Linux 历史上最杰出的新安全子系统。是一种基于“域-类型”模型（domain-type）的强制访问控制（MAC）安全系统，它由 NSA 编写并设计成内核模块包含到内核中，相应的某些安全相关的应用也被打了 SELinux 的补丁，最后还有一个相应的安全策略。2.6 及以上版本的 Linux 内核都已经集成了 SELinux 模块。</p>
<p>SELinux 的结构及配置非常复杂，而且有大量概念性的东西，要学精难度较大。很多 Linux 系统管理员嫌麻烦都把 SELinux 关闭了。如果可以熟练掌握 SELinux 并正确运用，我觉得整个系统基本上可以到达&quot;坚不可摧&quot;的地步了（请永远记住没有绝对的安全）。</p>
<p>其配置文件：  <code>/etc/selinux/config</code></p>
<p>SELinux 有三种工作模式，分别是：</p>
<ol>
<li>
<p>enforcing：强制模式。违反 SELinux 规则的行为将被阻止并记录到日志中。</p>
</li>
<li>
<p>permissive：宽容模式。违反 SELinux 规则的行为只会记录到日志中。一般为调试用。</p>
</li>
<li>
<p>disabled：关闭 SELinux。</p>
</li>
</ol>
</div>
<h2 id="chmod-命令"> chmod 命令</h2>
<p><code>chmod</code> 命令，用于修改文件权限。</p>
<p>英文原意：change file mode bits</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># chmod [选项] 权限模式 文件名</span>
选项：
	-R	：第归设置权限，也就是给子目录中所有文件设定权限。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="权限模式"> 权限模式</h3>
<p><code>chmod</code> 命令的权限模式的格式是<code>[ugoa][[+-=][perms]]</code>，也就是<code>[用户身份][[赋予方式][权限]]</code>的格式，我们来解释一下。</p>
<ul>
<li>用户身份。</li>
</ul>
<blockquote>
<p>u：代表所有者（user）。</p>
<p>g：代表所属组（group）。</p>
<p>o：代表其他人（other）。</p>
<p>a：代表全部身份（all）。</p>
</blockquote>
<ul>
<li>赋予方式。</li>
</ul>
<blockquote>
<p>+：加入权限。</p>
<p>-：减去权限。</p>
<p>=：设置权限。</p>
</blockquote>
<ul>
<li>权限。</li>
</ul>
<blockquote>
<p>r：读取权限（read）。</p>
<p>w：写权限（write）。</p>
<p>x：执行权限（execute）。</p>
</blockquote>
<p>这里我们只讲解基本权限，至于特殊权限（如 suid、sgid 和 sbit 等），我们在后面再详细讲解。</p>
<h3 id="数字权限"> 数字权限</h3>
<p>数字权限的赋予方式是最简单的，但是不如前面的字母权限好记、直观。</p>
<p>数字权限的含义：</p>
<ul>
<li>
<p>4：代表 r 权限</p>
</li>
<li>
<p>2：代表 w 权限</p>
</li>
<li>
<p>1：代表 x 权限</p>
</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># chmod 755 install.log</span>
<span>[</span>root@localhost ~<span>]</span><span># ls -l install.log</span>
-rwxr-xr-x    <span>1</span> root root    <span>24772</span> <span>1</span>月  <span>14</span> <span>18</span>:17 install.log
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>755权限解释说明：</p>
<blockquote>
<p>第一个数字 7 ：代表所有者的权限是“ 4+2+1 ”，也就是“ rwx ”，读、写、执行权限</p>
<p>第二个数字 5 ：代表所有组的权限是“ 4+1 ”，也就是“ r-x ”，读、执行权限</p>
<p>第三个数字 5 ：代表其他人的权限是“ 4+1 ”，也就是“ r-x ”，读、执行权限</p>
</blockquote>
<div><p>提示</p>
<p>数字权限的赋予方式更加简单，但是需要用户对这几个数字更加熟悉。其实常用的权限也并不多，只有如下几个：</p>
<ul>
<li>644：这是文件的基本权限，代表所有者拥有读、写权限，而所属组和其他人拥有只读权限</li>
<li>755：这是文件的执行权限和目录的基本权限，代表所有者拥有读、写、执行权限，而所有组和其他人拥有读、执行权限</li>
<li>777：这是最大权限，在实际生产服务器中，要尽力避免给文件或目录赋予这样的权限，这回造成一定的安全隐患</li>
</ul>
<p>我们很少会使用 457 这样的权限，因为这样的权限是不合理的，怎么可能文件的所有者的权限还没有其他人的权限大呢？所以，除非是实验需要，否则一般情况下所有者的权限要大于所属组和其他人的权限。</p>
</div>
<h3 id="基本权限的含义"> 基本权限的含义</h3>
<ol>
<li>权限含义的解释</li>
</ol>
<p>我们已经知道了权限的赋予方式，但是这些读、写、执行权限到底是什么含义呢？有些人可能会说：“你也太小瞧我们了，读、写、执行的含义这么明显，我们还能不知道吗？” 其实，这些权限的含义不像表面上这么明显，下面我们就来讲讲这些权限到底是什么含义。</p>
<p>首先，读、写、执行权限对文件和目录的作用是不同的。</p>
<ul>
<li>
<p>权限对文件的作用</p>
<ul>
<li>读（r）：对文件有读（r）权限，代表可以读取文件中的数据。如果把权限对应到命 令上，那么一旦对文件有读（r）权限，就可以对文件执行 <code>cat</code>、<code>more</code>、<code>less</code>、<code>head</code>、<code>tail</code> 等文件查看命令。</li>
<li>写（w）：对文件有写（w）权限，代表可以修改文件中的数据。如果把权限对应到命令上，那么一旦对文件有写（w）权限，就可以对文件执行 <code>vim</code>、<code>echo</code> 等修改文件数据的命令。<u>注意：对文件有写权限，是不能删除文件本身的，只能修改文件中的数据。如果要想删除文件，则需要对文件的上级目录拥有写权限。</u></li>
<li>执行（x）：对文件有执行（x）权限，代表文件拥有了执行权限，可以运行。在 Linux 中，只要文件有执行（x）权限，这个文件就是执行文件了。只是这个文件到底能不能正确执行，不仅需要执行（x）权限，还要看文件中的代码是不是正确的语言代码。对文件来说，执行（x）权限是最高权限。</li>
</ul>
</li>
<li>
<p>权限对目录的作用</p>
<ul>
<li>读（r）：对目录有读（r）权限，代表可以查看目录下的内容，也就是可以查看目录下有哪些子文件和子目录。如果把权限对应到命令上，那么一旦对目录拥有了读（r） 权限，就可以在目录下执行 <code>ls</code> 命令，查看目录下的内容了。</li>
<li>写（w）：对目录有写（r）权限，代表可以修改目录下的数据，也就是可以在目录中新建、删除、复制、剪切子文件或子目录。如果把权限对应到命令上，那么一旦对目录拥有了写（w）权限，就可以在目录下执行 <code>touch</code>、<code>rm</code>、<code>cp</code>、<code>mv</code> 命令。对目录来 说，写（w）权限是最高权限。</li>
<li>执行（x）：目录是不能运行的，那么对目录拥有执行（x）权限，代表可以进入目录。 如果把权限对应到命令上，那么一旦对目录拥有了执行（x）权限，就可以对目录执行 <code>cd</code> 命令，进入目录。</li>
</ul>
</li>
</ul>
<h2 id="chown-命令"> chown 命令</h2>
<p><code>chown</code> 命令，用于修改文件和目录的所有者和所属组。</p>
<p>英文原意：change file owner and group</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># chown [选项] 所有者:所属组 文件或目录</span>
选项：
	-R	：第归设置权限，也就是给子目录中的所有文件设置权限。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="常见用法"> 常见用法</h3>
<ol>
<li><strong>修改文件的所有者</strong></li>
</ol>
<p>之所以需要修改文件的所有者，是因为赋予权限的需要。当普通用户需要对某个文件拥有最高权限的时候，是不能把其他人的权限修改为最高权限的，也就是不能出现 777 的权限，这是非常不安全的做法。合理的做法是修改文件的所有者，这样既能让普通用户拥有最高权限，又不会影响其他普通用户。我们来看一个例子：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># touch laowang </span>
<span>#由 root 用户创建 laowang 文件 </span>
<span>[</span>root@localhost ~<span>]</span><span># ll laowang</span>
-rw-r--r-- 1root root <span>0</span> <span>6</span>月 <span>16</span> 05:12 laowang 
<span>#文件的所有者是 root，普通用户 user 对这个文件拥有只读权限 </span>
<span>[</span>root@localhost ~<span>]</span><span># chown user laowang </span>
<span>#修改文件的所有者 </span>
<span>[</span>root@localhost ~<span>]</span><span># ll laowang </span>
-rw-r--r-- <span>1</span> user root <span>0</span> <span>6</span>月 <span>16</span> 05:12 laowang 
<span>#所有者变成了user 用户，这时 user 用户对这个文件就拥有了读、写权限</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ol start="2">
<li><strong>修改文件的所属组</strong></li>
</ol>
<p><code>chown</code> 命令不仅可以修改文件的所有者，也可以修改文件的所属组。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># chown user:user laowang </span>
<span>#“:”之前是文件的所有者，之后是所属组。这里的“:”也可以使用“.”代替 </span>
<span>[</span>root@localhost ~<span>]</span><span># ll laowang </span>
-rw-r--r-- l user user <span>0</span> <span>6</span>月 <span>16</span> 05:12 laowang 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>修改所属组，也是为了调整文件的权限。只是我们目前还没有学习如何把用户加入用户组中，如果可以把用户加入同一个组当中，然后直接调整所属组的权限，那当然要比一个一个用户赋予权限要简单方便。 Linux 中用户组的建立与 Windows 中是不同的。在 Windows 中，新建的用户都属于 users 这个组，而不会建立更多的新组。但是在 Linux 中，每个用户建立之后，都会建立和用户名同名的用户组，作为这个用户的初始组，user 用户组是自动建立的。</p>
<ol start="3">
<li><strong>普通用户修改权限</strong></li>
</ol>
<p>在讲权限作用的时候强调过，并不是只有 root 用户才可以修改文件的权限，而是超级用户可以修改任何文件的权限，但是普通用户只能修改自己文件的权限。也就是说，只有普通用户是这个文件的所有者，才可以修改文件的权限。我们试试：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cd /home/user/ </span>
<span>#进入 user 用户的家目录 </span>
<span>[</span>root@localhost user<span>]</span><span># touch test </span>
<span>#由 root 用户新建文件 test </span>
<span>[</span>root@localhost user<span>]</span><span># ll test</span>
-rw-r--r-- <span>1</span> root root <span>0</span> <span>6</span>月 <span>16</span> 05:37 <span>test</span> 
<span>#文件所有者和所属组都是 root 用户 </span>
<span>[</span>root@localhost user<span>]</span><span># su- user </span>
<span>#切换为 user 用户 </span>
<span>[</span>user@localhost ~<span>]</span>$ <span>chmod</span> <span>755</span> <span>test</span>
chmod：更改"test”的权限：不允许的操作 
<span>#user 用户不能修改 test 文件的权限 </span>
<span>[</span>user@localhost ~<span>]</span>$ <span>exit</span> 
<span>#退回到 root 身份 </span>
<span>[</span>root@localhost user<span>]</span><span># chown user test </span>
<span>#由 root 用户把 test 文件的所有者改为 user 用户 </span>
<span>[</span>root@localhost user<span>]</span><span># su- user </span>
<span>#切换为user 用户 </span>
<span>[</span>user@localhost ~<span>]</span>$ <span>chmod</span> <span>755</span> <span>test</span> 
<span>#user 用户由于是 test 文件的所有者，所以可以修改文件的权限 </span>
<span>[</span>user@localhost ~<span>]</span>$ ll <span>test</span> 
-rwxr-xr-x <span>1</span> user root <span>0</span> <span>6</span>月 <span>16</span> 05:37 <span>test</span> 
<span>#查看权限</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>通过这个实验，我们可以确定，如果普通用户是这个文件的所有者，就可以修改文件的权限。</p>
<h2 id="chgrp-命令"> chgrp 命令</h2>
<p><code>chgrp</code> 命令，用于修改文件或目录的所属组。</p>
<p>英文原意：change group ownership</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># chgrp 所属组 文件或目录</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="常见用法-2"> 常见用法</h3>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># touch test </span>
<span>#由 root 用户创建 test 文件 </span>
<span>[</span>root@localhost ~<span>]</span><span># chgrp user test </span>
<span>#修改文件的所属组 </span>
<span>[</span>root@localhost ~<span>]</span><span># ll test </span>
-rw-r--r-- <span>1</span> root user <span>0</span> <span>6</span>月 <span>16</span> 09:32 <span>test</span> 
<span>#所属组变成了user</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="umask-命令"> umask 命令</h2>
<h3 id="umask-默认权的作用"> umask 默认权的作用</h3>
<p><code>umask</code> 默认权限是 Linux 权限的一种，主要用于 Linux 中的新建文件和目录拥有默认权限。 Limux 是一个比较安全的操作系统，而安全的基础就是权限，所以，在 Linux 中所有的文件和目录都要有基本的权限，新建的文件和目录当然也要有默认的权限。</p>
<p>在 Linux 中，通过 <code>umask</code> 默认权限来给所有新建立的文件和目录赋予初始权限，这一点和 Windows 不太一样，Windows是通过继承上级目录的权限来给文件和目录赋予初始权限的。</p>
<p>查看系统的 <code>umask</code> 权限：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># umask</span>
0022
<span>#用八进制数值显示 umask 权限</span>
<span>[</span>root@localhost ~<span>]</span><span># umask -S</span>
u-rwx,g-rx,o<span>=</span>rx 
<span>#用字母表示文件和目录的初始权限</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>使用“ -S ”选项，会直接用字母来表示文件和目录的初始权限。我们查看数值的 <code>umask</code> 权限，看到的是 4 位数字“0022”，其中第一个数字“0”代表的是文件的特殊权限（SetUID、 SetGID、Sticky BIT），暂不讨论。也就是后 3 位数字“022”才是真正的 <code>umask</code> 默认权限。</p>
<h3 id="umask-默认权限的计算方法"> umask 默认权限的计算方法</h3>
<p>在学习 <code>umask</code> 默认权限的计算方法之前，我们需要先了解一下新建文件和目录的默认最大权限。</p>
<ul>
<li>
<p>对文件来讲，新建文件的默认最大权限是 666，没有执行（x）权限。这是因为执行权限对文件来讲比较危险，不能在新建文件的时候默认赋予，而必须通过用户手工赋予。</p>
</li>
<li>
<p>对目录来讲，新建目录的默认最大权限是 777。这是因为对目录而言，执行（x）权限仅仅代表进入目录，所以即使建立新文件时直接默认赋予，也没有什么危险。</p>
</li>
</ul>
<p>接下来我们学习如何计算 <code>umask</code> 默认权限。按照官方的标准算法，<code>umask</code> 默认权限需要使用二进制进行逻辑与和逻辑非联合运算才可以得到正确的新建文件和目录的默认权限。这种方法既不好计算，也不好理解，并不推荐。 我们在这里还是按照权限字母来讲解 <code>umask</code> 权限的计算方法。</p>
<p>我们就按照默认的 <code>umask</code> 值是 022 来分别计算一下新建文件和目录的默认权限吧。</p>
<ul>
<li>文件的默认权限最大只能是 666，换算成字母就是“-rw-rw-rw-”；而 <code>umask</code> 的值是 022， 也换算成字母就是“----w--w-”。把两个字母权限相减，得到的就是新建文件的默认权限 644：（ -rw-r--r-- ）=<strong>（ -rw-rw-rw- ）-（ ----w--w-）</strong>。</li>
<li>目录的默认权限最大可以是 777，换算成字母就是“drwxrwxrwx”；而 umask 的值是 022，也换算成字母就是“d----w--w-”。也把两个字母权限相减，得到的就是新建目录的默认权限 755：（ drwx-r-xr-x ）=<strong>（ drwxrwxrwx ）-（ d----w--w- ）</strong>。</li>
</ul>
<p>我们测试一下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># umask</span>
0022
<span>#默认 umask 的值是 0022 </span>
<span>[</span>rootelocalhost ~<span>]</span><span># touch laowang </span>
<span>[</span>root@localhost ~<span>]</span><span># mkdir fengjie </span>
<span>[</span>root@localhost ~1<span># ll -d laowang fengjie/ </span>
drwxr-xr-x <span>2</span> root root <span>4096</span> <span>6</span>月 <span>16</span> 02:36 fengjie/ 
-rw-r--r-- <span>1</span> root root <span>0</span> <span>6</span>月 <span>16</span> 02:36 laowang 
<span>#新建立目录的默认权展是 755，新建立文件的默认权限是 644 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><p>注意</p>
<p>这里强调一下，<code>umask</code> 默认权限的计算是不能直接使用数字相减的。很多人会理解为，既然文件的默认极限最大是“666”，<code>umask</code> 的值是“022”，而新建文件的值刚好是“644”，那是不是就是直接使用“666-644”呢？这是不对的，如果 <code>umask</code> 的值是“033”呢？按照数值相减，就会得到“633”的值。但是我们强调过文件是不能在新建立时就拥有执行（x）权限 的，而权限“3”是包含执行（x）权限的。我们测试一下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># umask 033</span>
<span>#修改 umask 的值为 033 </span>
<span>[</span>root@localhost ~<span>]</span><span># touch xuejie</span>
<span>#建立测试文件xuejie </span>
<span>[</span>root@localhost ~<span>]</span><span># ll xuejie </span>
-rw-r--r-- <span>1</span> root root <span>0</span> <span>6</span>月 <span>16</span> 02:46 xuejie xuejie 
<span>#文件的默认权限依然是 644 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>由这个例子我们可以知道：</p>
<p><strong><code>umask</code> 默认权限一定不是直接使用权限数字相减得到的，而是通过二进制逻辑与和逻辑非联合运算得到的。最简单的办法还是使用权限字母来计算。</strong></p>
<p>文件的默认权限最大只能是 666 ，换算成字母就是“-rw-rw-rw-”；而 <code>umask</code> 的值是 033，也换算成字母就是“-----wx-wx”。把两个字母权限相减，得到的就是新建文件的默认权限：（-rw-rw-rw-）-（-----wx-wx）=（-rw-r--r--）。</p>
</div>
<h3 id="umask-默认权限的修改方法"> umask 默认权限的修改方法</h3>
<p><code>umask</code> 默认权限可以直接通过命令来进行修改，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># umask 002</span>
<span>[</span>root@localhost ~<span>]</span><span># umask 033</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>不过，通过命令进行的修改只能临时生效，一旦重启或重新登录就会失效。如果想让修改永久生效，则需要修改对应的环境变量配置文件<code>/etc/profile</code>。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vi /etc/profile</span>
<span>..</span>.省略部分内容<span>..</span>.
if<span>[</span> <span>$UID</span> -gt <span>199</span> <span>]</span> <span>&amp;&amp;</span> <span>[</span><span>"<span><span>`</span><span>id</span> -gn'<span>`</span></span>"</span><span>=</span><span>"<span><span>`</span><span>id</span> -un<span>`</span></span>"</span><span>]</span><span>;</span> <span>then</span>
	<span>umask</span> 002 
	<span>#如果 UID 大于199（普通用户），则使用此 umask 值 </span>
<span>else</span>
	<span>umask</span> 022 
	<span>#如果 UID 小于 199（超级用户)，则使用此 umask 值</span>
<span>fi</span>
<span>..</span>.省略部分内容<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>这是一段 Shell 脚本，大家目前可能看不懂，但是没有关系，只需知道普通用户的 <code>umask</code> 值由 if 语句的第一段定义，而超级用户的 <code>umask</code> 值由 else 语句定义即可。如果修改的是这个文件，则 <code>umask</code> 值是永久生效的。 我们学习了文件的基本权限和 <code>umask</code> 默认权限这两种权限，但是 Linux 的权限并不只有这两种，其他的权限内容我们会在后面详细介绍，这里就不一一列举了。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-05-07T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">linux帮助命令</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_basic/05.linux_help/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_basic/05.linux_help/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="man-命令"> man 命令</h2>
<p><code>man</code> 命令，是最常见的帮助命令，也是 Linux 最主要的帮助命令。</p>
<p>英文原意：an interface to the on-line reference manuals</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># man [选项] 命令</span>
选项：
	-f	：查看命令拥有哪个级别的帮助
	-k	：查看和命令相关的所有帮助
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><code>man</code> 命令比较简单，我们举个例子：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># man ls</span>
<span>#获取 ls 命令的帮助信息</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这就是 <code>man</code> 命令的基本使用方法，非常简单。但是帮助命令的重点不是命令如何使用，而是帮助信息应该如何查询。这些信息较多，我们通过下面的内容来详细讲解。</p>
<ol>
<li><strong>使用方法</strong></li>
</ol>
<p>还是查看 <code>ls</code> 命令的帮助，我们看看这个帮助信息的详细内容。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># man ls</span>
LS<span>(</span><span>1</span><span>)</span>                            User Commands                           LS<span>(</span><span>1</span><span>)</span>

NAME
       <span>ls</span> - list directory contents
       <span>#命令名称及英文原意</span>

SYNOPSIS
       <span>ls</span> <span>[</span>OPTION<span>]</span><span>..</span>. <span>[</span>FILE<span>]</span><span>..</span>.
       <span>#命令的格式</span>

DESCRIPTION
<span>#开始详细介绍命令选项的作用</span>
       List  information  about  the FILEs <span>(</span>the current directory by default<span>)</span>.
       Sort entries alphabetically <span>if</span> none of -cftuvSUX nor --sort  is  speci‐
       fied.

       Mandatory  arguments  to  long  options are mandatory <span>for</span> short options
       too.

       -a, --all
              <span>do</span> not ignore entries starting with <span>.</span>

       -A, --almost-all
              <span>do</span> not list implied <span>.</span> and <span>..</span>

AUTHOR
<span>#作者</span>
       Written by Richard M. Stallman and David MacKenzie.

REPORTING BUGS
<span>#bug的报告地质</span>
       GNU coreutils online help: <span>&lt;</span>http://www.gnu.org/software/coreutils/<span>></span>
       Report <span>ls</span> translation bugs to <span>&lt;</span>http://translationproject.org/team/<span>></span>

COPYRIGHT
<span>#著作权受GPL规则保护</span>
       Copyright © <span>2017</span> Free Software Foundation, Inc.   License  GPLv3+:  GNU
       GPL version <span>3</span> or later <span>&lt;</span>http://gnu.org/licenses/gpl.html<span>></span>.
       This  is  <span>free</span>  software:  you  are <span>free</span> to change and redistribute it.
       There is NO WARRANTY, to the extent permitted by law.

SEE ALSO
<span>#可以通过其他哪些命令查看到 ls 的相关信息</span>
       Full documentation at: <span>&lt;</span>http://www.gnu.org/software/coreutils/ls<span>></span>
       or available locally via: info <span>'(coreutils) ls invocation'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><p>虽然不同命令的 <code>man</code> 信息有一些区别，但是每个命令 <code>man</code> 信息的整体结构皆如演示这样。在帮助信息中，我们主要查看的就是命令的格式和选项的详细作用。不过大家请注意，在 <code>man</code> 信息的最后，可以看到还有哪些命令可以查看到此命令的相关信息。这是非常重要的提示，不同的帮助信息记录的侧重点是不太一样的。所以，如果在 <code>man</code> 信息中找不到想要的内容，则可以尝试查看其他相关帮助命令。</p>
<ol start="2">
<li><strong><code>man</code> 命令的快捷键</strong></li>
</ol>
<p><code>man</code> 命令的快捷键可以参考表6-1。</p>
<p><strong>表6-1	<u>man 命令快捷键</u></strong></p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>上箭头</td>
<td>向上移动一行</td>
</tr>
<tr>
<td>下箭头</td>
<td>向下移动一行</td>
</tr>
<tr>
<td>PgUp</td>
<td>向上翻一页</td>
</tr>
<tr>
<td>PgDn</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>g</td>
<td>移动到第一页</td>
</tr>
<tr>
<td>G</td>
<td>移动到最后一页</td>
</tr>
<tr>
<td>q</td>
<td>退出</td>
</tr>
<tr>
<td><code>/字符串</code></td>
<td>从当前页向下搜索<code>字符串</code></td>
</tr>
<tr>
<td><code>?字符串</code></td>
<td>从当前页向上搜索<code>字符串</code></td>
</tr>
<tr>
<td>n</td>
<td>当搜索字符串时，可以使用 n 键找到下一个字符串</td>
</tr>
<tr>
<td>N</td>
<td>当搜索字符串时，使用 N 键反向查询字符串。（与 n 作用相反）</td>
</tr>
</tbody>
</table>
<p>如果我们使用 <code>man -k ls</code> 命令，则会发现输出内容会多出几页，那是因为很多命令中都包含“ls”这个关键字。这条命令适合你只记得命令的几个字符，用来查找相关命令的情况。</p>
<p>在系统中还有两个命令。</p>
<ul>
<li>
<p><code>whatis</code>：这个命令的作用和 <code>man -f</code> 是一致的。</p>
</li>
<li>
<p><code>apropos</code>：这个命令的作用和 <code>man -k</code> 是一致的。</p>
</li>
</ul>
<p>不过这两个命令和 <code>man</code> 基本一致，所以了解就好。如果执行以上两个命令报错，那是因为 <code>whatis</code> 数据库没有建立。只要手工执行以下命令，重新建立 <code>whatis</code> 数据库即可。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># makewhatis</span>
</code></pre>
<div><span>1</span><br></div></div><div><p>补充</p>
<p>不过 Linux 的命令很有意思：</p>
<blockquote>
<p>想知道这个命令是干什么的，可以执行 <code>whatis</code> 命令；</p>
<p>想知道命令在哪里，可以执行 <code>whereis</code> 命令；</p>
<p>想知道当前登录用户是谁，可以执行 <code>whoami</code> 命令。</p>
</blockquote>
</div>
<h2 id="info-命令"> info 命令</h2>
<p><code>info</code> 命令，也可以获取命令的帮助。</p>
<p>英文原意：read Info documents</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># info 命令</span>
</code></pre>
<div><span>1</span><br></div></div><p>和 <code>man</code> 命令不同的是，<code>info</code> 命令的帮助信息是一套完整的资料，每个单独命令的帮助信息只是这套完整资料中的某一个小章节。大家可以把 info 命令帮助信息看成一部独立的电子书，所以每个命令的帮助信息都会和书籍一样，拥有章节编号。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># info ls</span>
Next: <span>dir</span> invocation,  Up: Directory listing

<span>10.1</span> ‘ls’: List directory contents
<span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span>

The ‘ls’ program lists information about files <span>(</span>of any type, including
directories<span>)</span>.  Options and <span>file</span> arguments can be intermixed arbitrarily,
as usual.
<span>..</span>.省略部分内容<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>可以看到，<code>ls</code> 命令的帮助只是整个 <code>info</code> 帮助信息中的第 10.1 节。在这个帮助信息中，如果标题的前面有“*”符号，则代表这是一个可以进入查看详细信息的子页面，只要按下回车键就可以进入。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># info ls</span>
<span>..</span>.省略部分内容<span>..</span>.
   Also see *note Common options::.

* Menu:

* Which files are listed::
* What information is listed::
* Sorting the output::
* Details about version sort::
* General output formatting::
* Formatting <span>file</span> timestamps::
* Formatting the <span>file</span> names::
<span>..</span>.省略部分内容<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>在 <code>ls</code> 命令的 <code>info</code> 帮助信息中可以查看详细的子页面的标题。<code>info</code> 命令主要是靠快捷键来进行操作的，我们来看看常用的快捷键，如表6-2 所示。</p>
<p><strong>表6-2	<u>info 命令的常用快捷键</u></strong></p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>上箭头</td>
<td>向上移动一行</td>
</tr>
<tr>
<td>下箭头</td>
<td>向下移动一行</td>
</tr>
<tr>
<td>PgUp</td>
<td>向上翻一页</td>
</tr>
<tr>
<td>PgDn</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>Tab</td>
<td>在有“*”符号的节点进行切换</td>
</tr>
<tr>
<td>回车</td>
<td>进入有“*”符号的子页面，查看详细帮助信息</td>
</tr>
<tr>
<td>u</td>
<td>进入上一层信息（回车是进入下一层信息）</td>
</tr>
<tr>
<td>n</td>
<td>进入下一小节信息</td>
</tr>
<tr>
<td>p</td>
<td>进入上一小节信息</td>
</tr>
<tr>
<td>?</td>
<td>查看帮助信息</td>
</tr>
<tr>
<td>q</td>
<td>退出 info 信息</td>
</tr>
</tbody>
</table>
<p>这是常用的快捷键，其他快捷键可以使用“?”快捷键查看。</p>
<h2 id="help-命令"> help 命令</h2>
<p><code>help</code> 命令，是非常简单且不经常使用的帮助命令。</p>
<p>因为 <code>help</code> 只能获取 Shell 内置命令的帮助，但在 Linux 中绝大多数命令是外部命令，所以 <code>help</code> 命令的作用非常有限。而且内置命令也可以 使用 <code>man</code> 命令获取帮助。</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># help 内置命令 </span>
</code></pre>
<div><span>1</span><br></div></div><p>Linux 中有哪些命令是内置命令呢？我们可以随意使用 <code>man</code> 命令来查看一个内置命令的帮助，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># man help</span>
BASH_BUILTINS<span>(</span><span>1</span><span>)</span>            General Commands Manual           BASH_BUILTINS<span>(</span><span>1</span><span>)</span>

NAME
       bash,  :,  .,  <span>[</span>, alias, bg, bind, break, builtin, caller, cd, command, compgen, complete, compopt,  continue,  declare,  dirs,  disown,  echo, enable,  eval,  exec, exit, export, false, fc, fg, getopts, hash, help, history, jobs, kill, let, local, logout, mapfile, popd, printf,  pushd, pwd,  read, readonly, return, set, shift, shopt, source, suspend, test, times, trap, true, type, typeset, ulimit, umask, unalias, unset, <span>wait</span> - <span>bash</span> built-in commands, see bash<span>(</span><span>1</span><span>)</span>
<span>..</span>.省略部分内容<span>..</span>.
<span>#这里列出的命令就是所有的 shell 内置命令</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="help-选项"> --help 选项</h2>
<p>绝大多数命令都可以使用 <strong>--help</strong> 选项来查看帮助，这也是一种获取帮助的方法。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls --help</span>
</code></pre>
<div><span>1</span><br></div></div><p>这种方法非常简单，输出的帮助信息基本上是 <code>man</code> 命令的信息简要版。</p>
<div><p>提示</p>
<p>对于这 4 中常见的获取帮助的方法，大家可以按照自己的习惯任意使用。</p>
</div>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-05-06T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">VBA 之 控件与用户窗体2</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Excel/11.VBA_controls_form_2/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Excel/11.VBA_controls_form_2/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="_116、使用-dtp-控件输入日期"> 116、使用 DTP 控件输入日期</h2>
<p>在工作表中输入日期可以使用日期时间控件（Microsoft Date and Time Picker Control 6.0，简称 DTP 控件）。</p>
<p>在工作表中单击菜单“视图”→“工具栏”→“控件工具箱”，选择“其他控件”中的 DTP 控件如图 116-1 所示，在工作表中添加一个 DTP 控件。</p>
<div>
<p><img src="./assets/116-1.png" alt="" loading="lazy"></p>
<p><u>图 116-1</u>	选择 DTP 控件</p>
</div>
<p>在设计模式下双击 DTP 控件写入下面的代码：</p>
<div><pre><code><span>Private</span> <span>Sub</span> Worksheet_SelectionChange<span>(</span><span>ByVal</span> Target <span>As</span> Range<span>)</span>
	<span>With</span> <span>Me</span><span>.</span>DTPicker1
		<span>If</span> Target<span>.</span>Count <span>=</span> <span>1</span> <span>And</span> Target<span>.</span>Column <span>=</span> <span>2</span> <span>And</span> <span>(</span><span>Not</span> Target<span>.</span>Row <span>=</span> <span>1</span><span>)</span> <span>Or</span> Target<span>.</span>MergeCells <span>Then</span>
			<span>.</span>Visible <span>=</span> <span>True</span>
			<span>.</span>Top <span>=</span> Selection<span>.</span>Top
			<span>.</span>Left <span>=</span> Selection<span>.</span>Left
			<span>.</span>Height <span>=</span> Selection<span>.</span>Height
			<span>.</span>Width <span>=</span> Selection<span>.</span>Width
			<span>If</span> Target<span>.</span>Cells<span>(</span><span>1</span><span>,</span> <span>1</span><span>)</span> <span>&lt;</span><span>></span> <span>""</span> <span>Then</span>
				<span>.</span>Value <span>=</span> Target<span>.</span>Cells<span>(</span><span>1</span><span>,</span> <span>1</span><span>)</span><span>.</span>Value
			<span>Else</span>
				<span>.</span>Value <span>=</span> <span>Date</span>
			<span>End</span> <span>If</span>
		<span>Else</span>
			<span>.</span>Visible <span>=</span> <span>False</span>
		<span>End</span> <span>If</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
<span>Private</span> <span>Sub</span> DTPicker1_CloseUp<span>(</span><span>)</span>
	ActiveCell<span>.</span>Value <span>=</span> <span>Me</span><span>.</span>DTPicker1<span>.</span>Value
	<span>Me</span><span>.</span>DTPicker1<span>.</span>Visible <span>=</span> <span>False</span>
<span>End</span> <span>Sub</span>
<span>Private</span> <span>Sub</span> Worksheet_Change<span>(</span><span>ByVal</span> Target <span>As</span> Range<span>)</span>
	<span>If</span> Target<span>.</span>Count <span>=</span> <span>1</span> <span>And</span> Target<span>.</span>Column <span>=</span> <span>2</span> <span>Or</span> Target<span>.</span>MergeCells <span>Then</span>
		<span>If</span> Target<span>.</span>Cells<span>(</span><span>1</span><span>,</span> <span>1</span><span>)</span><span>.</span>Value <span>=</span> <span>""</span> <span>Then</span>
			DTPicker1<span>.</span>Visible <span>=</span> <span>False</span>
		<span>End</span> <span>If</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>代码解析：</p>
<p>第 1 行到第 18 行代码工作表的 SelectionChange 事件，当选择工作表的 B 列第 2 行以下的单个单元格时显示日期控件供用户选择日期。</p>
<p>其中第 3 行代码设置显示日期控件的触发条件。只有当用户选择 B 列第 2 行以下单元格且只能选择单个单元格时才显示日期控件，因为本例 B 列中存在合并单元格，所以需要加上 Or Target.MergeCells 这个条件，否则单击合并单元格不显示日期控件。</p>
<p>第 4 行到第 8 行代码显示日期控件并设置日期控件的大小等于所选单元格的大小。</p>
<p>第 9 行到第 13 行代码，如果单元格已经输入了日期，将单元格中的日期赋给日期控件，否则将当前日期赋给日期控件。因为本例 B 列中存在合并单元格，而合并区域的值在该区域左上角的单元格中指定，所以用 Target.Cells(1, 1) 指定合并单元格的值，否则代码会出错。</p>
<p>第 15 行代码如果选择的是其他列则隐藏日期控件。</p>
<p>第 19 行到第 22 行代码日期控件的 CloseUp 事件，将日期控件的值赋给活动单元格后隐藏日期控件。</p>
<p>第 23 行到第 29 行代码工作表的 Change 事件，如果删除了 B 列单元格的日期则隐藏日期控件。</p>
<p>当用户选择 B 列单元格时效果如图 116-2 所示。</p>
<div>
<p><img src="./assets/116-2.png" alt="" loading="lazy"></p>
<p><u>图 116-2</u>	使用 DTP 控件输入日期</p>
</div>
<h2 id="_117、使用-refedit-控件选择区域"> 117、使用 RefEdit 控件选择区域</h2>
<p>在 76-2 中介绍了如何使用 InputBox 方法获得所选单元格区域的地址，而使用 RefEdit 控件获得单元格区域的地址比使用 InputBox 方法更加方便，可以单击 RefEdit 控件中的按钮以折叠用户窗体，选定区域后再单击按钮展开用户窗体，示例代码如下：</p>
<div><pre><code><span>Private</span> <span>Sub</span> CommandButton1_Click<span>(</span><span>)</span>
	<span>Dim</span> Rng <span>As</span> Range
	<span>On</span> <span>Error</span> <span>GoTo</span> line
	<span>Set</span> Rng <span>=</span> Range<span>(</span>RefEdit1<span>.</span>Value<span>)</span>
		Rng<span>.</span>Interior<span>.</span>ColorIndex <span>=</span> <span>15</span>
		Unload UserForm1
		<span>Exit</span> <span>Sub</span>
line<span>:</span>
	MsgBox <span>"你选择的是非单元格区域!"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>代码解析：</p>
<p>用户窗体中按钮的单击事件过程，改变用户使用 RefEdit 控件所选择的单元格区域内部的颜色。</p>
<p>第 3 行代码，错误处理语句。因为如果用户输入或选定了错误的单元格区域地址，将显示一错误信息，如图 117-1 所示，所以必需使用 On Error GoTo 语句来绕过错误。</p>
<div>
<p><img src="./assets/117-1.png" alt="" loading="lazy"></p>
<p><u>图 117-1</u>	提示运行错误</p>
</div>
<p>第 4 行代码，使用 Set 语句将用户选择的单元格区域赋给变量 rng。</p>
<p>第 5 行代码，改变用户所选单元格区域内部的颜色。</p>
<div><p>注意</p>
<p>不能在无模式用户窗体中使用 RefEdit 控件。</p>
</div>
<p>窗体运行后，当用户在工作表中选择一个单元格区域后改变所选单元格区域内部的颜色，如图 117-2 所示。</p>
<div>
<p><img src="./assets/117-2.png" alt="" loading="lazy"></p>
<p><u>图 117-2</u>	使用 RefEdit 控件获得区域地址</p>
</div>
<h2 id="_118、如何注册控件"> 118、如何注册控件</h2>
<p>Excel 文件中如果有 ActiveX 控件如日期时间控件（Microsoft Date and Time Picker Control 6.0，简称 DTP 控件），在有些电脑上运行时会出现“无法装载这个对象，因为它不适于这台计算机”的提示，如图 118-1 所示。文件中的控件丢失，无法正常使用。</p>
<div>
<p><img src="./assets/118-1.png" alt="" loading="lazy"></p>
<p><u>图 118-1</u>	无法装载对象提示</p>
</div>
<p>这是因为 DTP 控件没有注册引起的，解决办法是在能运行该控件的电脑中复制 DTP 控件的文件到目标电脑中进行注册。在 VBE 窗口中右键单击“工具箱”，选择“附加控件”，在“附加控件”对话框中选择 DTP 控件，对话框底部会显示控件的名称和文件所在的路径，如图 118-2 所示。</p>
<div>
<p><img src="./assets/118-2.png" alt="" loading="lazy"></p>
<p><u>图 118-2</u>	OCX 文件名称和路径</p>
</div>
<p>DTP 控件的文件名为 MSCOMCT2.OCX，在 <code>C盘的Windows\system32</code> 文件夹中，把该文件复制到目标电脑 <code>C盘的Windows\system32</code> 文件夹中，单击“开始”→“运行”，在“运行”对话框中键入“regsvr32 C:\Windows\system32\MSCOMCT2.OCX”，注册成功后会出现如图 118-3 所示的对话框，DTP 控件即能正常使用。</p>
<div>
<p><img src="./assets/118-3.png" alt="" loading="lazy"></p>
<p><u>图 118-3</u>	注册成功提示</p>
</div>
<p>在 Excel 中可以使用程序代码进行自动注册，代码如下：</p>
<div><pre><code><span>Sub</span> regsvrs<span>(</span><span>)</span>
	<span>Dim</span> SouFile <span>As</span> <span>String</span>
	<span>Dim</span> DesFile <span>As</span> <span>String</span>
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	SouFile <span>=</span> ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\MSCOMCT2.OCX"</span>
	DesFile <span>=</span> <span>"c:\Windows\system32\MSCOMCT2.OCX"</span>
	FileCopy SouFile<span>,</span> DesFile
	Shell <span>"regsvr32 /s"</span> <span>&amp;</span> DesFile
	MsgBox <span>"DTP控件已成功注册，现在可以使用了!"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>代码解析：</p>
<p>Regsvrs 过程将保存在同一目录中的 MSCOMCT2.OCX 文件复制到电脑的文件夹中，使用 Shell 函数注册 DTP 控件。</p>
<p>第 4 行代码，错误处理语句，用于忽略复制文件时可能出现的错误。因为如果电脑文件夹中已存在 MSCOMCT2.OCX 文件，使用 FileCopy 方法复制时会发生错误，如图 118-4 所示。</p>
<div>
<p><img src="./assets/118-4.png" alt="" loading="lazy"></p>
<p><u>图 118-4</u>	复制文件错误提示</p>
</div>
<p>第 7 行代码，使用 FileCopy 方法复制 MSCOMCT2.OCX 文件到电脑中。</p>
<p>FileCopy 方法的语法如下：</p>
<div><pre><code>FileCopy source<span>,</span> destination

参数Source是必需的，字符串表达式，用来表示要被复制的文件名。
参数destination是必需的，字符串表达式，用来指定要复制的目的文件名。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第 8 行代码，使用 Shell 函数注册 DTP 控件。</p>
<p>Shell 函数执行一个可执行文件，语法如下：</p>
<div><pre><code>Shell<span>(</span>pathname[<span>,</span>windowstyle]<span>)</span>

参数pathname是必需的，要执行的程序名，以及任何必需的参数或命令行变量，可能还包括目录或文件夹，以及驱动器。
参数windowstyle是可选的，表示在程序运行时窗口的样式。windowstyle参数值如表格 <span>118</span><span>1</span>所示。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><u>表格 118-1</u>	windowstyle参数值</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>vbHide</td>
<td>0</td>
<td>窗口被隐藏，且焦点会移到隐式窗口。常数vbHide在Macintosh平台不可用。</td>
</tr>
<tr>
<td>VbNormalFocus</td>
<td>1</td>
<td>窗口具有焦点，且会还原到它原来的大小和位置。</td>
</tr>
<tr>
<td>VbMinimizedFocus</td>
<td>2</td>
<td>窗口会以一个具有焦点的图标来显示。</td>
</tr>
<tr>
<td>VbMaximizedFocus</td>
<td>3</td>
<td>窗口是一个具有焦点的最大化窗口。</td>
</tr>
<tr>
<td>VbNormalNoFocus</td>
<td>4</td>
<td>窗口会被还原到最近使用的大小和位置，而当前活动的窗口仍然保持活动。</td>
</tr>
<tr>
<td>VbMinimizedNoFocus</td>
<td>6</td>
<td>窗口会以一个图标来显示。而当前活动的的窗口仍然保持活动。</td>
</tr>
</tbody>
</table>
<p>运行程序前应确保在工作簿同一目录中存在 MSCOMCT2.OCX 文件。此代码相当于在“运行”对话框中键入“regsvr32 C:\ Windows\system32\MSCOMCT2.OCX”后进行注册，只是在“REGSVR32”后加上了 s 参数，使注册成功后不会出现如图 118-3 所示的对话框。</p>
<p>可以使用程序代码卸载该控件，代码如下：</p>
<div><pre><code><span>Sub</span> regsvru<span>(</span><span>)</span>
	Shell <span>"REGSVR32 /u "</span> <span>&amp;</span> ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\MSCOMCT2.OCX"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>Regsvru 过程使用 Shell 函数注册 DTP 控件，在 pathname 参数“REGSVR32”后加上 u 参数，对 DTP 控件进行反注册。</p>
<h2 id="_119、遍历控件的方法"> 119、遍历控件的方法</h2>
<p>如果窗体或工作表中的控件很多，在写代码时，如果是相同的代码，可以使用循环语句遍历控件，无需每个控件都写相同的代码，以减少代码量。</p>
<h3 id="_1-使用名称中的变量遍历控件"> 1）使用名称中的变量遍历控件</h3>
<p>如果控件使用系统缺省名称，如“TextBox1”、“TextBox2”，前面是固定的字符串，后面是序号的，可以使用 For...Next 语句循环遍历控件。</p>
<p>对于窗体中的控件，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> CommandButton1_Click<span>(</span><span>)</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>For</span> i <span>=</span> <span>1</span> <span>To</span> <span>3</span>
		<span>Me</span><span>.</span>Controls<span>(</span><span>"TextBox"</span> <span>&amp;</span> i<span>)</span> <span>=</span> <span>""</span>
	<span>Next</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>代码解析：</p>
<p>窗体按钮的单击事件，一次性清空窗体中三个文本框的内容。</p>
<p>第 4 行代码，将窗体中三个文本框名称中的最后一个序号设成变量，在文本框中循环并清空其内容。</p>
<p>对于工作表中的控件，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> CommandButton1_Click<span>(</span><span>)</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>For</span> i <span>=</span> <span>1</span> <span>To</span> <span>4</span>
		<span>Me</span><span>.</span>OLEObjects<span>(</span><span>"TextBox"</span> <span>&amp;</span> i<span>)</span><span>.</span><span>Object</span><span>.</span>Text <span>=</span> <span>""</span>
	<span>Next</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>代码解析：</p>
<p>工作表中按钮的单击事件，在工作表中的三个文本框中循环，清空文本框的内容。</p>
<p>第 4 行代码，将工作表中四个文本框名称中的最后一个序号设成变量，使用 OLEObjects 方法在工作表中的文本框中循环。</p>
<p>OLEObjects 方法返回图表或工作表上单个 OLE 对象（OLEObject）或所有 OLE 对象的集合（OLEObjects 集合）的对象，语法如下：</p>
<div><pre><code>expression<span>.</span>OLEObjects<span>(</span>Index<span>)</span>

参数expression是必需的，返回一个Chart 对象或Worksheet 对象。
参数Index 是可选的，OLE对象的名称或编号。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>注意 控件的名称是指控件在属性窗口中的名称，如图 119-1 所示。如果控件的名称没有规律不适用此方法。</p>
<div>
<p><img src="./assets/119-1.png" alt="" loading="lazy"></p>
<p><u>图 119-1</u>	控件属性窗口中的名称</p>
</div>
<h3 id="_2-使用对象类型遍历控件"> 2）使用对象类型遍历控件</h3>
<p>如果控件的名称没有规律，可以使用 For Each...Next 语句循环遍历所有控件，使用 TypeName 函数返回控件的对象类型，根据控件的对象类型进行相应的操作。</p>
<p>对于窗体中的控件，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> CommandButton1_Click<span>(</span><span>)</span>
	<span>Dim</span> Ctr <span>As</span> Control
	<span>For</span> <span>Each</span> Ctr <span>In</span> <span>Me</span><span>.</span>Controls
		<span>If</span> TypeName<span>(</span>Ctr<span>)</span> <span>=</span> <span>"TextBox"</span> <span>Then</span>
			Ctr <span>=</span> <span>""</span>
		<span>End</span> <span>If</span>
	<span>Next</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>代码解析：</p>
<p>按钮的单击事件，遍历所有控件并把所有文本框的内容清空。</p>
<p>第 2 行代码，声明变量类型。</p>
<p>第 3 行代码，使用 For Each...Next 语句遍历窗体所有控件。</p>
<p>第 4 行代码，使用 TypeName 函数返回变量的对象类型。</p>
<p>TypeName 函数返回一个字符串，提供有关变量的信息，语法如下：</p>
<div><pre><code>TypeName<span>(</span>varname<span>)</span>

参数 varname是必需的，它包含用户定义类型变量之外的任何变量。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果变量 Ctr 是文本框控件，无论该文本框的名称是否已经被修改，TypeName(Ctr) 都会返回“TextBox”字符串。</p>
<p>对于工作表中的控件，则使用下面的代码。</p>
<div><pre><code><span>Private</span> <span>Sub</span> CommandButton1_Click<span>(</span><span>)</span>
	<span>Dim</span> Obj <span>As</span> OLEObject
	<span>For</span> <span>Each</span> Obj <span>In</span> <span>Me</span><span>.</span>OLEObjects
		<span>If</span> TypeName<span>(</span>Obj<span>.</span><span>Object</span><span>)</span> <span>=</span> <span>"TextBox"</span> <span>Then</span>
			Obj<span>.</span><span>Object</span><span>.</span>Text <span>=</span> <span>""</span>
		<span>End</span> <span>If</span>
	<span>Next</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="_3-使用程序标识符遍历控件"> 3）使用程序标识符遍历控件</h3>
<p>工作表中的 ActiveX 控件还可以根据控件的程序标识符找到相应的控件，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> CommandButton1_Click<span>(</span><span>)</span>
	<span>Dim</span> Obj <span>As</span> OLEObject
	<span>For</span> <span>Each</span> Obj <span>In</span> <span>Me</span><span>.</span>OLEObjects
		<span>If</span> Obj<span>.</span>progID <span>=</span> <span>"Forms.TextBox.1"</span> <span>Then</span>
			Obj<span>.</span><span>Object</span><span>.</span>Text <span>=</span> <span>""</span>
		<span>End</span> <span>If</span>
	<span>Next</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>代码解析：</p>
<p>工作表中按钮的单击事件，遍历工作表中的所有控件并把工作表中所有文本框的内容清空。</p>
<p>第 2 行代码，声明变量类型。</p>
<p>第 3 行代码，使用 For Each...Next 语句遍历工作表中的所有控件。</p>
<p>第 4 行代码，使用控件的 ProgId 属性返回控件的程序标识符。</p>
<p>ProgId 属性返回控件的程序标识符，语法如下：</p>
<div><pre><code>expression<span>.</span>ProgId

参数expression是必需的，一个有效的对象。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>ActiveX 控件的程序标识符如表格 119-1 所示。</p>
<p><u>表格 119-1</u>	ActiveX 控件的程序标识符</p>
<table>
<thead>
<tr>
<th>控件名称</th>
<th>标识符</th>
</tr>
</thead>
<tbody>
<tr>
<td>复选框</td>
<td>Forms.CheckBox.1</td>
</tr>
<tr>
<td>组合框</td>
<td>Forms.ComboBox.1</td>
</tr>
<tr>
<td>命令按钮</td>
<td>Forms.CommandButton.1</td>
</tr>
<tr>
<td>框架</td>
<td>Forms.Frame.1</td>
</tr>
<tr>
<td>图像</td>
<td>Forms.Image.1</td>
</tr>
<tr>
<td>标签</td>
<td>Forms.Label.1</td>
</tr>
<tr>
<td>列表框</td>
<td>Forms.ListBox.1</td>
</tr>
<tr>
<td>多页</td>
<td>Forms.ListBox.1</td>
</tr>
<tr>
<td>选项按钮</td>
<td>Forms.OptionButton.1</td>
</tr>
<tr>
<td>滚动条</td>
<td>Forms.ScrollBar.1</td>
</tr>
<tr>
<td>旋转按钮</td>
<td>Forms.SpinButton.1</td>
</tr>
<tr>
<td>TabStrip</td>
<td>Forms.TabStrip.1</td>
</tr>
<tr>
<td>文字框</td>
<td>Forms.TextBox.1</td>
</tr>
<tr>
<td>切换按钮</td>
<td>Forms.ToggleButton.1</td>
</tr>
</tbody>
</table>
<p>文本框控件返回的程序标识符是“Forms.TextBox.1”，此返回值并不受文本框控件名称的影响，所以根据工作表中控件的程序标识符可以找出全部文本框控件。</p>
<h3 id="_4-使用名称中的变量遍历图形"> 4）使用名称中的变量遍历图形</h3>
<p>如果工作表中有多个图形，可以根据名称的序号使用 For...Next 语句遍历图形，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> CommandButton1_Click<span>(</span><span>)</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>For</span> i <span>=</span> <span>1</span> <span>To</span> <span>3</span>
		<span>Me</span><span>.</span>Shapes<span>(</span><span>"文本框 "</span> <span>&amp;</span> i<span>)</span><span>.</span>TextFrame<span>.</span>Characters<span>.</span>Text <span>=</span> <span>"TextBox"</span> <span>&amp;</span> i
	<span>Next</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>代码解析：</p>
<p>工作表中按钮的单击事件，在工作表中的三个图形文本框中依次写入“TextBox1”、“TextBox2”和“TextBox3”字符串。</p>
<p>第 3 行到第 5 行代码，使用 Shapes 属性在工作表上的三个图形文本框中循环。</p>
<p>Shapes 属性返回 Shapes 对象，代表工作表或图形工作表上的所有图形，可以使用 Shapes(index)（其中 index 是图形的名称或索引号）返回单个的 Shape 对象。</p>
<p>返回单个的 Shape 对象后使用 Characters 方法向图形文本框中添加字符。Characters 方法的语法如下：</p>
<div><pre><code>expression<span>.</span>Characters<span>(</span>Start<span>,</span> Length<span>)</span>

参数expression是必需的，返回一个指定文本框内Characters对象的表达式。
参数Start是可选的，表示将要返回的第一个字符。如果此参数设置为 <span>1</span> 或被忽略，则Characters方法会返回以第一个字符为起始字符的字符区域。
参数Length是可选的，表示要返回的字符个数。如果此参数被忽略，则Characters 方法会返回该字符串的剩余部分。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="_5-使用-formcontroltype-属性遍历图形"> 5）使用 FormControlType 属性遍历图形</h3>
<p>如果工作表中的是窗体控件，可以使用 For Each...Next 语句遍历工作表中图形并根据其 FormControlType 属性返回特定的窗体控件，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> CommandButton2_Click<span>(</span><span>)</span>
	<span>Dim</span> myShape <span>As</span> Shape
	<span>For</span> <span>Each</span> myShape <span>In</span> Sheet4<span>.</span>Shapes
		<span>If</span> myShape<span>.</span><span>Type</span> <span>=</span> msoFormControl <span>Then</span>
			<span>If</span> myShape<span>.</span>FormControlType <span>=</span> xlCheckBox <span>Then</span>
				myShape<span>.</span>ControlFormat<span>.</span>Value <span>=</span> <span>1</span>
			<span>End</span> <span>If</span>
		<span>End</span> <span>If</span>
	<span>Next</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>代码解析：</p>
<p>工作表中按钮的单击事件，清除工作表中所有的复选框。</p>
<p>第 2 行代码声明变量 myShape 为图形对象。</p>
<p>第 3 行代码使用 For Each...Next 语句遍历工作表中的图形。</p>
<p>第 4 行代码根据图形的 Type 属性判断图形是否为窗体控件。应用于 Shape 对象的 Type 属性返回或设置图形类型，窗体控件返回常量 msoFormControl。</p>
<p>第 5 行代码根据控件的 FormControlType 属性判断窗体控件是否为复选框控件。FormControlType 属性返回窗体控件的类型，可以为表格 119-2 所示的 XlFormControl 常量之一。</p>
<p><u>表格 119-2</u>	XlFormControl 常量</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>控件类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>xlButtonControl</td>
<td>0</td>
<td>按钮</td>
</tr>
<tr>
<td>xlCheckBox</td>
<td>1</td>
<td>复选框</td>
</tr>
<tr>
<td>xlDropDown</td>
<td>2</td>
<td>组合框</td>
</tr>
<tr>
<td>xlGroupBox</td>
<td>4</td>
<td>分组框</td>
</tr>
<tr>
<td>xlLabel</td>
<td>5</td>
<td>标签</td>
</tr>
<tr>
<td>xlListBox</td>
<td>6</td>
<td>列表框</td>
</tr>
<tr>
<td>xlOptionButton</td>
<td>7</td>
<td>选项按钮</td>
</tr>
<tr>
<td>xlScrollBar</td>
<td>8</td>
<td>滚动条</td>
</tr>
<tr>
<td>xlSpinner</td>
<td>9</td>
<td>微调项</td>
</tr>
</tbody>
</table>
<p>第 6 行代码使用 ControlFormat 属性返回工作表中的复选框，并将其他 Value 属性设置为 1 选中复选框，如果需要取消复选框只需将 Value 属性设置为 -4146。</p>
<h2 id="_120、使微调框最小变动量小于-1"> 120、使微调框最小变动量小于 1</h2>
<p>在用微调框调节数值时，默认的变动量只能设置成整数。为了使微调框的变动量小于 1，如每次的变动量为 0.01，需要在代码中做必要的设置，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	<span>With</span> <span>Me</span><span>.</span>SpinButton1
		<span>.</span>Max <span>=</span> <span>10000</span>
		<span>.</span>Min <span>=</span> <span>-</span><span>10000</span>
		<span>.</span>SmallChange <span>=</span> <span>1</span>
		<span>.</span>Value <span>=</span> <span>0</span>
		<span>Me</span><span>.</span>TextBox1 <span>=</span> Format<span>(</span><span>.</span>Value<span>,</span> <span>"0.00"</span><span>)</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
<span>Private</span> <span>Sub</span> SpinButton1_Change<span>(</span><span>)</span>
	<span>Me</span><span>.</span>TextBox1 <span>=</span> Format<span>(</span><span>Me</span><span>.</span>SpinButton1 <span>*</span> <span>0.01</span><span>,</span> <span>"0.00"</span><span>)</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>代码解析：</p>
<p>使用微调框调节文本框的数值，每次的变动量为 0.01。</p>
<p>第 1 行代码到第 9 行代码，窗体的初始化事件，在窗体显示时对微调框控件进行必要的设置。</p>
<p>第 3、4 行代码，设置微调框控件的 Max、Min 属性。Max、Min 属性规定滚动条或数值调节钮的 Value 属性可接收的最大值和最小值，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>Max [<span>=</span> <span>Long</span>]
<span>object</span><span>.</span>Min [<span>=</span> <span>Long</span>]

参数<span>object</span>是必需的，一个有效的对象。
参数<span>Long</span>是可选的，指定Value属性的最大设置值或最小设置值。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>第 5 行代码，设置微调框控件的 SmallChange 属性为 1。SmallChange 属性设定当用户单击滚动条或数值调节钮中的滚动箭头时发生的变动量，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>SmallChange [<span>=</span> <span>Long</span>]

参数<span>object</span>是必需的，一个有效的对象。
参数<span>Long</span>是可选的，设定Value属性的变动量。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>SmallChange 属性只能设置为整数。</p>
<p>第 6 行代码，设置窗体显示时微调框控件的 Value 属性为 0。</p>
<p>第 7 行代码，使用 Format 函数将将文本框的初始值格式化为“0.00”。关于 Format 函数请参阅 102 。</p>
<p>第 11 行代码，微调框控件的 Change 事件，在微调框控件的 Value 属性发生变动时，将变动量乘 0.01 后赋给文本框，使文本框的变动量每次为 0.01。</p>
<p>窗体运行后效果如图 120-1 所示。</p>
<div>
<p><img src="./assets/120-1.png" alt="" loading="lazy"></p>
<p><u>图 120-1</u>	微调框变动量小于 1</p>
</div>
<h2 id="_121、不打印工作表中的控件"> 121、不打印工作表中的控件</h2>
<p>在打印工作表时，如果工作表中有控件，会把控件也一起打印出来，从而影响打印出来的工作表的美观。经过简单的设置能使工作表中的控件不被打印出来。</p>
<h3 id="_1-设置控件格式"> 1）设置控件格式</h3>
<p>如果工作表中的是窗体控件，设置时右键单击控件，在显示的右键快捷菜单中选择“设置控件格式”，在“设置控件格式”选项卡中选择“属性”页面，使“打印对象”前的复选框为空白状态，如图 121-1 所示。</p>
<div>
<p><img src="./assets/121-1.png" alt="" loading="lazy"></p>
<p><u>图 121-1</u>	窗体控件</p>
</div>
<p>如果工作表中的控件是 ActiveX 控件，那么需要在设计模式下右键单击控件，在显示的右键快捷菜单中选择“设置控件格式”，在“设置控件格式”选项卡中选择“属性”页面，使“打印对象”前的复选框为空白状态，如图 121-2 所示。</p>
<div>
<p><img src="./assets/121-2.png" alt="" loading="lazy"></p>
<p><u>图 121-2</u>	ActiveX 控件</p>
</div>
<h3 id="_2-设置控件的-printobjcet-属性"> 2）设置控件的 printobjcet 属性</h3>
<p>如果工作表中的控件是 ActiveX 控件，使用除了使用 121-1 的方法外，还可以在设计模式下右键单击控件，选择“属性”，设置控件的 printobjcet 属性为 False。如图 121-3 所示。</p>
<div>
<p><img src="./assets/121-3.png" alt="" loading="lazy"></p>
<p><u>图 121-3</u>	设置控件 printobjcet 属性</p>
</div>
<h2 id="_122、在框架中使用滚动条"> 122、在框架中使用滚动条</h2>
<p>如果需要在窗体中显示较多的内容，比如使用标签显示一段很长的文本内容，而又不希望窗体很大的话，可以在窗体中使用框架放置标签，设置框架可滚动区域的高度，使标签可以进行上下移动以查看全部区域。</p>
<p>在VBE窗口中单击菜单“插入”→“用户窗体”，在窗体中添加一个框架控件，在框架中添加一个标签控件。根据需要显示的内容调整好标签的大小，再将框架和窗体调整为合适的大小。</p>
<p>在VBE中双击窗体，写入下面的代码。</p>
<div><pre><code><span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	<span>Dim</span> sLab <span>As</span> <span>String</span>
	sLab <span>=</span> Space<span>(</span><span>4</span><span>)</span> <span>&amp;</span> <span>"欢迎来到ExcelHome技术论坛，全球最领先的Excel技术论坛之一。"</span> <span>&amp;</span> vbLf <span>_</span>
		<span>&amp;</span> Space<span>(</span><span>4</span><span>)</span> <span>&amp;</span> <span>"在这里，我们讨论Microsoft Office系列产品的应用技术，重点讨论Microsoft Excel。本论坛从属于Excel Home这一全球最大的华语Excel技术门户，目前是个人、非营利性质的网站学习平台。各行各业的Excel使用者都活跃在此，各种形式的学习资源也汇聚于在此，所以，只要您愿意花时间，并使用正确的方法，我们有理由相信您的绝大部分应用问题和学习愿望都在这里被满足。无数已经取得了非凡进步的人，也可以证明这一点。"</span> <span>&amp;</span> vbLf <span>_</span>
		<span>&amp;</span> Space<span>(</span><span>4</span><span>)</span> <span>&amp;</span> <span>"Let’s do it better!这是Excel Home的口号，我们的宗旨是帮助大家解决在使用Office软件中的问题，提升自己的应用技能。"</span> <span>&amp;</span> vbLf <span>_</span>
		<span>&amp;</span> Space<span>(</span><span>4</span><span>)</span> <span>&amp;</span> <span>"鉴于许多人在此之前没有正确使用网络学习资源的经验，或者对Excel Home的行为规则缺乏了解，我们特别准备了这样一篇文章，送给每一位有志与我们一起成长的朋友。本文将重点叙述学习方法和论坛的规则，对于如何使用论坛的各项功能，请阅读论坛的帮助系统（http://club.excelhome.net/boardhelp.asp ）"</span>
	Label1<span>.</span>Caption <span>=</span> sLab
	<span>With</span> Frame1
		<span>.</span>ScrollBars <span>=</span> <span>2</span>
		<span>.</span>ScrollHeight <span>=</span> Label1<span>.</span>Height
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>代码解析：</p>
<p>窗体的初始化事件，在窗体加载时使用标签显示文本内容。</p>
<p>第 3 行到第 6 行代码，变量 sLab 为要显示的文本，使用 Space 函数在每段的首字前插入 4 个空格，使首字缩进。在需要换行的地方插入常数 vbLf 进行换行。</p>
<p>第 9 行代码，设置框架的 ScrollBars 属性为显示垂直滚动条。ScrollBars 属性指定一个控件、窗体或页面是否有垂直或水平滚动条，或两者都有，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>ScrollBars [<span>=</span> fmScrollBars]

参数<span>object</span>是必需的，一个有效的对象。
参数fmScrollBars是可选的，滚动条的显示位置，设置值如表格 <span>122</span><span>-</span><span>1</span>所示。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><u>表格 122-1</u>	ScrollBars 属性设置值</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>fmScrollBarsNone</td>
<td>0</td>
<td>不显示滚动条（默认）。</td>
</tr>
<tr>
<td>fmScrollBarsHorizontal</td>
<td>1</td>
<td>显示水平滚动条。</td>
</tr>
<tr>
<td>fmScrollBarsVertical</td>
<td>2</td>
<td>显示垂直滚动条。</td>
</tr>
<tr>
<td>fmScrollBarsBoth</td>
<td>3</td>
<td>垂直和水平滚动条都显示。</td>
</tr>
</tbody>
</table>
<p>第 10 行代码，设置框架的 ScrollHeight 属性为标签的高度。ScrollHeight 属性指定通过移动控件、窗体或页面中的滚动条，可以查看的全部区域的高度，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>ScrollHeight [<span>=</span> <span>Single</span>]

参数<span>object</span>是必需的，一个有效的对象。
参数<span>Single</span>是可选的，可滚动区域的高度。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果框架具有水平滚动条，可以设置框架的 ScrollWidth 属性来设置可以查看的全部区域的宽度。</p>
<p>运行窗体，使用标签显示文本内容，可通过框架的滚动条查看全部内容，如图 122-1 所示。</p>
<div>
<p><img src="./assets/122-1.png" alt="" loading="lazy"></p>
<p><u>图 122-1</u>	在框架中使用滚动条</p>
</div>
<h2 id="_123、使用多页控件"> 123、使用多页控件</h2>
<p>在处理可以划分为不同类别的大量信息时可以使用多页控件。例如，在示例中，多页控件的第一页用于显示欢迎信息，另三页显示其他信息。利用多页控件能够将相关信息组织在一起显示出来，同时又能够随时访问整条记录。</p>
<p>多页控件中的每个页面都是一个窗体，含有自己的控件，并且可以有唯一的布局。一般情况下，多页控件中的页面都有标签，以便让用户选择单个页面。</p>
<p>在窗体中使用多页控件时，往往希望窗体显示时能显示特定的页面，比如每次打开窗体时先显示第一页的欢迎信息，除了在 VBE 中选择多页控件的第一页后保存外，还可以通过设置多页控件的 Value 属性来实现，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	MultiPage1<span>.</span>Value <span>=</span> <span>0</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>窗体的 Initialize 事件，在窗体显示时选择多页控件的第一页。</p>
<p>控件的 Value 属性定义某给定的控件的状态或内容，对于多页控件标识当前激活页。</p>
<p>Value 属性是多页控件的默认属性，该属性返回当前活动页面的索引编号（位于多页控件的 Pages 集合中），零 ( 0 ) 表示是第一页，最大值比总页数少一。</p>
<p>多页控件的默认事件是 Change 事件，示例中使用消息框显示当前活动页面的 Caption 属性，代码如下：</p>
<div><pre><code><span>Private</span> <span>Sub</span> MultiPage1_Change<span>(</span><span>)</span>
	<span>If</span> MultiPage1<span>.</span>SelectedItem<span>.</span>Index <span>></span> <span>0</span> <span>Then</span>
		MsgBox <span>"欢迎来到"</span> <span>&amp;</span> MultiPage1<span>.</span>SelectedItem<span>.</span>Caption <span>&amp;</span> <span>"版块!"</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>代码解析：</p>
<p>MultiPage1_Change 过程根据当前活动页面是否是第一页，如果不是则使用消息框显示当前活动页面的 Caption 属性。</p>
<p>应用于 Page 对象的 Index 属性指 Pages 集合中 Page 对象的位置，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>Index [<span>=</span> <span>Integer</span>]

参数<span>object</span>是必需的，一个有效对象。
参数<span>Integer</span>是可选的，当前选定的Page对象的索引。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>Index 属性指定了标签出现的顺序，改变 Index 属性的值将改变多页控件中页面的顺序，第一页的索引值是 0，第二页的索引值是 1，依此类推。</p>
<p>应用于多页控件的 SelectedItem 属性返回当前选中的 Page 对象，SelectedItem 属性是只读的，用 SelectedItem 属性可对当前选中的 Page 对象进行可编程控制。</p>
<p>运行窗体，多页控件显示第一页的欢迎信息，当选择其他页面时显示提示信息，如图 123-1 所示。</p>
<div>
<p><img src="./assets/123-1.png" alt="" loading="lazy"></p>
<p><u>图 123-1</u>	使用多页控件</p>
</div>
<h2 id="_124、标签文字垂直居中对齐"> 124、标签文字垂直居中对齐</h2>
<p>在使用标签控件为其他控件作题注时，只能设置题注文字在水平方向的对齐方式，不能设置为垂直居中。要达到题注文字垂直居中的效果，可以使用两个标签控件组合来完成。</p>
<ul>
<li>
<p>步骤 1，在窗体中添加一个标签控件 Label1，将 Caption 属性设置为空，再设置需要的背景颜色及边框颜色。</p>
</li>
<li>
<p>步骤 2，添加一个标签控件 Label2，将 Caption 属性设置为需要的标题；AutoSize 属性设置为 True，BackStyle 属性设置为 0，TextAligh 属性设置为 fmTextAlignCenter，其它属性不改变。</p>
</li>
</ul>
<p>AutoSize 属性规定对象是否自动调整大小以显示其完整的内容，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>AutoSize [<span>=</span> <span>Boolean</span>]

参数<span>object</span>是必需的，一个有效对象。
参数<span>Boolean</span>是可选的，是否自动调整大小。设置值为<span>True</span>控件可自动调整大小以显示其完整的内容，设置为<span>False</span>控件尺寸保持不变。如果内容超出了控件的区域，内容将被剪裁（默认）。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>BorderStyle 属性指定控件或窗体的边框类型，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>BorderStyle [<span>=</span> fmBorderStyle]

参数<span>object</span>是必需的，一个有效对象。
参数fmBorderStyle是可选的，指定边框类型，设置值如表格 <span>124</span><span>1</span>所示。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><u>表格 124-1</u>	fmBorderStyle 设置值</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>fmBackStyleTransparent</td>
<td>0</td>
<td>背景为透明</td>
</tr>
<tr>
<td>fmBackStyleOpaque</td>
<td>1</td>
<td>背景为不透明（默认值）</td>
</tr>
</tbody>
</table>
<p>TextAligh 属性定义控件中文本的对齐方式，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>TextAlign [<span>=</span> fmTextAlign]

参数<span>object</span>是必需的，一个有效对象。
参数fmTextAlign是可选的，控件中文本的对齐方式，设置值如表格 <span>124</span><span>-</span><span>2</span> 所示。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><u>表格 124-2</u>	fmTextAlign设置值</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>fmTextAlignLeft</td>
<td>1</td>
<td>将所显示文本的第一个字符与控件显示或编辑区的左边界对齐（默认值）。</td>
</tr>
<tr>
<td>fmTextAlignCenter</td>
<td>2</td>
<td>在控件的显示或编辑区中，使文本中央对齐</td>
</tr>
<tr>
<td>fmTextAlignRight</td>
<td>3</td>
<td>将所显示文本的最后一个字符与控件显示或编辑区的右边界对齐。</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>步骤 3，同时选中两个标签控件，在右键弹出菜单中选择“统一尺寸”→“宽度相同”，再右击选择“对齐”→“左对齐”，重新右键“对齐”→“中间对齐”。</p>
</li>
<li>
<p>步骤 4，最后同时选中两个标签控件，在右键弹出菜单中选择“生成组”，就达到标题为垂直居中的效果了，如图 124-1 窗体中左边的标签所示。</p>
</li>
</ul>
<div>
<p><img src="./assets/124-1.png" alt="" loading="lazy"></p>
<p><u>图 124-1</u>	标签控件标题垂直居中</p>
</div>
<h2 id="_125、使用-tabstrip-控件"> 125、使用 TabStrip 控件</h2>
<p>使用 TabStrip 控件，可以在用户窗体中的同一区域定义多个数据页面，也就是说使用 TabStrip 控件可以使用户窗体中的同一组控件根据 TabStrip 控件所选择的页面具有不同的功能，而不必像多页控件那样需要在每个页面中放置相同的控件。</p>
<p>在示例的窗体中使用一个图像控件和一个标签控件，根据 TabStrip 控件所选择的页面来显示相应城市的图片和标签控件的题注。</p>
<ul>
<li>
<p>步骤 1，在窗体中添加一个 TabStrip 控件，默认情况下，一个 TabStrip 控件包含两个页面，所以需要在 TabStrip 控件上右键单击，在显示的右键菜单中选择“新建页”继续添加三个页面。因为 TabStrip 控件不像多页控件具有分页的属性窗口，所以需要在显示的右键菜单中选择“重命名”将页面分别重命名为各城市的名称。</p>
</li>
<li>
<p>步骤 2，在 TabStrip 控件上添加一个 Image 控件和一个 Label 控件，调整为合适的大小。</p>
</li>
<li>
<p>步骤 3，双击窗体写入下面的代码：</p>
</li>
</ul>
<div><pre><code><span>Private</span> <span>Sub</span> TabStrip1_Change<span>(</span><span>)</span>
	<span>Dim</span> FilPath <span>As</span> <span>String</span>
	FilPath <span>=</span> ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\"</span> <span>&amp;</span> TabStrip1<span>.</span>SelectedItem<span>.</span>Caption <span>&amp;</span> <span>".jpg"</span>
	Image1<span>.</span>Picture <span>=</span> LoadPicture<span>(</span>FilPath<span>)</span>
	Label1<span>.</span>Caption <span>=</span> TabStrip1<span>.</span>SelectedItem<span>.</span>Caption <span>&amp;</span> <span>"欢迎您!"</span>
<span>End</span> <span>Sub</span>
<span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	TabStrip1<span>.</span>Value <span>=</span> <span>0</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>代码解析：</p>
<p>第 1 行到第 6 行代码，TabStrip 控件的 Change 事件过程，根据 TabStrip 控件所选择的页面来显示相应城市的图片和标签控件的题注。</p>
<p>第 3 行代码设置 Image 控件需加载图片的完整路径，使用 SelectedItem 属性返回 TabStrip 控件当前选中页面的 Caption 属性，即窗体中所选城市的名称，将图片的完整路径设置为保存在同一目录中已命名为所选城市的图片。</p>
<p>第 4 行代码为 Image 控件加载图片。Picture 属性指定显示在对象上的位图，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>Picture <span>=</span> LoadPicture<span>(</span> pathname <span>)</span>

参数expression是必需的，一个有效的对象。
参数pathname是必需的，一个图片文件的完整路径。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第 5 行代码设置标签控件的题注为窗体中所选城市的名称和“欢迎您!”。</p>
<p>第 7 行到第 9 行代码窗体的 Initialize 事件过程，为了使窗体显示时 TabStrip 控件显示第一页，将其 Value 设置为零 ( 0 )。</p>
<p>运行窗体，选择不同的标签将显示不同城市的图片，如图 125-1 所示。</p>
<div>
<p><img src="./assets/125-1.png" alt="" loading="lazy"></p>
<p><u>图 125-1</u>	使用 TabStrip 控件（一）</p>
</div>
<p>如果将 TabStrip 控件的 Style 属性设置为 1，则在标签条中显示的是按钮而不是标签，如图 125-2 所示。</p>
<div>
<p><img src="./assets/125-2.png" alt="" loading="lazy"></p>
<p><u>图 125-2</u>	使用 TabStrip 控件（一）</p>
</div>
<h2 id="_126、显示-gif-动画图片"> 126、显示 GIF 动画图片</h2>
<p>如果希望在 Excel 中显示 GIF 格式的动画图片，可以使用 AniGif 控件。</p>
<ul>
<li>步骤 1，在工作表中单击菜单“视图”→“工具栏”→“控件工具箱”→“其他控件”，选择“VBAniGIF. AniGif”后在工作表中拖动添加 AniGif 控件，如图 126-1 所示。</li>
</ul>
<div>
<p><img src="./assets/126-1.png" alt="" loading="lazy"></p>
<p><u>图 126-1</u>	添加 AniGif 控件</p>
</div>
<p>如果“其他控件”中没有该控件，那么需要对该控件进行注册。注册控件请参阅 118 。AniGif 控件的文件名为 VBAniGIF.OCX，也可以在工作表中单击菜单“视图”→“工具栏”→“控件工具箱”→“其他控件”，选择“注册自定义控件”，在显示的对话框中选择 VBAniGIF.OCX 文件进行注册，如图 126-2 所示。</p>
<div>
<p><img src="./assets/126-2.png" alt="" loading="lazy"></p>
<p><u>图 126-2</u>	注册 AniGif 控件</p>
</div>
<ul>
<li>步骤 2，在设计模式下右键单击 AniGif 控件，选择“属性”，设置 AniGif 控件的 Filename 属性为 CIF 图片所在的路径，如图 126-3 所示。</li>
</ul>
<div>
<p><img src="./assets/126-3.png" alt="" loading="lazy"></p>
<p><u>图 126-3</u>	设置 Filename 属性</p>
</div>
<p>可以使用代码设置 AniGif 控件的 Filename 属性，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Workbook_Open<span>(</span><span>)</span>
	Sheet1<span>.</span>AniGif1<span>.</span>Filename <span>=</span> ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\001.gif"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>工作簿打开时将 AniGif 控件的 Filename 属性设置为同一目录中的“001.gif”文件。</p>
<p>工作簿打开时可能出现如图 126-4 所示的对话框，这是因为当打开包含 ActiveX 控件的文件时，如果该控件被标识为初始化不安全时，Office 程序不加载或激活未被标志为初始化安全的 ActiveX 控件。</p>
<div>
<p><img src="./assets/126-4.png" alt="" loading="lazy"></p>
<p><u>图 126-4</u>	初始化不安全 ActiveX 控件提示</p>
</div>
<p>解决此问题的方法是更改 Office 程序处理 ActiveX 组件的方式，需要对注册表进行修改。也可以使用以下代码修改注册表：</p>
<div><pre><code><span>Sub</span> RegWriteProc<span>(</span><span>)</span>
	<span>Dim</span> WshShell
	<span>Set</span> WshShell <span>=</span> CreateObject<span>(</span><span>"Wscript.Shell"</span><span>)</span>
	WshShell<span>.</span>RegWrite <span>"HKCU\Software\Microsoft\Office\Common\Security\UFIControls"</span><span>,</span> <span>1</span><span>,</span> <span>"REG_DWORD"</span>
	WshShell<span>.</span>RegWrite <span>"HKCU\Software\Microsoft\VBA\Security\LoadControlsInForms"</span><span>,</span> <span>1</span><span>,</span> <span>"REG_DWORD"</span>
	<span>Set</span> WshShell <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>RegWriteProc 过程修改注册表设置。第 4 行代码将 UFIControls 子项设置为 1（最不安全）。第 5 行代码将 LoadControlsInForms 子项设置为 1（最不安全）。关于为 ActiveX 控件授予权限请参阅微软的技术文章：http://support.microsoft.com/kb/827742/zh-cn</p>
<p>退出设计模式后，将在工作表中显示 GIF 动画图片，如图 126-5 所示。</p>
<div>
<p><img src="./assets/126-5.png" alt="" loading="lazy"></p>
<p><u>图 126-5</u>	显示 GIF 动画图片</p>
</div>
<h2 id="_127、播放-flash-文件"> 127、播放 Flash 文件</h2>
<p>如果需要在工作表中播放 Flash 文件，那么可以使用 ShockwaveFlash 控件。</p>
<ul>
<li>步骤 1，在工作表中单击菜单“视图”→“工具栏”→“控件工具箱”→“其他控件”，选择“ShocKwave Flash Object”后在工作表中拖动添加 ShockwaveFlash 控件，如图 127-1 所示。</li>
</ul>
<div>
<p><img src="./assets/127-1.png" alt="" loading="lazy"></p>
<p><u>图 127-1</u>	添加 ShockwaveFlash 控件</p>
</div>
<p>如果“其他控件”中没有该控件，请参阅 126 对其进行注册，ShockwaveFlash 控件的文件名为 Flash9d.OCX。</p>
<ul>
<li>步骤 2，在设计模式下右键单击 ShockwaveFlash 控件，选择“属性”，设置 ShockwaveFlash 控件的 Base 属性和 Movie 属性为 Flash 文件所在的路径，设置 Embedmovie 属性为 True，使 Flash 文件嵌入到 Excel 中，如图 127-2 所示。</li>
</ul>
<div>
<p><img src="./assets/127-2.png" alt="" loading="lazy"></p>
<p><u>图 127-2</u>	设置 ShockwaveFlash 控件属性</p>
</div>
<p>可以使用代码设置 ShockwaveFlash 控件的各项属性，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Workbook_Open<span>(</span><span>)</span>
	<span>With</span> Sheet1<span>.</span>ShockwaveFlash1
		<span>.</span>Base <span>=</span> ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\face.swf"</span>
		<span>.</span>Movie <span>=</span> ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\face.swf"</span>
		<span>.</span>EmbedMovie <span>=</span> <span>True</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>工作簿打开时将 ShockwaveFlash 控件的 Base 属性和 Movie 属性设置为同一目录中的“face.swf”文件，设置 Embedmovie 属性为 True。</p>
<p>退出设计模式后，将在工作表中显示 Flash 动画，如图 127-3 所示。</p>
<div>
<p><img src="./assets/127-3.png" alt="" loading="lazy"></p>
<p><u>图 127-3</u>	显示 Flash 动画</p>
</div>
<h2 id="_128、在工作表中添加窗体控件"> 128、在工作表中添加窗体控件</h2>
<p>在工作表中添加窗体控件，除了使用手工添加外，还可以使用代码添加，方法如下：</p>
<h3 id="_1-使用-addformcontrol-方法"> 1）使用 AddFormControl 方法</h3>
<p>使用 AddFormControl 方法在工作表中添加窗体控件，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> AddFormControls<span>(</span><span>)</span>
	<span>Dim</span> myShape <span>As</span> Shape
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	Sheet1<span>.</span>Shapes<span>(</span><span>"myButton"</span><span>)</span><span>.</span>Delete
	<span>Set</span> myShape <span>=</span> Sheet1<span>.</span>Shapes<span>.</span>AddFormControl<span>(</span><span>0</span><span>,</span> <span>108</span><span>,</span> <span>72</span><span>,</span> <span>108</span><span>,</span> <span>27</span><span>)</span>
	<span>With</span> myShape
		<span>.</span>Name <span>=</span> <span>"myButton"</span>
		<span>With</span> <span>.</span>TextFrame<span>.</span>Characters
			<span>.</span>Font<span>.</span>ColorIndex <span>=</span> <span>3</span>
			<span>.</span>Font<span>.</span>Size <span>=</span> <span>12</span>
			<span>.</span>Text <span>=</span> <span>"新建的按钮"</span>
		<span>End</span> <span>With</span>
		<span>.</span>OnAction <span>=</span> <span>"myButton"</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
<span>Sub</span> myButton<span>(</span><span>)</span>
	MsgBox <span>"这是使用AddFormControl方法新建的按钮!"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>代码解析：</p>
<p>AddFormControls 过程使用 AddFormControl 方法在工作表中添加窗体控件。</p>
<p>第 3、4 行代码为了避免在工作表中重复添加按钮控件，先删除工作表中的“myButton”按钮。</p>
<p>第 5 行代码，使用 AddFormControl 方法在工作表中添加命令按钮控件并设置控件的坐标和大小。应用于 Shapes 对象的 AddFormContl 方法创建一个 Microsoft Excel 控件，返回一个 Shape 对象，该对象代表新建的控件，语法如下：</p>
<div><pre><code>expression<span>.</span>AddFormControl<span>(</span><span>Type</span><span>,</span> Left<span>,</span> Top<span>,</span> Width<span>,</span> Height<span>)</span>

参数expression是必需的，一个有效的对象。
参数<span>Type</span>是必需的，Microsoft Excel控件类型，可以为表格 <span>128</span><span>-</span><span>1</span>所列XlFormControl 常量之一。
参数Left是必需的，新对象的初始坐标（以[磅]<span>(</span><span>#</span><span>#</span><span>)</span>为单位）相对于工作表 A1 单元格的左上角或图表的左上角。
参数Top是必需的，新对象的初始坐标（以[磅]<span>(</span><span>#</span><span>#</span><span>)</span>为单位）相对于工作表 A1 单元格的左上角或图表的左上角。
参数Width是必需的，以磅为单位的新对象的初始大小。
参数Height是必需的，以磅为单位的新对象的初始大小。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><u>表格 128-1</u>	XlFormControl 常量</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>xlButtonControl</td>
<td>0</td>
<td>命令按钮</td>
</tr>
<tr>
<td>xlCheckBox</td>
<td>1</td>
<td>复选框</td>
</tr>
<tr>
<td>xlDropDown</td>
<td>2</td>
<td>组合框</td>
</tr>
<tr>
<td>xlEditBox</td>
<td>3</td>
<td>编辑框</td>
</tr>
<tr>
<td>xlGroupBox</td>
<td>4</td>
<td>分组框</td>
</tr>
<tr>
<td>xlLabel</td>
<td>5</td>
<td>标签</td>
</tr>
<tr>
<td>xlListBox</td>
<td>6</td>
<td>列表框</td>
</tr>
<tr>
<td>xlOptionButton</td>
<td>7</td>
<td>选项按钮</td>
</tr>
<tr>
<td>xlScrollBar</td>
<td>8</td>
<td>滚动条</td>
</tr>
<tr>
<td>xlSpinner</td>
<td>9</td>
<td>微调项</td>
</tr>
</tbody>
</table>
<p>第 7 行代码将新添加的按钮名称设置为“myButton”。</p>
<p>第 8 行到第 12 行代码设置新添加的按钮文字设置为“新建的按钮”，并设置文字的大小和颜色。</p>
<p>第 13 行代码，指定新添加按钮所执行的宏名称。</p>
<p>myButton 过程是单击新添加按钮所执行的过程，显示一个消息框。</p>
<p>运行 AddFormControls 过程将在工作表中添加一个命令按钮，单击按钮显示一个消息框，如图 128-1 所示。</p>
<div>
<p><img src="./assets/128-1.png" alt="" loading="lazy"></p>
<p><u>图 128-1</u>	使用 AddFormControl 方法添加窗体控件</p>
</div>
<h3 id="_2-使用-add-方法"> 2）使用 Add 方法</h3>
<p>在工作表中添加窗体控件还可以使用 Add 方法，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> AddChartObjects<span>(</span><span>)</span>
	<span>Dim</span> myButton <span>As</span> Button
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	Sheet1<span>.</span>Shapes<span>(</span><span>"myButton"</span><span>)</span><span>.</span>Delete
	<span>Set</span> myButton <span>=</span> Sheet1<span>.</span>Buttons<span>.</span>Add<span>(</span><span>108</span><span>,</span> <span>72</span><span>,</span> <span>108</span><span>,</span> <span>27</span><span>)</span>
	<span>With</span> myButton
		<span>.</span>Name <span>=</span> <span>"myButton"</span>
		<span>.</span>Font<span>.</span>Size <span>=</span> <span>12</span>
		<span>.</span>Font<span>.</span>ColorIndex <span>=</span> <span>5</span>
		<span>.</span>Characters<span>.</span>Text <span>=</span> <span>"新建的按钮"</span>
		<span>.</span>OnAction <span>=</span> <span>"myButton"</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
<span>Sub</span> myButton<span>(</span><span>)</span>
	MsgBox <span>"这是使用Add方法新建的按钮!"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>代码解析：</p>
<p>AddChartObjects 过程使用 Add 方法在工作表中添加窗体控件。</p>
<p>第 3、4 行代码为了避免在工作表中重复添加按钮控件，先删除工作表中的“myButton”按钮。</p>
<p>第 5 行代码，使用 Add 方法在工作表中添加命令按钮控件，Add 方法适用于 ChartObjects 对象的语法如下：</p>
<div><pre><code>expression<span>.</span>Add<span>(</span>Left<span>,</span> Top<span>,</span> Width<span>,</span> Height<span>)</span>

参数expression是必需的，该表达式返回一个ChartObjects对象。
如果需要在工作表中添加其他窗体控件，可以将参数expression设置为表格 <span>128</span><span>-</span><span>2</span>所示的ChartObjects对象之一。
参数Left和Top是必需的，以磅为单位给出新对象的初始坐标，该坐标是相对于工作表上单元格 A1 的左上角或图表的左上角的坐标。
参数Width和参数Height是必需的，以磅为单位给出新对象的初始大小。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><u>表格 128-2</u>	ChartObjects 对象</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>ChartObjects对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>复选框</td>
<td>CheckBoxes</td>
</tr>
<tr>
<td>组合框</td>
<td>DropDowns</td>
</tr>
<tr>
<td>标签</td>
<td>Labels</td>
</tr>
<tr>
<td>列表框</td>
<td>ListBoxes</td>
</tr>
<tr>
<td>选项按钮</td>
<td>OptionButtons</td>
</tr>
<tr>
<td>滚动条</td>
<td>ScrollBars</td>
</tr>
<tr>
<td>微调项</td>
<td>Spinners</td>
</tr>
</tbody>
</table>
<p>第 7 行代码将新添加的按钮的名称设置为“myButton”。</p>
<p>第 8 行到第 10 代码新添加的按钮的文字设置为“新建的按钮”并设置文字的大小和颜色。</p>
<p>第 11 行代码，指定新添加命令按钮所执行的宏名称。</p>
<p>myButton 过程是单击新添加按钮所执行的过程，显示一个消息框。</p>
<p>运行 AddChartObjects 过程将在工作表中添加一个命令按钮，单击按钮显示一个消息框，如图 128-2 所示。</p>
<div>
<p><img src="./assets/128-2.png" alt="" loading="lazy"></p>
<p><u>图 128-2</u>	使用 Add 方法添加窗体控件</p>
</div>
<h2 id="_129、在工作表中添加-activex-控件"> 129、在工作表中添加 ActiveX 控件</h2>
<p>在 128 中使用代码在工作表中添加的是窗体控件，而本例中使用代码在工作表中添加的是 ActiveX 控件，两者是有区别的，在工作表中前者是使用窗体对话框添加，而后者是使用控件工具箱添加，如图 129-1 所示。</p>
<div>
<p><img src="./assets/129-1.png" alt="" loading="lazy"></p>
<p><u>图 129-1</u>	窗体控件和 ActiveX 控件的区别</p>
</div>
<h3 id="_1-使用-add-方法"> 1）使用 Add 方法</h3>
<p>使用 Add 方法在工作表中添加 ActiveX 控件，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> AddObj<span>(</span><span>)</span>
	<span>Dim</span> Obj <span>As</span> <span>New</span> OLEObject
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	Sheet1<span>.</span>OLEObjects<span>(</span><span>"MyButton"</span><span>)</span><span>.</span>Delete
	<span>Set</span> Obj <span>=</span> Sheet1<span>.</span>OLEObjects<span>.</span>Add<span>(</span>ClassType<span>:</span><span>=</span><span>"Forms.CommandButton.1"</span><span>,</span> <span>_</span>
			Left<span>:</span><span>=</span><span>108</span><span>,</span> Top<span>:</span><span>=</span><span>72</span><span>,</span> Width<span>:</span><span>=</span><span>108</span><span>,</span> Height<span>:</span><span>=</span><span>27</span><span>)</span>
	<span>With</span> Obj
		<span>.</span>Name <span>=</span> <span>"MyButton"</span>
		<span>.</span><span>Object</span><span>.</span>Caption <span>=</span> <span>"新建的按钮"</span>
		<span>.</span><span>Object</span><span>.</span>Font<span>.</span>Size <span>=</span> <span>16</span>
		<span>.</span><span>Object</span><span>.</span>ForeColor <span>=</span> <span>&amp;HFF</span><span>&amp;</span>
	<span>End</span> <span>With</span>
	<span>With</span> ActiveWorkbook<span>.</span>VBProject<span>.</span>VBComponents<span>(</span>Sheet1<span>.</span>CodeName<span>)</span><span>.</span>CodeModule
		<span>If</span> <span>.</span>Lines<span>(</span><span>1</span><span>,</span> <span>1</span><span>)</span> <span>&lt;</span><span>></span> <span>"Option Explicit"</span> <span>Then</span>
			<span>.</span>InsertLines <span>1</span><span>,</span> <span>"Option Explicit"</span>
		<span>End</span> <span>If</span>
		<span>If</span> <span>.</span>Lines<span>(</span><span>2</span><span>,</span> <span>1</span><span>)</span> <span>=</span> <span>"Private Sub MyButton_Click()"</span> <span>Then</span> <span>Exit</span> <span>Sub</span>
		<span>.</span>InsertLines <span>2</span><span>,</span> <span>"Private Sub MyButton_Click()"</span>
		<span>.</span>InsertLines <span>3</span><span>,</span> vbTab <span>&amp;</span> <span>"MsgBox ""这是使用Add方法新建的按钮!"""</span>
		<span>.</span>InsertLines <span>4</span><span>,</span> <span>"End Sub"</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>代码解析：</p>
<p>AddOLEObject 过程使用 Add 方法在向工作表中添加 ActiveX 控件中的命令按钮和相应的代码。</p>
<p>第 3、4 行代码为了避免在工作表中重复添加按钮控件，先删除工作表中的名称为“myButton”的按钮。</p>
<p>第 5、6 行代码，使用 Add 方法在向工作表中添加 ActiveX 控件中的命令按钮，Add 方法应用于 OLEObjects 对象的语法如下：</p>
<div><pre><code>expression<span>.</span>Add<span>(</span>ClassType<span>,</span> FileName<span>,</span> Link<span>,</span> DisplayAsIcon<span>,</span> IconFileName<span>,</span> IconIndex<span>,</span> IconLabel<span>,</span> Left<span>,</span> Top<span>,</span> Width<span>,</span> Height<span>)</span>

其中参数expression是必需的，返回一个 OLEObjects 对象。
参数ClassType是可选的，创建的对象的程序标识符。如果指定了 ClassType参数，则忽略FileName参数和Link参数。
在本例中指定添加控件的程序标识符为<span>“Forms.CommandButton.1”</span>，即命令按钮控件，关于对象的程序标识符请参阅技巧<span>119</span><span>-</span><span>3</span>。
参数Left和参数Top是必需的，以磅为单位给出新对象的初始坐标，该坐标是相对于工作表上单元格 A1 的左上角或图表的左上角的坐标。
参数Width和参数Height是可选的，以磅为单位给出OLE对象的初始大小。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>第 8 行代码，设置命令按钮的名称为“MyButton”。</p>
<p>第 9 行代码，设置命令按钮的文字为“新建的按钮”</p>
<p>第 10 行代码，设置命令按钮的文字的大小。</p>
<p>第 11 行代码，设置命令按钮的文字的颜色。</p>
<p>第 13 行到第 21 行代码，在工作表中写入新添加的命令按钮的单击事件代码。</p>
<p>ActiveX 控件不能像窗体控件用 OnAction 属性来指定宏，需要使用 CodeModule 对象的 InsertLines 方法在工作表中插入代码。</p>
<p>应用于 CodeModule 对象的 InsertLines 方法的语法如下：</p>
<div><pre><code><span>object</span><span>.</span>InsertLines<span>(</span>line<span>,</span> code<span>)</span>

参数<span>object</span>是必需的，一个有效的对象。
参数line是必需的，用来指定要插入代码的位置。
参数code是必需的，要插入的代码。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>第 14 行到第 16 行代码判断首行内容是否为要求变量声明，如不是则添加要求变量声明语句。</p>
<p>第 17 行到第 20 行代码判断是否已存在相同名称的过程，如不存在则使用 InsertLines 方法在工作表中插入代码。</p>
<p>运行 AddOLEObject 过程，将在工作表中添加一个命令按钮和相应的代码，单击按钮显示一个消息框，如图 129-2 所示。</p>
<div>
<p><img src="./assets/129-2.png" alt="" loading="lazy"></p>
<p><u>图 129-2</u>	使用 Add 方法添加 ActiveX 控件</p>
</div>
<h3 id="_2-使用-addoleobject-方法"> 2）使用 AddOLEObject 方法</h3>
<p>在工作表中添加 ActiveX 控件，还可以使用 AddOLEObject 方法，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> AddShapes<span>(</span><span>)</span>
	<span>Dim</span> ShpBut <span>As</span> Shape
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	Sheet1<span>.</span>OLEObjects<span>(</span><span>"MyButton"</span><span>)</span><span>.</span>Delete
	<span>Set</span> ShpBut <span>=</span> Sheet1<span>.</span>Shapes<span>.</span>AddOLEObject<span>(</span>ClassType<span>:</span><span>=</span><span>"Forms.CommandButton.1"</span><span>,</span> <span>_</span>
			Left<span>:</span><span>=</span><span>108</span><span>,</span> Top<span>:</span><span>=</span><span>72</span><span>,</span> Width<span>:</span><span>=</span><span>108</span><span>,</span> Height<span>:</span><span>=</span><span>27</span><span>)</span>
			ShpBut<span>.</span>Name <span>=</span> <span>"MyButton"</span>
	<span>With</span> ActiveWorkbook<span>.</span>VBProject<span>.</span>VBComponents<span>(</span>Sheet1<span>.</span>CodeName<span>)</span><span>.</span>CodeModule
		<span>If</span> <span>.</span>Lines<span>(</span><span>1</span><span>,</span> <span>1</span><span>)</span> <span>&lt;</span><span>></span> <span>"Option Explicit"</span> <span>Then</span>
			<span>.</span>InsertLines <span>1</span><span>,</span> <span>"Option Explicit"</span>
		<span>End</span> <span>If</span>
		<span>If</span> <span>.</span>Lines<span>(</span><span>2</span><span>,</span> <span>1</span><span>)</span> <span>=</span> <span>"Private Sub MyButton_Click()"</span> <span>Then</span> <span>Exit</span> <span>Sub</span>
		<span>.</span>InsertLines <span>2</span><span>,</span> <span>"Private Sub MyButton_Click()"</span>
		<span>.</span>InsertLines <span>3</span><span>,</span> vbTab <span>&amp;</span> <span>"MsgBox ""这是使用AddOLEObject方法新建的按钮!"""</span>
		<span>.</span>InsertLines <span>4</span><span>,</span> <span>"End Sub"</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>代码解析：</p>
<p>AddShapes 过程使用 AddOLEObject 方法在向工作表中添加 ActiveX 控件中的命令按钮和相应的代码。</p>
<p>第 5、6 行代码，使用 AddOLEObject 方法在向工作表中添加 ActiveX 控件中的命令按钮，AddOLEObject 方法创建 OLE 对象，语法如下：</p>
<div><pre><code>expression<span>.</span>AddOLEObject<span>(</span>ClassType<span>,</span> FileName<span>,</span> Link<span>,</span> DisplayAsIcon<span>,</span> IconFileName<span>,</span> IconIndex<span>,</span> IconLabel<span>,</span> Left<span>,</span> Top<span>,</span> Width<span>,</span> Height<span>)</span>

AddOLEObject方法参数与Add方法类似，请参阅技巧<span>129</span><span>-</span><span>1</span>。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>运行 AddShapes 过程，将在工作表中添加一个命令按钮和相应的代码，单击按钮显示一个消息框，如图 129-3 所示。</p>
<div>
<p><img src="./assets/129-3.png" alt="" loading="lazy"></p>
<p><u>图 129-3</u>	使用 AddOLEObject 方法添加 ActiveX 控件</p>
</div>
<h2 id="_130、使用-spreadsheet-控件"> 130、使用 spreadsheet 控件</h2>
<p>如果希望在窗体中显示类似工作表的表格，并且可以像工作表一样进行操作，那么可以在窗体中使用表格控件（Spreadsheet 控件）。</p>
<ul>
<li>步骤 1，在 VBE 窗口中单击菜单“插入”→“用户窗体”，在窗体上添加一个 Spreadsheet 控件，双击窗体，在其代码窗口中输入下面的代码：</li>
</ul>
<div><pre><code><span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	<span>Dim</span> iRow <span>As</span> <span>Integer</span>
	<span>Dim</span> arr <span>As</span> <span>Variant</span>
	<span>With</span> <span>Me</span><span>.</span>Spreadsheet1
		<span>.</span>DisplayToolbar <span>=</span> <span>False</span>
		<span>.</span>DisplayHorizontalScrollBar <span>=</span> <span>False</span>
		<span>.</span>DisplayVerticalScrollBar <span>=</span> <span>False</span>
		<span>.</span>DisplayWorkbookTabs <span>=</span> <span>False</span>
		iRow <span>=</span> Sheet1<span>.</span>Range<span>(</span><span>"B65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row
		arr <span>=</span> Sheet1<span>.</span>Range<span>(</span><span>"B2:H"</span> <span>&amp;</span> iRow<span>)</span>
		<span>With</span> <span>.</span>Range<span>(</span><span>"B2:H"</span> <span>&amp;</span> iRow<span>)</span>
			<span>.</span>Value <span>=</span> arr
			<span>.</span>Borders<span>.</span>LineStyle <span>=</span> xlContinuous
			<span>.</span>Borders<span>.</span>Weight <span>=</span> xlMedium
			<span>.</span>Borders<span>.</span>ColorIndex <span>=</span> <span>10</span>
		<span>End</span> <span>With</span>
		<span>With</span> <span>.</span>Range<span>(</span><span>"B2:H2"</span><span>)</span>
			<span>.</span>HorizontalAlignment <span>=</span> <span>-</span><span>4108</span>
			<span>.</span>VerticalAlignment <span>=</span> <span>-</span><span>4108</span>
			<span>.</span>Interior<span>.</span>ColorIndex <span>=</span> <span>44</span>
		<span>End</span> <span>With</span>
		<span>.</span>Range<span>(</span><span>"B3:B"</span> <span>&amp;</span> iRow<span>)</span><span>.</span>HorizontalAlignment <span>=</span> <span>-</span><span>4108</span>
		<span>.</span>Range<span>(</span><span>"C3:H"</span> <span>&amp;</span> iRow<span>)</span><span>.</span>NumberFormat <span>=</span> <span>"0.00"</span>
		<span>.</span>Rows<span>(</span><span>2</span><span>)</span><span>.</span>RowHeight <span>=</span> <span>23.25</span>
		<span>.</span>Columns<span>(</span><span>"A"</span><span>)</span><span>.</span>ColumnWidth <span>=</span> <span>2.75</span>
		<span>.</span>Columns<span>(</span><span>"B:H"</span><span>)</span><span>.</span>ColumnWidth <span>=</span> <span>8</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>代码解析：</p>
<p>用户窗体的初始化事件过程，使用窗体显示工作表中的表格。</p>
<p>第 5 行代码，设置 Spreadsheet 控件不显示工具栏。</p>
<p>DisplayToolbar 属性设置工具栏是否隐藏，语法如下：</p>
<div><pre><code>expression<span>.</span>DisplayToolbar

参数expression是必需的，一个有效的对象。
如果指定电子表格、图表区或<span>“数据透视表”</span>列表显示了工具栏，则返回<span>True</span>。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第 6、7 行代码，设置 Spreadsheet 控件不显示水平和垂直滚动条。</p>
<p>第 8 行代码，设置 Spreadsheet 控件不显示工作表标签。</p>
<p>第 9 行代码，取得工作表 B 列有数据的最后一行的行号。</p>
<p>第 10 行代码，把工作表数据赋值给数组。</p>
<p>第 11 行到 16 行代码，把数组赋给 Spreadsheet 控件的单元格，使 Spreadsheet 控件显示工作表内容，并且添加加框线。</p>
<p>第 17 行到第 21 行代码，设置 Spreadsheet 控件中表格第一行的字体对齐方式为居中并添加单元格的底纹颜色。</p>
<p>第 22 行代码，设置 Spreadsheet 控件中表格第一列的字体对齐方式为居中。</p>
<p>第 23 行代码，设置 Spreadsheet 控件中表格数据的格式。</p>
<p>第 24 行到 26 行代码，设置 Spreadsheet 控件的行高与列宽。</p>
<ul>
<li>步骤 2，在窗体上添加一个按钮控件，将其 Caption 属性设置为“保存”，双击按钮控件，在其代码窗口中输入下面的代码：</li>
</ul>
<div><pre><code><span>Private</span> <span>Sub</span> CommandButton1_Click<span>(</span><span>)</span>
	<span>Dim</span> iRow <span>As</span> <span>Integer</span>
	<span>Dim</span> arr <span>As</span> <span>Variant</span>
	<span>If</span> MsgBox<span>(</span><span>"是否保存对表格所作的修改?"</span><span>,</span> <span>4</span> <span>+</span> <span>32</span><span>)</span> <span>=</span> <span>6</span> <span>Then</span>
		<span>With</span> <span>Me</span><span>.</span>Spreadsheet1
			iRow <span>=</span> <span>.</span>Range<span>(</span><span>"B65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row
			arr <span>=</span> <span>.</span>Range<span>(</span><span>"B2:H"</span> <span>&amp;</span> iRow<span>)</span><span>.</span>Value
			Sheet1<span>.</span>Range<span>(</span><span>"B2:H"</span> <span>&amp;</span> iRow<span>)</span><span>.</span>Value <span>=</span> arr
		<span>End</span> <span>With</span>
	<span>End</span> <span>If</span>
	Unload <span>Me</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>代码解析：</p>
<p>用户窗体中“保存”按钮的单击过程，把在窗体中对数据的修改重新保存到工作表。</p>
<p>第 4 行代码，询问用户是否保存修改。</p>
<p>第 5 行到第 10 行代码，如果用户选择保存，把 Spreadsheet 控件中的数据保存到工作表。</p>
<p>运行窗体，显示效果如图 130-1 所示。</p>
<div>
<p><img src="./assets/130-1.png" alt="" loading="lazy"></p>
<p><u>图 130-1</u>	使用 Spreadsheet 控件</p>
</div>
<h2 id="_131、使用-listview-控件"> 131、使用 Listview 控件</h2>
<p>ListView 控件是 VBA 程序开发中的常用控件，可以用来显示各项带图标的列表，也可以用来显示带有子项的列表。</p>
<h3 id="_1-使用-listview-控件显示数据列表"> 1）使用 Listview 控件显示数据列表</h3>
<p>使用 Listview 控件在用户窗体中显示数据列表，代码如下：</p>
<div><pre><code><span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	<span>Dim</span> Itm <span>As</span> ListItem
	<span>Dim</span> r <span>As</span> <span>Integer</span>
	<span>Dim</span> c <span>As</span> <span>Integer</span>
	<span>With</span> ListView1
		<span>.</span>ColumnHeaders<span>.</span>Add <span>,</span> <span>,</span> <span>"人员编号 "</span><span>,</span> <span>50</span><span>,</span> <span>0</span>
		<span>.</span>ColumnHeaders<span>.</span>Add <span>,</span> <span>,</span> <span>"技能工资 "</span><span>,</span> <span>50</span><span>,</span> <span>1</span>
		<span>.</span>ColumnHeaders<span>.</span>Add <span>,</span> <span>,</span> <span>"岗位工资 "</span><span>,</span> <span>50</span><span>,</span> <span>1</span>
		<span>.</span>ColumnHeaders<span>.</span>Add <span>,</span> <span>,</span> <span>"工龄工资 "</span><span>,</span> <span>50</span><span>,</span> <span>1</span>
		<span>.</span>ColumnHeaders<span>.</span>Add <span>,</span> <span>,</span> <span>"浮动工资 "</span><span>,</span> <span>50</span><span>,</span> <span>1</span>
		<span>.</span>ColumnHeaders<span>.</span>Add <span>,</span> <span>,</span> <span>"其他"</span><span>,</span> <span>50</span><span>,</span> <span>1</span>
		<span>.</span>ColumnHeaders<span>.</span>Add <span>,</span> <span>,</span> <span>"应发合计"</span><span>,</span> <span>50</span><span>,</span> <span>1</span>
		<span>.</span>View <span>=</span> lvwReport
		<span>.</span>Gridlines <span>=</span> <span>True</span>
		<span>For</span> r <span>=</span> <span>2</span> <span>To</span> Sheet1<span>.</span>[A65536]<span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row
			<span>Set</span> Itm <span>=</span> <span>.</span>ListItems<span>.</span>Add<span>(</span><span>)</span>
			Itm<span>.</span>Text <span>=</span> Space<span>(</span><span>2</span><span>)</span> <span>&amp;</span> Sheet1<span>.</span>Cells<span>(</span>r<span>,</span> <span>1</span><span>)</span>
			<span>For</span> c <span>=</span> <span>1</span> <span>To</span> <span>6</span>
				Itm<span>.</span>SubItems<span>(</span>c<span>)</span> <span>=</span> Format<span>(</span>Sheet1<span>.</span>Cells<span>(</span>r<span>,</span> c <span>+</span> <span>1</span><span>)</span><span>,</span> <span>",,0.00"</span><span>)</span>
			<span>Next</span>
		<span>Next</span>
		<span>End</span> <span>With</span>
	<span>Set</span> Itm <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>代码解析：</p>
<p>窗体的初始化事件，在窗体显示时将工作表中数据显示在 Listview 控件中。</p>
<p>第 6 行到第 12 行代码，使用 ColumnHeader 对象的 Add 方法在 Listview 控件中添加标题列，并设置列标题、列宽和文本对齐方式。</p>
<p>ColumnHeader 对象是 ListView 控件中包含标题文字的项目，应用于 ColumnHeader 对象的 Add 方法语法如下：</p>
<div><pre><code><span>object</span><span>.</span>ColumnHeader<span>.</span>Add<span>(</span>index<span>,</span>key<span>,</span>text<span>,</span>width<span>,</span>alignment<span>)</span>

其中参数text代表标题文字，参数width代表标题的列宽，参数alignment代表列标题中文本对齐方式。Listview控件中文本的对齐方法有三种，如表格 <span>131</span><span>-</span><span>1</span>所示。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><u>表格 131-1</u>	Listview 控件中文本的对齐方法</p>
<table>
<thead>
<tr>
<th>常数</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>lvwColumnLeft</td>
<td>0</td>
<td>文本向左对齐。（缺省值）</td>
</tr>
<tr>
<td>lvwColumnRight</td>
<td>1</td>
<td>文本向右对齐。</td>
</tr>
<tr>
<td>lvwColumnCenter</td>
<td>2</td>
<td>文本居中对齐。</td>
</tr>
</tbody>
</table>
<p>在 Listview 控件中第一列的文本对齐方式只能设置为左对齐。</p>
<p>第 13 行代码，设置 Listview 控件的 View 属性为 lvwReport，使 Listview 控件显示为报表型。View 属性决定在列表中控件使用何种视图显示项目，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>view [<span>=</span> value]

参数<span>object</span>是必需的，对象表达式，listview控件。
参数value是必需的，指定控件外观的整数或常数，如表格 <span>131</span><span>-</span><span>2</span>所示。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><u>表格 131-2</u>	View 属性的设置值</p>
<table>
<thead>
<tr>
<th>常数</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>lvwicon</td>
<td>0</td>
<td>图标</td>
</tr>
<tr>
<td>lvwsmallicon</td>
<td>1</td>
<td>小图标</td>
</tr>
<tr>
<td>lvwlist</td>
<td>2</td>
<td>列表</td>
</tr>
<tr>
<td>lvwreport</td>
<td>3</td>
<td>报表</td>
</tr>
</tbody>
</table>
<p>第 14 行代码，设置 Listview 控件的 Gridlines 属性为 True，显示网格线。只有在将 View 属性设置为 lvwReport 时才能显示网格线，否则 Gridlines 属性无效。</p>
<p>第 16 行代码，使用 ListItem 对象的 Add 方法在 Listview 控件中添加项目。应用于ListItem对象的 Add 方法语法如下：</p>
<div><pre><code>ListItems<span>.</span>Add<span>(</span>index<span>,</span>key<span>,</span>text<span>,</span>icon<span>,</span>smallIcon<span>)</span>

其中参数text代表添加的项目内容。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>第 17 行代码，添加行标题。ListItem 对象的 text 属性代表 Listview 控件的第一列内容，因为 Listview 控件的第一列的文本对齐方式只能设置为左对齐，所以在添加时使用 Space 函数插入两个空格，使行标题达到居中显示的效果。</p>
<p>第 18 行到 20 行代码，继续添加其他列的内容。Listview 控件其他列的项目需要使用 SubItems 属性来添加。</p>
<p>运行窗体，Listview 控件显示工作表中的内容，如图 131-1 所示。</p>
<div>
<p><img src="./assets/131-1.png" alt="" loading="lazy"></p>
<p><u>图 131-1</u>	使用 Listview 控件显示数据</p>
</div>
<h3 id="_2-在-listview-控件中使用复选框"> 2）在 Listview 控件中使用复选框</h3>
<p>在 Listview 控件中使用复选框，可以进行多重选择，示例代码如下：</p>
<div><pre><code><span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	<span>Dim</span> Itm <span>As</span> ListItem
	<span>Dim</span> r <span>As</span> <span>Integer</span>
	<span>Dim</span> c <span>As</span> <span>Integer</span>
	<span>With</span> ListView1
		<span>.</span>ColumnHeaders<span>.</span>Add <span>,</span> <span>,</span> <span>"人员编号 "</span><span>,</span> <span>50</span><span>,</span> <span>0</span>
		<span>.</span>ColumnHeaders<span>.</span>Add <span>,</span> <span>,</span> <span>"技能工资 "</span><span>,</span> <span>50</span><span>,</span> <span>1</span>
		<span>.</span>ColumnHeaders<span>.</span>Add <span>,</span> <span>,</span> <span>"岗位工资 "</span><span>,</span> <span>50</span><span>,</span> <span>1</span>
		<span>.</span>ColumnHeaders<span>.</span>Add <span>,</span> <span>,</span> <span>"工龄工资 "</span><span>,</span> <span>50</span><span>,</span> <span>1</span>
		<span>.</span>ColumnHeaders<span>.</span>Add <span>,</span> <span>,</span> <span>"浮动工资 "</span><span>,</span> <span>50</span><span>,</span> <span>1</span>
		<span>.</span>ColumnHeaders<span>.</span>Add <span>,</span> <span>,</span> <span>"其他"</span><span>,</span> <span>50</span><span>,</span> <span>1</span>
		<span>.</span>ColumnHeaders<span>.</span>Add <span>,</span> <span>,</span> <span>"应发合计"</span><span>,</span> <span>50</span><span>,</span> <span>1</span>
		<span>.</span>View <span>=</span> lvwReport
		<span>.</span>Gridlines <span>=</span> <span>True</span>
		<span>.</span>FullRowSelect <span>=</span> <span>True</span>
		<span>.</span>CheckBoxes <span>=</span> <span>True</span>
		<span>For</span> r <span>=</span> <span>2</span> <span>To</span> Sheet2<span>.</span>[A65536]<span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row <span>-</span> <span>1</span>
			<span>Set</span> Itm <span>=</span> <span>.</span>ListItems<span>.</span>Add<span>(</span><span>)</span>
			Itm<span>.</span>Text <span>=</span> Sheet2<span>.</span>Cells<span>(</span>r<span>,</span> <span>1</span><span>)</span>
			<span>For</span> c <span>=</span> <span>1</span> <span>To</span> <span>6</span>
				Itm<span>.</span>SubItems<span>(</span>c<span>)</span> <span>=</span> Format<span>(</span>Sheet2<span>.</span>Cells<span>(</span>r<span>,</span> c <span>+</span> <span>1</span><span>)</span><span>,</span> <span>",,0.00"</span><span>)</span>
			<span>Next</span>
		<span>Next</span>
		<span>End</span> <span>With</span>
	<span>Set</span> Itm <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
<span>Private</span> <span>Sub</span> CommandButton1_Click<span>(</span><span>)</span>
	<span>Dim</span> r <span>As</span> <span>Integer</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>Dim</span> c <span>As</span> <span>Integer</span>
	r <span>=</span> Sheet1<span>.</span>[A65536]<span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row
	<span>If</span> r <span>></span> <span>1</span> <span>Then</span> Sheet1<span>.</span>Range<span>(</span><span>"A2:G"</span> <span>&amp;</span> r<span>)</span> <span>=</span> <span>""</span>
	<span>With</span> ListView1
		<span>For</span> i <span>=</span> <span>1</span> <span>To</span> <span>.</span>ListItems<span>.</span>Count
			<span>If</span> <span>.</span>ListItems<span>(</span>i<span>)</span><span>.</span>Checked <span>=</span> <span>True</span> <span>Then</span>
				Sheet1<span>.</span>Range<span>(</span><span>"A65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Offset<span>(</span><span>1</span><span>,</span> <span>0</span><span>)</span> <span>=</span> <span>.</span>ListItems<span>(</span>i<span>)</span>
				<span>For</span> c <span>=</span> <span>1</span> <span>To</span> <span>6</span>
					Sheet1<span>.</span>Cells<span>(</span><span>65536</span><span>,</span> c <span>+</span> <span>1</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Offset<span>(</span><span>1</span><span>,</span> <span>0</span><span>)</span> <span>=</span> <span>.</span>ListItems<span>(</span>i<span>)</span><span>.</span>SubItems<span>(</span>c<span>)</span>
				<span>Next</span>
			<span>End</span> <span>If</span>
		<span>Next</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><p>代码解析：</p>
<p>第 1 行到第 26 行代码，用户窗体的 Initialize 事件过程，在窗体显示时将工作表中数据显示在 Listview 控件中。</p>
<p>其中第 15 行代码设置 Listview 控件的 FullRowSelect 属性为 True，使用户可以选择整行。</p>
<p>第 16 行代码设置 Listview 控件的 CheckBoxes 属性为 True，使 Listview 控件在列表的每个项的旁边显示复选框。</p>
<p>第 27 行到第 43 行代码，用户窗体中“保存”按钮的单击过程，将 Listview 控件中选中的项目写入到工作表中。</p>
<p>第 31、32 行代码，删除工作表中原有的数据，</p>
<p>第 34、35 行代码遍历 Listview 控件中所有的 ListItem 对象，判定其 Checked 值，如果为 True，即说明其处于选中状态。</p>
<p>第 36 行到第 40 行代码将 Listview 控件中选中的内容依次写入到工作表中。</p>
<p>运行窗体，Listview 控件显示工作表中的内容，单击“保存”按钮将如 Listview 控件中选中的内容依次写入到工作表中，如图 131-2 所示。</p>
<div>
<p><img src="./assets/131-2.png" alt="" loading="lazy"></p>
<p><u>图 131-2</u>	Listview 控件使用复选框</p>
</div>
<h3 id="_3-调整-listview-控件的行距"> 3）调整 Listview 控件的行距</h3>
<p>在使用 Listview 控件显示数据列表时，行距是由 Listview 控件所设置的字体大小决定的，无法自定义行距，即使调整了字体大小，行距还是很近。</p>
<p>如果需要自定义 Listview 控件的行距，可以在窗体中添加一个 ImageList 控件，在 ImageList 控件中导入一张大小合适的空白图片，然后指定 Listview 控件的 SmallIcons 属性为 ImageList 控件中的图片，代码如下：</p>
<div><pre><code><span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	<span>Dim</span> Itm <span>As</span> ListItem
	<span>Dim</span> r <span>As</span> <span>Integer</span>
	<span>Dim</span> c <span>As</span> <span>Integer</span>
	<span>Dim</span> Img <span>As</span> ListImage
	<span>With</span> ListView1
		<span>.</span>ColumnHeaders<span>.</span>Add <span>,</span> <span>,</span> <span>"人员编号 "</span><span>,</span> <span>50</span><span>,</span> <span>0</span>
		<span>.</span>ColumnHeaders<span>.</span>Add <span>,</span> <span>,</span> <span>"技能工资 "</span><span>,</span> <span>50</span><span>,</span> <span>1</span>
		<span>.</span>ColumnHeaders<span>.</span>Add <span>,</span> <span>,</span> <span>"岗位工资 "</span><span>,</span> <span>50</span><span>,</span> <span>1</span>
		<span>.</span>ColumnHeaders<span>.</span>Add <span>,</span> <span>,</span> <span>"工龄工资 "</span><span>,</span> <span>50</span><span>,</span> <span>1</span>
		<span>.</span>ColumnHeaders<span>.</span>Add <span>,</span> <span>,</span> <span>"浮动工资 "</span><span>,</span> <span>50</span><span>,</span> <span>1</span>
		<span>.</span>ColumnHeaders<span>.</span>Add <span>,</span> <span>,</span> <span>"其他"</span><span>,</span> <span>50</span><span>,</span> <span>1</span>
		<span>.</span>ColumnHeaders<span>.</span>Add <span>,</span> <span>,</span> <span>"应发合计"</span><span>,</span> <span>50</span><span>,</span> <span>1</span>
		<span>.</span>View <span>=</span> lvwReport
		<span>.</span>Gridlines <span>=</span> <span>True</span>
		<span>.</span>FullRowSelect <span>=</span> <span>True</span>
		<span>Set</span> Img <span>=</span> ImageList1<span>.</span>ListImages<span>.</span>Add<span>(</span><span>,</span> <span>,</span> LoadPicture<span>(</span>ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\"</span> <span>&amp;</span> <span>"1×25.bmp"</span><span>)</span><span>)</span>
		<span>.</span>SmallIcons <span>=</span> ImageList1
		<span>For</span> r <span>=</span> <span>2</span> <span>To</span> Sheet1<span>.</span>[A65536]<span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row <span>-</span> <span>1</span>
			<span>Set</span> Itm <span>=</span> <span>.</span>ListItems<span>.</span>Add<span>(</span><span>)</span>
			Itm<span>.</span>Text <span>=</span> Space<span>(</span><span>2</span><span>)</span> <span>&amp;</span> Sheet1<span>.</span>Cells<span>(</span>r<span>,</span> <span>1</span><span>)</span>
			<span>For</span> c <span>=</span> <span>1</span> <span>To</span> <span>6</span>
				Itm<span>.</span>SubItems<span>(</span>c<span>)</span> <span>=</span> Format<span>(</span>Sheet1<span>.</span>Cells<span>(</span>r<span>,</span> c <span>+</span> <span>1</span><span>)</span><span>,</span> <span>",,0.00"</span><span>)</span>
			<span>Next</span>
		<span>Next</span>
	<span>End</span> <span>With</span>
	<span>Set</span> Itm <span>=</span> <span>Nothing</span>
	<span>Set</span> Img <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>代码解析：</p>
<p>用户窗体的 Initialize 事件过程，在窗体显示时将工作表中数据显示在 Listview 控件中并调整 Listview 控件的行距。</p>
<p>第 17 行代码使用 Add 方法在 ImageList 控件中添加图片。ImageList 控件是一个向其他控件提供图像的资料中心，它包含了一组 ListImage 对象即一组图像的集合，该集合中的每个对象都可以通过其索引或关键字被其他控件所引用，但控件本身并不能单独使用。</p>
<p>在运行时给 ImageList 控件添加图片需要使用 Add 方法，语法如下：</p>
<div><pre><code>Add<span>(</span>index<span>,</span>key<span>,</span>picture<span>)</span>

参数index是可选的，整数，指定要插入的ListImage对象的位置。如果没有指定index，ListImage对象将被添加到ListImages集合的末尾。
参数key是可选的，用来标识ListImage对象的唯一字符串。
参数picture是必需的，指定欲添加到集合中的图片。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>也可以在设计时在 ImageList 控件中添加图片，这样就无需在文件夹中保留图片文件。在 VBE 中选择 ImageList 控件属性页中的“自定义”，在显示的“属性页”对话框中插入图片，如图 131-3 所示。</p>
<div>
<p><img src="./assets/131-3.png" alt="" loading="lazy"></p>
<p><u>图 131-3</u>	在 ImageList 控件中添加图片</p>
</div>
<p>第 18 行代码，指定 Listview 控件的 SmallIcons 属性为 ImageList 控件中的图片，使用图片来调整行距。</p>
<p>运行窗体，Listview 控件显示工作表中的内容，调整 Listview 控件的行距，如图 131-4 所示。</p>
<div>
<p><img src="./assets/131-4.png" alt="" loading="lazy"></p>
<p><u>图 131-4</u>	调整 Listview 控件的行距</p>
</div>
<h3 id="_4-在-listview-控件中排序"> 4）在 Listview 控件中排序</h3>
<p>在使用 Listview 控件显示报表型的数据时，可能通过单击 Listview 控件的列标题对列表数据进行排序，代码如下：</p>
<div><pre><code><span>Private</span> <span>Sub</span> ListView1_ColumnClick<span>(</span><span>ByVal</span> ColumnHeader <span>As</span> MSComctlLib<span>.</span>ColumnHeader<span>)</span>
	<span>With</span> ListView1
		<span>.</span>Sorted <span>=</span> <span>True</span>
		<span>.</span>SortOrder <span>=</span> <span>(</span><span>.</span>SortOrder <span>+</span> <span>1</span><span>)</span> <span>Mod</span> <span>2</span>
		<span>.</span>SortKey <span>=</span> ColumnHeader<span>.</span>Index <span>-</span> <span>1</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>Listview 控件的 ColumnClick 事件过程，单击列标题时触发，对列表数据进行升序或降序排序。</p>
<p>第 3 行代码将 Listview 控件的 Sorted 属性设置为 True。Sorted 属性返回或设置确定 ListView 控件中的 ListItem 对象是否排序，设置为 False则不进行排序。</p>
<p>第 4 行代码设置 Listview 控件的排序方式。SortOrder 属性返回或设置一个值，决定 ListView 控件中的 ListItem 对象以升序或降序排序，设置为 0 以升序排序，设置为 1 则以降序排序。在设置 SortOrder 属性值时使用 Mod 运算符以达到第一次排序以降序排序，再次排序时以升序排序，交替进行的效果。</p>
<p>第 5 行代码设置 Listview 控件排序关键字的整数，即指定 Listview 控件以当前选定的列数据进排序。SortKey 属性返回或设置一个值，此值决定 ListView 控件中的 ListItem 对象如何排序，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>SortKey [<span>=</span><span>integer</span>]

参数<span>object</span>是必需的，对象表达式，其值为ListView控件。
参数<span>integer</span>是必需的，指定排序关键字的整数，设置为<span>0</span>使用ListItem对象的Text属性排序，即第一列的数据进行排序。设置为大于<span>0</span>的整数则使用子项目的集合索引排序。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>运行窗体，Listview 控件显示工作表中的内容，单击列标题对列表数据进行升序或降序排序，如图 131-5 所示。</p>
<div>
<p><img src="./assets/131-5.png" alt="" loading="lazy"></p>
<p><u>图 131-5</u>	在 Listview 控件中排序</p>
</div>
<h3 id="_5-listview-控件的图标设置"> 5）Listview 控件的图标设置</h3>
<p>ListView 控件作为一个可以显示图标或者子项的列表控件，可以在控件中显示自定义的图标，它最重要的属性就是 View 属性，该属性决定了以哪种视图模式显示控件的项，请参阅 131-1。</p>
<p>在 ListView 控件中显示图标，需要在用户窗体中添加一个 ImageList 控件用于保存图像文件。关于 ImageList 控件的使用请参阅 131-3。</p>
<p>以大图标模式显示 ListView 控件的代码如下：</p>
<div><pre><code><span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	<span>Dim</span> ITM <span>As</span> ListItem
	<span>Dim</span> r <span>As</span> <span>Integer</span>
	<span>With</span> ListView1
		<span>.</span>View <span>=</span> lvwIcon
		<span>.</span>Icons <span>=</span> ImageList1
		<span>For</span> r <span>=</span> <span>2</span> <span>To</span> <span>6</span>
			<span>Set</span> ITM <span>=</span> <span>.</span>ListItems<span>.</span>Add<span>(</span><span>)</span>
			ITM<span>.</span>Text <span>=</span> Cells<span>(</span>r<span>,</span> <span>1</span><span>)</span>
			ITM<span>.</span>Icon <span>=</span> r <span>-</span> <span>1</span>
		<span>Next</span>
	<span>End</span> <span>With</span>
	<span>Set</span> ITM <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>代码解析：</p>
<p>在用户窗体中以大图标模式显示 ListView 控件，可使用鼠标拖放图标，并重新排列。</p>
<p>第 5 行代码将 ListView 控件的 View 属性设置为 lvwIcon，大图标视图模式。</p>
<p>第 6 行代码使用 ListView 控件的 Icons 属性建立与 ImageList 控件的关联。</p>
<p>第 7 行到第 11 行代码在 ListView 控件中添加 ListItem 对象，其中第 10 行代码设置使用 ListItem 对象的 Icon 属性指定其图像文件在 ImageList 控件中的编号。</p>
<p>ListView 控件以大图标视图模式显示时如图 131-6 所示。</p>
<div>
<p><img src="./assets/131-6.png" alt="" loading="lazy"></p>
<p><u>图 131-6</u>	大图标视图模式</p>
</div>
<p>以小图标模式显示 ListView 控件的代码如下：</p>
<div><pre><code><span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	<span>Dim</span> ITM <span>As</span> ListItem
	<span>Dim</span> r <span>As</span> <span>Integer</span>
	<span>With</span> ListView1
		<span>.</span>View <span>=</span> lvwSmallIcon
		<span>.</span>SmallIcons <span>=</span> ImageList1
		<span>For</span> r <span>=</span> <span>2</span> <span>To</span> <span>6</span>
			<span>Set</span> ITM <span>=</span> <span>.</span>ListItems<span>.</span>Add<span>(</span><span>)</span>
			ITM<span>.</span>Text <span>=</span> Sheet1<span>.</span>Cells<span>(</span>r<span>,</span> <span>1</span><span>)</span>
			ITM<span>.</span>SmallIcon <span>=</span> r <span>-</span> <span>1</span>
		<span>Next</span>
	<span>End</span> <span>With</span>
	<span>Set</span> ITM <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>代码解析：</p>
<p>在用户窗体中以小图标模式显示 ListView 控件，可使用鼠标拖放图标，并重新排列。</p>
<p>第 5 行代码将 ListView 控件的 View 属性设置为 lvwSmallIcon，小图标视图模式。</p>
<p>与大图标视图模式有所不同的是，当使用小图标视图模式时需要使用 ListView 控件的 SmallIcons 属性建立与 ImageList 控件的关联，使用 ListItem 对象的 SmallIcon 属性指定其图像文件在 ImageList 控件中的编号。</p>
<p>ListView 控件以小图标视图模式显示时如图 131-7 所示。</p>
<div>
<p><img src="./assets/131-7.png" alt="" loading="lazy"></p>
<p><u>图 131-7</u>	小图标视图模式</p>
</div>
<p>将 ListView 控件的 View 属性设置为 lvwList，以列表视图模式显示，如图 131-8 所示。</p>
<div>
<p><img src="./assets/131-8.png" alt="" loading="lazy"></p>
<p><u>图 131-8</u>	列表视图模式</p>
</div>
<p>将 ListView 控件的 View 属性设置为 lvwReport，以报表视图模式显示，如图 131-9 所示。</p>
<div>
<p><img src="./assets/131-9.png" alt="" loading="lazy"></p>
<p><u>图 131-9</u>	报表视图模式</p>
</div>
<h2 id="_132、调用非模式窗体"> 132、调用非模式窗体</h2>
<p>在 VBA 中显示用户窗体需要使用 Show 方法，Show 方法显示窗体对象，语法如下：</p>
<div><pre><code>[<span>object</span><span>.</span>]Show modal

参数<span>object</span>是可选的，对象表达式。如果省略掉<span>object</span>，则将与活动的窗体模块相关联的窗体当作<span>object</span>。
参数modal是可选的，决定窗体是模态的还是非模式的。Modal参数的设置值如表格 <span>132</span><span>-</span><span>1</span>所示。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><u>表格 132-1</u>	modal 参数的设置值</p>
<table>
<thead>
<tr>
<th>常数</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>vbModal</td>
<td>1</td>
<td>UserForm是模态的，缺省值。</td>
</tr>
<tr>
<td>vbModeless</td>
<td>0</td>
<td>UserForm是非模式的。</td>
</tr>
</tbody>
</table>
<p>当窗体显示时是模态时，用户在使用应用程序的其它部分之前，必须先对其作出响应。在隐藏或卸载窗体之前，后续代码不会被执行。</p>
<p>比如下面的代码，希望在显示窗体的同时给单元格赋值，但因为窗体显示为模态的，在窗体没有关闭之前，给单元格赋值的代码是不会执行的，所以达不到显示窗体的同时给单元格赋值的目的。</p>
<div><pre><code><span>Private</span> <span>Sub</span> CommandButton1_Click<span>(</span><span>)</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	Columns<span>(</span><span>1</span><span>)</span><span>.</span>ClearContents
	UserForm1<span>.</span>Show <span>0</span>
	<span>For</span> i <span>=</span> <span>1</span> <span>To</span> <span>1000</span>
		Cells<span>(</span>i<span>,</span> <span>1</span><span>)</span> <span>=</span> i
	<span>Next</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>只有在窗体显示为非模式时，后续代码才一出现即被执行。模态下是无法操作工作表的，所以应将第 4 行代码改成如下的代码，才能在显示窗体的同时给单元格赋值，如图 132-1 所示。</p>
<div><pre><code>UserForm1<span>.</span>Show <span>0</span>
</code></pre>
<div><span>1</span><br></div></div><div>
<p><img src="./assets/132-1.png" alt="" loading="lazy"></p>
<p><u>图 132-1</u>	调用非模式窗体</p>
</div>
<h2 id="_133、进度条的制作"> 133、进度条的制作</h2>
<p>如果程序执行时间较长，使用进度条能让用户知道程序执行到何种程度，大约需等待多长时间，可以使界面显得友好。</p>
<h3 id="_1-使用进度条控件"> 1）使用进度条控件</h3>
<p>使用窗体加进度条控件（ProgressBar）制作进度条是最常用的方法。</p>
<p>在 VBE 窗口中单击菜单“插入”→“用户窗体”，在窗体上添加一个进度条控件，调整为合适的大小，如图 133-1 所示。</p>
<div>
<p><img src="./assets/133-1.png" alt="" loading="lazy"></p>
<p><u>图 133-1</u>	使用ProgressBar控件</p>
</div>
<p>在工作表中添加一个命令按钮，双击后写入下面的代码。</p>
<div><pre><code><span>Private</span> <span>Sub</span> CommandButton1_Click<span>(</span><span>)</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	UserForm1<span>.</span>Show <span>0</span>
	<span>With</span> UserForm1<span>.</span>ProgressBar1
		<span>.</span>Min <span>=</span> <span>1</span>
		<span>.</span>Max <span>=</span> <span>10000</span>
		<span>.</span>Scrolling <span>=</span> <span>0</span>
		<span>For</span> i <span>=</span> <span>1</span> <span>To</span> <span>10000</span>
			Cells<span>(</span>i<span>,</span> <span>1</span><span>)</span> <span>=</span> i
			<span>.</span>Value <span>=</span> i
			UserForm1<span>.</span>Caption <span>=</span> <span>"正在运行,已完成"</span> <span>&amp;</span> i <span>/</span> <span>100</span> <span>&amp;</span> <span>"%,请稍候!"</span>
		<span>Next</span>
	<span>End</span> <span>With</span>
	Unload UserForm1
	Columns<span>(</span><span>1</span><span>)</span><span>.</span>ClearContents
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>代码解析：</p>
<p>工作表中命令按钮的单击事件，在给工作表 <code>A1:A10000</code> 单元格赋值的同时使用进度条显示其运行速度。</p>
<p>第 3 行代码，使用 Show 方法显示进度条控件所在的窗体，并且设置为无模式显示，请参阅 132 。</p>
<p>第 5、6 行代码，设置进度条控件的最小值和最大值，应与第 8 行代码中的循环计数器的 start 参数和 End 参数相一致。</p>
<p>第 7 行代码，设置进度条控件显示为有间隔的。如果将 Scrolling 属性设置为 1 则显示为无间隔的。</p>
<p>第 9 行代码，在单元格中进行无意义的填充数据以演示进度条。在实际应用中可以将进度条嵌入到程序的循环中。</p>
<p>第 11 行代码，在窗体的标题栏中显示已完成的百分比。</p>
<p>第 14 行代码，使用 Unload 语句卸载窗体。</p>
<p>Unload 语句从内存中删除一个对象，语法如下：</p>
<div><pre><code>Unload <span>object</span>

参数<span>object</span>参数是必需的，一个有效的对象。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>第 19 行代码，清空 A 列填充的数据。</p>
<p>单击工作表中的命令按钮，填充单元格并显示进度条，如图 133-2 所示。</p>
<div>
<p><img src="./assets/133-2.png" alt="" loading="lazy"></p>
<p><u>图 133-2</u>	ProgressBar 进度条</p>
</div>
<h3 id="_2-使用标签控件"> 2）使用标签控件</h3>
<p>在窗体中使用标签可以制作双色的进度条。</p>
<ul>
<li>
<p>步骤 1，在 VBE 窗口中单击菜单“插入”→“用户窗体”，在窗体上添加一个框架控件，在框架控件中添加两个标签控件。</p>
</li>
<li>
<p>步骤 2，在控件的属性窗口中将框架的 BackColor 属性设为 &amp;H000000FF&amp;，使框架的背景色为红色。将标签1 的 BackColor 属性设为 &amp;H0000C000&amp;，使标签1 的背景色为绿色。将标签2 的 BackStyle 属性设为 fmBackStyleTransparent，使标签2 的背景为透明，并把它们的 Caption 属性全部设置为空白。</p>
</li>
<li>
<p>步骤 3，将窗体和控件调整为合适的大小，如图 133-3 所示。</p>
</li>
</ul>
<div>
<p><img src="./assets/133-3.png" alt="" loading="lazy"></p>
<p><u>图 133-3</u>	制作标签进度条</p>
</div>
<ul>
<li>步骤 4，在 VBE 中双击窗体，写入下面的代码。</li>
</ul>
<div><pre><code><span>Private</span> <span>Declare</span> <span>Function</span> DrawMenuBar <span>Lib</span> <span>"user32"</span> <span>(</span><span>ByVal</span> Hwnd <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Declare</span> <span>Function</span> GetWindowLong <span>Lib</span> <span>"user32"</span> <span>Alias</span> <span>"GetWindowLongA"</span> <span>(</span><span>ByVal</span> Hwnd <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> nIndex <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Declare</span> <span>Function</span> SetWindowLong <span>Lib</span> <span>"user32"</span> <span>Alias</span> <span>"SetWindowLongA"</span> <span>(</span><span>ByVal</span> Hwnd <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> nIndex <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> dwNewLong <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Declare</span> <span>Function</span> FindWindow <span>Lib</span> <span>"user32"</span> <span>Alias</span> <span>"FindWindowA"</span> <span>(</span><span>ByVal</span> lpClassName <span>As</span> <span>String</span><span>,</span> <span>ByVal</span> lpWindowName <span>As</span> <span>String</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Const</span> GWL_STYLE <span>As</span> <span>Long</span> <span>=</span> <span>(</span><span>-</span><span>16</span><span>)</span>
<span>Private</span> <span>Const</span> GWL_EXSTYLE <span>=</span> <span>(</span><span>-</span><span>20</span><span>)</span>
<span>Private</span> <span>Const</span> WS_CAPTION <span>As</span> <span>Long</span> <span>=</span> <span>&amp;HC00000</span>
<span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	<span>Dim</span> IStyle <span>As</span> <span>Long</span>
	<span>Dim</span> Hwnd <span>As</span> <span>Long</span>
	<span>If</span> Val<span>(</span>Application<span>.</span>Version<span>)</span> <span>&lt;</span> <span>9</span> <span>Then</span>
		Hwnd <span>=</span> FindWindow<span>(</span><span>"ThunderXFrame"</span><span>,</span> <span>Me</span><span>.</span>Caption<span>)</span>
	<span>Else</span>
		Hwnd <span>=</span> FindWindow<span>(</span><span>"ThunderDFrame"</span><span>,</span> <span>Me</span><span>.</span>Caption<span>)</span>
	<span>End</span> <span>If</span>
	IStyle <span>=</span> GetWindowLong<span>(</span>Hwnd<span>,</span> GWL_STYLE<span>)</span>
	IStyle <span>=</span> IStyle <span>And</span> <span>Not</span> WS_CAPTION
	SetWindowLong Hwnd<span>,</span> GWL_STYLE<span>,</span> IStyle
	DrawMenuBar Hwnd
	UserForm1<span>.</span>Height <span>=</span> <span>28</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>代码解析：</p>
<p>窗体的初始化事件，在窗体加载时使用 API 函数去除其标题栏。</p>
<p>第 1 行到第 7 行代码，API 函数的声明。</p>
<p>第 11 行到第 15 行代码，获取窗口句柄。</p>
<p>第 16 行到第 19 行代码，去除窗体标题栏。</p>
<p>第 20 行代码，设置窗体的高度。</p>
<ul>
<li>步骤 5，在工作表中添加一个命令按钮，双击后写入下面的代码。</li>
</ul>
<div><pre><code><span>Private</span> <span>Sub</span> CommandButton1_Click<span>(</span><span>)</span>
	<span>Dim</span> n <span>As</span> <span>Integer</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	n <span>=</span> <span>10000</span>
	<span>With</span> UserForm1
		<span>.</span>Show <span>0</span>
		<span>For</span> i <span>=</span> <span>1</span> <span>To</span> n
			Cells<span>(</span>i<span>,</span> <span>1</span><span>)</span> <span>=</span> i
			<span>.</span>Label1<span>.</span>Width <span>=</span> i <span>/</span> n <span>*</span> <span>.</span>Frame1<span>.</span>Width
			<span>.</span>Label2<span>.</span>Caption <span>=</span> <span>"已完成"</span> <span>&amp;</span> Round<span>(</span>i <span>/</span> n <span>*</span> <span>100</span><span>,</span> <span>0</span><span>)</span> <span>&amp;</span> <span>"%"</span>
			<span>.</span>Label2<span>.</span>Left <span>=</span> <span>.</span>Label1<span>.</span>Width <span>-</span> <span>50</span>
			DoEvents
		<span>Next</span>
	<span>End</span> <span>With</span>
	Unload UserForm1
	Range<span>(</span><span>"A1:A"</span> <span>&amp;</span> n<span>)</span><span>.</span>ClearContents
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>代码解析：</p>
<p>工作表中命令按钮的单击事件，在给工作表 <code>A1:A10000</code> 单元格赋值的同时使用进度条显示其运行速度。</p>
<p>第 4 行代码，设置循环最大值，可根据实际需要设置。</p>
<p>第 6 行代码，使用 Show 方法显示窗体，并且设置为无模式的。</p>
<p>第 8 行代码，在单元格中进行无意义的填充数据以演示进度条。</p>
<p>第 9 行代码，根据程序运行程度动态设置标签1的宽度，使之达到进度条的效果。</p>
<p>第 10 行代码，标签2 显示已完成百分比。</p>
<p>第 11 行代码，根据标签1 的宽度动态设置标签2 的 Left 属性，使已完成百分比跟随标签1 移动。</p>
<p>第 12 行代码，使用 DoEvents 函数转让控制权。DoEvents 函数将控制权传给操作系统。当操作系统处理完队列中的事件，并且在 SendKeys 队列中的所有键也都已送出之后，返回控制权。如果不使用 DoEvents 函数转让控制权，进度条不能正常显示。</p>
<p>第 15 行代码，使用 Unload 语句卸载窗体。</p>
<p>单击工作表中的命令按钮，填充单元格并显示进度条，如图 133-4 所示。</p>
<div>
<p><img src="./assets/133-4.png" alt="" loading="lazy"></p>
<p><u>图 133-4</u>	标签进度条</p>
</div>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-07-02T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">linux压缩、解压缩命令</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_basic/07.linux_compress/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_basic/07.linux_compress/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="压缩文件介绍"> 压缩文件介绍</h2>
<p>在系统中，如果需要有大量的文件进行复制和保存，那么把它们打成压缩包是不错的选择。打包压缩作为常规操作，在 Windows 和 Linux 中都比较常见。Windows 中常见的压缩包格式主要有“.zip”、“.rar”和“.7z”等，但是你了解这些不同压缩格式的区别吗？其实，普通用户并不用理解这些压缩格式的算法有什么区别、压缩比有哪些不同，只要在碰到这些压缩包时会正确地解压缩，在想要压缩时可以正确地操作，目的就达到了。</p>
<p>在 Limux 中也是一样的，可以识别的常见压缩格式有十几种，比如 “.zip”、“.gz”、“.bz2”、“.tar”、“.tar.gz” 压缩等。我们也不需要知道这些压缩格式的具体区别，只要对应的压缩包会解压缩、想要压缩的时候会操作即可。</p>
<p>还有一件事，之前一直强调“Linux 不靠扩展名区分文件类型，而是靠权限”，那压缩包也不应该医分扩展名啊？为什么还要区分是“.gz”还是“.bz2”的扩展名呢？这是因为，在 Linux 中，不同的压缩方法对应的解压缩方法也是不同的，这里的扩展名并不是 Linux 系统一定需要的（Linux 不区分扩展名），而是用来给用户标识压缩格式的。只有知道了正确的压缩格式，才能采用正确的解压缩命令。</p>
<p>大家可以想象一下，如果你压缩了一个文件，起了一个名字“abc”，今天你知道这是一个压缩包，可以解压缩，那半年之后呢？而如果你将它命名为“etc_bak.tar.gz”，那无论什么时 候、无论哪个用户都知道这是<code>/etc/</code>目录的备份压缩包。所以压缩文件一定要严格区分扩展名，这不是系统必需的，而是用来让管理员区分文件类型的。</p>
<h2 id="zip-格式"> <code>.zip</code> 格式</h2>
<p>“.zip”是 Windows 中最常用的压缩格式，Linux 也可以正确识别“.zip”格式，这可以方便地和 Windows 系统通用压缩文件。</p>
<h3 id="压缩命令-zip"> 压缩命令 zip</h3>
<p>压缩命令就是 <strong><code>zip</code></strong>， 命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># zip [选项] 压缩包名 源文件或源目录</span>
选项：
	-r	：压缩目录
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>zip</code> 压缩命令需要手工指定压缩之后的压缩包名，注意写清楚扩展名，以方便解压缩时使用。举个例子：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># zip ana.zip anaconda-ks.cfg</span>
adding: anaconda-ks.cfg <span>(</span>deflated <span>37</span>%<span>)</span> 
<span>#压缩</span>
<span>[</span>root@localhost ~<span>]</span><span># ll ana.zip</span>
-rw-r--r-- <span>1</span> root root <span>935</span> <span>6</span>月 <span>17</span> <span>16</span>:00 ana.zip
<span>#压缩文件生成</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>所有的压缩命令都可以同时压缩多个文件，例如：</p>
<div><pre><code><span>[</span>rootelocalhost ~<span>]</span><span># zip test.zip install.log install.log.syslog</span>
adding: install.log <span>(</span>deflated <span>72</span>%<span>)</span>
adding: install.log.syslog <span>(</span>deflated <span>85</span>%<span>)</span>
<span>#同时压缩多个文件到 test.zip 压缩包中</span>
<span>[</span>root@localhost ~<span>]</span><span># ll test.zip</span>
-rw-r--r-- <span>1</span> root root <span>8368</span> <span>6</span>月 <span>17</span> <span>16</span>:03 test.zip
<span>#压缩文件生成</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>如果想要压缩目录，则需要使用“-r”选项，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mkdir dir1</span>
<span>#建立测试目录</span>
<span>[</span>root@localhost ~<span>]</span><span># zip -r dir1.zip dir1</span>
adding: dir1/<span>(</span>stored 0g<span>)</span>
<span>#压缩目录</span>
<span>[</span>root@localhost ~<span>]</span><span># ls -dl dir1.zip</span>
-rw-r--r-- <span>1</span> root root <span>160</span> <span>6</span>月 <span>17</span> <span>16</span>:22 dir1.zip
<span>#压缩文件生成 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="解压缩命令-unzip"> 解压缩命令 unzip</h3>
<p>“.zip”格式的解压缩命令是 <strong><code>unzip</code></strong>，命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># unzip [选项] 压缩包名</span>
选项：
	-d	：指定解压缩位置 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>不论是文件压缩包，还是目录压缩包，都可以直接解压缩，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># unzip dir1.zip</span>
Archive: dir1.zip creating: dir1/
<span>#解压缩</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>也可以手工指定解压缩位置，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># unzip -d /tmp/ ana.zip</span>
Archive： ana.zip inflating：/tmp/anaconda-ks.cfg
<span>#把压缩包解压到指定位置</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="gz-格式"> <code>.gz</code> 格式</h2>
<p>“.gz”格式是 Linux 中最常用的压缩格式。</p>
<h3 id="压缩命令-gzip"> 压缩命令 gzip</h3>
<p>使用 <strong><code>gzip</code></strong> 命令进行压缩，命令的格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># gzip [选项] 源文件</span>
选项：
	-c		：将压缩数据输出到标准输出中，可以用于保留源文件
    -d		：解压缩
    -r		：压缩目录
    -v		：显示压缩文件的信息
    -数字	：用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高。默认压缩比是 -6 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>
<li><strong>基本压缩</strong></li>
</ul>
<p><code>gzip</code> 压缩命令非常简单，甚至不需要指定压缩之后的压缩包名，只需指定源文件名即可。 我们来试试：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># gzip install.log</span>
<span>#压缩 install.log 文件</span>
<span>[</span>root@localhost ~<span>]</span><span># ls</span>
anaconda-ks.cfg install.log.gz install.log.syslog
<span>#压缩文件生成，但是源文件也消失了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li><strong>保留源文件压缩</strong></li>
</ul>
<p>在使用 <code>gzip</code> 命令压缩文件时，源文件会消失，从而生成压缩文件。这时有些人会有强迫症，就会问：能不能在压缩文件的时候，不让源文件消失？好吧，也是可以的，不过很别扭。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># gzip -c anaconda-ks.cfg > anaconda-ks.cfg.gz</span>
<span>#使用 -c 选项，但是不让压缩数据输出到屏幕上，而是重定向到压缩文件中</span>
<span>#这样可以在压缩文件的同时不删除源文件 </span>
<span>[</span>root@localhost ~<span>]</span><span># ls</span>
<span>#可以看到压缩文件和源文件都存在 anaconda-ks.cfg anaconda-ks.cfg.gz install.log.gz install.log.syslog</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li><strong>压缩目录</strong></li>
</ul>
<p>我们可能会想当然地认为 <code>gzip</code> 命令可以压缩目录。（其实是分别压缩目录里的所有文件）我们来试试：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mkdir test</span>
<span>[</span>root@localhost ~<span>]</span><span># touch test/test1</span>
<span>[</span>root@localhost ~<span>]</span><span># touch test/test2</span>
<span>[</span>root@localhost ~<span>]</span><span># touch test/test3</span>
<span>#建立测试目录，并在里面建立几个测试文件</span>
<span>[</span>root@localhost ~<span>]</span><span># gzip -r test/</span>
<span>#压缩目录，并没有报错</span>
<span>[</span>root@localhost ~<span>]</span><span># ls</span>
anaconda-ks.cfg anaconda-ks.cfg.gz install.log.gz install.log.syslog <span>test</span>
<span>#但是查看发现 test 目录依然存在，并没有变为压缩文件</span>
<span>[</span>root@localhost ~<span>]</span><span># ls test/</span>
test1.gz test2.gz test3.gz
<span>#原来 gzip 命令不会打包目录，而是把目录下所有的子文件分别压缩</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><strong>在 Linux 中，打包和压缩是分开处理的。而 <code>gzip</code> 命令只会压缩，不能打包，所以才会出现没有打包目录，而只把目录下的文件进行压缩的情况。</strong></p>
<h3 id="解压缩命令-gunzip-或-gzip-d"> 解压缩命令 gunzip 或 gzip -d</h3>
<p>如果要解压缩“.gz”格式，那么使用 <strong><code>gzip -d 压缩包</code></strong> 和 <strong><code>gunzip 压缩包</code></strong> 命令都可以。</p>
<ul>
<li><strong><code>gunzip</code> 命令</strong>，格式如下：</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># gunzip [选项] 压缩文件</span>
选项：
	-r	：解压缩目录
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>常规用法就是直接解压缩文件，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># gunzip install.log.gz</span>
</code></pre>
<div><span>1</span><br></div></div><p>如果要解压缩目录下的内容，则依然使用“-r”选项，例如：</p>
<div><pre><code><span>[</span>root@Localhost ~<span>]</span><span># gunzip -r test/ </span>
</code></pre>
<div><span>1</span><br></div></div><p>当然，<code>gunzip -r</code>依然只会解压缩目录下的文件，而不会解打包。</p>
<ul>
<li><strong><code>gzip -d</code> 命令</strong>，例如：</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># gzip -d anaconda-ks.cfg.gz</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="查看压缩的文本文件内容-zcat"> 查看压缩的文本文件内容 zcat</h3>
<p>如果我们压缩的是一个纯文本文件，则可以直接使用 <strong><code>zcat</code></strong> 命令在不解压缩的情况下查看这个文本文件中的内容。其命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># zcat 压缩文件</span>
</code></pre>
<div><span>1</span><br></div></div><p>例如：</p>
<div><pre><code><span>[</span>root@Localhost ~<span>]</span><span># zcat anaconda-ks.cfg.gz</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="bz2-格式"> <code>.bz2</code> 格式</h2>
<p>“.bz2”格式是 Linux 的另一种压缩格式，从理论上来讲，“.bz2”格式的算法更先进、压 缩比更好；而“.gz”格式相对来讲压缩的时间更快。</p>
<h3 id="压缩命令-bzip2"> 压缩命令 bzip2</h3>
<p>“.bz2”格式的压缩命令是 <strong><code>bzip2</code></strong>，命令的格式：</p>
<div><pre><code><span>[</span>root@Localhost ~<span>]</span><span># bzip2 [选项] 源文件</span>
选项：
	-d		：解压缩
    -k		：压缩时，保留源文件
    -v		：显示压缩的详细信息
    -数字	：这个参数和 <span>gzip</span> 命令的作用一样，用于指定压缩等级，-1 压缩等级最低， 压缩比最差；-9 压缩比最高
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>大家注意，<code>gzip</code> 只是不会打包目录，但是如果使用“-r”选项，则可以分别压缩目录下的每个文件；而 <code>bzip2</code> 命令则根本不支持压缩目录，也没有“-r”选项。</p>
<ul>
<li><strong>基本压缩命令</strong></li>
</ul>
<p>在压缩文件命令后面直接指定源文件即可，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># bzip2 anaconda-ks.cfg</span>
<span>#压缩成“.bz2”格式 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这个压缩命令依然会在压缩的同时删除源文件。</p>
<ul>
<li><strong>压缩的同时保留源文件</strong></li>
</ul>
<p><code>bzip2</code> 命令可以直接使用“-k”选项来保留源文件，而不用像 <code>gzip</code> 命令一样使用输出重定向来保留源文件。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># bzip2 -k install.log.syslog</span>
<span>#压缩</span>
<span>[</span>root@localhost ~<span>]</span><span># ls</span>
anaconda-ks.cfg.bz2 install.log install.log.syslog install.log.syslog.bz2
<span>#压缩文件和源文件都存在 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="解压缩命令-bunzip2-或-bzip2-d"> 解压缩命令 bunzip2 或 bzip2 -d</h3>
<p>“.bz2”格式可以使用 <strong><code>bzip2 -d 压缩包</code></strong> 命令来进行解压缩，也可以使用 <strong><code>bunzip2 压缩包</code></strong> 命令来进行解压缩。</p>
<ul>
<li><strong><code>bunzip2</code> 命令</strong>，格式如下：</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># bunzip2 [选项] 源文件</span>
选项：
	-k	：解压缩时，保留源文件 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>先试试使用 <code>bunzip2</code> 命令来进行解压缩，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># bunzip2 anaconda-ks.cfg.bz2</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li><strong><code>bzip2 -d 压缩包</code> 命令</strong>，例如：</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># bzip2 -d install.log.syslog.bz2</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="查看压缩的文本文件内容-bzcat"> 查看压缩的文本文件内容 bzcat</h3>
<p>和“.gz”格式一样，“.bz2”格式压缩的纯文本文件也可以不解压缩直接查看，使用的命令是 <strong><code>bzcat</code></strong>。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># bzcat install.log.syslog.bz2</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="xz-格式"> <code>.xz</code> 格式</h2>
<p>“.xz”格式是一个压缩率非常高的压缩格式，<code>xz</code> 命令是绝大数 Linux 默认就带的一个压缩工具，压缩率很高。只能压缩文件，不能压缩目录。现在大部分的系统镜像文件都是用此格式压缩。</p>
<h3 id="压缩命令-xz"> 压缩命令 xz</h3>
<p>“.xz”格式的压缩命令是 <strong><code>xz</code></strong>，命令的格式：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># xz [选项] 文件名</span>
选项：
	-d		：解压缩
	-k		：压缩时保留源文件
	-t		：测试压缩文件的完整性
	-数字	：指定压缩比。默认是6，数字越大压缩比就越大（1-9）
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>例子：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cd /tmp/</span>
<span>[</span>root@localhost tmp<span>]</span><span># cp /var/log/messages ./</span>
<span>#复制 /var/log/messages 文件到当前 /tmp/ 目录下</span>
<span>[</span>root@localhost tmp<span>]</span><span># xz messages</span>
<span># xz 命令压缩 messages 文件</span>
<span>[</span>root@localhost tmp<span>]</span><span># ll -h</span>
total <span>4</span>.0K
-rw------- <span>1</span> root root <span>3</span>.6K Feb <span>25</span> <span>17</span>:00 messages.xz
<span>#生成压缩文件 messages.xz</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>再比如：</p>
<div><pre><code><span>[</span>root@localhost tmp<span>]</span><span># xz -k messages</span>
<span># xz -k 命令压缩 messages 文件</span>
<span>[</span>root@localhost tmp<span>]</span><span># ll -h</span>
total 100K
-rw------- <span>1</span> root root  95K Feb <span>25</span> <span>17</span>:00 messages
-rw------- <span>1</span> root root <span>3</span>.6K Feb <span>25</span> <span>17</span>:00 messages.xz
<span>#生成压缩文件 messages.xz，且源文件仍存在</span>
<span># 95K大小的文件，压缩后仅有3.6K，压缩高的不敢相信，但这是真的</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="解压缩命令-xz-d"> 解压缩命令 xz -d</h3>
<p>“.xz”格式的解压缩没有单独的命令，还是 <strong><code>xz</code></strong>，命令的格式：<code>xz -d 压缩文件</code>，看个例子：</p>
<div><pre><code><span>[</span>root@localhost tmp<span>]</span><span># xz -d messages.xz </span>
<span># xz -d 解压缩</span>
<span>[</span>root@localhost tmp<span>]</span><span># ll -h</span>
total 96K
-rw------- <span>1</span> root root 95K Feb <span>25</span> <span>17</span>:00 messages
<span>#xz 解压后，直接删除原压缩文件</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="tar-格式"> <code>.tar</code> 格式</h2>
<p>通过前面的学习，我们发现，不论是 <code>gzip</code> 命令还是 <code>bzip2</code> 命令，好像都比较笨，<code>gzip</code> 命令不能打包目录，而只能单独压缩目录下的子文件；<code>bzip2</code> 命令干脆就不支持目录的压缩。 在 Limux 中，对打包和压缩是区别对待的。也就是说，在 Linux 中，如果想把多个文件或 目录打包到一个文件包中，则使用的是 <code>tar</code> 命令；而压缩才使用 <code>gzip</code> 或 <code>bzip2</code> 命令。</p>
<h3 id="打包命令-tar-cvf"> 打包命令 tar -cvf</h3>
<p>“.tar”格式的打包和解打包都使用 <strong><code>tar</code></strong> 命令，区别只是选项不同。我们先看看 <code>tar</code> 命令的格式：</p>
<div><pre><code><span>[</span>root@localhost tmp<span>]</span><span># tar [选项] [-f 压缩包名] 源文件或目录</span>
选项：
	-c	：打包
	-f	：指定压缩包的文件名。建议一定要指定正确的指定扩展名。
    -v	：显示打包文件过程
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li><strong>基本用法</strong></li>
</ul>
<p>我们先打包一个文件练练手。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># tar -cvf anaconda-ks.cfg.tar anaconda-ks.cfg</span>
<span>#把 anaconda-ks.ctg 打包为 anaconda-ks.cfg.tar 文件包</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>选项“-cvf”一般是习惯用法，记住打包时需要指定打包之后的文件名，而且要用“.tar” 作为扩展名。那打包目录呢？我们也试试：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ll -d test/</span>
drwxr-xr-x <span>2</span> root root <span>4096</span> <span>6</span>月 <span>17</span> <span>21</span>:09 test/
<span>#test 是我们之前的测试目录</span>
<span>[</span>root@localhost ~<span>]</span><span># tar -cvf test.tar test/</span>
test/
test/test3
test/test2
test/testl
<span>#把目录打包为 test.tar 文件包</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><code>tar</code> 命令也可以打包多个文件或目录，只要用空格分开即可。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># tar -cvf ana.tar anaconda-ks.cfg /tmp/</span>
<span>#把 anaconda-ks.cfg 文件和 /tmp 目录打包成 ana.tar 文件包 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li><strong>打包压缩目录</strong></li>
</ul>
<p>我们已经解释过了，压缩命令不能直接压缩目录，我们就先用 <code>tar</code> 命令把目录打成数据包，然后再用 <code>gzip</code> 命令或 <code>bzip2</code> 命令压缩。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ll -d test test.tar</span>
drwxr-xr-x <span>2</span> root root <span>4096</span> <span>6</span>月 <span>17</span> <span>21</span>:09 <span>test</span>
-rw-r--r-- <span>1</span> root root <span>10240</span> <span>6</span>月 <span>18</span> 01:06 test.tar
<span>#我们之前已经把 test 目录打包成 test.tar 文件包</span>
<span>[</span>root@localhost ~<span>]</span><span># gzip test.tar</span>
<span>[</span>root@localhost ~<span>]</span><span># ll test.tar.gz</span>
-rw-r--r-- <span>1</span> root root <span>176</span> <span>6</span>月 <span>18</span> 01:06 test.tar.gz
<span># gzip 命令会把 test.tar 压缩成 test.tar.gz</span>
<span>[</span>root@localhost ~<span>]</span><span># gzip -d test.tar.gz</span>
<span>#解压缩，把 test.tar.gz 解压为 test.tar</span>
<span>[</span>root@localhost ~<span>]</span><span># bzip2 test.tar</span>
<span>[</span>root@localhost ~<span>]</span><span># ll test.tar.bz2</span>
-rw-r--r-- <span>1</span> root root <span>164</span> <span>6</span>月 <span>18</span> 01:06 teat.tar.bz2
<span>#bzip2命令会把 test.tar 压缩为 test.tar.bz2 格式 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="解打包命令-tar-xvf"> 解打包命令 tar -xvf</h3>
<p>“.tar”格式的解打包也需要使用 <strong><code>tar</code></strong> 命令，但是选项不太一样。命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># tar [选项] 压缩包</span>
选项：
	-x		：解打包
    -f		：指定压缩包的文件名
    -v		：显示解打包文件过程
    -t		：测试，不是解打包，只是查看包中有哪些文件
    -C 目录	：指定解打包位置
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>其实解打包和打包相比，只是把打包选项“-cvf”更换为“-xvf”。我们来试试：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># tar -xvf anaconda-ks.cfg.tar</span>
<span>#解打包到当前目录下</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果使用“-xvf”选项，则会把包中的文件解压到当前目录下。如果想要指定解压位置，则需要使用“-C（大写）”选项。例如：</p>
<div><pre><code><span>[</span>root@localhost ~1<span># tar -xvf test.tar -C /tmp</span>
<span>#把文件包 test.tar 解打包到 /tmp/ 目录下 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果只想查看文件包中有哪些文件，则可以把解打包选项“-x”更换为测试选项“-t”。例如：</p>
<div><pre><code><span>[</span>root@localhost -<span>]</span><span># tar -tvf test.tar</span>
drwxr-xr-x root/root <span>0</span> <span>2016</span>-06-17 <span>21</span>:09 test/
-rw-r--r-- root/root <span>0</span> <span>2016</span>-06-17 <span>17</span>:51 test/test3
-rw-r--r-- root/root <span>0</span> <span>2016</span>-06-17 <span>17</span>:51 test/test2
_rw-r--r-- root/root <span>0</span> <span>2016</span>-06-17 <span>17</span>:51 test/testi 
<span>#会用长格式显示 test.tar 文得包中文件的详網信息</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="tar-gz-、-tar-bz2-、-tar-xz-格式"> <code>.tar.gz</code> 、 <code>.tar.bz2</code> 、<code>.tar.xz</code> 格式</h2>
<p>你可能会觉得 Linux 实在太不智能了，一个打包压缩，居然还要先打包成“.tar”格式，再压缩成“.tar.gz”或“.tar.bz2”格式。其实 <code>tar</code>命令是可以同时打包压缩的，前面的讲解之所以把打包和压缩分开，是为了让大家了解在 Linux 中打包和压缩的不同。</p>
<p>使用 <code>tar</code> 命令直接打包压缩。命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost -<span>]</span><span># tar [选项] 压缩包 源文件或目录</span>
选项：
	-z	：压缩和解压缩 “.tar.gz” 格式
	-j	：压缩和解压缩 “.tar.bz2” 格式
	-J	：压缩和解压缩 “.tar.xz” 格式
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="压缩与解压缩-tar-gz-格式"> 压缩与解压缩 <code>.tar.gz</code> 格式</h3>
<p>我们先来看看如何压缩“.tar.gz”格式。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># tar -zcvf tmp.tar.gz /tmp/</span>
<span>#把 /tmp/ 目录直接打包压缩为“.tar.gz”格式，通过“-z”来识别格式，“-cvf”和打包选项一致</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>解压缩也只是在解打包选项“-xvf”前面加了一个“-z”选项。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># tar -zxvf tmp.tar.gz</span>
<span>#解压缩与解打包“.tar.gz”格式</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>前面讲的选项“-C”用于指定解压位置、“-t”用于查看压缩包内容，在这里同样适用。</p>
<h3 id="压缩与解压缩-tar-bz2-格式"> 压缩与解压缩 <code>.tar.bz2</code> 格式</h3>
<p>和“.tar.gz”格式唯一的不同就是“-z”选项换成了“-j”。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># tar -jcvf tmp.tar.bz2 /tmp/</span>
<span>#打包压缩为“.tar.bz2”格式，注意压缩包文件名</span>
<span>[</span>root@localhost ~<span>]</span><span># tar -jxvf tmp.tar.bz2</span>
<span>#解压缩与解打包“.tar.bz2”格式</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="压缩与解压缩-tar-xz-格式"> 压缩与解压缩 <code>.tar.xz</code> 格式</h3>
<p>和“.tar.gz”格式唯一的不同就是“-z”选项换成了“-J”（大写的 J ，与“.tar.bz2”的小写的 j 不要混淆）。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># tar -Jcvf tmp.tar.xz /tmp/</span>
<span>#打包压缩为“.tar.xz”格式，注意压缩包文件名</span>
<span>[</span>root@localhost ~<span>]</span><span># tar -Jxvf tmp.tar.xz</span>
<span>#解压缩与解打包“.tar.bz2”格式</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>把文件直接压缩成“.tar.gz”、“.tar.bz2”和“.tar.xz”格式，才是 Linux 中最常用的压缩方式，这是大家一定要掌握的压缩和解压缩方法。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-05-06T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">linux搜索命令</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_basic/06.linux_search/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_basic/06.linux_search/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>Linux 拥有强大的搜索功能，但是强大带来的缺点是相对比较复杂。但是大家不用担心，搜索命令只是选项较多，不容易记忆而已，并不难理解。</p>
<p>在使用搜索命令的时候，大家还是需要注意，如果搜索的范围过大、搜索的内容过多，则会给系统造成巨大的压力，所以不要在服务器访问的高峰执行大范围的搜索命令。</p>
<h2 id="whereis-命令"> whereis 命令</h2>
<p><code>whereis</code> 命令，用于搜索系统命令，也就是说，<code>whereis</code> 命令不能搜索普通文件，而只能搜索系统命令。</p>
<p><code>whereis</code> 命令不仅可以搜索二进制命令，还可以找到命令的帮助文档的位置。</p>
<p>英文原意：locate the binary, source, and manual page files for a command</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># where [选项] 系统命令</span>
选项：
	-b	：只查找二进制命令
	-m	：只查找帮助文档
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>常见用法：</p>
<p><code>whereis</code> 命令的使用比较简单，我们来试试，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># whereis ls</span>
ls：/bin/ls /usr/share/man/man1/ls.1.gz /usr/share/man/man1p/ls.1p.gz 
<span>#既可以看到二进制命令的位置，也可以看到帮助文档的位置</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>但是，如果使用 <code>whereis</code> 命令查看普通文件，则无法查找到。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># touch cangls</span>
<span>[</span>root@localhost ~<span>]</span><span># whereis cangls</span>
cangls:
<span>#无法查找到普通文件的信息</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果需要查找普通文件的内容，则需要使用 <code>find</code> 命令，我们稍后会详细讲解 <code>find</code> 命令。</p>
<p>再看一下 <code>whereis</code> 命令的选项。如果我们只想查看二进制命令的位置，则可以使用“-b” 选项；而如果我们只想查看帮助文档的位置，则可以使用“-m”选项。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># whereis -b ls</span>
ls：/bin/ls
<span>#只查看二进制命令的位置</span>
<span>[</span>root@localhost ~<span>]</span><span># whereis -m ls</span>
ls：/usr/share/man/man1/ls.1.gz /usr/share/man/man1p/ls.1p.gz
<span>#只查看帮助文档的位置</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="which-命令"> which 命令</h2>
<p><code>which</code> 命令，也是用于搜索系统命令。</p>
<p>和 <code>whereis</code> 命令的区别在于，<code>whereis</code> 命令可以在查找到二进制命令的同时，查找到帮助文档的位置；而 <code>which</code> 命令在查找到二进制命令的同时，如果这个命令有别名，则还可以找到别名命令。</p>
<p>英文原意：shows the full path of (shell) commands</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># which 系统命令</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>which</code> 命令非常简单，可用选项也不多，我们直接举个例子：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># which ls</span>
<span>alias</span> <span>ls</span><span>=</span><span>'ls --color=auto'</span>
/bin/ls
<span>#which 命令可以查找到命令的别名和命令所在的位置</span>
<span>#alias这段就是别名，别名就是小名，也就是说，当我们输入 ls 命令时，实际上执行的是 ls --color=auto</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="locate-命令"> locate 命令</h2>
<p><code>locate</code> 命令，按照文件名搜索普通文件。</p>
<p>英文原意：find files by name</p>
<p><code>whereis</code> 和 <code>which</code> 都是只能搜索系统命令的命令，而 <code>locate</code> 命令才是可以按照文件名搜索普通文件的命令。</p>
<p>但是 <code>locate</code> 命令的局限也很明显，它只能按照文件名来搜索文件，而不能执行更复杂的搜索，比如按照权限、大小、修改时间等搜索文件。如果要按照复杂条件执行搜索，则只能求助于功能更加强大的 <code>find</code> 命令。<code>locate</code> 命令的优点也非常明显，那就是搜索速度非常快，而且耗费系统资源非常小。这是因为 <code>locate</code> 命令不会直接搜索硬盘空间，而会先建立 <code>locate</code> 数据库，然后在数据库中按照文件名进行搜索，是快速的搜索命令。</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># locate [选项] 文件名</span>
选项：
	-i	：忽略大小写
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ol>
<li><strong>基本用法</strong></li>
</ol>
<p>搜索 Linux 的安装日志。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># locate install.log</span>
/root/install.log
/root/install.log.syslog
<span>#搜索文件名叫包含 install.log 的文件 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>系统命令其实也是文件，也可以按照文件名来搜索系统命令。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># locate mkdir</span>
/bin/mkdir
/usr/bin/gnomevfs-mkdir 
/usr/lib/per15/auto/POSIX/mkdir.al 
<span>..</span>.省略部分内容<span>..</span>. 
<span>#会搜索出所有含有 mkdir 字符串的文件名，当然也包含 mkdir 命令</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ol start="2">
<li><strong>locate 命令的数据库</strong></li>
</ol>
<p>我们在使用 <code>locate</code> 命令的时候，可能会发现一个问题：如果我们新建立一个文件，那么 <code>locate</code> 命令找不到这个文件。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># touch cangls</span>
<span>[</span>root@localhost ~<span>]</span><span># locate cangls</span>
<span>#新建立的文件，locate 命令找不到 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这是因为 <code>locate</code> 命令不会直接搜索硬盘空间，而会搜索 <code>locate</code> 数据库。这样做的好处是耗费系统资源小、搜索速度快；缺点是数据库不是实时更新的，而要等用户退出登录或重启系统时，<code>locate</code> 数据库才会更新，所以我们无法查找到新建立的文件。 既然如此，<code>locate</code> 命令的数据库在哪里呢？</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ll /var/lib/mlocate/mlocate.db</span>
-rw-r----- <span>1</span> root <span>slocate</span> <span>2328027</span> <span>6</span>月 <span>14</span> 02:08 /var/lib/mlocate/mlocate.db
<span>#这是 locate 命令实际搜索的数据库的位置</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这个数据库是二进制文件，不能直接使用 <code>Vim</code> 等编辑器查看，而只能使用对应的 <code>locate</code> 命令进行搜索。如果我们不想退出登录或重启系统，则也可以通过 <code>updatedb</code> 命令来手工更新这个数据。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># locate cangls</span>
<span>#没有更新数据库时，找不到 cangls 文件</span>
<span>[</span>root@localhost ~<span>]</span><span># updatedb</span>
<span>#更新数据库</span>
<span>[</span>root@localhost ~<span>]</span><span># locate cangls</span>
/root/cangls
<span>#新建立的文件已经可以搜索到了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ol start="3">
<li><strong>locate 配置文件</strong></li>
</ol>
<p>我们再做一个实验，看看这是什么原因导致的。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># touch /tmp/lmls</span>
<span>#在/tmp/目录下新建立一个文件</span>
<span>[</span>root@localhost ~<span>]</span><span># updatedb</span>
<span>#更新 locate 数据库</span>
<span>[</span>root@localhost ~<span>]</span><span># locate lmls</span>
<span>#依然查询不到 lmls 这个新建文件</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>新建立了 <code>/mp/lmls</code> 文件，而且也执行了 <code>updatedb</code> 命令，却依然无法找到这个文件，这是什么原因？这就要来看看 <code>locate</code> 的配置文件 <code>/etc/updatedb.conf</code> 了。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vi /etc/updatedb.conf</span>
PRUNE_BIND_MOUNTS <span>=</span><span>"yes"</span>
<span>#开启搜索限制，也就是让这个配置文件生效</span>
PRUNEFS <span>=</span><span>"9p afs anon_inodefs auto autofs bdev binfmt_misc cgroup cifs coda configts cpuset debugfs devpts ecryptfs exofs fuse fusectl gis gfs2 hugetibrs inotifyfs iso9660 jffs2 lustre mqueue nepfs nfs nfs4 nfsd pipefs proc ramfs rootta rpc_pipefs securityfs selinuxfs sfs sockfs sysfs tmpfs ubifs udf usbfs"</span>
<span>#在 locate 执行搜索时，禁止搜索这些文件系统类型</span>
PRUNENAMES <span>=</span><span>".git .hg . svn"</span>
<span>#在 locate 执行搜索时，禁止搜索带有这些扩展名的文件</span>
PRUNEPATHS <span>=</span><span>"/afs /media /net /sfs /tmp /udev /var/cache/ccache /var/spool/cupg /var/spool/squid /var/tmp"</span>
<span>#在 locate 执行搜索时，禁止搜索这些系统目录</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>在 <code>locate</code> 执行搜索时，系统认为某些文件系统、某些文件类型和某些目录是没有搜索必要的，比如光盘、网盘、临时目录等，这些内容要么不在 Linux 系统中（外来存储和网络存储），要么是系统的缓存和临时文件。刚好 <code>/tmp</code> 目录也在 <code>locate</code> 搜索的排除目录当中，所以在 <code>/tmp</code> 目录下新建的文件是无法被找到的。</p>
<h2 id="find-命令"> find 命令</h2>
<p><code>find</code> 命令，是 Linux 中强大的搜索命令。</p>
<p><code>find</code> 不仅可以按照文件名搜索文件，还可以按照权限、大小、时间、inode号等来搜索文件。但是 <code>find</code> 命令是直接在硬盘中进行搜索的，如果指定的搜索范围过大，<code>find</code> 命令就会消耗较大的系统资源，导致服务器压力过大。所以，在使用 <code>find</code> 命令搜索时，不要指定过大的搜索范围。</p>
<p>英文原意：search for files in a directory hierarchy</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># find 搜索路径 [选项] 搜索内容</span>
选项：
	按照文件名搜索
		-name	：按照文件名搜索
		-iname	：按照文件名搜索，不区分文件名大小写
		-inum	：按照 inode 号搜索
	按照文件大小搜索
		-size <span>[</span>+<span>|</span>-<span>]</span>大小	：按照指定大小搜索文件
						这里的“+”的意思是搜索比指定大小还要大的文件；
						这里的“-”的意思是搜索比指定大小还要 小的文件。
	按照修改时间搜索		
		-atime <span>[</span>+<span>|</span>-<span>]</span>时间	：按照文件访问时间搜索
    	-mtime <span>[</span>+<span>|</span>-<span>]</span>时间	：按照文件数据修改时间搜索
    	-ctime <span>[</span>+<span>|</span>-<span>]</span>时间	：按照文件状态修改时间搜索
    按照权限搜索
    	-perm 权限模式	：查找文件权限刚好等于“权限模式”的文件
    	-perm -权限模式	：查找文件权限全部包含“权限模式”的文件
    	-perm +权服模式	：查找文件权限包含“权限模式”的任意一个权限的文件
    按照所有者和所属组搜索	
 		-uid 用户ID		：按照用户 ID 查找所有者是指定 ID 的文件
		-gid 组ID		：按照用户组 ID 查找所属组是指定 ID 的文件
		-user 用户名		：按照用户名查找所有者是指定用户的文件
		-group 组名		：按照组名查找所属组是指定用户组的文件
		-nouser			：查找没有所有者的文件    	
    按照文件类型搜索
    	-type d	：查找目录
		-type f	：查找普通文件
		-type l	：查找软链接文件
	逻辑运算符
		-a		：and 逻辑与
    	-o		：or 逻辑或
    	-not	：not 逻辑非
    其他选项	
    	-exec
    	-ok
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><p><code>find</code> 是比较特殊的命令，它有两个参数：第一个参数用来指定搜索路径；第二个参数用来指定搜索内容。而且 <code>find</code> 命令的选项比较复杂，我们分类来看。</p>
<h3 id="按照文件名搜索"> 按照文件名搜索</h3>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># find 搜索路径 [选项] 搜索内容</span>
选项：
	-name	：按照文件名搜索
	-iname	：按照文件名搜索，不区分文件名大小写
	-inum	：按照 inode 号搜索
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这是 <code>find</code> 最常用的用法，我们来试试：</p>
<div><pre><code><span>[</span>rootelocalhost ~<span>]</span><span># find / -name yum.conf</span>
/etc/yum.conf
<span>#在 /目录下查找文件名是 yum.conf 的文件</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>但是 <code>find</code> 命令有一个小特性，就是搜索的文件名必须和你的搜索内容一致才能找到。如果只包含搜索内容，则不会找到。我们做一个实验：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># touch yum.conf.bak</span>
<span>#在 /root/ 目录下建立一个文件 yum.conf.bak</span>
<span>[</span>root@localhost ~<span>]</span><span># find / -name yum.conf</span>
/etc/yum.conf
<span>#搜索只能找到 yum.conf 文件，而不能找到 yum.conf.bak 文件 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>find</code> 能够找到的是只有和搜索内容 yum.conf 一致的 <code>/etc/yum.conf</code> 文件，而  <code>/tootyum.conf.bak</code> 文件虽然含有搜索关键字，但是不会被找到。这种特性我们总结为：<strong><code>find</code> 命令是完全匹配的，必须和搜索关键字一模一样才会列出。</strong></p>
<p>Linux 中的文件名是区分大小写的，也就是说，搜索小写文件，是找不到大写文件的。如果想要大小通吃，就要使用 -iname 来搜索文件。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># touch CANGLS</span>
<span>[</span>root@localhost ~<span>]</span><span># touch cangls</span>
<span>#建立大写和小写文件</span>
<span>[</span>root@localhost ~<span>]</span><span># find . -iname cangls</span>
./CANGLS ./cangls
<span>#使用 -iname，大小写文件通吃</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>每个文件都有 inode 号，如果我们知道 inode 号，则也可以按照 inode 号来搜索文件。</p>
<div><pre><code><span>[</span>root@localhost ^<span>]</span><span># ls -i install.log</span>
<span>262147</span> install.log
<span>#如果知道文件名，则可以用"1s -i"来查找 inode 号</span>
<span>[</span>root@localhost ~<span>]</span><span># find . -inum 262147</span>
./install.log
<span>#如果知道 inode 号，则可以用 find 命令来查找文件名</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>按照 inode 号搜索文件，也是区分硬链接文件的重要手段，因为硬链接文件的 inode 号是一致的。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ln /root/install.log /tmp/</span>
<span>#给 install.log 文件创建一个硬链接文件</span>
<span>[</span>root@localhost ~<span>]</span><span># ll -i /root/install.log /tmp/install.log</span>
<span>262147</span> -rw-r--r--. <span>2</span> root root <span>24772</span> <span>1</span>月 <span>14</span> <span>2014</span> /root/install.log
<span>262147</span> -rw-r--r--. <span>2</span> root root <span>24772</span> <span>1</span>月 <span>14</span> <span>2014</span> /tmp/install.log
<span>#可以看到这两个硬链接文件的 inode 号是一致的</span>
<span>[</span>root@localhost ~<span>]</span><span># find / -inum 262147</span>
/root/install.log
/tmp/install.log 
<span>#如果硬链接不是我们自己建立的，则可以通过 find 命令搜索 inode 号，来确定硬链接文件 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="按照文件大小搜索"> 按照文件大小搜索</h3>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># find 搜索路径 [选项] 搜索内容 </span>
选项：
	-size <span>[</span>+<span>|</span>-<span>]</span>大小	：按照指定大小搜索文件
	
			这里的“+”的意思是搜索比指定大小还要大的文件；
			这里的“-”的意思是搜索比指定大小还要 小的文件。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>我们来试试：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ll -h install.log</span>
-rw-r--r--. <span>1</span> root root 25K <span>1</span>月 <span>14</span> <span>2014</span> install.log
<span>#在当前目录下有一个大小是 25KB 的文件</span>
<span>[</span>root@localhost ~<span>]</span><span># find . -size 25k</span>
./install.log
<span>#在当前目录下，查找大小刚好是 25KB 的文件，可以找到</span>
<span>[</span>root@localhost ~<span>]</span><span># find . -size -25k</span>
<span>.</span>
./.bashrc
./.viminfo
./.tcshrc
<span>..</span>.省略部分输出<span>..</span>.
./install.log.syslog
./.cshrc
./cangls
<span>#搜索小于 25KB 的文件，可以找到很多文件</span>
<span>[</span>root@localhost ~<span>]</span><span># find . -size +25k</span>
<span>#而当前目录下没有大于 25KB 的文件</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>其实 <code>find</code> 命令的 -size 选项是比较恶心的选项，为什么这样说？find 命令可以按照 KB 来搜索，应该也可以按照 MB 来搜索吧。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># find . -size -25m</span>
find：无效的 -size 类型“m”
<span>#为什么会报错呢？其实是因为如果接照 MB 来搜索，则必须是大写的 M </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这就是纠结点，<strong>千字节必须是小写的“k”，而兆字节必须是大写的“M”</strong>。有些人会说： “你别那么执着啊，你就不能不写单位，直接按照字节搜索啊？”很傻、很天真，不写单位，你们就以为会按照字节来搜索吗？我们来试试：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ll anaconda-ks.cfg</span>
-rw-------. <span>1</span> root root <span>1207</span> <span>1</span>月 <span>14</span> <span>2014</span> anaconda-ks.cfg
<span>#anaconda-ks.cfg 文件有 1207 字节</span>
<span>[</span>root@localhost ~<span>]</span><span># find . -size 1207</span>
<span>#但用 find 查找 1207，是什么也找不到的 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>也就是说，<code>find</code> 命令的默认单位不是字节。如果不写单位，那么 <code>find</code> 命令是按照 512 Byte 来进行查找的。我们看看 <code>find</code> 命令的帮助。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># man find</span>
<span>..</span>.省略部分内容<span>..</span>.
	-size n<span>[</span>cwbkMG<span>]</span>
    	File uses n <span>units</span> of space. The following suffixes can be used:
    	
	    <span>'b'</span> <span>for</span> <span>512</span>-byte blocks <span>(</span>this is the default <span>if</span> no suffix is used<span>)</span>
        <span>#这是默认单位，如果单位为 b 或不写单位，则按照 512 Byte 搜索</span>
        <span>'c'</span> <span>for</span> bytes
        <span>#搜索单位是 c，按照字节搜索</span>
        ‘w’ <span>for</span> two-byte words
        <span>#搜索单位是 w，按照双字节（中文）搜索</span>
        ‘k’ <span>for</span> Kilobytes <span>(</span>units of <span>1024</span> bytes<span>)</span>
        <span>#按照 KB 单位搜索，必须是小写的 k</span>
        <span>'M'</span> <span>for</span> Megabytes <span>(</span>units of <span>1048576</span> bytes<span>)</span>
        <span>#按照 MB 单位搜索，必须是大写的 M </span>
        ‘G’ <span>for</span> Gigabytes <span>(</span>units of <span>1073741824</span> bytes<span>)</span>
        <span>#按照 GB 单位搜索，必须是大写的 G</span>
        The size does not count indirect blocks, but it does count blocks <span>in</span> sparse files that are not actually allo‐cated.  Bear <span>in</span> mind that the <span><span>`</span>%k' and <span>`</span></span>%b<span>' format specifiers of -printf  handle  sparse  files  differently. The  `b'</span>  suffix always denotes <span>512</span>-byte blocks and never <span>1</span> Kilobyte blocks, <span>which</span> is different to the behav‐iour of -ls.
<span>..</span>.省略部分内容<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>也就是说，如果想要按照字节搜索，则需要加搜索单位“c”。我们来试试：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># find . -size 1207c</span>
/anaconda-ks.cfg
<span>#使用搜索单位 c，才会按照字节搜索</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="按照修改时间搜索"> 按照修改时间搜索</h3>
<p>Linux 中的文件有访问时间（atime)、数据修改时间（mtime）、状态修改时间（ctime）这三个时间，我们也可以按照时间来搜索文件。</p>
<div><pre><code><span>find</span> 搜索路径 <span>[</span>选项<span>]</span> 搜索内容
选项：
	-atime <span>[</span>+<span>|</span>-<span>]</span>时间	：按照文件访问时间搜索
    -mtime <span>[</span>+<span>|</span>-<span>]</span>时间	：按照文件数据修改时间搜索
    -ctime <span>[</span>+<span>|</span>-<span>]</span>时间	：按照文件状态修改时间搜索 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这三个时间的区别我们在 <code>stat</code> 命令中已经解释过了，这里用 mtime 数据修改时间来举例， 重点说说“[+-]”时间的含义。</p>
<ul>
<li>-5：代表 5 天内修改的文件。</li>
<li>5：代表前 5～6 天那一天修改的文件。</li>
<li>+5：代表 6 天前修改的文件。</li>
</ul>
<p>我们画一个时间轴，来解释一下，如图7-1 所示。</p>
<div>
<p><img src="./assets/find_time.png" alt="find time" loading="lazy"></p>
<p><strong>图7-1	<u>find 命令时间轴</u></strong></p>
</div>
<p>讲到这里，“-5”代表 5 天内修改的文件，<s>而“+5”总有人说代表 5 天后修改的文件</s>。要是能知道 5 天后系统中能建立什么文件，早就去买彩票了，那是未卜先知啊！所以“-5”指的是 5 天内修改的文件，“5”指的是前 5～6 天那一天修改的文件，“+5”指 的是 6 天前修改的文件。我们来试试：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># find . -mtime -5</span>
<span>#查找 5 天内修改的文件</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>大家可以在系统中把几个选项都试试，就可以明白各选项之间的差别了。 <code>find</code> 不仅可以按照 atime、mtime 和 ctime 来查找文件的时间，也可以按照 <strong>amin、mmin 和 cmin</strong> 来查找文件的时间，区别只是所有 time 选项的默认单位是天，而 min 选项的默认单位是分钟。</p>
<h3 id="按照权限搜索"> 按照权限搜索</h3>
<p>在 <code>find</code> 中，也可以按照文件的权限来进行搜索。权限也支持 [+/-] 选项。我们先看一下命令格式：</p>
<div><pre><code><span>find</span> 搜索路径 <span>[</span>选项<span>]</span> 搜索內容
选项：
	-perm 权限模式	：查找文件权限刚好等于“权限模式”的文件
    -perm -权限模式	：查找文件权限全部包含“权限模式”的文件
    -perm +权服模式	：查找文件权限包含“权限模式”的任意一个权限的文件
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>为了便于理解，我们要举几个例子，先建立几个测试文件。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mkdir test</span>
<span>[</span>rootelocalhost ~<span>]</span><span># cd test/</span>
<span>[</span>root@localhost test<span>]</span><span># touch testl</span>
<span>[</span>root@localhost test<span>]</span><span># touch test2</span>
<span>[</span>root@localhost test<span>]</span><span># touch test3</span>
<span>[</span>root@localhost test<span>]</span><span># touch test4</span>
<span>#建立测试目录，以及测试文件</span>
<span>[</span>root@localhost test<span>]</span><span># chmod 755 test1</span>
<span>[</span>root@localhost test<span>]</span><span># chmod 444 test2</span>
<span>[</span>root@localhost test<span>]</span><span># chmod 600 test3</span>
<span>[</span>root@localhost test<span>]</span><span># chmod 200 test4</span>
<span>#设定实验权限。因为是实验权限，所以看起来比较别扭</span>
<span>[</span>root@localhost test<span>]</span><span># ll</span>
总用量 <span>0</span>
-rwxr-xr-x <span>1</span> root root <span>0</span> <span>6</span>月 <span>17</span> <span>11</span>:05 test1
-r--r--r-- <span>1</span> root root <span>0</span> <span>6</span>月 <span>17</span> <span>11</span>:05 test2
-rw------- <span>1</span> root root <span>0</span> <span>6</span>月 <span>17</span> <span>11</span>:05 test3
--w------- <span>1</span> root root <span>0</span> <span>6</span>月 <span>17</span> <span>11</span>:05 test4
<span>#查看权限 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><ul>
<li>例子 1：“-perm 权限模式”</li>
</ul>
<p>这种搜索比较简单，代表查找的权限必须和指定的权限模式一模一样，才可以找到。</p>
<div><pre><code><span>[</span>root@localhost test<span>]</span><span># find . -perm 444</span>
./test2
<span>[</span>root@localhost test<span>]</span><span># find . -Perm 200</span>
./test4
<span>#按照指定权限搜索文件，文件的权限必须和搜索指定的权限一致，才能找到 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>例子 2：“-perm -权限模式”</li>
</ul>
<p>如果使用“-权限模式”，代表的是文件的权限必须全部包含搜索命令指定的权限模式，才可以找到。</p>
<div><pre><code><span>[</span>root@localhost test<span>]</span><span># find . -perm -200</span>
<span>.</span>
./test4			<span>&lt;</span>---权限为 <span>200</span>，即 --w-------
./test3			<span>&lt;</span>---权限为 <span>600</span>，即 -rw-------
./test1			<span>&lt;</span>---权限为 <span>755</span>，即 -rwxr-xr-x
<span>#搜索文件的权限包含 200 的文件，不会找到权限为 444 的 test2 文件</span>
<span>#因为权限 444（即-r--r--r--），不包含权限 200（即 --w-------）</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>
<li>例子 3：“-perm +权限模式”</li>
</ul>
<p>包含任意一个指定权限，就可以找到。</p>
<div><pre><code><span>[</span>root@localhost <span>test</span><span>)</span><span># find . -perm +444</span>
./test3			<span>&lt;</span>---权限为 <span>600</span>，即 -rw-------
./test2 		<span>&lt;</span>---权限为 <span>444</span>，即 -r--r--r--
./test1 		<span>&lt;</span>---权限为 <span>755</span>，即 -rwxr-xr-x
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这里的“+444”能找到 test1、test2 和 test3 文件，那是因为 test3 的权限是 600（-w-----），虽然所属组和其他人的权限不包含 4 权限，但是“+权限模式”只要有一个身份的权限包含任意一个指定权限，就可以找到。而 test3 的所有者权限是 6，包含 4 权限，所以依然能够找到。 而找不到 test4，是因为 test4 的权限是 200 （--w------），test4 的任意身份（所有者、所属组和其他人）都没有 4 权限，所以找不到。 再试试：</p>
<div><pre><code><span>[</span>root@localhost test<span>]</span><span># find . -perm +777</span>
./test4
./test3
./test2
./test1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>如果搜索指定权限是“+777”，那么这 4 个测试文件的任意一个身份只要拥有读、写和执行任意一个权限都能找到。如果我们把 test4 的权限改为“000”，那“+777”还能找到吗？</p>
<div><pre><code><span>[</span>root@localhost test<span>]</span><span># chmod 000 test4</span>
<span>[</span>rootelocalhost test<span>]</span><span># find . -perm +777</span>
./test3
./test2
./test1 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>如果 test4 的权限是“000”，则搜索“+777”就不能找到了。因为 test4 的所有身份都不拥有读、写和执行权限，而“+777”要求至少有一个身份拥有读、写和执行的任意一个权限才 能找到。</p>
<h3 id="按照所有者和所属组搜索"> 按照所有者和所属组搜索</h3>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># find 搜索路径 [选项] 搜索内容</span>
选项：
	-uid 用户ID		：按照用户 ID 查找所有者是指定 ID 的文件
    -gid 组ID		：按照用户组 ID 查找所属组是指定 ID 的文件
    -user 用户名		：按照用户名查找所有者是指定用户的文件
    -group 组名		：按照组名查找所属组是指定用户组的文件
    -nouser			：查找没有所有者的文件 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这组选项比较简单，就是按照文件的所有者和所属组来进行文件的查找。在 Linux 系统中，绝大多数文件都是使用 root 用户身份建立的，所以在默认情况下，绝大多数系统文件的所有者都是 root。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># find . -user root</span>
<span>#在当前目录中查找所有者是 root 的文件</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>由于当前目录是 root 的家目录，所有文件的所有者都是 root 用户，所以这条搜索命令会找到当前目录下所有的文件。</p>
<p>按照所有者和所属组搜索时，“-nouser”选项比较常用，主要用于查找垃圾文件。在 Linux 中，所有的文件都有所有者，只有一种情况例外，那就是外来文件。比如光盘和 U盘中的文件如果是由 Windows 复制的，在 Linux 中查看就是没有所有者的文件；再比如手工源码包安装的文件，也有可能没有所有者。除这种外来文件外，如果系统中发现了没有所有者的文件，一般都是没有作用的垃圾文件（比如用户删除之后遗留的文件），这时需要用户手工处理。搜索没有所有者的文件，可以执行以下命令：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># find . -nouser</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="按照文件类型搜索"> 按照文件类型搜索</h3>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># find 搜索路径 [选项] 搜索内容</span>
选项：
	-type d	：查找目录
	-type f	：查找普通文件
	-type l	：查找软链接文件
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这个命令也很简单，主要按照文件类型进行搜索。在一些特殊情况下，比如需要把普通文件和目录文件区分开，使用这个选项就很方便。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># find /etc -type d</span>
<span>#查找 /etc/ 目录下有哪些子目录 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="逻辑运算符"> 逻辑运算符</h3>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># find 搜索路径 [选项] 搜索内容</span>
选项：
	-a		：and 逻辑与
    -o		：or 逻辑或
    -not	：not 逻辑非
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li><strong>-a：and 逻辑与</strong></li>
</ul>
<p><code>find</code> 命令也支持逻辑运算符选项，其中“-a”代表逻辑与运算，也就是“-a”的两个条件都成立，<code>find</code> 搜索的结果才成立。举个例子：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># find . -size +2k -a -type f</span>
<span>#在当前目录下搜索大于 2KB，并且文件类型是普通文件的文件 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>在这个例子中，文件既要大于 2KB，又必须是普通文件，<code>find</code> 命令才可以找到。再举个例子：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># find . -mtime -3 -a -perm 644</span>
<span>#在当前目录下搜索 3 天以内修改过，并且权限是 644 的文件 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li><strong>-o：or 逻辑或</strong></li>
</ul>
<p>“-o”选项代表逻辑或运算，也就是“-o”两个条件只要其中一个成立，<code>find</code> 命令就可以找到结果。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># find . -name cangls -o -name bols</span>
./cangls
./bols
<span>#在当前目录下搜索文件名要么是 cangls 的文件，要么是 bols 的文件</span>
<span># -o 选项的两个条件只要成立一个，find 命令就可以找到结果，所以这个命令既可以找到 cangls 文件，也可以找到 bols 文件。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li><strong>-not：not 逻辑非</strong></li>
</ul>
<p>“-not”是逻辑非，也就是取反的意思。举个例子：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># find . -not -name cangls</span>
<span>#在当前目录下搜索文件名不是 cangls 的文件 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="其他选项"> 其他选项</h3>
<p>这里我们主要讲解两个选项“-exec”和“-ok”，这两个选项的基本作用非常相似。</p>
<ul>
<li><strong>-exec 选项</strong></li>
</ul>
<p>我们先来看看“-exec”选项的格式。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># find 搜索路径 [选项] 搜索内容 -exec 命令2 {} \;</span>
</code></pre>
<div><span>1</span><br></div></div><p>首先，请大家注意这里的“<code>{}</code>”和“<code>\;</code>”是标准格式，只要执行“-exec”选项，这两个符号必须完整输入。其次，这个选项的作用其实是把 <code>find</code> 命令的结果交给由“-exec”调用的命令2 来处理。 “<code>{}</code>”就代表 <code>find</code> 命令的查找结果。我们举个例子，刚刚在讲权限的时候，使用权限模式搜索只能看到文件名，例如：</p>
<div><pre><code><span>[</span>root@localhost test<span>]</span><span># find . -perm 444 </span>
./test2 
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果要看文件的具体权限，还要用“<code>ls -l</code>”命令查看。用“-exec”选项则可以一条命令搞定：</p>
<div><pre><code><span>[</span>root@localhost test<span>]</span><span># find . -Perm 444 -exec ls -l {} \;</span>
-r--r--r-- <span>1</span> root root <span>0</span> <span>6</span>月 <span>17</span> <span>11</span>:05 ./test2
<span>#使用“-exec”选项，把 find 命令的结果直接交给“1s -l”命令处理</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>“-exec”选项的作用是把 <code>find</code> 命令的结果放入“{}”中，再由命令2 直接处理。在这个例 子中就是用“<code>ls -l</code>”命令直接处理，会使 <code>find</code> 命令更加方便。</p>
<ul>
<li><strong>-ok 选项</strong></li>
</ul>
<p>“-ok”选项的格式和“-exec”选项的格式一样。</p>
<div><pre><code><span>[</span>root@localhost test<span>]</span><span># find 搜索路径 [选项] 搜索内容 -ok 命令2 {} \; </span>
</code></pre>
<div><span>1</span><br></div></div><p>“-ok”选项和“-exec”选项的作用也基本一致，例如：</p>
<div><pre><code><span>[</span>root@localhost test<span>]</span><span># find . -perm 444 -ok rm -rf {} \;</span>
<span>&lt;</span>rm <span>..</span><span>..</span>/test2 <span>></span>？ y 		<span>&lt;</span>---需要用户输入 y，才会执行
<span>#我们这次使用 rm 命令来删除 find 找到的结果，删除的动作最好确认一下</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><p>区别</p>
<p>“-ok”选项和“-exec”选项的区别：</p>
<blockquote>
<p>“-exec”的命令2 会直接处理，而不询问；</p>
<p>“-ok”的命令2 在处理前会先询问用户是否这样处理，在得到确认命令后，才会执 行。</p>
</blockquote>
</div>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-05-06T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">linux关机和重启命令</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_basic/08.linux_shutdown_reboot/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_basic/08.linux_shutdown_reboot/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>说到关机和重启，很多人认为，重要的服务器（比如银行的服务器、电信的服务器）如果重启了，则会造成大范围的灾难。这里解释一下。</p>
<p>首先，就算是银行或电信的服务器，也不是不需要维护，而是依靠备份服务器来代替。其次，每个人的经验都是和自己的技术成长环境息息相关的。比如你是游戏运维出身， 而游戏又是数据为王，所以一切操作的目的就是保证数据的可靠和安全。这时，有计划的重启远比意外宕机造成的损失要小得多，所以定时重启是游戏运维的重要手段。既然是按照自己的技术出身来给出建议，那么难免有局限性，所以强调一下，这些只是“建议”，如果你有自己的经验，则完全可以按照自己的经验来维护服务器。</p>
<h2 id="sync-命令"> sync 命令</h2>
<p><code>sync</code> 命令，把内存中的数据强制向硬盘中保存。</p>
<p>英文原意：flush file system buffers</p>
<p>当我们在计算机上保存数据的时候，其实是先在内存中保存一定时间，再写入硬盘。这其实是一种缓存机制，当在内存中保存的数据需要被读取的时候，从内存中读取要比从硬盘中读取快得多。不过这也会带来一些问题，如果数据还没有来得及保存到硬盘中，就发生了突然宕机（比如断电）的情况，数据就会丢失。</p>
<p>sync 命令的作用就是把内存中的数据强制向硬盘中保存。这个命令在常规关机的命令中其实会自动执行，但如果不放心，则应该在关机或重启之前手工执行几次，避免数据丢失。</p>
<p><code>sync</code> 命令直接执行就可以了，不需要任何选项。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># sync</span>
</code></pre>
<div><span>1</span><br></div></div><p>记得在关机或重启之前多执行几次 <code>sync</code> 命令，多一重保险总是好的。</p>
<h2 id="shutdown-命令"> shutdown 命令</h2>
<p><code>shutdown</code> 命令，用于安全地关闭或重启 Linux 系统。</p>
<p>英文原意：Halt, power-off or reboot the machine</p>
<p>在早期的 Linux 系统中，应该尽量使用 <code>shutdown</code> 命令来进行关机和重启。因为在那时的 Linux 中，只有 <code>shutdown</code> 命令在关机或重启之前会正确地中止进程及服务，所以我们一直认为 <code>shutdown</code> 才是最安全的关机与重启命令。而在现在的系统中，一些其他的命令（如 <code>reboot</code> ）也会正确地中止进程及服务，但我们仍建议使用 <code>shutdown</code> 命令来进行关机和重启。</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># shutdown [选项] 时间 [警告信息]</span>
选项：
	-c：取消已经执行的 <span>shutdown</span> 命令
    -h：关机
    -r：重启
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li><strong>重启与定时重启</strong></li>
</ul>
<p>先来看看如何使用 <code>shutdown</code> 命令进行重启。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># shutdown -r now</span>
<span>#重启，now 是现在重启的意思</span>
<span>[</span>root@localhost ~<span>]</span><span># shutdown -r 05:30</span>
<span>#指定时间重启，但会占用前台终端</span>
<span>[</span>root@localhost ~<span>]</span><span># shutdown -r 05:30 &amp;</span>
<span>#把定时重启命令放入后台，&amp; 是后台的意思</span>
<span>[</span>root@localhost ~<span>]</span><span># shutdown -c</span>
<span>#取消定时重启</span>
<span>[</span>root@localhost ~<span>]</span><span># shutdown -r +10</span>
<span>#10分钟之后重启 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>
<li><strong>关机和定时关机</strong></li>
</ul>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># shutdown -h now</span>
<span>#现在关机</span>
<span>[</span>root@localhost ~<span>]</span><span># shutdown -h 05:30</span>
<span>#指定时间关机 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="reboot-命令"> reboot 命令</h2>
<p><code>reboot</code> 命令，重启 Linux 系统。在现在的系统中，<code>reboot</code> 命令也是安全的，而且不需要加入过多的选项。</p>
<p>英文原意：Halt, power-off or reboot the machine</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># reboot</span>
<span>#重启</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="halt-和-poweroff-命令"> halt 和 poweroff 命令</h2>
<p>这两个都是关机命令，直接执行即可。</p>
<p>英文原意：Halt, power-off or reboot the machine</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># halt</span>
<span>#关机</span>
<span>[</span>root@localhost ~<span>]</span><span># poweroff</span>
<span>#关机</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="init-命令"> init 命令</h2>
<p><code>init</code> 是修改 Linux 运行级别的命令，也可以用于关机和重启。</p>
<p>英文原意：systemd system and service manager</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># init 数字[0-6]</span>
数字：
	<span>0</span>：停机（千万不能把 initdefault 设置为 <span>0</span> ） 
	<span>1</span>：单用户模式
	<span>2</span>：多用户，没有 NFS 不联网
	<span>3</span>：完全多用户模式（标准的运行级）
	<span>4</span>：保留，暂时没有用到
	<span>5</span>：X11（xwindow<span>)</span> 图形化界面模式
	<span>6</span>：重新启动 （千万不要把 initdefault 设置为 <span>6</span> ）
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>关机和重启命令用 <code>init 0</code> 和 <code>init 6</code></p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># init 0</span>
<span>#关机，也就是调用系统的 0 级别</span>
<span>[</span>root@localhost ~<span>]</span><span># init 6</span>
<span>#重启，也就是调用系统的 6 级别</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><p>补充</p>
<p>开机默认模式设置方式：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vim /etc/inittab</span>
<span># inittab is no longer used when using systemd.</span>
<span>#</span>
<span># ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.</span>
<span>#</span>
<span># Ctrl-Alt-Delete is handled by /usr/lib/systemd/system/ctrl-alt-del.target</span>
<span>#</span>
<span># systemd uses 'targets' instead of runlevels. By default, there are two main targets:</span>
<span>#</span>
<span># multi-user.target: analogous to runlevel 3</span>
<span># graphical.target: analogous to runlevel 5</span>
<span>#</span>
<span># To view current default target, run:</span>
<span># systemctl get-default</span>
<span>#</span>
<span># To set a default target, run:</span>
<span># systemctl set-default TARGET.target</span>
<span>#</span>
<span>##查看 /etc/inittab 文件内容，</span>
<span>[</span>root@localhost ~<span>]</span><span># systemctl get-default</span>
multi-user.target
<span>#命令 systemctl set-default 获取默认 init 级别</span>
<span>#根据/etc/inittab的内容得知，multi-user.target: analogous to runlevel 3 </span>
<span>#默认级别为 3 ，就是完全多用户模式（标准的运行级）</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div></div>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-05-06T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">linux常用网络命令</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_basic/09.linux_net/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_basic/09.linux_net/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>我们在做练习的时候，需要让 Linux 进行联网配置。介绍一下如何给 Linux 配置 IP 地址，以及一些常用的网络命令。</p>
<h2 id="配置-linux-的-ip-地址"> 配置 Linux 的 IP 地址</h2>
<p>IP 地址是计算机在互联网中唯一的地址编码。每台计算机如果需要接入网络和其他计算机进行数据通信，就必须配置唯一的公网 IP 地址。</p>
<h3 id="setup-命令配置网卡"> setup 命令配置网卡</h3>
<p>Linux 当然也需要配置 IP 地址才可以正常使用网络。其实 Linux 主要是通过修改网卡配置文件来永久修改 IP 地址的。<code>setup</code> 是一个简化命令，是 Red Hat 系列专有的命令，其他的 Linux 系列不一定有此命令。<code>setup</code> 命令会开启一个图形化的配置工具，如图10-1 所示。</p>
<p>这是一个综合工具，既可以配置 IP 地址，也可以管理防火墙和系统服务。如果我们需要配置 IP 地址，则只要选择“Network configuration”就会开始 IP 地址配置。</p>
<div>
<p><img src="./assets/setup1.png" alt="setup1" loading="lazy"></p>
<p><strong>图10-1	<u>配置工具界面</u></strong></p>
</div>
<p>接下来就可以执行动作选择了。我们要配置 IP 地址，就选择“Decive configuration”，如图10-2 所示。</p>
<div>
<p><img src="./assets/setup2.png" alt="setup2" loading="lazy"></p>
<p><strong>图10-2	<u>选择动作</u></strong></p>
</div>
<p>在 CentOS 6.x 中，网卡的设备文件名用 eth0 来表示第一块网卡，如果有第二块网卡，则设备文件名会依次为 eth1。在这里，我们的 Linux 只有一块网卡，所以在选择设备时只需选择 eth0 网卡配置即可，如图10-3 所示。</p>
<div>
<p><img src="./assets/setup3.png" alt="setup3" loading="lazy"></p>
<p><strong>图10-3	<u>选择设备</u></strong></p>
</div>
<p>接下来就会进入网络配置界面，如图10-4 所示。这时如果在“Use DHCP”选项上输入 “*”号（空格输入）。就会自动获取 IP 地址：取消“*”号，就会手工分配 IP 地址。</p>
<div>
<p><img src="./assets/setup4.png" alt="setup4" loading="lazy"></p>
<p><strong>图10-4	<u>网络配置</u></strong></p>
</div>
<p>输入正确的 IP 地址后，使用 Tab 键切換至“OK”按钮上，接下来一路保存退出，IP 地址就输入完成了。但是，如果想让 IP 地址配置生效，则还需要重启网络服务。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># service network restart</span>
<span>#重启网络服务</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>当然，重启网络服务有很多种方法，这里直接使用 <code>service</code> 命令进行网络服务重启。</p>
<div><p>补充</p>
<p>CentOS 7.x 及以上版本的的 <code>setup</code> 命令没有网络配置“Decive configuration”选项了，但是可以用 <code>nmtui</code> 命令配置网络，同样也是图形化配置工具。</p>
</div>
<h3 id="手工配置网卡"> 手工配置网卡</h3>
<p>手工开启网卡 在 CentOS 5x 以前的系统中，通过 <code>setup</code> 配置 IP 地址，重启后，IP地址就可以配置成功。但如果是在 CenOS 6.x 中，那么重启后可能依然无法找到 eth0 网卡，而只能看到 lo（本地回环）网卡。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span> ifcontig
lo		Link encap:Local Loopback
inet adar:127.0.0.1 Mask:256.0.0.0
inet6 addr: ::1/128 Scope:Hoat
		UP LOOPBACK RUNNING MTU:16436 Metric:1
		RX packets:12 errors:0 dropped:0 qverruns:0 frame:0
        TX packets:12 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 
        RX bytes:840 <span>(</span><span>840.0</span> b<span>)</span> TX bytes:840 <span>(</span><span>840.0</span> b<span>)</span> 
<span>#只有lo网卡，没有eth0网卡</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>这是因为，在 CentOS 6.x 中，eth0 网卡是默认没有开启的，需要修改网卡配置文件手工开启。例如：</p>
<div><pre><code><span>[</span>root@1ocalhost ~<span>]</span><span># vi /etc/sysconfig/network-scripts/ifcfg-eth0</span>
<span>TYPE</span><span>=</span>Ethernet
<span>PROXY_METHOD</span><span>=</span>none
<span>BROWSER_ONLY</span><span>=</span>no
<span>BOOTPROTO</span><span>=</span>dhcp
<span>DEFROUTE</span><span>=</span>yes
<span>IPV4_FAILURE_FATAL</span><span>=</span>no
<span>IPV6INIT</span><span>=</span>yes
<span>IPV6_AUTOCONF</span><span>=</span>yes
<span>IPV6_DEFROUTE</span><span>=</span>yes
<span>IPV6_FAILURE_FATAL</span><span>=</span>no
<span>IPV6_ADDR_GEN_MODE</span><span>=</span>stable-privacy
<span>NAME</span><span>=</span>ens3
<span>UUID</span><span>=</span>c3c79e29-8228-4e7a-a39a-f54599644675
<span>DEVICE</span><span>=</span>eth0
<span>ONBOOT</span><span>=</span>yes
<span>#在网卡配置文件中，ONBOOT默认是 no</span>
<span>[</span>root@1ocalhost ~<span>]</span><span># service network restart</span>
Restarting network <span>(</span>via systemctl<span>)</span>:                        <span>[</span>  OK  <span>]</span>
<span>[</span>root@1ocalhost ~<span>]</span><span># </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>手工把 ONBOOT 选项改为 yes，然后再重启网络服务（<code>service network restart</code>），就会发现 eth0 网卡启动了，IP 地址也可以正常使用了。</p>
<div><p>补充</p>
<p>Debain/Ubuntu 系统的网络配置：<code>/etc/network/interfaces</code></p>
<ol>
<li>打开 ubuntu 的 <code>/etc/network/interfaces</code> 文件</li>
</ol>
<p>默认的内容如下：</p>
<div><pre><code>$ <span>cat</span> /etc/network/interfaces
auto lo
iface lo inet loopback
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>在文件中添加如下信息：（动态或者静态，二选一）</p>
<div><pre><code><span># 1. 动态获取的配置方法：</span>
auto eth0
iface eth0 inet dhcp

<span># 2. 静态分配的配置方法：</span>
auto eth0
iface eth0 inet static
address <span>192.168</span>.2.6
netmask <span>255.255</span>.255.0
gateway <span>192.168</span>.2.1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ol start="2">
<li>添加域名服务器（DNS）：</li>
</ol>
<p>打开 <code>/etc/resolv.conf</code> 文件，添加如下内容。DNS 写自己常用的就可以了。</p>
<div><pre><code>nameserver <span>114.114</span>.114.114
</code></pre>
<div><span>1</span><br></div></div><ol start="3">
<li>重启下网络</li>
</ol>
<div><pre><code>$ /etc/init.d/networking restart
<span>#这条命令是重启网卡</span>
或者
$ <span>ifdown</span> eth0
$ <span>ifup</span> eth0
<span>#这两条命令是有针对性的重启某个网络接口，因为一个系统可能有多个网络接口</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>以上配置好之后， <code>ifconfig</code> 查看下配置是否成功，<code>ping</code> 一下，验证网络是否通了。</p>
<blockquote>
<p>Ubuntu 16.04 之后的版本，启用了新的网络工具 netplan，命令行配置网络参数跟之前的版本有比较大的差别，其网卡配置文件为：<code>/etc/netplan/01-network-manager-all.yaml</code>，netplan 描述文件采用了 yaml 语法，默认是用 dhcp方式，如果要配置静态地址，则需要修改此文件的想关内容。</p>
</blockquote>
<div><pre><code><span># 1. 默认配置为 DHCP 方式：</span>
<span>#注意行缩进</span>
root@ubuntu:~<span># vim /etc/netplan/01-network-manager-all.yaml</span>
network:
 version: <span>2</span>
 ethernets:
     eth0:
         dhcp4: <span>true</span>
         match:
             macaddress: <span>52</span>:54:00:d4:51:ad
         set-name: eth0
         
<span># 2. 配置静态 IP 地址：</span>
<span>#注意行缩进</span>
root@ubuntu:~<span># grep -v ^# /etc/netplan/01-network-manager-all.yaml</span>
network:
 version: <span>2</span>
 ethernets:
     eth0:
         addresses: <span>[</span><span>192.168</span>.120.18/24<span>]</span>
         gateway4: <span>192.168</span>.120.1
         nameservers:
                 addresses: <span>[</span><span>183.60</span>.83.19,183.60.82.98<span>]</span>
               
<span># 更新配置生效  </span>
root@ubuntu:~<span># sudo netplan apply</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div></div>
<h2 id="ifconfig-命令"> ifconfig 命令</h2>
<p><code>ifconfig</code> 命令，是 Linux 中查看和临时修改 IP 地址的命令。</p>
<ol>
<li><strong>查看 IP 地址信息</strong></li>
</ol>
<p><code>ifconfig</code> 命令最主要的作用就是查看 IP 地址的信息，直接输入 <code>ifconfig</code> 命令即可。</p>
<p>英文原意：configure a network interface</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ifconfig</span>
eth0	Link encap:Ethernet HWaddr 00:0C:29:C5:FB:AA
<span>#eth0网卡信息 网络类型为以太网	MAC 地址</span>
inet addr:192.168.44.3 Bcast:192.168.44.255 Mask:255.255.255.0
<span>#IP地址 				  广播地址 				子网掩码</span>
inet6 addr：fe80::20c:29ff:fec5:fbaa/64 Scope:Link
<span>#IPv6的地址（目前不生效）</span>
		UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
		<span>#网络参数 					   最大传输单元  数据包转送次数</span>
		RX packets:881 errors:0 dropped:O overruns:0 frame:0
		<span>#接收到的数据包情况</span>
		TX packets:853 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000
        <span>#发送的数据包情况         								  数据包碰撞		数据缓冲区长度</span>
        RX bytes:82229 （80.3 KiB<span>)</span> TX bytes:273463 （267.0 KiB）
        <span>#接收包的大小 发送包的大小</span>
        Interrupt:19 Base address:0x2000
        <span>#TRQ中断 			 内存地址</span>
        
lo 		Link encap:Local Loopback
<span>#本地回环网卡信息</span>
inet addr:127.0.0.1 Mask:255.0.0.0
inet6 addr: ::1/128 Scope:Host
		UP LOOPBACK RUNNING MTU:16436 Metric:1
        RX packets:12 errors:0 dropped:0 overruns:0 frame:0
        TX packets:12 errors:O dropped:O overruns:0 carrier:0 collisions:0 txqueuelen:0
        RX bytes:840 <span>(</span><span>840.0</span> b<span>)</span> TX bytes:840 <span>(</span><span>840.0</span> b<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p><code>ifconfig</code> 命令主要用于查看 <strong>IP 地址、子网掩码</strong> 和 <strong>MAC地址</strong>这三类信息，其他信息我们有所了解即可。</p>
<p>lo 网卡是 Loopback 的缩写，也就是本地回环网卡，这个网卡的 IP 地址是 <strong>127.0.0.1</strong>。它只代表我们的网络协议正常，就算不插入网线也可以 <code>ping</code> 通，所以基本没有实际使用价值，大家了解一下即可。</p>
<ol start="2">
<li><strong>临时配置 IP 地址</strong></li>
</ol>
<p><code>ifconfig</code> 命令除可以查看 IP 地址之外，还可以临时配置 IP 地址，但是一旦重启，IP 地址就会失效，所以我们还是应该使用 <code>setup</code> 命令来进行 IP 地址配置。</p>
<p>使用 <code>ifconfig</code> 命令临时配置 IP 地址的示例如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span>#ifconfig eth0 192.168.44.3</span>
<span>#配置 IP地址，不指定子网掩码就会使用标准子网掩码</span>
<span>[</span>rootelocalhost -<span>]</span><span>#ifconfig eth0 192.168.44.3 netmask 255.255.255。0</span>
<span>#配置 IP地址，同时配置子网掩码</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="ifup-和-ifdown-命令"> ifup 和 ifdown 命令</h2>
<p><code>ifup</code> 和 <code>ifdown</code> 是两个非常简单的命令，其作用类似于 Windows 中的启用和禁用网卡，主要用于启用和关闭网卡。</p>
<p>英文原意：bring a network interface up <strong>&amp;</strong> take a network interface down</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ifdown 网卡设备名</span>
<span>#例子：</span>
<span>[</span>root@localhost ~<span>]</span><span># ifdown eth0</span>
<span>#关闭 eth0 网卡</span>
<span>[</span>root@localhost ~<span>]</span><span># ifup eth0</span>
<span>#启用 eth0 网卡</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="ping-命令"> ping 命令</h2>
<p><code>ping</code> 是常用的网络命令，主要通过 ICMP 协议进行网络探测，测试网络中主机的通信情况。</p>
<p>英文原意：send ICMP ECHO_REQUEST to network hosts</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ping [选项] IP</span>
选项：
	-b		：后面加入广播地址，用于对整个网段进行探测
    -c 次数	：用于指定 <span>ping</span> 的次数
    -s 字节	：指定探测包的大小 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ol>
<li><strong>探测与指定主机通信</strong></li>
</ol>
<p>直接输入 <code>ping IP地址</code> 即可，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ping 192.168.103.151</span>
PING <span>192.168</span>.103.151 <span>(</span><span>192.168</span>.103.151<span>)</span> <span>56</span><span>(</span><span>84</span><span>)</span> bytes of data.
<span>64</span> bytes from <span>192.168</span>.103.151: <span>icmp_seq</span><span>=</span><span>1</span> <span>tt1</span><span>=</span><span>128</span> <span>time</span><span>=</span><span>0.300</span> ms
<span>64</span> bytes from <span>192.168</span>.103.151: <span>icmp_seq</span><span>=</span><span>2</span> <span>ttl</span><span>=</span><span>128</span> <span>time</span><span>=</span><span>0.481</span> ms
<span>..</span>.省略部分内容<span>..</span><span>..</span> 
<span>#探测与指定主机是否通信</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>Linux 是一个比较实在的操作系统，这个 <code>ping</code> 命令如果不使用 <kbd>Ctrl</kbd>+<kbd>C</kbd> 快捷键强行中止， 就会一直 <code>ping</code> 下去，直到天荒地老……</p>
<ol start="2">
<li><strong>指定 ping 的次数</strong></li>
</ol>
<p>既然 <code>ping</code> 这么“实在”，如果不想一直 <code>ping</code> 下去，则可以使用“-c”选项指定 ping 的次数。例如：</p>
<div><pre><code> <span>[</span>root@localhost ~<span>]</span><span># ping -c 3 192.168.103.151</span>
 <span>#只探测3次，就中止 ping 命令</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ol start="3">
<li><strong>探测网段中的可用主机</strong></li>
</ol>
<p>在 <code>ping</code> 命令中，可以使用“-b”选项，后面加入广播地址，探测整个网段。我们可以使 用这个选项知道整个网络中有多少主机是可以和我们通信的，而不用一个一个 IP 地址地进行探测。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ping -b -c 3 192.168.103.255</span>
WARNING：pinging broadcast address
PING <span>192.168</span>.103.255 <span>(</span><span>192.168</span>.103.255<span>)</span> <span>56</span><span>(</span><span>84</span><span>)</span> bytes of data.
<span>64</span> bytes from <span>192.168</span>.103.199:icmp_seq<span>=</span><span>1</span> <span>ttl</span><span>=</span><span>64</span> <span>time</span><span>=</span><span>1.95</span> ms
<span>64</span> bytes from <span>192.168</span>.103.168:icmp_seq<span>=</span><span>1</span> <span>ttl</span><span>=</span><span>64</span> <span>time</span><span>=</span><span>1.97</span> ms
<span>64</span> bytes from <span>192.168</span>.103.252:icmp_seq<span>=</span><span>1</span> <span>ttl</span><span>=</span><span>64</span> <span>time</span><span>=</span><span>2.29</span> ms
<span>..</span>.省略部分内容<span>..</span>.
<span>#探测 192.168.103.0/24 网段中有多少可以通信的主机</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="natstat-命令"> natstat 命令</h2>
<blockquote>
<p>说道这个命令，就不得不提以下端口的作用。</p>
<p>我们要先简单了解一下端口的作用。在互联网中，如果 IP 地址是服务器在互联网中唯一的地址标识，那么大家可以想象一下：我有一台服务器，它有固定的公网 IP 地址，通过 IP 地址可以找到我的服务器。但是我的服务器中既启动了网页服务（Web 服务），又启动了文件传输服务（FTP 服务），那么你的客户端访问我的服务器，到底应该如何确定你访问的是哪一个服务呢？</p>
<p>端口就是用于网络通信的接口，是数据从传输层向上传递到应用层的数据通道。我们可以理解为每个常规服务都有默认的端口号，通过不同的端口号，我们就可以确定不同的服务。也就是说，客户端通过 IP 地址访问到我的服务器，如果数据包访问的是 80 端口，则访问的是 Web 服务；而如果数据包访问的是 21 端口，则访问的是 FTP 服务。</p>
<p>我们可以简单地理解为每个常规服务都有一个默认端口（默认端口可以修改)，这个端口是所有人都知道的，客户端可以通过固定的端口访问指定的服务。而我们通过在服务器中查看已经开启的端口号，就可以判断服务器中开启了哪些服务。</p>
</blockquote>
<p><code>netstat</code> 命令，是网络状态查看命令，既可以查看到本机开启的端口，也可以查看有哪些客户端连接。</p>
<p>英文原意：Print network connections, routing tables, interface statis‐tics, masquerade connections, and multicast memberships</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># netstat [选项]</span>
选项：
	-a		：列出所有网络状态，包括 Socket 程序
	-c 秒数	：指定每隔几秒刷新一次网络状态
	-n		：使用 IP 地址和端口号显示，不使用域名与服务名
	-p		：显示 PID 和程序名
	-t		：显示使用 TCP 协议端口的连接状况
	-u		：显示使用 UDP 协议端口的连接状况
	-l		：仅显示监听状态的连接
	-r		：显示路由表
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ol>
<li><strong>查看本机开启的端口</strong></li>
</ol>
<p>这是本机最常用的方式，使用选项“-tuln”。因为使用了”-l“项，所以只能看到监听状态的连接，而不能看到已经建立连接状态的连接。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># netstat -tuln</span>
Active Internet connections <span>(</span>only servers<span>)</span>
Prota  Recv-Q  Send-Q	Local Address		Foreign Address		State
tcp			<span>0</span>		<span>0</span> 	<span>0.0</span>.0.0:3306		<span>0.0</span>.0.0:*			LISTEN
tcp			<span>0</span>		<span>0</span>	<span>0.0</span>.0.0:11211		<span>0.0</span>.0.0:*			LISTEN
tcp			<span>0</span>		<span>0</span>	<span>0.0</span>.0.0:22			<span>0.0</span>.0.0:*			LISTEN
tcp			<span>0</span>		<span>0</span>	:::11211			:::*				LISTEN
tcp			<span>0</span>		<span>0</span>	:::80				:::*				LISTEN
tcp			<span>0</span>		<span>0</span>	:::22				:::*				LISTEN
udp			<span>0</span>		<span>0</span>	<span>0.0</span>.0.0:11211		<span>0.0</span>.0.0:*			
udp			<span>0</span>		<span>0</span>	:::11211			:::*				
<span>#协议  接收队列  发巡队列  本机的IP及端口号		 远程主机的IP地扯及端口号  状态</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>这个命令的输出较多。</p>
<blockquote>
<ul>
<li>Proto：网络连接的协议，一般就是 TCP 协议或者 UDP 协议。</li>
<li>Reev-Q：表示接收到的数据，已经在本地的缓冲中，但是还没有被进程取走。</li>
<li>Send-Q：表示从本机发送，对方还没有收到的数据，依然在本地的缓冲中，一般是不具备 ACK 标志的数据包。</li>
<li>Local Address：本机的 IP 地址和端口号。</li>
<li>Foreign Address：远程主机的 IP 地址和端口号。</li>
<li>State：状态。常见的状态主要有以下几种。
<ul>
<li>LISTEN：监听状态，只有 TCP 协议需要监听，而 UDP 协议不需要监听。</li>
<li>ESTABLISHED：已经建立连接的状态。如果使用“-l”选项，则看不到已经建立连接的状态。</li>
<li>SYN_SENT：SYN 发起包，就是主动发起连接的数据包。</li>
<li>SYN_RECV：接收到主动连接的数据包。</li>
<li>FIN_WAIT1：正在中断的连接。</li>
<li>FIN_WAIT2：已经中断的连接，但是正在等待对方主机进行确认。</li>
<li>TIME_WAIT：连接已经中断，但是套接字依然在网络中等待结束。</li>
<li>CLOSED：套接字没有被使用。</li>
</ul>
</li>
</ul>
</blockquote>
<p>在这些状态中，我们最常用的就是 LISTEN 和 ESTABLISHED 状态，一种代表正在监听，另一种代表已经建立连接。</p>
<ol start="2">
<li><strong>查看本机有哪些程序开启的端口</strong></li>
</ol>
<p>如果使用“-p”选项，则可以查看到是哪个程序占用了端口，并且可以知道这个程序的 PID。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># netstat -tulnp</span>
Active Internet connections <span>(</span>only servers<span>)</span>
Prota  Recv-Q  Send-Q	Local Address		Foreign Address		State		PID/Program name
tcp			<span>0</span>		<span>0</span>	<span>0.0</span>.0.0:3306		<span>0.0</span>.0.0:*			LISTEN		<span>2359</span>/mysqld
tcp			<span>0</span>		<span>0</span>	<span>0.0</span>.0.0:11211		<span>0.0</span>.0.0:*			LISTEN		<span>1563</span>/memcached
tcp			<span>0</span>		<span>0</span>	<span>0.0</span>.0.0:22			<span>0.0</span>.0.0:*			LISTEN		<span>1490</span>/sshd
tcp			<span>0</span>		<span>0</span>	:::11211			:::*				LISTEN		<span>1563</span>/memcached
tcp			<span>0</span>		<span>0</span>	:::80				:::*				LISTEN		<span>21025</span>/httpd
tcp			<span>0</span>		<span>0</span>	:::22				:::*				LISTEN		<span>1490</span>/sshd
udp			<span>0</span>		<span>0</span>	<span>0.0</span>.0.0:11211		<span>0.0</span>.0.0:*						<span>1563</span>/memcached
udp			<span>0</span>		<span>0</span>	:::11211			:::*							<span>1563</span>/memcached
<span>#协议  接收队列  发巡队列  本机的IP及端口号		 远程主机的IP地扯及端口号  状态		PID/程序名</span>
<span>#比之前的命令多了一个“-p”选项，结果多了“PID/程序名”，可以知道是哪个程序占用了端口</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><ol start="3">
<li><strong>查看所有连接</strong></li>
</ol>
<p>查看所有连接使用选项“-an”可以查看所有连接，包括监听状态的连接（LISTEN）、已经建立连接状态的连接（ESTABLISHED）、Socket程序连接等。因为连接较多，所以输出的内容有很多。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># netstat -an</span>
Active Internet connections <span>(</span>servers and established<span>)</span>
Proto Recv-Q Send-Q		Local Address		Foreign Address		 State
tcp			<span>0</span>		<span>0</span> 	<span>0.0</span>.0.0:3306		<span>0.0</span>.0.0:*			 LISTEN
tcp			<span>0</span>		<span>0</span>	<span>0.0</span>.0.0:11211		<span>0.0</span>.0.0:*			 LISTEN
tcp			<span>0</span>		<span>0</span>	<span>117.79</span>.130.170:80	<span>78.46</span>.174.55:58815	 SYN_RECV
tcp			<span>0</span>		<span>0</span>	<span>0.0</span>.0.0:22			<span>0.0</span>.0.0:*			 LISTEN
tcp			<span>0</span>		<span>0</span>	<span>117.79</span>.130.170:22	<span>124.205</span>.129.99:10379 ESTABLISHED
tcp			<span>0</span>		<span>0</span>	<span>117.79</span>.130.170:22	<span>124.205</span>.129.99:11811 ESTABLISHED
<span>..</span>.省略部分内容<span>..</span>.
udp			<span>0</span>		<span>0</span>	<span>0.0</span>.0.0:11211		<span>0.0</span>.0.0:*			
udp			<span>0</span>		<span>0</span>	:::11211			:::*				
Active UNIX domain sockets <span>(</span>servers and established<span>)</span>
Proto	RefCnt	Flags	Type	state		I-Node	Path
unix	<span>2</span>		<span>[</span> ACC <span>]</span>	STREAM	LISTENING	<span>9761</span>	@/var/run/hald/dbus-fr41WkQn1c
<span>..</span>.省略部分内容<span>..</span><span>..</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>从“Active UNIX domain sockets”开始，之后的内容就是 Socket 程序产生的连接，之前的内容都是网络服务产生的连接。我们可以在“-an”选项的输出中看到各种网络连接状态，而之前的“-tuln”选项则只能看到监听状态。</p>
<h2 id="write-命令"> write 命令</h2>
<p>在服务器上，有时会有多个用户同时登录，一些必要的沟通就显得尤为重要。比如，我必须关闭某个服务，或者需要重启服务器，当然需要通知同时登录服务器的用户，这时就可以使用 <code>write</code> 命令，向其他用户发送信息。</p>
<p><code>write</code> 命令，用于向指定登录用户终端上发送信息。</p>
<p>英文原意：send a message to another user</p>
<p>write 命令的基本格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span>#write 用户名 [终端号]</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>write</code> 命令没有多余的选项，我们要向在某个终端登录的用户发送信息，就可以这样来执行命令：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># wlite userl pts/1</span>
hello
I will be <span>in</span> <span>5</span> minutes to restart, please save your data
<span>#向在 pts/1（远程终端1）登录的 user1 用戶发送信息，使用“Ctrl+D”快捷键保存发送的数据</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这时，user1 用户就可以收到你要在 5 分钟之后重启系统的信息了。</p>
<h2 id="wall-命令"> wall 命令</h2>
<p><code>wall</code> 命令，用于给所有登录用户发送信息，包括你自己。</p>
<p>英文原意：send a message to everybody's terminal.</p>
<p>命令格式，在 <code>wall</code> 命令后加入需要发送的信息即可，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># wall "I will be in 5 minutes to restart, please save your data"</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="mail-命令"> mail 命令</h2>
<p><code>mail</code> 是 Linux 的邮件客户端命令，可以利用这个命令给其他用户发送邮件。</p>
<ol>
<li><strong>发送邮件</strong></li>
</ol>
<p>如果我们想要给其他用户发送邮件，则可以执行如下命令：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mail userl</span>
Subject：hello					<span>&lt;</span>---邮件标题
Nice to meet you<span>!</span>				<span>&lt;</span>---部件具体内容
<span>.</span>								<span>&lt;</span>---使用 “.” 来结束邮件输入
<span>#发送邮件给 user1 用户</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>我们接收到的邮件都保存在 <code>/var/spool/mail/用户名</code> 中，每个用户都有一个以自己的用户名命名的邮箱。</p>
<ol start="2">
<li><strong>发送文件内容</strong></li>
</ol>
<p>如果我们想把某个文件的内容发送给指定用户，则可以执行如下命令：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mail -s "test mall" root &lt; /root/anaconda-ks.cfg</span>
选项：
	-s：指定邮件标题
<span>#把 /root/anaconda-ks.cfg 文件的内容发送给 root用户</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>我们在写脚本时，有时需要脚本自动发送一些信息给指定用户，把要发送的信息预先写到文件中，是一个非常不错的选择。</p>
<ol start="3">
<li><strong>查看已经接收的邮件</strong></li>
</ol>
<p>我们可以直接在命令行中执行 <code>mail</code> 命令，进入 <code>mail</code> 的交互命令中，可以在这里查看已经接收到的邮件。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>)</span><span># mail</span>
Heirloom Mail version <span>12.4</span> <span>7</span>/29/08.Type ?for help.
<span>"/var/spool/mail/root"</span><span>:</span> <span>1</span> message <span>1</span> new
<span>></span>N <span>1</span> root		Mon Dec <span>5</span> <span>22</span>:45  <span>68</span>/1777  <span>"teat mall"</span>		<span>&lt;</span>---之前收到的邮件
<span>></span>N <span>2</span> root		Mon Dec <span>5</span> <span>23</span>:08  <span>18</span>/602   <span>"hello"</span>
<span>#未读 编号 发件人 时间						标题</span>

<span>&amp;</span>		<span>&lt;</span>---等待用户输入命令
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>可以看到已经接收到的邮件列表，“N”代表未读邮件，如果是已经阅读过的邮件，则前面是不会有这个“N”的；之后的数字是邮件的编号，我们主要通过这个编号来进行邮件的操作。如果我们想要查看第一封邮件，则只需输入邮件的编号“<code>1</code>”就可以了。</p>
<p>在交互命令中执行“<code>?</code>”，可以查看这个交互界面支持的命令。例如：</p>
<div><pre><code>$ ?		<span>&lt;</span>-输入 ? 命令
               mail commands
<span>type</span> <span>&lt;</span>message list<span>></span>             <span>type</span> messages
next                            goto and <span>type</span> next message
from <span>&lt;</span>message list<span>></span>             give <span>head</span> lines of messages
headers                         print out active message headers
delete <span>&lt;</span>message list<span>></span>           delete messages
undelete <span>&lt;</span>message list<span>></span>         undelete messages
save <span>&lt;</span>message list<span>></span> folder      append messages to folder and mark as saved
copy <span>&lt;</span>message list<span>></span> folder      append messages to folder without marking them
<span>write</span> <span>&lt;</span>message list<span>></span> <span>file</span>       append message texts to file, save attachments
preserve <span>&lt;</span>message list<span>></span>         keep incoming messages <span>in</span> mailbox even <span>if</span> saved
Reply <span>&lt;</span>message list<span>></span>            reply to message senders
reply <span>&lt;</span>message list<span>></span>            reply to message senders and all recipients
mail addresses                  mail to specific recipients
<span>file</span> folder                     change to another folder
quit                            quit and apply changes to folder
xit                             quit and discard changes made to folder
<span>!</span>                               shell escape
<span>cd</span> <span>&lt;</span>directory<span>></span>                  chdir to directory or home <span>if</span> none given
list                            list names of all available commands
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>这些交互命令是可以简化输入的，比如 <code>headers</code> 命令，就可以直接输入 <code>h</code>，这是列出邮件标遇列表的命令。我们解释一下常用的交互命令。</p>
<ul>
<li>headers：列出邮件标题列表，直接输入 <code>h</code> 命令即可。</li>
<li>delete：删除指定邮件。比如想要删除第二封邮件，可以输入 <code>d2</code>。</li>
<li>save：保存邮件。可以把指定邮件保存成文件，如 <code>s2 /tmp/tcst.mail</code>。</li>
<li>quit：退出，并把已经操作过的邮件进行保存。比如移除已删除邮件、保存已阅读邮件等。</li>
<li>exit：退出，但是不保存任何操作。</li>
</ul>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-05-06T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">linux文本编辑器</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_basic/10.linux_text_edit/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_basic/10.linux_text_edit/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="文本编辑器-vim"> 文本编辑器 Vim</h2>
<p>Linux 中的所有内容以文件形式管理，在命令行下更改文件内容，常常会用到文本编辑器。</p>
<p>我们首选的文本编辑器是 Vim，它是一个基于文本界面的编辑工具，使用简单且功能强大，更重要的是，Vim 是所有 Linux 发行版本的默认文本编辑器。</p>
<p>很多 UNIX 和 Linux 的老用户习惯称呼它为 Vi，Vi 是 Vim 的早期版本，现在我们使用的 Vim（Vi improved）是 Vi 的增强版，增加了一些正则表达式的查找、多窗口的编辑等功能，使得 Vim 对于程序开发来说更加方便。想了解 Vi 和 Vim 的区别，可以在 Vim 命令模式下输入 <code>:help vi_diff</code>，就能够看到两者区别的摘要。</p>
<p>值得一提的是，Vim 是慈善软件，如有赞助或评比得奖，所得钱财将用于救助乌干达孤儿。软件使用是免费的，使用者是否捐款赞助当然不会勉强。不过，如果有有奖评比活动，那么你去投一票也算功德一件。</p>
<p>了解 Vim 更多信息可以访问官网：<a href="http://www.vim.org" target="_blank" rel="noopener noreferrer">http://www.vim.org</a></p>
<h3 id="vim-的工作模式"> Vim 的工作模式</h3>
<p>在使用 Vim 编辑文件前，我们先来了解一下它的 3 种工作模式：<strong>命令模式</strong>、<strong>输入模式</strong>和<strong>编辑模式</strong>，这 3 种工作模式可随意切换，如图11-1 所示。</p>
<div>
<p><img src="./assets/vim.jpg" alt="vim" loading="lazy"></p>
<p><strong>图11-1	<u>Vim 的三种工作模式</u></strong></p>
</div>
<ul>
<li><strong>命令模式</strong></li>
</ul>
<p>使用 Vim 编辑文件时，默认处于命令模式。此模式下，可使用方向键（上、下、左、右键）或 <kbd>k</kbd>、<kbd>j</kbd>、<kbd>h</kbd>、<kbd>i</kbd> 移动光标的位置，还可以对文件内容进行复制、粘贴、替换、删除等操作。</p>
<ul>
<li>输入模式</li>
</ul>
<p>在输入模式下，Vim 可以对文件执行写操作，类似于在 Windows 系统的文档中输入内容。使 Vim 进行输入模式的方式是在命令模式状态下输入 <kbd>i</kbd>、<kbd>I</kbd>、<kbd>a</kbd>、<kbd>A</kbd>、<kbd>o</kbd>、<kbd>O</kbd> 等插入命令，编辑文件完成后按 <kbd>Esc</kbd> 键即可返回命令模式。</p>
<ul>
<li><strong>编辑模式</strong></li>
</ul>
<p>如果要保存、查找或者替换一些内容等，就需要进入编辑模式。编辑模式的进入方法为：在命令模式下按 <kbd>:</kbd> 键，Vim 窗口的左下方会出现一个“:”符号，这时就可以输入相关的指令进行操作了。指令执行后会自动返回命令模式。</p>
<p>对于新手来说，经常不知道自己处于什么模式。不论是自己忘了，还是不小心切换了模式，都可以直接按一次 <kbd>Esc</kbd> 键返回命令模式。如果你多按几次 <kbd>Esc</kbd> 键后听到了“嘀——”的声音，则代表你已经处于命令模式了。</p>
<h2 id="进入-vim"> 进入 Vim</h2>
<p>了解了 Vim 的工作模式后，就可以愉快地使用 Vim 进行文件编辑了。先来看一下 Vim 打开文件的方法。</p>
<h3 id="使用-vim-打开文件"> 使用 Vim 打开文件</h3>
<p>使用 Vim 打开文件很简单，例如，你想打开一个自己编写的文件 <code>/test/vi.test</code>，打开方法如下：</p>
<div><pre><code><span>[</span>root@itxdl ~<span>]</span><span># vim /test/vi.test</span>
</code></pre>
<div><span>1</span><br></div></div><p>刚打开文件时进入的是命令模式，此时文件的下方会显示文件的一些信息，包括文件名，文件的总行数和字符数，以及当前光标所在的位置等，此时可以使用插入命令（如：<kbd>i</kbd>）进入输入模式对文件进行编辑，如图11-2 所示。</p>
<div>
<p><img src="./assets/vim_open.png" alt="vim open" loading="lazy"></p>
<p><strong>图11-2	<u>Vim 打开文件</u></strong></p>
</div>
<p>接下来的操作练习，如果你的 Linux 中没有自己编写的文件，或者你懒得编写文件，则可以直接复制一个系统文件，方法如下：</p>
<div><pre><code><span>[</span>root@itxdl ~<span>]</span><span># cp /etc/passwd /tmp/passwd.vi</span>
</code></pre>
<div><span>1</span><br></div></div><p>千万不要随意打开一个系统文件就直接开始练习！</p>
<h3 id="直接进入指定位置"> 直接进入指定位置</h3>
<p>如果想直接进入 Vim 编辑文件的指定行数处或者特定字符串所在行，节省编辑时间，例如，打开 <code>/tmp/passwd.vi</code> 文件时直接进入第 20 行，则可以这样操作：</p>
<div><pre><code><span>[</span>root@itxdl ~<span>]</span><span># vim +20 /tmp/passwd.vi</span>
</code></pre>
<div><span>1</span><br></div></div><p>打开文件后，直接进入“nobody”字符串所在行，则可以这样操作：</p>
<div><pre><code><span>[</span>root@itxdl ~<span>]</span><span># vim +/nobody /tmp/passwd.vi</span>
</code></pre>
<div><span>1</span><br></div></div><p>如果文件中有多个“nobody”字符串，则会以查到的第一个为准。</p>
<h2 id="vim-的基本应用"> Vim 的基本应用</h2>
<p>打开文件后，接下来开始对文件进行编辑。Vim 虽然是一个基于文本模式的编辑器，但却提供了丰富的编辑功能。对于习惯使用图形界面的朋友来说，刚开始会较难适应，但是熟练后就会发现，使用 <code>Vim</code> 进行编辑实际上更加快速。</p>
<h3 id="插入命令"> 插入命令</h3>
<p>从命令模式进入<strong>输入模式</strong>进行编辑，可以按下 <kbd>i</kbd>、<kbd>I</kbd>、<kbd>a</kbd>、<kbd>A</kbd>、<kbd>o</kbd>、<kbd>O</kbd> 等键来完成，不同的键只是光标所处的位置不同而已。当进入输入模式后，你会发现，在 Vim 编辑窗口的左下角会出现“INSERT”标志（中文版本出现“插入”标志），这就代表我们可以执行写入操作了，如图11-3 所示。</p>
<div>
<p><img src="./assets/vim_insert.png" alt="vim insert" loading="lazy"></p>
<p><strong>图11-3	<u>输入模式</u></strong></p>
</div>
<p>常用的插入命令：</p>
<div><pre><code>i	——在当前光标所在位置插入随后输入的文本，光标后的文本相应向右移动
I 	——在光标所在行的行首插入随后输入的文本，行首是该行的第一个非空白字符，相当于光标移动到行首再执行 i 命令
a	——在当前光标所在位置之后插入随后输入的文本
A	——在光标所在行的行尾插入随后输入的文本，相当于光标移动到行尾再执行 a 命令
o	——在光标所在行的下面插入新的一行。光标停在空行的行首，等待输入文本
O	——在光标所在行的上面插入新的一行。光标停在空行的行首，等待输入文本
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><p>注意</p>
<p>在Linux 纯字符界面中，默认是不支持中文输入的。如果想要输入中文，则有三种方法。</p>
<ol>
<li>
<p>安装中文语言支持和图形界面，在图形界面下输入中文，使用 gVim（Vim 的图形前端）。</p>
</li>
<li>
<p>安装中文语言支持，使用远程连接工具（如 PuTTY )，在远程连接工具中调整中文编码，进行中文输入。</p>
</li>
<li>
<p>倘若非要在 Linux 纯字符界面中输入中文，则可以安装中文插件，如 zhcon。</p>
</li>
</ol>
</div>
<h3 id="光标移动命令"> 光标移动命令</h3>
<p>在进行编辑工作之前，需要将光标移动到适当的位置。Vim 提供了大量的光标移动命令，注意这些命令需要在<strong>命令模式</strong>下执行。下面介绍一些常用的光标移动命令。</p>
<ol>
<li><strong>以字符为单位移动</strong></li>
</ol>
<div><pre><code>上、下、左、右方向健		——移动光标
</code></pre>
<div><span>1</span><br></div></div><p>习惯使用鼠标的用户可能很自然地想到用鼠标来进行编辑定位，但是你会发现鼠标不会给你任何反应。在 Vim 中进行定位需要通过上、下、左、右方向键，并且无论是命令模式还是输入模式，都可以通过方向键来移动光标（在编辑模式中，方向键是用来查看命令历史记录的）。</p>
<div><pre><code>h、j、k、l					——移动光标
</code></pre>
<div><span>1</span><br></div></div><p>另外，还可以在命令模式中使用 h、j、k、l 四个字符控制方向，分别表示向左、向下、向上、向右。在大量编辑文档时，会频繁地移动光标，这时使用方向键可能会比较浪费时间，使用这 4 个键就很方便快捷。当然，这同样是一件熟能生巧的事情。</p>
<ol start="2">
<li>以单词为单位移动</li>
</ol>
<div><pre><code>w	——移动光标到下一个单词的词首
b	——移动光标到上一个单词的词首
e	——移动光标到下一个单词的词尾
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>有时候需要迅速进入一行中的某个位置，如果能使光标一次移动一个单词就会非常方便。可以在命令模式中使用“w”命令来使光标向后跳到下一个单词的词首，或者使用“b”命令使光标向前跳到上一个单词的词首，还可以使用“e”命令使光标跳到下一个单词的词尾。</p>
<ol start="3">
<li><strong>移动到行尾或者行首</strong></li>
</ol>
<div><pre><code>$		——移动光标到行尾
<span>0</span> 或 ^	——移动光标到行首
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>可以使用 <code>$</code> 命令将光标移至行尾，使用 <code>0</code> 或 <code>^</code> 命令将光标移至行首。其实，对于 <code>$</code> 命令来说，可以使用诸如 <code>n$</code> 之类的命令来将光标移至当前光标所在行的之后 n 行的行尾（n 为数字）：对于 <code>0</code> 命令来说却不可以，但可以用 <code>n^</code>。</p>
<ol start="4">
<li><strong>移动到一行的指定字符处</strong></li>
</ol>
<div><pre><code>f字符				——移动光标到第一个符合条件的字符处
</code></pre>
<div><span>1</span><br></div></div><p>如果在一行中需要将光标移动到当前行的某个特定字符处，则可以使用 <code>f</code> 命令。例如，某行内容为“you can you up，no can no bb”，现在需要将光标移动到字符 p 处，则可以使用“<code>fp</code>”命令，这样光标就会迅速定位到字符 p 处。<code>f</code> 命令有一个使用条件，即光标需在指定字符前。</p>
<ol start="5">
<li><strong>移动到匹配的括号处</strong></li>
</ol>
<div><pre><code>%		 			——在匹配的括号间切换
</code></pre>
<div><span>1</span><br></div></div><p>如果你是一名程序员，那么在使用 Vim 进行编辑时经常会为将光标移动到与一个 “<code>(</code>&quot; 匹配的 “<code>)</code>” （对于[ ]和{ }也是一样的）处而感到头疼。其实在 Vim 里面提供了一个非常方便地查找匹配括号的命令，这就是 <code>%</code> 。比如，在 <code>/etc/init.d/sshd</code> 脚本文件中（最好还是复制后练习，小心驶得万年船)，想迅速地将光标定位到与第 49 行的 “<code>{</code>” 相对应的 “<code>}</code>” 处，则可以将光标先定位在 “<code>{</code>” 处，然后再使用 <code>%</code> 命令，使之定位在 “<code>}</code>” 处，如图11-4 所示。关于定位文件指定的行，后续会有介绍。</p>
<div>
<p><img src="./assets/vim100.png" alt="vim %" loading="lazy"></p>
<p><strong>图11-4	<u>使用“%”命令定位括号</u></strong></p>
</div>
<ol start="6">
<li><strong>移动到指定行处</strong></li>
</ol>
<div><pre><code>nG 或 :n			——移动光标到指定的行
</code></pre>
<div><span>1</span><br></div></div><p>可以直接在命令模式中输入 <code>nG</code>（n 为数字，G 为大写）或  <code>:n</code>（在编辑模式中输入数字）命令将光标快速地定位到指定行的行首。这种方法对于快速移动光标非常有效。</p>
<h3 id="使用-vim-进行编辑"> 使用 Vim 进行编辑</h3>
<p>光标移动到指定位置后，如何进行编辑操作呢？Vim 提供了大量的编辑命令，下面介绍其中一些常用的命令。</p>
<ol>
<li><strong>查找指定字符串</strong></li>
</ol>
<div><pre><code>/要查找的字符串		——从光标所在行开始向下查找所需的字符串
?要查找的字符串		——从光标所在行开始向上查找所需的字符串
:set ic				——查找时忽略大小写
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>一个字符串可以是一个或者多个字母的集合。如果想在 Vim 中查找字符串，则需要在命令模式下进行。在 Vim 命令模式中输入 <code>/要查找的字符串</code>，再按一下回车键，就可以从光标所在行开始向下查找指定的字符串。如果要向上查找，则只需输入 <code>?要查找的字符串</code> 即可。例如，在 <code>/etc/passwd.vi</code> 文件中查找字符串“root”，则运行命令如图11-5 所示。</p>
<div>
<p><img src="./assets/vim_s_root.png" alt="vim_s_root" loading="lazy"></p>
<p><strong>图11-5	<u>使用 Vim 进行查找</u></strong></p>
</div>
<p>如果匹配的字符串有多个，则可以按 <kbd>n</kbd> 键向下继续匹配查找，按 <kbd>N</kbd> 键向上继续匹配查找。如果在文件中并没有找到所要查找的字符串，则在文件底部会出现“Pattern not found”提示（中文版本出现“找不到模式”），如图11-6 所示。</p>
<div>
<p><img src="./assets/vim_s_zdm.png" alt="vim_s_zdm" loading="lazy"></p>
<p><strong>图11-6	<u>未查找到指定字符串的提示</u></strong></p>
</div>
<p>在查找的过程中需要注意的是，要查找的字符串是严格区分大小写的，如查找“zhiling”和“ZhiLing”会得到不同的结果。如果想忽略大小写，则输入命令 <code>:set ic</code>；调整回来输入<code>:set noice</code>，如果在字符串中出现特殊符号，则需要加上转义字符“\”，常见的特殊符号有 <strong>\、?、^、$</strong> 等。如果出现这些字符，例如，要查找字符串“10$”，则需要在命令模式中输入 <code>/10\$</code>。还可以查找指定的行。例如，要查找一个以”root“为行首的行，则可以进行如下操作：</p>
<div><pre><code>/^root
</code></pre>
<div><span>1</span><br></div></div><p>要查找一个以“root”为行尾的行，则可以进行如下操作：</p>
<div><pre><code>/root$
</code></pre>
<div><span>1</span><br></div></div><ol start="2">
<li><strong>使用 Vim 进行替换</strong></li>
</ol>
<div><pre><code>r	——潜換光标所在处的字符
R	——从光标所在处开始替换字符，按 Esc 键结束
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>小写“r”可以替换光标所在处的某个字符，将光标移动到想替换的单个字符处，按下 <kbd>r</kbd> 键，然后直接输入替换的字符即可；大写“R”可以从光标所在处开始替换字符，输入会覆盖后面的文本内容，直到按 <kbd>Esc</kbd> 键结束替换，如图11-7 所示。</p>
<div>
<p><img src="./assets/vim_R.png" alt="vim R" loading="lazy"></p>
<p><strong>图11-7	<u>使用“R”进行替换</u></strong></p>
</div>
<p>按下 <kbd>R</kbd> 键替换后，Vim 编辑文件左下角会显示“REPLACE”（中文版为“替换”），进入替换状态。输入的内容会替换掉所在行光标后面的内容，直到按 <kbd>Esc</kbd> 键才会退出替换；否则将一直处于替换状态。</p>
<p>批量替换：</p>
<div><pre><code>:替换起始处,替换结束处 s/源字符串/替换的字符串/g	——替换范围内的字符串
:% s/源字符串/替换的字符串/g						——替换整篇文档的字符串
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果不加“g”，则只替换每行第一个找到的字符串。</p>
<p>假设要将 <code>/tmp/passwd.vi</code> 文件中所有的“root”替换为“liudehua”，则可以输入 <code>:1,$ s/root/liudehua/g</code> 或 <code>:% s/root/liudehua/g</code>。如图11-8 所示：</p>
<div>
<p><img src="./assets/vim_liudehua.png" alt="vim liudehua" loading="lazy"></p>
<p><strong>图11-8	<u>指定范围替换</u></strong></p>
</div>
<p>上述命令是在<strong>编辑模式</strong>下操作的，表示的是从第一行到最后一行，即全文查找“root”，然后替换成“liudehua”。</p>
<p>如果刚才的命令变成如下这样：</p>
<div><pre><code>:10,20 s/root/liudehua/g
</code></pre>
<div><span>1</span><br></div></div><p>则知替换从第 10 行到第 20 行的“root”。</p>
<ol start="3">
<li><strong>使用 Vim 进行删除、粘贴、复制</strong></li>
</ol>
<div><pre><code>x					——删除光标所在字符
nx					——从光标所在位置向后删除 n 个字符，n 为数字
<span>dd</span>					——删除整行。如果之后粘贴，则此命令的作用是剪切
ndd					——删除多行
dG					——删除从光标所在行到文件末尾的内容
D					——删除从光标所在处到这行行尾的内容
:起始行,终止行 d	——删除指定范围的行
yy 或 Y				——复制单行
nyy 或 nY			——复制多行
P					——粘贴到当前光标所在行下
p					——粘贴到当前光标所在行上
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>如果处于<strong>命令模式</strong>下，则可以按下 <kbd>x</kbd> 键来删除光标所在位置的单个字符；快速按两下 <kbd>d</kbd> 键来进行整行删除；如果想要删除连续多行，例如，想要删除 10 行，则可以按下<code>10dd</code>，可以快速删除当前光标所在行下 10 行。</p>
<p>此时被删除的内容并没有真正删除，都临时放在了内存中。将光标移动到指定位置处，按下 <kbd>p</kbd> 键，就可以将刚才删除的内容又粘贴到此处。在软件开发中可能需要将连续两行进行互换，就可以先将上面的一行通过 <code>dd</code> 键删除，再将光标移动到下面，通过 <kbd>p</kbd> 键将其重新粘贴，这样就能够达到两行互相交换位置的目的。 <code>dG</code> 键可以删除从光标所在行一直到文件末尾的全部内容，而 <kbd>D</kbd> 键可以删除从光标所在处到这行行尾的内容。如果要删除指定范围的行，则可以用 <code>:起始行,终止行 d</code>。如删除第 1～3 行，则输入 <code>:1,3 d</code>，如图11-9 所示，会提示“3 fewer lines”。（或“少了 3 行”）</p>
<div>
<p><img src="./assets/vim_1,3d.png" alt="vim 1,3d" loading="lazy"></p>
<p><strong>图11-9	<u>删除指定范围的行</u></strong></p>
</div>
<p>还可以通过 <code>yy</code> 键来复制单行，或者通过在前面加上数字来复制当前光标所在行下的多行。</p>
<p>有时候可能需要把两行进行连接。如在下面的文件中有两行，现在需要使其成为一行，实际上就是将两行同的换行符去掉。可以直接在命令模式中按下 <kbd>J</kbd> 键，按下前后如图11-10所示：</p>
<div>
<p><img src="./assets/vim_J.png" alt="J" loading="lazy"></p>
<p><strong>图11-10	<u>按下“J”之前和之后对比</u></strong></p>
</div>
<ol start="4">
<li><strong>使用 Vim 撤销上一步操作</strong></li>
</ol>
<div><pre><code>u	——撒销
</code></pre>
<div><span>1</span><br></div></div><p>如果不小心误删除了文件内容，则可以通过 <kbd>u</kbd> 键来撤销刚才执行的命令。如果要撤销刚才的多次操作，则可以多按几次 <kbd>u</kbd> 键。</p>
<h3 id="保存退出命令"> 保存退出命令</h3>
<p>估计前面一大堆的操作已经让你有些力不从心了，其实，这还只是总结出来的常用部分。不过对于日常使用基本足够了，不用死记硬背，只需多练习就能掌握。</p>
<p>Vim 的保存和退出是在<strong>命令模式</strong>中进行的，为了方便记忆，只需要记住 <strong>w、q、!</strong> 三个符号的含义即可完成保存任务。</p>
<div><pre><code>字母“w”	——保存不退出
字母“q”	——不保存退出
字符“<span>!</span>”	——强制性操作
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>例如，在命令模式中只輸入“w”字母就意味着保存但不退出；如果输入“wq”就意味着保存并且退出：如果输入“w!”或“wq！”就意味着强制保存或强制保存退出，这种情况经常发生在对一个文件没有写权限的时候（显示 “readonly” 或 “只读”，如图11-11 所示)，但如果你是文件的所有着或者 root 用户，就可以强制执行。</p>
<div>
<p><img src="./assets/vim_ro.png" alt="/vim_ro" loading="lazy"></p>
<p><strong>图11-11	<u>只读文件</u></strong></p>
</div>
<p>其他用法，如“q!”表示不保存退出：保留源文件，而另存为其他的文件，可以用 <code>w 新文件名</code>，如：<code>w /tmp/shadow.vi</code>。</p>
<p>在命令模式中，还可以输入 <code>ZZ</code> 命令退出，按两次 <kbd>Shif</kbd> + <kbd>Z</kbd> 快捷键比较方便，强烈推荐。此时如果对文件没有修改，就是不保存退出；如果对文件已经进行了一些修改，就是保存后退出。</p>
<h2 id="vim-的进阶应用"> Vim 的进阶应用</h2>
<p>以上介绍了 Vim 的常见用法，接下来给大家介绍一下 Vim 使用的小技巧。</p>
<h3 id="vim-配置文件"> Vim 配置文件</h3>
<p>在使用 Vim 进行编辑的过程中，经常会遇到需要同时对连续几行进行操作的情况，这时如果每行都有行号提示，就会非常方便。在命令模式下输入 <code>:set nu</code> 即可显示每一行的行号，如图11-12 所示。如果想要取消行号，则再次输入 <code>:set nonu</code> 即可。</p>
<div>
<p><img src="./assets/vim_nu.png" alt="vim_nu" loading="lazy"></p>
<p><strong>图11-12	<u>显示行号</u></strong></p>
</div>
<p>如果希望每次打开文件都默认显示行号，则可以编辑 Vim 的配置文件。每次使用 Vim打开文件时，Vim 都会到当前登录用户的宿主目录（用户配置文件所在位置）中读取 <code>.vimnc</code> 文件，此文件可以对 Vim 进行一-些默认配置设定。如果 <code>.vimrc</code> 文件存在，就先读取其中对 Vim 的设置；否则就采取默认配置。在默认情况下，用户宿主目录中是没有此文件的，需要在当前用户的宿主目录中手工建立，如 <code>vim ~/.vimne</code>，“~”代表宿主目录，root 的宿主目录为 <code>/root</code>，普通用户的宿主目录存放在 <code>/home/</code> 目录下。可以直接使用 Vim 編辑生成此文件，并在此文件中添加一行“set nu”，保存并退出，如图11-13 所示。</p>
<div>
<p><img src="./assets/vimrc.png" alt="vimrc" loading="lazy"></p>
<p><strong>图11-13	<u>.vimrc 配置文件</u></strong></p>
</div>
<p>之后此用户登录，每次 Vim 打开文件时，都会默认显示行号。后面将要讲到的 mmp，ab 等 Vim 命令也可以写入配置文件中，便于使用。常见的可以写入 <code>.vimrc</code> 文件中的设置参数如表11-1 所示。</p>
<p><strong>表11-1	<u>常见的可以写入 .vimrc 文件中的设置参数</u></strong></p>
<table>
<thead>
<tr>
<th>设置参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>:set nu</code><br /><code>:set nonu</code></td>
<td>设置与取消行号</td>
</tr>
<tr>
<td><code>:syn on</code><br /><code>:syn off</code></td>
<td>是否依据语法显示相关的颜色帮助。在 Vim 中修改相关的<br />配置文件或 Shell 脚本文件时，默认会显示相应的颜色，用来帮助排错。</td>
</tr>
<tr>
<td><code>:set hlsearch</code><br /><code>:set nohlcearch</code></td>
<td>设置是否将查找的字符串高亮显示。默认是 hlsearch 高亮显示</td>
</tr>
<tr>
<td><code>:set backup</code><br /><code>:set nobackup</code></td>
<td>是否保存自动备份文件。默认是 nobackup 不自动备份，<br />如果设定了:sel backup，则会产生“文件名~”作为备份文件</td>
</tr>
<tr>
<td><code>:set ruler</code><br /><code>:set noruler</code></td>
<td>设置是否显示右下角的状态栏默认是 ruler 显示</td>
</tr>
<tr>
<td><code>:set showmode</code><br /><code>:set noshowmode</code></td>
<td>设置是否在左下角显示如“--INSTALL--”之类的状态栏，默认是 showmode 显示</td>
</tr>
</tbody>
</table>
<p>设置参数实在太多了，这里只列举了常见的几个，可以使用 <code>:set all</code> 命令查看所有的设置参数。这些设置参数都可以写入 <code>.vimre</code> 配置文件中，让它们永久生效；也可以直接在 Vim 中执行，让它们临时生效。</p>
<h3 id="多窗口编辑"> 多窗口编辑</h3>
<p>在编辑文件时，有时需要参考另一个文件，如果在两个文件之间进行切换则比较麻烦。可以使用 Vin 同时打开两个文件，每个文件分别占用一个窗口。例如，在查看 <code>/etc/passwd</code> 时需要参考 <code>/etc/shadow</code>，有两种办法可以实现：可以先使用 Vim 打开第一个文件，接着输入命令 <code>:sp /etc/shadow</code> 水平切分窗口，然后按回车键，如果想垂直切分窗口则可以输入 <code>vs /etc/shadow</code>；也可以直接执行命令 <code>vim -o 第一个文件名 第二个文件名</code>，也就是 <code>vim -o /etc/passwd /etc/shadow</code>。得到的结果图11-14 所示。</p>
<div>
<p><img src="./assets/vim-o.png" alt="vim-o" loading="lazy"></p>
<p><strong>图11-14	<u>使用 Vim 打开多个窗口</u></strong></p>
</div>
<p>切换到另一个文件窗口，可以按 <kbd>Ctl</kbd>+<kbd>W</kbd><kbd>W</kbd> 快捷键。</p>
<p>如果想将一个文件的内容全部复制到另一个文件中，则可以输入命令 <code>:r 被复制的文件名</code>，即可将导入文件的全部内容复制到当前光标所在行下面。</p>
<h3 id="区域复制"> 区域复制</h3>
<p>通过前面的操作，大家会发现，Vim 是以行为单位进行整体编辑的。但是有时候需要对一些特定格式的文件进行某个范围的编辑，就需要使用区域复制功能。</p>
<p>举例来说，现在想将 <code>/etc/services</code> 文件（此文件记录了所有服务名与端口的对应关系）中的服务名都复制下来，就可以执行以下操作：先使用 Vim 打开 <code>/etc/scrvices</code> 文件，再将光标移动到需要复制的第一行处，然后按下 <kbd>Ctrl</kbd> + <kbd>V</kbd> 快捷键，这时底部状态栏出现“--VISUAL BLOCK--”（或“--可视 块--”），就可以使用上、下、左、右方向键进行区域的选取了；当全 <kbd>y</kbd> 健，然后将光标移动到目标位置处；按下 <kbd>p</kbd> 键，即可完成区域复制，如图11-15 所示。</p>
<div>
<p><img src="./assets/vim_vb.png" alt="vim vb" loading="lazy"></p>
<p><strong>图11-15	<u>区域复制</u></strong></p>
</div>
<h3 id="定义快捷键"> 定义快捷键</h3>
<p>使用 Vim 编辑 Shell 脚本，在进行调试时，需要进行多行的注释，每次都要先切换到输入模式，在行首输入注释符“#”，再退回命令模式，非常麻烦。连续行的注释其实可以用替换命令来完成。</p>
<p>在指定范围行添加“#”注释，可以使用 <code>:起始行,终止行 s/^/#/g</code>，例如：</p>
<div><pre><code>:1,10s /^/<span>#/g</span>
</code></pre>
<div><span>1</span><br></div></div><p>表示在第 1～10 行行首加“#”注释。“^”意为行首。“g”表示执行替换时不询问确认。如果希望每行交互询问是否执行，则可将“g”改为“c”。</p>
<p>取消连续行注释，则可以使用 <code>:起始行,终止行 s/#//g</code>，例如：</p>
<div><pre><code>:1,10s/^<span>#//g</span>
</code></pre>
<div><span>1</span><br></div></div><p>意为将行首的“#”替换为空，即删除。当然，使用语言不同，注释符号或想替换的内容不同，都可以采用此方法，添加“//”注释，要稍微麻烦一些，<code>:起始行,终止行 s/^/\/\//g</code>”，因为“/”前面需要加转义字符“\&quot;，所以写出来比较奇特，例如：</p>
<div><pre><code>:1,5s /^/<span>\</span>/<span>\</span>//g
</code></pre>
<div><span>1</span><br></div></div><p>表示在第 1～5 行行首加“//”注释。</p>
<p>以上方法可以解决连续行的注释问题，如果是非连续的多行就不灵了，这时我们可以定义快捷键简化操作。</p>
<p>格式如下：</p>
<div><pre><code>:map 快捷健 执行命令		——定义快捷键
</code></pre>
<div><span>1</span><br></div></div><p>如定义快捷键 <kbd>Ctrl</kbd>+<kbd>P</kbd> 为在行首添加“#”注释，可以执行 <code>:map ^P I#&lt;Esc&gt;</code>。其中“^P”为定义快捷键 <kbd>Ctrl</kbd>+<kbd>P</kbd>。注意：必须同时按 <kbd>Ctrl</kbd>+<kbd>V</kbd>+<kbd>P</kbd> 快捷键生成“^P”方可有效，或先按 <kbd>Ctrl</kbd>+<kbd>V</kbd> 再按 <kbd>Ctrl</kbd>+<kbd>P</kbd> 也可以，直接输入“^P”是无效的。</p>
<p>“I#&lt;Esc&gt;”就是此快捷键要触发的动作，“I”为在光标所在行行首插入，“#”为要输入的字符，“&lt;Esc&gt;”表示退回命令模式。“&lt;Esc&gt;”要逐个字符输入，不可直接按键盘上的 <kbd>Esc</kbd> 键。</p>
<p>设置成功后，直接在任意需要注释的行上按 <kbd>Ctrl</kbd>+<kbd>P</kbd> 快捷键，就会自动在行首加上“#”注释。取消此快捷键定义，输入 <code>:unmap ^P</code> 即可。我们可以延伸一下，如果想定义删除文件行首字符的快捷键，则可以设置 <code>:map ^B 0x</code>，快捷键为 <kbd>Ctrl</kbd>+<kbd>B</kbd>，“0”表示跳到行首，“x”表示删除光标所在处字符。</p>
<p>再如，有时我们写完脚本等文件，需要在末尾注释中加入自己的邮箱，则可以直接定义解次按快捷键 <kbd>Ctrl</kbd>+<kbd>E</kbd> 实现插入邮箱，定义方法为 <code>:map ^E asamlee@itxdl.net&lt;Esc&gt;</code>。其中，“a”表示在当前字符后插入，“samlee@itxdl.net“为插入的邮箱，”&lt;Esc&gt;“表示插入后返回命令模式。</p>
<p>所以，通过定义快捷键，我们可以把前面讲到的命令组合起来使用。</p>
<p>将快捷键对应的命令保存在<code>.vimrc</code> 文件中，即可在每次使用 Vim 时自动调用，非常方便。</p>
<h3 id="在-vim-中与-shell-交互"> 在 Vim 中与 Shell 交互</h3>
<p>在 Vim中，可以在编辑模式下用 <code>!</code> 命令来访问 Linux 的 Shell 以进行操作。命令格式如下：</p>
<div><pre><code>:<span>!</span> 命令
</code></pre>
<div><span>1</span><br></div></div><p>直接在 <code>!</code> 后面跟所要执行的命令即可，这样可以在系统中直接查看命令的执行结果。例如，在编辑过程中想查看一下 <code>/etc/passwd</code> 文件的权限，则可以使用如下命令：</p>
<div><pre><code>:<span>!</span> <span>ls</span> -l /etc/passwd
</code></pre>
<div><span>1</span><br></div></div><p>执行后，会在当前编辑文件中显示命令的执行结果，完毕后会提示用户按回车键返回编辑状态。如图11-16 所示。</p>
<div>
<p><img src="./assets/vimi0.png" alt="vim" loading="lazy"></p>
<p><strong>图11-16	<u>与 shell 交互</u></strong></p>
</div>
<p>如果想把命令的执行结果导入编辑文件中，则还可以与导入命令 <code>r</code> 一起使用。如在编辑完文件后，在文件未尾加入当前时间，命令如下：</p>
<div><pre><code>:r <span>!</span>date
</code></pre>
<div><span>1</span><br></div></div><p>这也是一种可以展开想象的使用方法，这里就不再举例了，大家可以自行尝试。</p>
<h3 id="文本格式转换"> 文本格式转换</h3>
<p><code>unix2dos</code> 和 <code>dos2unix</code> 命令可实现文本格式转换的功能。从命令名称即可得知，这两个文本操作命令是在 UNIX 与 DOS 文件格式之间进行数据转换的。在实际应用中，管理员经常会把 Linux 平台上的重要文档放到自己的 Windows 工作站上保存和查看，而这两种平台之间的文本在互相查看的时候可能会因为一些控制符号的存在而使屏幕显得很乱，甚至无法使用。这时就需要用到这两个转换命令。</p>
<div><p>注意</p>
<p>在默认安装时，<code>dos2unix</code> 和 <code>unix2dos</code> 命令是没有的，需要手工安装。先放入安装光盘，如果是 VMware，则加载一下 ISO 安装镜像，然后挂载光盘。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mount /dev/cdrom /mnt/cdrom</span>
<span>[</span>root@localhost ~<span>]</span><span># rpm -ivh /mnt/cdrom/Packages/dos2unix-3.1-37.e16.1686.rpm</span>
<span>[</span>root@localhost ~<span>]</span><span># rpm -ivh /mnt/cdrom/packages/unix2dos-2.2-35.e16.1686.rpm</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>不同版本的 Linux，以上 RPM 包版本号可能有差别，但方法相同。</p>
<p>Ubuntu 系统使用的是 <code>todos</code> 和 <code>fromdos</code>，命令的字面意思也很好理解，都在 tofrodos 包里，安装如下：</p>
<div><pre><code><span>[</span>root@ubuntu ~<span>]</span><span># sudo apt install tofrodos</span>
</code></pre>
<div><span>1</span><br></div></div></div>
<p>不少人喜欢将 Linux 的 Shell 脚本备份存放在 Windows 个人计算机上，有时会在 Windown 上进行更改，但是再复制到 Linux 中可能就无法执行了。</p>
<p>在 Windows 文件中，列的结束符号有两个控制字符：一个是归位字符（Carriage Retwm，^M），另一个是换行字符（New Line，^J）；但在 Linux 文件中只使用一个换行字符“\n”（功能同 ^J）。所以，当 Linux 中的文本文件放到 Windows 上用文本编辑器编辑时，会乱成首尾相连的一行。</p>
<p><code>unix2dos</code> 命令的作用就是把 Linux 中的行尾符号 “n\” 转换成 Windows 中使用的 “^M^J”。命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># unix2dos 源文件名</span>
<span>[</span>root@localhost ~<span>]</span><span># dos2unix 源文件名</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如下命令可更新 <code>ls.man. txt</code> 文件，再复制到 Windows 中查看就正常了。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># unix2dos ls.man.txt</span>
</code></pre>
<div><span>1</span><br></div></div><p>可以想象，<code>dos2unix</code> 命令的作用正好相反，即把 Windows 文档中的行尾符号“^M^J”转换为“^J”。命令格式也相同，如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># dos2unix backup.sh</span>
</code></pre>
<div><span>1</span><br></div></div><p>在 Windows 上编辑后无法执行的 Shell 脚本就是通过上面的命令来解决的。</p>
<h3 id="vim-的宏记录"> Vim 的宏记录</h3>
<p>有时候需要对某些行进行相同的改动，如果逐一对每行进行修改则比较麻烦。Vim 提供了非常优秀的宏记录功能，下面举例说明。</p>
<p>现在有一个文件名列表，如图11-17 所示。</p>
<div>
<p><img src="./assets/vim@1.png" alt="vim@1" loading="lazy"></p>
<p><strong>图11-17	<u>文件名列表</u></strong></p>
</div>
<p>假设这是我们所需的库文件名列表，需要将其编辑成如图11-18 所示的格式。</p>
<div>
<p><img src="./assets/vim@2.png" alt="vim@2" loading="lazy"></p>
<p><strong>图11-18	<u>需要完成的文件格式</u></strong></p>
</div>
<p>可以看到，如果行数比较多，那么一行一行地修改会比较麻烦。可以使用宏记录的方式来完成。</p>
<ol>
<li>在命令模式中将光标移动到 zhaoyun.h 行的行首，按下 <code>qx</code> 键，其中“q”代表宏记录，“x”代表给宏起的名，可以是任意字符，这时候可以发现，在屏幕左下角会出现“rcording”（或“记录中”）字样，如图11-19 所示。</li>
</ol>
<div>
<p><img src="./assets/vim@3.png" alt="vim@3" loading="lazy"></p>
<p><strong>图11-19	<u>开始进行宏记录</u></strong></p>
</div>
<ol start="2">
<li>将第一行设置成下图中第一行所示的形式。当修改完成后，接 <kbd>Ese</kbd>键回到命令模式，再按下 <kbd>q</kbd> 键退出宏记录模式，如图11-20 所示。</li>
</ol>
<div>
<p><img src="./assets/vim@4.png" alt="vim@4" loading="lazy"></p>
<p><strong>图11-20	<u>完成宏记录</u></strong></p>
</div>
<ol start="3">
<li>当宏记录完成后，就可以执行它了。执行的方法是将光标移动到需要进行修改的行首，然后执行 <code>@宏名</code> 命令即可。如本例就可以将光标移动到第二行行首，然后执行 <code>@x</code> 命令，其他的行以此类推，最后得到图11-18 所示的效果。</li>
</ol>
<h3 id="ab-命令的小技巧"> ab 命令的小技巧</h3>
<p>在 Vim 中可以使用 <code>map</code> 定义快捷键，如输入电子邮箱、通信地址、联系电话……但是定义太多，难以记住，此时可以在编辑模式中使用神奇的 <code>ab</code> 命令。命令格式如下：</p>
<div><pre><code>:ab 替代符 原始信息
</code></pre>
<div><span>1</span><br></div></div><p>示例如下：</p>
<div><pre><code>:ab mymail samlee@itxal.cn
:ab xdl http://mge.itxdl.cn
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>执行之后，在任何地方输入 <code>mymail</code>、<code>xdl</code>，再敲任意非字母，非数字的符号（如句号，逗号等)，或者回车，或者空格，马上就会变成对应的邮箱和网址，非常方便。Linux 的编辑工具当然不止 Vim 一种，如大名鼎痛的 Emacs、类似 DOS 下的 cdit 程序的 Pico、名字很华丽的午夜执行官 MC（Midnight Commander）……不过 Vim 如终是 Linux 平台上默认及应用最为广泛的文本编辑器，是编辑器中的“霸主”。虽然初学时可能应用起来比较吃力，但是一旦用熟，必将爱不释手。</p>
<h2 id="文本编辑器-nano"> 文本编辑器 nano</h2>
<p>nano 是 Linux 中的一款功能非常简单的文本编辑器，该编辑器支持鼠标功能，因此非常容易上手。标准的 Ubuntu 系统默认都安装了nano文本编辑器。</p>
<p>命令格式：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># nano [选项] 文件名</span>
选项：
	-w	：禁止 <span><span>`</span><span>nano</span><span>`</span></span> 自动换行，这个选项在编辑系统配置文件时比较有用，防止因自动换行而对配置文件产生误解
	-m	：启用鼠标支持，开启此选项在使用SSH远程连接时也可以使 <span>nano</span> 支持鼠标。如果忘了添加 -m 选项，在启动 <span>nano</span> 后也可以通过快捷键 Alt+M 启用鼠标支持。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>在 <code>nano</code> 打开或新建文件之后，下方有常用快捷键的提示，配合<kbd>Ctrl</kbd>键使用，使用更方便，不用怕忘记命令。如图11-21 所示：</p>
<div>
<p><img src="./assets/nano.png" alt="nano" loading="lazy"></p>
<p><strong>图11-21	<u>nano 命令打开文件</u></strong></p>
</div>
<p><strong>表11-2	<u>nano 命令的常用快捷键及作用</u></strong></p>
<table>
<thead>
<tr>
<th>按键</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><kbd>Ctrl</kbd>+<kbd>O</kbd></td>
<td>保存文件</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd>+<kbd>X</kbd></td>
<td>退出编辑器</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd>+<kbd>K</kbd></td>
<td>剪切行</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd>+<kbd>U</kbd></td>
<td>粘贴</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd>+<kbd>\</kbd></td>
<td>替换</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd>+<kbd>W</kbd></td>
<td>查找</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd>+<kbd>G</kbd></td>
<td>调用帮助菜单</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-05-06T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">linux软件安装</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_basic/11.linux_soft_install/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_basic/11.linux_soft_install/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>计算机没有安装操作系统，就是一坨废铁，不能实现任何功能；如果计算机安装了换作系统，但没有应用软件，也只是中看不中用的花瓶。所以我们需要学习软件的安装，只有安装了所需的软件，才能实现想要的功能。比如，想要上网就需要安装浏览器，想要看小电影就需要安装视频播放器。</p>
<p>很多初学者会很困惑：Linux 中的软件安装方法是否和 Windows 中的软件安装方法一样呢？Windows 中的软件是否可以直接安装到 Linux 上呢？理想很美好,现实很骨感，答案是否定的，Linux 和 Windows 是完全不同的操作系统，软件包管理是截然不同的。有一个坏消息和一个好消息，坏消息是我们需要重新学习一种新的软件包管理方法，而且 Linux 软件包的管理要比 Windows 软件包的管理复杂得多；好消息是 Windows 下所有的软件都不能在 Linux 中识别，所以 Windows 中大量的木马和病毒也都无法感染 Linux。</p>
<h2 id="软件包管理简介"> 软件包管理简介</h2>
<h3 id="软件包的分类"> 软件包的分类</h3>
<p>Limux 下的软件包众多，而且几乎都是经 GPL 授权的，也就是说这些软件都免费，振奋人心吧？而且更棒的是，这些软件几乎都提供源代码（开源的），只要你愿意，就可以修改程序源代码，以符合个人的需求和习惯。当然，你要具备修改这些软件的能力才可以。</p>
<p><strong>源码包</strong>到底是什么呢？其实就是软件工程师使用特定的格式和语法所书写的文本代码，是人写的计算机语言的指令，一般由英文单词组成。是不是有点晕？其实源代码程序就是程序员写的计算机指令，符合特定的格式和语法。那么，众所周知，计算机可以识别的是机器语言，也就是二进制语言，所以需要一名翻译官把 abcd 翻译成二进制机器语言。我们一般把这名翻译官称为<strong>编译器</strong>，它的作用就是把人能够识别的 abcd 翻译成二进制机器语言，让计算机可以识别并执行。</p>
<p>源码包不用担心收费问题，但是我并不会 C 语言怎么办？那一大堆的源代码程序到底如何使用呢？这个源码包容易安装吗？源码包的安装因为要把源代码编译为二进制语言，所以安装的时间较长。比如，在 Windows 下大家可能安装过 QQ，现在的 QQ 功能较多，程序相对较大，大概有 60MB，但由于 QQ 并不是以源代码形式发布的，而是经过编译之后发布的，所以只需要几分钟并经过简单的配置就可以安装成功，安装时间较短（当然功能也基本不能自定义)。在 Linux 中安装一个 MySQL 数据库，这个数据库的压缩包大概有 23MB，需要多长时间呢？答案是 30 分钟左右（根据计算机硬件配置不同)。这样看来编译还是很浪费时间的，而且绝大多数用户并不熟悉写程序的语言，所以我们要祈祷程序不要报错，否则对初学者来讲很难解决。</p>
<p>为了解决源码包的这些问题，在 Linux 中就出现了<strong>二进制包</strong>，也就是源码包经过编译之后的包。这种包因为编译过程在发布之前已经完成，所以用户安装时速度较快（和 Windows 下安装软件速度相当)，而且报错也大大减少。<u>二进制包是 Linux 下的默认安装软件包，所以有时我们也把二进制包称作默认安装软件包。</u>目前主要有两个系列的二进制包管理系统：一个是 Red Hat 上的 <strong>RPM 包管理系统</strong>：另一个是 Debian 和 Ubuntu 上的 <strong>DPKG 包管理系统</strong>。不过这两个系列的二进制包管理的原理与形式大同小异，可以触类旁通。</p>
<p>说了这么多，到底源码包和二进制包哪个好呢？举个例子，我们想做一套家具，源码包就像所有的家具完全由自己动手手工打造（手工编译)，想要什么样的板材、油漆、颜色和样式都由自己决定（功能自定义，甚至可以修改源代码)。想想就觉得爽，完全不用被黑心的厂商所左右，而且不用担心质量问题（软件更适合自己的系统，效率更高，更加稳定)。但是，所花费的时间大大超过了买一套家具的时间（编译浪费时间)，而且我自己真的有做木工活这个能力吗（需要对源代码非常了解）？就算请别人定制好的家具，再由我自己组装，万一哪个部件不匹配（报错很难解决)，怎么办？那么二进制包呢？也是我需要一套家具，可是我去商场买了一套（安装简单)，家具都是现成的，不会有哪个部件不匹配，除非因为我没有量好尺寸而导致放不下（报错很少)。但是我完全不知道这套家具用的是什么材料、油漆是否合格，而且家具的样式也不能随意选择（软件基本不能自定义功能）。</p>
<p>好了，通过这个例子大家可以了解源码包和二进制包有什么区别了吧，稍后会再解释一下每种包的特点。</p>
<h3 id="源码包的特点"> 源码包的特点</h3>
<p>源码包既然是软件包，就不会是一个文件，而是多个文件的集合。出于发行的需要，我们一般会把源码包打包压缩之后发布，而 Linux 中最常用的打包压缩格式是“*.tar.gz”，所以我们也把源码包叫作 Tarball。源码包需要大家自己去软件的官方网站进行下载。</p>
<p>源码包的压缩包中一般会包含如下内容:</p>
<ul>
<li>
<p>源代码文件。</p>
</li>
<li>
<p>配置和检测程序（如 configure 或 config 等)。</p>
</li>
<li>
<p>软件安装说明和软件说明（如 INSTALL 或 README）。</p>
</li>
</ul>
<p>源码包的优点如下：</p>
<blockquote>
<ul>
<li>
<p>开源。如果你有足够的能力，则可以修改源代码。</p>
</li>
<li>
<p>可以自由选择所需的功能。</p>
</li>
<li>
<p>因为软件是编译安装的，所以更加适合自己的系统，更加稳定，效率也更高。</p>
</li>
<li>
<p>卸载方便。</p>
</li>
</ul>
</blockquote>
<p>源码包的缺点如下：</p>
<blockquote>
<ul>
<li>
<p>安装过程步骤较多，尤其是在安装较大的软件集合时（如 LAMP 环境搭建），容易出现拼写错误。</p>
</li>
<li>
<p>编译过程时间较长，安装时间比二进制包安装要长。</p>
</li>
<li>
<p>因为软件是编译安装的，所以在安装过程中一旦报错，新手很难解决。</p>
</li>
</ul>
</blockquote>
<h3 id="二进制包的特点"> 二进制包的特点</h3>
<p>二进制包是在软件发布的时候已经进行过编译的软件包，所以安装速度比源码包快得多（和 Windows 下软件安装速度相当）。但是因为已经进行过编译，大家也就不能再看到软件的源代码了。目前两大主流的二进制包系统是 DPKG 包和 RPM 包。</p>
<ul>
<li>
<p>DPKG 包是由 Debian Linux 所开发的包管理机制，通过 DPKG 包，Debian Linux 就可以进行软件包管理，主要应用在 Debian 和 Ubuntu 中。（一般是   *.deb 格式）</p>
</li>
<li>
<p>RPM 包是由 Red Hat 公司所开发的包管理系统，功能强大，安装、升级、查询和卸载都非常简单和方便。目前很多 Linux 版本都在使用这种包管理方式，包括 Fedon、CentOS、SuSE 等。（一般是 *.rpm 格式）</p>
</li>
</ul>
<p>二进制包的优点如下：</p>
<blockquote>
<ul>
<li>
<p>包管理系统简单，只通过几个命令就可以实现包的安装、升级、查询和卸载。</p>
</li>
<li>
<p>安装速度比源码包安装快得多。</p>
</li>
</ul>
</blockquote>
<p>二进制包的缺点如下：</p>
<blockquote>
<ul>
<li>
<p>经过编译，不能再看到源代码。</p>
</li>
<li>
<p>功能选择不如源码包灵活。</p>
</li>
<li>
<p>依赖性。有时我们会发现，在安装软件包 a 时需要先安装 b 和 c，而在安装 b 时需要先安装 d 和 e。这就需要先安装 d 和 e，再安装 b 和 c，最后才能安装 a。比如，我买了一个漂亮的灯具，打算安装到客厅里，可是在安装灯具之前，客厅总要有顶棚吧，顶棚总要刷好了油漆吧。装修和安装软件其实类似，总要有一定的顺序，但是有时依赖性会非常强。</p>
</li>
</ul>
</blockquote>
<h2 id="包管理命令"> 包管理命令</h2>
<h3 id="二进制包命名规则"> 二进制包命名规则</h3>
<p>大多数Linux应用软件包的命名也有一定的规律，他遵循： <strong>名称-版本-修正版-可用平台-类型</strong></p>
<p>如 wps-office-11.1.0.10161-1.x86_64.rpm。他是 Redhat Linux 提供的一种包封装格式。</p>
<blockquote>
<ul>
<li>软件名称：wps-office</li>
<li>版本号：11.1.0.10161</li>
<li>修正版本：1</li>
<li>可用平台：x86_64，适用于 x86 平台</li>
<li>类型：rpm，说明是个rpm包。</li>
</ul>
</blockquote>
<p><em>如 wps-office_11.1.0.10161-1_amd64.deb。他是 Debain Linux 提供的一种包封装格式。</em></p>
<blockquote>
<ul>
<li><em>软件名称：wps-office</em></li>
<li><em>版本号：11.1.0.10161</em></li>
<li><em>修正版本：1</em></li>
<li><em>可用平台：amd64，适用于 x86 平台</em></li>
<li><em>类型：deb，说明是个deb包。</em></li>
</ul>
</blockquote>
<div><p>注意</p>
<p>我们把 ngin-1.16.1-2.el7.x86_64.rpm（<em>或者 nginx_1.20.0-1~bionic_amd64.deb</em>）
叫作包全名，而把 nginx 叫作包名。为什么要做出特殊说明呢？因为有些命令后面一定跟的是包全名，如安装和升级；而有些命令后面一定跟的是包名，如查询和卸载。如果弄错，命令就会报错。</p>
</div>
<h3 id="包的依赖性"> 包的依赖性</h3>
<p>很多人不喜欢 RPM 包管理系统（<em>DPKG 包管理系统</em>），是因为它的依赖性。我们看看示意图，如图12-1 所示。</p>
<div>
<p><img src="./assets/bao_yilai.png" alt="bao_yilai" loading="lazy"></p>
<p><strong>图12-1	<u>RPM包的依赖性</u></strong></p>
</div>
<p>刚刚说过，假设我们要安装软件包 a，则可能需要先安装软件包 d 和 e，再安装软件包 b 和 c 才行。有时这种依赖可能会有几十个之多，当然这也要看你的系统默认安装了哪些软件。</p>
<p>但这还不是最可怕的，最可怕的依赖性是什么呢？我们来安装一个 RPM 包 mysql-connector-odbc。这里我们并非讲解安装命令，所以先不说安装命令，只是来看一下安装这个软件的报错。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># rpm -ivh /mnt/CentOS/mysql-connector-odbc-3.51.26r1127-1.e15.i386.rpm</span>
<span>#安装指定软件包</span>
warning:/mnt/centOS/mysql-connector-odbc-3.51.26r1127-1.e15.1386.rpm: HeaderV3 DSA signature: NOKEY， key ID e8562897
error: Failed dependencies:
       libodbcinst.so.1 is needed by mysql-connector-odbc-3.51.26r1127-1.e15.1386
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这个报错很明显是依赖性错误（error: Failed dependencies:），也就是说，在安装 mysql-connector-odbe 前需要先安装 libodbcinst.so.1 这个软件包。那还不简单，在光盘中找到这个软件包安装上不就行了吗？可是问题来了,我们找遍了两张光盘，发现居然没有叫 libodbcinst.so.1 的软件包，这是怎么回事？原因很简单，我们一直在说 RPM 软件包，既然是软件包，那么包中就不止有一个文件，而我们刚刚依赖的 libodbcinst.so.1 这个库文件只是包中的一个文件而己。如果想要安装 libodbcinst.so.1 这个库文件，就必须安装它所在的软件包。怎么知道这个库文件属于哪个软件包呢？因为库文件名不和它所属的软件包名类似，所以很难确定这个库文件属于哪个软件包。RPM 包管理系统也发现了这个问题，它给我们提供的解决办法是一个网站&lt;www.rpmfind.net&gt;</p>
<p>在搜索框中输入要查找的库文件名，如 libodbcinst.so.1，单击“Search”按钮，网站会帮你查询出此库文件所在的软件包。如果在 CentOS 系统中，那么搜索结果是这个库文件团于 unixODBC-libs-2.2.11-10.el5.i386.rpm 软件包。所以，只要安装了 unixODBC-libs-22.11-10.el5.i386.rpm 软件包，那么库文件 libodbcinst.so.1 就会自动安装。</p>
<hr>
<p><em>同样，DPKG 包也是有依赖的问题，解决方法是在安装的时候提示缺少依赖提示后，紧接着输入如下命令，即可解决依赖包问题。</em></p>
<div><pre><code><span>sudo</span> <span>apt-get</span> -f -y <span>install</span>
</code></pre>
<div><span>1</span><br></div></div><hr>
<div><p>注意</p>
<p>并不是安装 mysql-connector-odbe 包一定会报缺少 libodbcinst.so.1 库文件的错误，这和你的系统安装方式有关。如果你的系统默认已经安装好了 unixODBC-libs，就不会报剛刚的错误。那什么是库文件呢？库文件是系统写好的实现一定功能的计算机程序，其他软件如果需要这个功能，就不用再自己写了，直接拿过来使用就可以了，大大加快了软件开发速度。比如，我喜欢玩高达模型，这个模型是已经做好的一个一个的零件，自己组装的时候，只要把这些零件组装在一起就可以了，而不用自己去制作这些零件，大大简化了模型组装的难度。</p>
</div>
<h3 id="包的安装与升级"> 包的安装与升级</h3>
<p>说了这么多，终于可以开始安装了，我们先安装 apache 程序。之所以选择安装 apache 程序，是因为我们后续安装源码包时也计划安装 apachc 程序，这样就能初步认识到源码包和 RPM 的区别。不过需要注意的是，同一个程序的 RPM 包和源码包可以安装到一台服务器上，但是只能启动一个，因为它们需要占用同样的 80 端口。不过，如果真在生产服务器上，那么一定不会同时安装两个 apache 程序，容易把管理员搞糊涂，而且会占用更多的服务器磁盘空间。</p>
<ol>
<li><strong>RPM 包默认安装路径</strong></li>
</ol>
<p>源码包和 RPM 包安装的程序为什么可以在一台服务器上呢？主要是因为安装路径不同，所以不会覆盖安装。RPM 包一般采用系统默认路径安装，而源码包一般通过手工指定安装路径（一般安装到 <code>/usr/local/</code> 中）安装。</p>
<p>RPM 包（ <em>DPKG 包同样</em>）默认安装路径是可以通过命令查询的，一般安装在如表12-1 所示的目录中。</p>
<p><strong>表12-1	<u>RPM包默认安装路径</u></strong></p>
<table>
<thead>
<tr>
<th>安装路径</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>/etc/</td>
<td>配置文件安装目录</td>
</tr>
<tr>
<td>/usr/bin/</td>
<td>可执行命令安装目录</td>
</tr>
<tr>
<td>/usr/lib/</td>
<td>程序所使用的函数库保存位置</td>
</tr>
<tr>
<td>/usr/share/doc/</td>
<td>基本的软件使用手册保存位置</td>
</tr>
<tr>
<td>/usr/share/man/</td>
<td>帮助文件保存位置</td>
</tr>
</tbody>
</table>
<p>RPM 包（<em>DPKG 包</em>）难道就不能手工指定安装路径吗？当然是可以的，但是一旦手工指定安装路径，所有的安装文件就会安装到手工指定位置，而不会安装到系统默认位置。而系统的默认搜索位置并不会改变，依然会去默认位置之下搜索，当然系统就不能直接找到所需的文件，也就失去了作为系统默认安装路径的一些好处。所以我们一般不会指定 RPM 包的安装路径，而使用默认安装路径。</p>
<ol start="2">
<li><strong>RPM 包的安装</strong></li>
</ol>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># rpm -ivh 包全名</span>
选项：
	-i	：安装（install）
	-v	：显示更详细的信息（verbose）
	-h	：打印 <span>#，显示安装进度（hash）</span>
<span>#注意一定是包全名。如果是跟包全名的命令，则要注意路径，因为软件包在光盘当中</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>例如，安装 apache 软件包，注意出现两个 100% 才是正确安装，第一个 100%仅是在准备，第二个 100%才是正确安装。</p>
<div><pre><code>例子1：
<span>[</span>root@localhost ~<span>]</span><span># rpm -ivh /mnt/cdrom/Packages/httpd-2.2.15-15.e16.centos.1.i686.rpm</span>
Preparing<span>..</span>.		<span>################################################################# [100%]</span>
    <span>1</span>:httpd			<span>################################################################# [100%]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果打算同时安装多个软件包呢？可以用一条命令同时安装，将多个软件包用空格分开就可以了。</p>
<hr>
<p><em>DPKG 包的安装</em></p>
<div><pre><code><span>[</span>root@ubuntu ~<span>]</span><span># dpkg -i 包全名</span>
选项：
	-i	：安装（install）
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ol start="3">
<li><strong>RPM 包的升级</strong></li>
</ol>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># rpm -Uvh 包全名</span>
选项：
	-U	：升级安装。如果没有安装过，则系统直接安装。如果安装过的版本较低，则升级到新版本（upgrade）
	-F	：升级安装。如果没有安装过，则不会安装。必须安装有较低版本才能升级（freshen）
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><hr>
<p><em>DPKG 包的升级</em></p>
<div><pre><code><span>[</span>root@ubuntu ~<span>]</span><span># dpkg -i 包全名</span>
<span>#和安装命令一样</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><hr>
<h3 id="包的查询"> 包的查询</h3>
<p>RPM 包管理工具是非常强大和方便的包管理工具，它比源码包的方便之处就在于可以使用命令查询、升级和卸载。在查询的时候，其实是在查询 <code>/var/lib/rpm/</code> 这个目录下的数据库文件，那为什么不直接查看这些文件呢？你可以尝试使用 Vim 查看这些文件，会发现都是乱码，也就是说，这些文件其实都是二进制文件，不能直接用编辑器查看，所以才需要使用命令查看。</p>
<p>RPM 查询命令采用如下格式：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># rpm [选项] 查询对象</span>
选项：
	-q	：查询（query）
	-a 	：查询所有已安装的包（all）
	-i 	：查询软件信息（information）
	-p	：查询没有安装的软件包（package）
	-l	：列出软件包中所有的文件列表和软件所安装的目录（list）
	-f	：查询系统文件属于哪个软件包（file）
	-R	：查询软件包的依赖性（requires）
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><strong>表12-2	<u>常用 rpm 命令</u></strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>rpm -q 包名</code></td>
<td>查询软件包是否安装</td>
</tr>
<tr>
<td><code>rpm -qa</code> <br /><code>rpm -ga | grep 包名</code></td>
<td>查询系统中的所有安装软件包<br />查询系统中的已安装，指定包名的软件包</td>
</tr>
<tr>
<td><code>rpm -qi 包名</code><br /><code>rpm -qip 包全名</code></td>
<td>查询软件包的详细信息<br />查询还没有安装的软件包的详细信息</td>
</tr>
<tr>
<td><code>rpm -ql 包名</code><br /><code>rpm -qlp 包全名</code></td>
<td>查询软件包中的文件列表<br />查询还没有安装的软件包中的文件列表</td>
</tr>
<tr>
<td><code>rpm -qf 文件名</code></td>
<td>查询文件属于哪个 RPM 包</td>
</tr>
<tr>
<td><code>rpm -qR 包名</code><br /><code>rpm -qRp 包名</code></td>
<td>查询软件包所依赖的软件包<br />查询没有安装的软件包所依赖的软件包</td>
</tr>
</tbody>
</table>
<p><em>DPKG 包的查询</em></p>
<p><em>dpkg 包管理工具同样是非常强大和方便的包管理工具，可以实现软件包的安装、卸载、查询、编译、打包等功能。</em></p>
<p><em>dpkg（Debian Package）管理工具 ，Ubuntu 相关的软件包文件使用 .deb 后缀，就是因为 Ubuntu 与 Debian GNU/Linux 发行版有着紧密的关系。</em></p>
<div><pre><code><span>[</span>root@ubuntu ~<span>]</span><span># dpkg [选项] 查询对象</span>
选项：
	-l	：简明地列出软件包的状态（list），后面跟着包名则显示该包名的软件包状态
	-s	：显示指定软件包的详细状态（status）
	-L	：列出属于指定软件包的文件（listfiles）
	-c	：列出没有安装的软件包中的文件列表（contents）
	-I	：（大写 i）查询还没有安装的软件包的详细信息（info）
	-S	：（大写 s）搜索含有指定文件的软件包（search）
	-x	：解压 deb 格式的包
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><strong>表12-3	<u>常用 dpkg 命令</u></strong></p>
<table>
<thead>
<tr>
<th><em>命令</em></th>
<th><em>说明</em></th>
</tr>
</thead>
<tbody>
<tr>
<td><em><code>dpkg -l 包名</code></em></td>
<td><em>查询软件包是否安装</em></td>
</tr>
<tr>
<td><em><code>dpkg -l</code></em><br /><em><code>dpkg -l 包名</code></em></td>
<td><em>查询系统中的所有安装软件包</em><br /><em>查询系统中的已安装，指定包名的软件包</em></td>
</tr>
<tr>
<td><em><code>dpkg -s 包名</code></em><br /><em><code>dpkg -I 包全名</code></em></td>
<td><em>查询软件包的详细信息</em><br /><em>查询还没有安装的软件包的详细信息</em></td>
</tr>
<tr>
<td><em><code>dpkg -L 包名</code></em><br /><em><code>dpkg -c 包全名</code></em></td>
<td><em>查询软件包中的文件列表</em><br /><em>查询还没有安装的软件包中的文件列表</em></td>
</tr>
<tr>
<td><em><code>dpkg -S 文件名</code></em></td>
<td>查询文件属于哪个 DPKG 包</td>
</tr>
<tr>
<td><em><code>dpkg -s 包名 | grep Depends</code></em><br /><em><code>dpkg -I 包全名 | grep Depends</code></em></td>
<td><em>查询软件包所依赖的软件包</em><br /><em>查询没有安装的软件包所依赖的软件包</em></td>
</tr>
</tbody>
</table>
<h3 id="包的卸载"> 包的卸载</h3>
<p>卸载也是有依赖性的。比如，在安装的时候，要先安装 httpd 软件包，再安装 htpd 的功能模块 mod_ ssl 包。那么，在卸载的时候，一定要先卸载 mod_ssl 软件包，再卸载 htpd 软件包，否则就会报错。软件包卸载和拆除大楼是一样的，你要拆除 2 楼和3 楼，一定要先拆除 3 楼；如果非要先拆除 2 楼，那么 3 楼该存在于什么地方呢？</p>
<p>删除格式非常简单，如下:</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># rpm -e 包名</span>
选项：
	-e	：卸载（erase）
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果不按依赖性卸载，就会报依赖性错误。当然，卸载命令是支持“-nodeps”选项的，可以不检测依赖性直接卸载。但是，如果这样做，则很可能导致其他软件包无法正常使用，所以并不推荐这样卸载。</p>
<p><em>dpkg 包卸载</em></p>
<div><pre><code><span>[</span>root@ubuntu ~<span>]</span><span># dpkg [选项] 包名</span>
选项：
	-r	：卸载软件包，但是不删除软件包的配置文件。
	-P	：完全删除软件包，包括相关配置文件。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="包的校验与数字证书"> 包的校验与数字证书</h3>
<ol>
<li><strong>包的校验</strong></li>
</ol>
<p>系统中安装的 RPM 包数量众多，而每个 RPM 包中都包含大量的文件，万一某个文件被删除了，或者误修改了某个文件中的数据，或者有人恶意修改了某个文件，我们是否有监控和检测手段发现这些问题呢？这时候，必须使用  RPM 包校验来确认文件是否被动过手脚，校验其实就是把已经安装的文件和 <code>/var/lib/rpm/</code> 目录下的数据库内容进行比较，以确定是否有文件被修改。校验的格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># rpm -Va</span>
选项：
	-Va	：校脸本机已经安装的所有软件包

<span>[</span>root@localhost ~<span>]</span><span># rpm -V 已安装的包名</span>
选项：
	-V	：校验指定 RPM 包中的文件（verify）

<span>[</span>root@localhost ~<span>]</span><span># rpm -Vf 系统文件名</span>
选项：
	-Vf	：校验某个系统文件是否被修改
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ol start="2">
<li><strong>数字证书</strong></li>
</ol>
<p>刚刚的校验方法只能对已经安装的 RPM 包中的文件进行校验，但如果 RPM 包本身就被动过手脚，那么 RPM 包校验就不能解决问题了，必须使用数字证书验证。数字证书也叫数字签名，它由软件开发商直接发布。只要安装了这个数字证书，如果 RPM包被进行了修改，那么数字证书验证就不能匹配，软件也就不能安装。数字签名，可以想象成人的签名，每个人的签名都是不能模仿的（广商的数字证书是唯一的）。只有我认可的文件现才会签名（只要是厂商发布的软件，都要符合数字证书验证)；如果我的文件被人修改了，那么我的签名就会变得不同（如果软件改变，数字证书就会改变，从而通不过验证。当然，现实中人的手工签名不会直接改变，所以数字证书比手工签名还要可靠）。</p>
<p>数字证书有如下特点：</p>
<ul>
<li>首先必须找到原厂的公钥文件，然后才能进行安装。•再安装 RPM 包，会去提取 RPM 包中的证书信息，然后和本机安装的原厂证书进行验证。</li>
<li>如果验证通过，则允许安装；如果验证不通过，则不允许安装并发出警告。</li>
</ul>
<h3 id="包中的文件提取"> 包中的文件提取</h3>
<p>在讲 RPM 包文件提取之前，先介绍一下 <code>cpio</code> 命令。<code>cpio</code> 命令可以把文件或目录从文件库中提取出来，也可以把文件或目录复制到文件库中。可以把 <code>cpio</code> 命令看成<u>备份或还原命令</u>，它既可以把数据备份成 cpio 文件库，也可以把 cpio 文件库中的数据还原出来。不过，<code>epio</code> 命令最大的问题是不能自己指定备份或还原的文件是什么，而必须由其他命令告诉 <code>epio</code> 命令要备份和还原哪个文件，这必须依赖数据流重定向的命令。</p>
<p><code>cpio</code> 命令主要有三种基本模式：</p>
<ul>
<li>
<p>“-o”模式指的是 copy-out 模式，就是把数据备份到文件库中；</p>
</li>
<li>
<p>“-i”模式指的是 copy-in 模式，就是把数据从文件库中恢复；</p>
</li>
<li>
<p>“-p”模式指的是 copy 模式，就是不把数据备份到 cpio 库中，而是直接复制为其他文件。</p>
</li>
</ul>
<p>命令格式如下:</p>
<div><pre><code>cpio -o<span>[</span>vcB<span>]</span> <span>></span> <span>[</span>文件<span>|</span>设备<span>]</span>
<span>#备份</span>
选项：
	-o	：copy-out 模式，各份
	-v	：显示备份过程
	-c	：使用较新的 portable <span>format</span> 存储方式
	-B	：设定输入/输出块为 5120Bytes，而不是模式的512Bytes

cpio -i<span>[</span>vcdu<span>]</span> <span>&lt;</span> <span>[</span>文件<span>|</span>设备<span>]</span>
<span>#还原</span>
选项：
	-i	：copy-in 模式，还原
	-v	：显示还原过程
	-c	：使用较新的 portable <span>format</span> 存储方式
	-d	：还原时自动新建目录
	-u	：自动使用较新的文件覆盖较旧的文件
	
<span>#复制</span>
<span>[</span>文件<span>|</span>设备<span>]</span> <span>|</span> cpio -p 目标目录
<span>#[文件|设备]常用 find 或 ls 命令</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>先来看一下使用 cpio 备份、还原、复制数据的方法，命令如下：</p>
<div><pre><code><span>[</span>root@localnost ~<span>]</span><span># find /etc -print | cpio -ocvB > /root/etc.cpio</span>
<span>#利用find 命令指定要备份/etc/目录，使用 > 导出到 etc.cpio 文件</span>
<span>[</span>root@localhost ~<span>]</span><span># ll -h etc.cpio</span>
-rw-r--r--. <span>1</span> root root 21M <span>6</span>月 <span>5</span> <span>12</span>:29 ete.cpio
<span>#etc.cpio 文件生成</span>
-------------------------------------------------------------------------------------
<span>[</span>root@localnost ~<span>]</span><span># cpio -idveu &lt; /root/etc.cpio</span>
<span>#还原 etc 的备份</span>
<span>#如果大家查看一下当前目录 /root/，就会发现没有生成 /etc/ 目录。这是因为备份时 /etc/ 目录使用的是绝对路径，所以数据直接恢复到/etc/系统目录中，而没有生成在 /root/etc/目录中</span>
--------------------------------------------------------------------------------------
<span>[</span>root@localnost ~<span>]</span><span># cd /tmp/</span>
<span>#进入 /tmp/ 目录</span>
<span>[</span>root@localhost tmp<span>]</span><span># rm -rf *</span>
<span>#删除 /tmp/ 目录中的所有数据</span>
<span>[</span>root@localhost tmp<span>]</span><span># mkdir test</span>
<span>#建立备份目录</span>
<span>[</span>root@localhost tmp<span>]</span><span># find /boot/-print i cpio -p /tmp/test</span>
<span>#备份 /boot/ 目录到 /tmp/test/ 目录中</span>
<span>[</span>root@localhost tmp<span>]</span><span># ls test/</span>
boot 
<span>#在/tmp/test/目录中备份出了/boot/目录</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>接下来介绍如何在 RPM 包中提取某个特定的文件。假设在服务器使用过程中，我们发现某个系统文件被人动了手脚，或者不小心删除了某个系统重要文件，那么我们可以在 RPM 包中把这个系统文件提取出来修复有问题的源文件吗？当然可以。RPM 包中的文件虽然众多，但也是可以逐个提取的。命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># rpm2cpio 包全名 | cpio -idv .文件绝对路径</span>
	rpm2cpio		<span>&lt;</span>---将 RPM 包转换为 cpio 格式的命令
    cpio			<span>&lt;</span>---这是一个标准工具，用于创建软件档案文件和从档案文件中提取文件
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>举个例子，假设把系统中的 <code>/bin/ls</code> 命令误删除了，可以修复吗？这时有两种方法修复：一种方法是使用--force 选项覆盖安装一遍 coreutilis-8.4-19.el6.i686 包：另一种方法是先使用 <code>cpio</code> 命令提取出 <code>/bin/ls</code> 命令文件，再把它复制到对应位置。不过，怎么知道/bin/ls 命令属于Coreutils-8.4-19.cl6.i686 软件包呢？还记得 -qf 选项吗？命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span> <span>rpm</span> -qf /bin/ls
coreutils-8.4-19.e16.1686
<span>#查看 ls 文件属于哪个软件包</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>我们先使用 cpio 命令提取出 ls 命令文件，然后复制到对应位置，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span> <span>mv</span> /bin/ls /root/
<span>#把 /bin/ls 今令移动到 /root/ 目录下，造成误删除的假象</span>
<span>[</span>rootelocalhost ~<span>]</span><span># ls</span>
-bash: 1s:command not found 
<span>#这时执行 1s 命令，系统会报“命令没有找到”错误</span>
<span>[</span>root@localhost ~<span>]</span><span># rpm2cpio /mnt/cdrom/Packages/coreutils-8.4-19.e16.i686.rpm | cpio -idv ./bin/ls</span>
./bin/ls
<span>24772</span> 块
<span>#提取 ls 命令文件到当前目来下</span>
<span>[</span>root@localhost ~<span>]</span> <span>cp</span> /root/bin/ls /bin/
<span>#把提取出来的 1s 命令文件复制到 /bin/ 目录下</span>
<span>[</span>root@localhost ~<span>]</span><span># ls</span>
anaconda-ks.cfg		bin		inittab		install.log		install.log.syslog		<span>ls</span>
<span>#恭事，ls 命令又可以正常使用了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><em>DPKG 包中的文件提取</em></p>
<p><em>还是用上面的 ls 命令丢失的例子：</em></p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span> dpkg -S /bin/ls
coreutils: /bin/ls
<span>#查看 ls 文件属于哪个软件包</span>
<span>[</span>root@localhost ~<span>]</span> <span>mv</span> /bin/ls /root/
<span>#把 /bin/ls 今令移动到 /root/ 目录下，造成误删除的假象</span>
<span>[</span>rootelocalhost ~<span>]</span><span># ls</span>
-bash: 1s:command not found 
<span>#这时执行 1s 命令，系统会报“命令没有找到”错误</span>
<span>[</span>root@localhost ~<span>]</span><span># mkdir debdir &amp;&amp; dpkg -x coreutils_8.28-1ubuntu1_amd64.deb ./debdir</span>
<span>#在当前目录下新建目录 debdir，再解压 deb 包文件到 debdir 目录下</span>
<span>[</span>root@localhost ~<span>]</span><span># cp ./debdir/bin/ls /bin/ &amp;&amp; rm -rf debdir/</span>
<span>#把提取出来的 ls 命令文件复制到 /bin/ 目录下，并删除 debdir 目录</span>
<span>[</span>root@localhost ~<span>]</span><span># ls</span>
anaconda-ks.cfg		bin		inittab		install.log		install.log.syslog		<span>ls</span>
<span>#恭事，ls 命令又可以正常使用了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="依赖管理"> 依赖管理</h2>
<h3 id="yum-在线管理"> yum 在线管理</h3>
<p>RPM 包的安装虽然很方便和快捷，但是依赖性实在是很麻烦。尤其是库文件依赖，还要去 rpmfind 网站查找库文件到底属于哪个 RPM 包，从而导致 RPM 包的安装非常烦琐。那有没有可以自动解决依赖性、自动安装的方法呢？当然有，yum 在线管理就可以自动处理 RPM 包的依赖性问题，从而大大简化 RPM 包的安装过程。但是大家需要注意：首先，yum 安装所安装的还是 RPM 包；其次，yum 安装是需要有可用的 yum 服务器存在的，当然这个 yum 服务器可以在网上，也可以使用光盘在本地搭建。</p>
<p>yum 可以方便地进行 RPM 包的安装、升级、查询和卸载，而且可以自动解决依赖性问题，非常方便和快捷。但是，一定要注意 yum 的卸载功能。**yum 在卸载软件的同时会卸载这个软件的依赖包，但是如果卸载的依赖包是系统的必备软件包，就有可能导致系统崩溃。**除非你确实知道 yum 在自动卸载时会卸载哪些软件包，否则<u>最好还是不要执行 yum 卸载。</u></p>
<h3 id="yum-源搭建"> yum 源搭建</h3>
<p>yum 源既可以使用网络 yum 源，也可以使用本地光盘作为 yum 源。要使用网络 yum 源，那么你的主机必须是正常联网的。</p>
<p>当然，要使用 yum 进行 RPM 包安装，那么必须安装 yum 软件。查看命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># rpm -qa | grep yum</span>
yum-metadata-parser-1.1.2-16.e16.1686
yum-3.2.29-30.e16.centos.noarch
yum-uti1s-1.1.30-14 e16.noarch
yum-plugin-fastestmirror-1.1.30-14.e16.noarch
yum-plugin-security-1.1.30-14.e16.noarch
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>如果没有安装，则需要手工使用 RPM 包方式安装.</p>
<ol>
<li><strong>网络 yum 源服务器搭建</strong></li>
</ol>
<p>在主机网络正常的情况下，CentOS 的 yum 是可以直接使用的，不过我们需要了解一下 yum 源配置文件的内容。yum 源配置文件保存在 <code>/ete/yum.repos.d/</code> 目录中，文件的扩展名一定是“*.repo&quot;。也就是说，yum 源配置文件只要扩展名是“*.repo”就会生效。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span> <span>ls</span> /etc/yum.repos.d/
Centos-Base.repo	CentOs-Media.repo	Centos-Debuginfo.repo.bak	CentOS-Vault repo
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这个目录中有 4 个 yum 源配置文件，默认情况下 <code>CentOS-Base.repo</code> 文件生效。我们打开这个文件看看，命令如下：</p>
<div><pre><code><span>[</span>root@Localhost ~<span>]</span><span># vim /ete/yum.repom.d/Centos-Base.ropo</span>

<span>[</span>base<span>]</span>
<span>name</span><span>=</span>CentOS-<span>$releasever</span> - Base
<span>mirrorlist</span><span>=</span>http://mirrorlist.centoa.org/?release-<span>$releasever</span><span>&amp;</span>arch-<span>$basearch</span><span>&amp;</span><span>ropo</span><span>=</span>os
<span>baseurl</span><span>=</span>http://mirror.centos.org/centos/<span>$releasever</span>/os/<span>$basearch</span>/gpgcheck<span>=</span><span>1</span>
<span>gpgkey</span><span>=</span>file:///etc/pki/rpm-gpg/RPM-GPG-KEY-Centos-6
<span>..</span>.省略部分输出<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>在 <code>CentOS-Base.repo</code> 文件中有 5 个 yum 源容器，这里只列出了 base 容器，其他容器和 base 容器类似。我们解释一下 base 这个容器。</p>
<ul>
<li>
<p>[basc]：容器名称，一定要放在[  ]中。</p>
</li>
<li>
<p>name：容器说明，可以自己随便写。</p>
</li>
<li>
<p>mirrorlist：镜像站点，这个可以注释掉。</p>
</li>
<li>
<p>baseurl：我们的 yum 源服务器的地址。默认是 CeniOS 官方的 yum 源服务器，是可以使用的。如果你觉得慢，则可以改成你喜欢的 yum 源地址。</p>
</li>
<li>
<p>enabled：此容器是否生效，如果不写或写成 enabled=1 则表示此容器生效，写成 enabled=0 则表示此容器不生效。</p>
</li>
<li>
<p>gpgcheck：如果为 1 则表示 RPM 的数字证书生效；如果为 0 则表示 RPM 的数字证书不生效。</p>
</li>
<li>
<p>gpgkey：数字证书的公钥文件保存位置。不用修改。</p>
</li>
</ul>
<p>yum 源配置文件默认不需要进行任何修改就可以使用，只要网络可用就行。</p>
<ol start="2">
<li><strong>以本地光盘作为 yum 源服务器</strong></li>
</ol>
<p>如果 Linux 主机不能联网，yum 就不能使用吗？yum 已经考虑到这个问题，所以在 <code>/etc/yum.repos.d/</code> 目录下还有一个 <code>CentOS-Media.repo</code> 文件，这个文件就是以本地光盘作为 yum 源服务器的模板文件，只需要进行简单的修改即可。</p>
<p>第一步：放入 CentOS 安装光盘，并挂载光盘到指定位置。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mkdir /mnt/cdrom</span>
<span>#创建 cdrom 目录，作为光盘的挂载点</span>
<span>[</span>root@localhost ~<span>]</span><span># mount /dev/cdrom /mnt/cdrom/</span>
mount: block device /dev/sr0 is write-protected, mounting read-only
<span>#挂载光盘到/mnt/cdrom 目录下</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>第二步：修改其他几个 yum 源配置文件的扩展名，让它们失效，因为只有扩展名是“*.repo”的文件才能作为 yum  源配置文件。当然也可以删除其他几个 yum 源配置文件，但是如果删了，当你又想用网络作为 yum 源时，就没有了参考文件，所以最好还是修改扩展名。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cd /etc/yum.repos.d/</span>
<span>[</span>rootelocalhost yum.repos.d<span>]</span><span># mv Centos-Base.repo CentOS-Base.repo.bak</span>
<span>[</span>root@localhost yum.repos.d<span>]</span><span># mv Centos-Debuginfo.repo Centos-Debuginfo.repo.bak</span>
<span>[</span>root@localhost yum.repos.d<span>]</span><span># mv Centos-Vault.repo Centos-Vault.repo.bak</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第三步：修改光盘 yum 源配置文件 CentOS-Media.repo，参照以下方法修改：</p>
<div><pre><code><span>[</span>root@localhost yum.repos.d<span>]</span><span># vim CentOS-Media.repo</span>
<span>[</span>c6-media<span>]</span>
<span>name</span><span>=</span>CentOS-<span>$releasever</span> - Media
<span>baseurl</span><span>=</span>file:///mnt/cdrom
<span>#地址为你自己的光盘挂载地址</span>
<span>#			file:///media/cdrom/</span>
<span>#			file:///media/cdrecorder/</span>
<span>#注释这两个不存在的地址</span>
<span>gpgcheck</span><span>=</span><span>1</span>
<span>enabled</span><span>=</span><span>1</span>
<span>#把 enabled=0 改为 enabled=1，让这个yum 源配置文件生效</span>
<span>gpgkey</span><span>=</span>file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentoS-6
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>配置完成，现在可以感受一下 yum 的便捷了。</p>
<h3 id="yum-常用命令"> yum 常用命令</h3>
<ol>
<li><strong>查询</strong></li>
</ol>
<ul>
<li>查询 yum 源服务器上所有可安装的软件包列表。</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># yum list</span>
<span>#查询所有可用的软件包列表</span>
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors.nju.edu.cn
 * extras: mirrors.njupt.edu.cn
 * updates: mirrors.nju.edu.cn
Installed Packages
<span>#已经安装的软件包</span>
NetworkManager.x86_64                       <span>1</span>:1.18.8-1.el7             @anaconda
NetworkManager-libnm.x86_64                 <span>1</span>:1.18.8-1.el7             @anaconda
<span>..</span>.省略部分输出<span>..</span>.
Available Packages
<span>#还可以安装的软件包</span>
<span>389</span>-ds-base.x86_64                          <span>1.3</span>.10.2-10.el7_9          base
<span>389</span>-ds-base-devel.x86_64                    <span>1.3</span>.10.2-10.el7_9          updates
<span>#软件名										版本						所在源</span>
<span>..</span>.省略部分输出<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><ul>
<li>查询 yum 源服务器中是否包含某个软件包。</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># yum list 包名</span>
<span>#查询单个软件包</span>
<span>[</span>root@localhost ~<span>]</span><span># yum list samba</span>
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors.nju.edu.cn
 * extras: mirrors.njupt.edu.cn
 * updates: mirrors.nju.edu.cn
Available Packages
samba.x86_64                                <span>4.10</span>.16-13.el7_9            updates
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>
<li>搜索 yum 源服务器上所有和关键字相关的软件包</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># yum search 关键字</span>
<span>#搜索服务器上所有和关键字相关的软件包</span>
<span>[</span>root@localhost ~<span>]</span><span># yum search samba</span>
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors.nju.edu.cn
 * extras: mirrors.njupt.edu.cn
 * updates: mirrors.nju.edu.cn
<span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>=</span> N/S matched: samba <span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span>
kdenetwork-fileshare-samba.x86_64 <span>:</span> Share files via samba
samba-client.x86_64 <span>:</span> Samba client programs
samba-client-libs.i686 <span>:</span> Samba client libraries
<span>..</span>.省略部分输出<span>..</span>.

  Name and summary matches only, use <span>"search all"</span> <span>for</span> everything.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><ul>
<li>查询指定软件包的信息</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># yum info 关键字</span>
<span>#查询软件包的信息</span>
<span>[</span>root@localhost ~<span>]</span><span># yum info samba</span>
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors.nju.edu.cn
 * extras: mirrors.njupt.edu.cn
 * updates: mirrors.nju.edu.cn
Available Packages
Name        <span>:</span> samba
Arch        <span>:</span> x86_64
Version     <span>:</span> <span>4.10</span>.16
Release     <span>:</span> <span>13</span>.el7_9
Size        <span>:</span> <span>719</span> k
Repo        <span>:</span> updates/7/x86_64
<span>..</span>.省略部分输出<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><ol start="2">
<li><strong>安装</strong></li>
</ol>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># yum -y install 包名</span>
选项：
	<span>install</span>		：安装
	-y			：自动回答 yes。如果不加 -y，那么每个安装的软件都需要手工回答 <span>yes</span>

<span>[</span>root@localhost ~<span>]</span><span># yum -y install gcc</span>
<span>#使用 yum 自动安装 gcc</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>在讲 RPM 包安装时提到，gec 是 C 语言的编译器，如果没有安装，那么源码包就无法安装。但 gcc 依赖的软件包比较多，手工使用 RPM 包安装太麻烦了，所以使用 yum安装。</p>
<p>yum 安装可以自动解决依赖性，而且安装速度也比源码包快得多。不过，yum 到底安装的还是 RPM 包，所以 rpm 命令还是必须学习和使用的。</p>
<ol start="3">
<li><strong>升级</strong></li>
</ol>
<div><pre><code><span>[</span>root@localhost ～<span>]</span><span># yum -y update 包名</span>
选项：
    update		：升级
	-y			：自动回答 <span>yes</span>

<span>[</span>root@localhost ~<span>]</span><span># yum -y install zip</span>
<span>#使用 yum 自动升级 zip</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><p>注意</p>
<p>在进行升级操作时，yum 源服务器中软件包的版本要比本机安装的软件包的版本高。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># yum -y update</span>
<span>#升级本机所有软件包</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这条命令会升级系统中所有的软件包。不过我们的生产服务器是稳定优先的，所以这种全系统升级的情况并不多见。</p>
</div>
<ol start="4">
<li><strong>卸载</strong></li>
</ol>
<p>再次强调一下，除非你确定卸载的软件的依赖包不会对系统产生影响，否则不要执行 yum 的卸载，因为很有可能在卸载软件包的同时卸载的依赖包也是重要的系统文件，这就有可能导致系统崩溃。卸载命令如下：</p>
<div><pre><code><span>[</span>root@localhost yum.repos.d<span>)</span><span># yum remove 包名</span>
选项：
	remove		：卸载
<span>#卸载指定的软件包</span>

<span>[</span>root@localhost yum.repos.d<span>)</span><span># yum remove samba</span>
<span>#卸载 samba 软件包</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="yum-软件组管理"> yum 软件组管理</h3>
<p>在安装 Linux 的过程中，在选择软件包的时候，如果选择了“现在自定义”，就会看到 Linux 支持的许多软件组，比如编辑器、系统工具、开发工具等。那么，在系统安装完成后，是否可以利用 yum 安装这些软件组呢？当然可以，只需要利用 yum 的软件组管理命令。</p>
<ul>
<li>查询可以安装的软件组。</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># yum grouplist </span>
<span>#查询可以安装的软件组</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>查询软件组中包含的软件。</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># yum groupinfo 软件组名</span>
<span>#查询软件组中包合的软件</span>

<span>[</span>root@localhost ~<span>]</span><span># yum groupinfo "Web Server"</span>
<span>#查询软件组“Web Server”中包合的软件</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>安装软件组。</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># yum groupinstall 软件组名</span>
<span>#安装指定软件组，组名可以由 grouplist 查询出来</span>

例如：
<span>[</span>root@localhost ~<span>]</span><span># yum groupinstall "web Server"</span>
<span>#安装网页服务软件组</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>
<li>卸载软件组。</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># yum groupremove 软件组名</span>
<span>#卸载指定软件组</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>软件组管理对于安装功能集中的软件集合非常方便。比如，在安装 Linux 的时候没有安装图形界面，但是后来发现需要图形界面的支持，这时可以手工安装图形界面软件组（XWindow System 和 Desktop），就可以很方便地安装图形界面了。</p>
<h3 id="apt-在线管理"> <em>apt 在线管理</em></h3>
<p><em>DPKG 包的安装虽然很方便和快捷，同样依赖性实在是很麻烦。APT 是 Advanced Packaging Tool 的简称，是一款安装包管理工具。在 Debain/Ubuntu 下，我们可以使用 <code>apt</code> 命令用于软件包的安装、删除、清理等。类似于 Windows 中的软件管理工具。</em></p>
<h3 id="apt-源配置"> <em>apt 源配置</em></h3>
<p><em>Debain/Ubuntu 的软件源配置文件是 <code>/etc/apt/sources.list</code>。我们看看源文件里的内容。  或者 <code>sudo apt edit-sources</code>  编辑软件源信息文件</em></p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vim /etc/apt/source.list</span>
<span>#除了注释外，主要是以下内容</span>
deb http://cn.archive.ubuntu.com/ubuntu/ bionic main restricted
deb http://cn.archive.ubuntu.com/ubuntu/ bionic-updates main restricted
deb http://cn.archive.ubuntu.com/ubuntu/ bionic universe
deb http://cn.archive.ubuntu.com/ubuntu/ bionic-updates universe
<span>#格式  软件包地址（在线或本地）				发行版本代号		软件包的分类目录</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ol>
<li><em><strong>网络源服务搭建</strong></em></li>
</ol>
<p><em>一般我们会将系统自带的该文件做个备份，再将该文件修改为你想要的源地址，比如国内的源比较快，可以使用中科大的软件源镜像。</em></p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cp /etc/apt/source.list /etc/apt/source.list.bk</span>
<span>#备份 /etc/apt/source.list 源文件</span>
<span>[</span>root@localhost ~<span>]</span><span># vim /etc/apt/source.list</span>
<span>#编辑 /etc/apt/source.list，删除或注释所有内容后，输入下面的国内中科大的源，保存退出</span>
deb https://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiverse
<span># deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial main main restricted universe multiverse</span>
deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse
<span># deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse</span>
deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse
<span># deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span>
deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse
<span># deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse</span>
<span>[</span>root@localhost ~<span>]</span><span># apt-get update</span>
<span>#更新源</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><ol start="2">
<li><em><strong>本地源搭建</strong></em></li>
</ol>
<div><pre><code><span>#先备份 /etc/apt/source.list 源文件</span>
<span>[</span>root@localhost ~<span>]</span><span># mkdir /mnt/cdrom</span>
<span>[</span>root@localhost ~<span>]</span><span># mount /mnt/ubuntu-18.04.2-server-amd64.iso /mnt/cdrom/</span>
<span>#创建挂载目录，挂载镜像源</span>
<span>[</span>root@localhost ~<span>]</span><span># vim /etc/apt/source.list</span>
deb file:///mnt/cdrom xenial main
<span>#修改 /etc/apt/source.list 源文件，注释掉所有内容，加入上一句内容</span>
<span>#设置本地源，file 路径对应挂载的路径</span>
<span>[</span>root@localhost ~<span>]</span><span># apt-get update</span>
<span>#更新源</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="apt-常用命令"> <em>apt 常用命令</em></h3>
<ol>
<li><em><strong>查询</strong></em></li>
</ol>
<ul>
<li><em>查询 apt 源服务器上所有可安装的软件包列表</em></li>
</ul>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># apt list</span>
<span>..</span>.省略部分输出<span>..</span>.
apg/bionic,now <span>2.2</span>.3.dfsg.1-5 amd64 <span>[</span>已安装，自动<span>]</span>
cubicsdr/bionic <span>0.2</span>.3+dfsg-1 amd64
flvmeta/bionic <span>1.2</span>.1-1 amd64
gzip/bionic,now <span>1.6</span>-5ubuntu1 amd64 <span>[</span>已安装<span>]</span>
<span>..</span>.省略部分输出<span>..</span>.
<span>#已安装的会显示 [已安装] 字样</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ul>
<li><em>查询 apt 源服务器中是否包含某个软件包</em></li>
</ul>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># apt list 包名</span>
<span>#查询单个软件包</span>

<span>[</span>root@localhost ~<span>]</span><span># apt list samba</span>
samba/bionic-updates,bionic-security <span>2</span>:4.7.6+dfsg~ubuntu-0ubuntu2.23 amd64
N: 还有 <span>1</span> 个版本。请使用 -a 选项来查看它<span>(</span>他们<span>)</span>。
<span>#如果没有的话，就不显示信息了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>
<li><em>搜索 apt 源服务器上所有和关键字相关的软件包</em></li>
</ul>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># apt search 关键字</span>
<span>#搜索源中含有关键字的所有软件包</span>

<span>[</span>root@localhost ~<span>]</span><span># apt search samba</span>
4pane/bionic <span>5.0</span>-1 amd64
  four-pane detailed-list <span>file</span> manager

argonaut-samba/bionic,bionic <span>1.0</span>-1 all
  Argonaut scripts to generate Samba share configurations
<span>..</span>.省略部分输出<span>..</span>.
<span>#搜索含有关键字信息的包，有的没有关键字的包也显示出来，其实包的详细信息里是包含关键字的</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ul>
<li><em>查询指定软件包的详细信息</em></li>
</ul>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># apt show 包名</span>
<span>#显示单个包的详细信息</span>

<span>[</span>root@localhost ~<span>]</span><span># apt show samba</span>
Package: samba
Version: <span>2</span>:4.7.6+dfsg~ubuntu-0ubuntu2.23
Priority: optional
Section: net
Origin: Ubuntu
Maintainer: Ubuntu Developers <span>&lt;</span>ubuntu-devel-discuss@lists.ubuntu.com<span>></span>
Original-Maintainer: Debian Samba Maintainers <span>&lt;</span>pkg-samba-maint@lists.alioth.debian.org<span>></span>
Bugs: https://bugs.launchpad.net/ubuntu/+filebug
Installed-Size: <span>11.3</span> MB
Pre-Depends: dpkg <span>(</span><span>>=</span> <span>1.15</span>.6~<span>)</span>
<span>..</span>.省略部分输出<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><ol start="2">
<li><em><strong>安装</strong></em></li>
</ol>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># apt -y install 包名</span>
	<span>install</span>		：安装
	-y			：自动回答 yes。如果不加 -y，那么每个安装的软件都需要手工回答 <span>yes</span>
<span>#自动安装指定软件包，并解决依赖性</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ol start="3">
<li><em><strong>升级</strong></em></li>
</ol>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># apt install --only-upgrade 包名</span>
<span>#升级单个软件包，但可能会出现升级后，原先的依赖包不支持更新后的软件，慎用</span>
<span>[</span>root@localhost ~<span>]</span><span># apt update</span>
<span>#更新可用软件包列表</span>
<span>[</span>root@localhost ~<span>]</span><span># apt upgrade</span>
<span>#通过 安装/升级 软件来更新系统</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ol start="4">
<li><em><strong>卸载</strong></em></li>
</ol>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># apt remove 包名</span>
	remove		：卸载
<span>#移除软件包</span>
<span>[</span>root@localhost ~<span>]</span><span># apt autoremove</span>
<span>#移除不需要的软件包</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><em>apt 没有 yum 的软件组管理功能，但是不代表 apt 没有 yum 强大，各有各的优势。</em></p>
<div><p>*apt 和 apt-get*</p>
<p><em>在基于 Debian 的 Linux 发行版中，apt-get 便是其中一款广受欢迎的命令行工具，另外一款较为流行的是 Aptitude 这一命令行与 GUI 兼顾的小工具。类似的命令还有其他，如apt-cache、apt-config 等。如你所见，这些命令都比较低级又包含众多功能，普通的 Linux 用户也许永远都不会使用到。换种说法来说，就是最常用的 Linux 包管理命令都被分散在了 apt-get、apt-cache 和 apt-config 这三条命令当中。</em></p>
<p><em>apt 命令的引入就是为了解决命令过于分散的问题，它包括了 apt-get 命令出现以来使用最广泛的功能选项，以及 apt-cache 和 apt-config 命令中很少用到的功能。在使用 apt 命令时，用户不必再由 apt-get 转到 apt-cache 或 apt-config，而且 apt 更加结构化，并为用户提供了管理软件包所需的必要选项。</em></p>
<p><em><strong>简单来说就是：apt = apt-get、apt-cache 和 apt-config 中最常用命令选项的集合。</strong></em></p>
<p><em>目前还没有任何 Linux 发行版官方放出 apt-get 将被停用的消息，至少它还有比 apt 更多、更细化的操作功能。对于低级操作，仍然需要 apt-get。既然两个命令都有用，那么我该使用 apt 还是 apt-get 呢？作为一个常规 Linux 用户，系统极客建议大家尽快适应并开始首先使用 apt。不仅因为广大 Linux 发行商都在推荐 apt，更主要的还是它提供了 Linux 包管理的必要选项。</em></p>
<p><em>最重要的是，apt 命令选项更少更易记，因此也更易用，所以没理由继续坚持 apt-get。</em></p>
</div>
<h2 id="源码包安装"> 源码包安装</h2>
<h3 id="源码包的安装准备"> 源码包的安装准备</h3>
<ol>
<li><strong>支持软件的安装</strong></li>
</ol>
<p>Linux 下的绝大多数源码包都是用 C 语言编写的，还有少部分是用 C++ 等其他程序语言编写的。所以，要想安装源码包，必须安装 C 语言编译器 gcc（如果是用 C+ 编写的程序，则还需要安装 gcc-c+）。我们可以先检测一下 gcc 是否已经安装，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># rpm -q gcc</span>
gcc-4.4.6-4.e16.i686
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果没有安装 gcc，则推荐大家采用 yum 安装方式安装。因为如果手工使用 rpm 命令安装，那么 gcc 所依赖的包太多了。命令如下:</p>
<div><pre><code><span>[</span>root@localhost yum.repos.d<span>]</span><span># yum -y install gcc</span>
</code></pre>
<div><span>1</span><br></div></div><p>有了编译器，还需要考虑一个问题：假如“hello.c”只是一个源码文件，所以我们可以利用 gcc 手工编译。但是真正发布的源码包软件内的源码文件可能有成百上千个，而且这些文件之间都是有联系的，编译时有先后顺序。如果这样的源码文件需要手工编译，光想想就是一项难以完成的工作。这时就需要 make 命令来帮助我们完成编译，所以 make 也是必须安装的。我们也需要查看一下 make 是否已经安装，命令如下：</p>
<div><pre><code><span>[</span>root@localhost yum.repos.d<span>]</span><span># rpm -q make</span>
make-3.81-20.e16.i686
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ol start="2">
<li><strong>源码包从哪里来</strong></li>
</ol>
<p>RPM 包是保存在 CentOS 6.3 的安装光盘中的，那么源码包从哪里来呢？是从官方网站上下载的，我们依然以下载和安装 apache 为例。</p>
<div><pre><code><span>[</span>root@localhost yum.repos.d<span>]</span><span># yum -y install wget</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="源码包安装-2"> 源码包安装</h3>
<ol>
<li><strong>注意事项</strong></li>
</ol>
<p>在安装之前，我们先来解释一下源码包的安装注意事项。</p>
<ul>
<li>
<p>软件包是从互联网上下载的。比如 apache 是从网站 <a href="http://archive.apache.org/dist/httpd/" target="_blank" rel="noopener noreferrer">http://archive.apache.org/dist/httpd/</a> 上下载的。</p>
</li>
<li>
<p>下载的软件包格式。下载格式一般都是压缩格式，常见的是“.tar.gz”或“.tar.bz2”，选择你习惯的格式下载即可。</p>
</li>
<li>
<p>下载之后的源代码保存位置。Linux 是一个非常严谨的操作系统，每个目录的作用都是固定而且明确的，作为管理员，养成良好的操作习惯非常重要，其中在正确的目录中保存正确的数据就是一个约定俗成的习惯。在系统中保存源代码的位置主要有两个；<code>/usr/src</code> 和 <code>/usr/local/src</code>。其中，<code>/usr/src</code> 用来保存内核源代码：<code>/usr/local/src</code> 用来保存用户下载的源代码。</p>
</li>
<li>
<p>软件安装位置。我们刚说了 Linux 非常注意每个目录的作用，所以安装软件也有默认目录，即 <code>/usr/local/软件名</code>。我们需要给安装的软件包单独规划一个安装目录，以便于管理和卸载。大家可以想象一下，如果我把每个软件都安装到 <code>/usr/local/</code> 目录下，但是没有给每个软件单独分配一个安装目录，那么以后还能分清哪个文件是哪个软件吗？这样一来也就不能正确地卸载软件了。</p>
</li>
<li>
<p>软件安装报错。源码包如果安装不报错，那么安装还是很方便的。但是报错后的排错对刚学习的人来说还是有难度的，不过我们先要知道什么样的情况是报错。报错有两个典型特点，这两个特点必须都具备才是报错：其一是出现“enor”或“warning”字样；其二是安装过程停止。如果没有停止但是出现警告信息，那么只是软件中的部分功能不能使用，而不是报错。</p>
</li>
</ul>
<ol start="2">
<li><strong>安装步骤</strong></li>
</ol>
<p>我们来解释一下源码包安装的具体步骤。</p>
<p>​	1) 下载软件包。</p>
<p>​	2) 解压缩。</p>
<p>​	3) 进入解压目录。</p>
<p>​	4) <code>./configure</code> 软件配置与检查。</p>
<blockquote>
<p>这一步主要有三个作用：</p>
<ul>
<li>在安装之前需要检测系统环境是否符合安装要求。</li>
<li>定义需要的功能选项。<code>./configure</code> 支持的功能选项较多，可以执行 <code>./configure -help</code> 命令查询其支持的功能。一般都会通过<code>./configure --prefix=安装路径</code> 来指定安装路径。</li>
<li>把系统环境的检测结果和定义好的功能选项写入 Makefile 文件，后续的编译和安装需要依赖这个文件的内容。</li>
</ul>
<p>需要注意的是，configure 不是系统命令，而是源码包软件自带的一个脚本程序，所以必须采用 <code>./configure</code> 方式执行（<code>./</code> 代表在当前目录下)。</p>
</blockquote>
<p>​	5) make 编译。</p>
<blockquote>
<p>make 会调用 gcc 编译器，并读取 Makefile 文件中的信息进行系统软件编译。编译的目的就是把源码程序转变为能被 Linux 识别的可执行文件，这些可执行文件保存在当前目录下。编译过程较为耗时，需要有足够的耐心。</p>
</blockquote>
<p>​	6) make clean：清空编译内容（非必需步骤）。</p>
<blockquote>
<p>如果在 <code>./configure</code> 或 <code>make</code> 编译中报错，那么我们在重新执行命令前一定要记得执行 <code>make clean</code> 命令，它会清空 Makefile 文件或编译产生的“.o”头文件。</p>
</blockquote>
<p>​	7) make install：安装。</p>
<blockquote>
<p>这才是真正的安装过程，一般会写清楚程序的安装位置。如果忘记指定安装目录，则可以把这个命令的执行过程保存下来，以备将来删除使用。</p>
</blockquote>
<ol start="3">
<li><strong>举例安装 apache</strong></li>
</ol>
<div><pre><code><span># 1. 下载</span>
<span># wget 下载到指定目录 /usr/local/src/</span>
<span>[</span>root@localhost ~<span>]</span><span># wget -P /usr/local/src/ https://mirrors.tuna.tsinghua.edu.cn/apache/httpd/httpd-2.2.9.tar.gz</span>

<span># 2. 解压缩</span>
<span>[</span>root@localhost ~<span>]</span><span># cd /usr/local/src/</span>
<span>[</span>root@localhost ~<span>]</span><span># tar -zxvf httpd-2.2.9.tar.gz</span>

<span># 3. 进入解压缩目录</span>
<span>[</span>root@localhost ~<span>]</span><span># ls</span>
anaconda-ks.cfg		httpd-2.2.9	httpd-2.2.9.tar.gz	 install.log	 install.log.syslog
<span>[</span>root@localhost ~<span>]</span><span># cd httpd-2.2.9</span>

<span># 4. 软件配置</span>
<span>[</span>root@localhost httpd-2.2.9<span>]</span><span># ./configure --prefix=/usr/local/apache2</span>
选项：
	--prefix：指定安装目录
checking <span>for</span> chosen layout. Apache
checking <span>for</span> working <span>mkdir</span> -P<span>..</span> <span>yes</span>
ichecking build system type<span>..</span>. <span>1686</span>-pc-14nux-gnu
checking <span>host</span> system type<span>..</span>. <span>1686</span>-pc-linux-gnu
checking target system type<span>..</span>. <span>1686</span>-pe-linux-gnu
<span>..</span>.省略部分输出<span>..</span>.
<span>#这里的安装选项没有加载其他功能，只是指定了安装目录。“/usr/local/apache2”目录不需要手工建立，安装完成后会自动建立，这个目录是否生成也是检测软件是否正确安装的重要标志。</span>
		<span>#当然，在配置之前也可以查询一下 apache 支持的选项功能，命令如下:</span>
		<span>[</span>root@localhost httpd-2.2.9<span>]</span><span># ./configure --help | more</span>
		<span>#查询 apache 支持的选項功能（不是必需步果）</span>
		
<span># 5. 编译</span>
<span>[</span>root@localhost httpd-2.2.9<span>]</span><span># make</span>
<span>#这一步命令较为简单，但是编译时间较长，主要作用是把源码文件转换为二进制文件。</span>

<span># 6. 安装</span>
<span>[</span>root@localnost httpd-2.2.9<span>]</span><span># make install</span>
<span>#如果不报错，这一步完成后就安装成功了。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><h3 id="源码包升级"> 源码包升级</h3>
<p>我们的软件如果进行了数据更新，那么是否需要先把整个软件卸载，然后重新安装呢？当然不需要，我们只需要下载补丁、打上补丁，重新编译和安装就可以了（不用 <code>./configure</code> 生成新的 Makefile 文件，make 命令也只是重新编译数据），速度会比重新安装一次快得多。</p>
<ol>
<li><strong>补丁的生成与使用</strong></li>
</ol>
<p>怎么知道两个软件之间的不同呢？难道需要手工比对两个软件吗？当然不是，Linux 有 <code>diff</code> 命令用来比较两个软件的不同，当然也是利用这个命令生成补丁文件的。那么我们先看看这个命令的格式。</p>
<div><pre><code><span>[</span>root@localhost <span>]</span><span># diff 选项 old new</span>
<span>#比较old 和new文件的不同</span>
选项：
	-a	：将任何文档当作文本文档处理
	-b	：忽略空格造成的不同
	-B	：忽略空白行造成的不同
	-I	：忽略大小写造成的不同
	-N	：当比较两个目录时，如果某个文件只在一个目录中，则在另一个目录中视作空文件
	-r	：当比较目录时，递归比较子目录
	-u	：使用同一输出格式
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>我们举一个简单的例子，来看看补丁是怎么来的，然后应用一下这个补丁，看看有什么效果，这样就可以说明补丁的作用了。先写两个文件，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mkdir teat</span>
<span>#建立测试目录</span>
<span>[</span>root@localhost ~<span>]</span><span># cd test</span>
<span>#进入测试目录</span>
<span>[</span>root@localhost test<span>]</span><span># vi old.txt</span>
our
school
is
lampbrother
<span>#文件 old.txt。为了便于比较，将每行分开</span>
<span>[</span>root@localhost <span>test</span><span>)</span> <span>vi</span> new.txt
our
school
is
Lampbrother
<span>in</span>
Beljing
<span>#文件 new.txt </span>

<span>[</span>root@localhost <span>test</span><span>)</span><span># diff -Naur /root/test/old.txt /root/test/new.txt > txt.patch</span>
<span>#比较一下两个文件的不同，并生成补丁文件 txt.patch</span>
<span>[</span>root@localhost test<span>]</span><span># vi txt.patch</span>
<span>#查看一下这个文件</span>
--- /root/test/old.txt <span>2021</span>-05-20 <span>10</span>:35:46.446414105 +0800
+++ /root/test/new.txt <span>2021</span>-05-20 <span>10</span>:35:57.274469831 +0800
@@ -2,3 +2,5 @@
school
is
Lampbrother
+in
+Beljing
<span>#后一个文件比前一个文件多两行（用+表示）</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>既然 <code>new.bxt</code> 比 <code>old.txt</code> 文件多了两行，那么我们能不能让 <code>old.txt</code> 文件按照补丁文件 <code>txt.patch</code> 进行更新呢？当然可以，使用命令 <code>patch</code> 即可。命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost test<span>]</span> patch -pn <span>&lt;</span> 补丁文件
<span>#按照补丁文件进行更新</span>
选项：
	-Pn	：n 为数字。代表接照补丁文件中的路径，指定更新文件的位置
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>“-pn”不好理解，我们说明一下。补丁文件是要打入旧文件的，但是你当前所在的目录和补丁文件中记录的目录不一定是匹配的，所以就需要“-pn”选项来同步两个目录。比如，我当前在 <code>/root/test/</code> 目录中（我要打补丁的旧文件就在当前目录下），补丁文件中记录的文件目录为 <code>/root/test/old.txt</code>，这时如果写入“-p1”（在补丁文件目录中取消一级目录），那么补丁文件就会打入 <code>/root/test/</code><strong><code>root/test/old.txt</code></strong> 文件中，这显然是不对的。那如果写入的是“-p2”（在补丁文件目录中取清二级目录），那么补丁文件就会打入 <code>/root/test/</code><strong><code>test/old.txt</code></strong> 文件中，这显然也不对。如果写入的是“-p3”（在补丁文件目录中取消三级目录），那么补丁文件就会打入 <code>/root/test/</code><strong><code>old.txt</code></strong> 文件中，我们的 old.txt 文件就在这个目录下，所以应该用“-p3”选项。</p>
<p>如果我的当前所在目录是 <code>/root/</code> 目录呢？因为补丁文件中记录的文件目录为 <code>/root/test/old.txt</code>，所以这里就应该用“-p2”选项，代表取消两级目录，补丁打在当前目录下的**<code>test/old.txt</code>** 文件上。</p>
<p>大家可以这样理解：“-pn”就是想要在补丁文件中所记录的目录中取消几个<code>/</code>，n 就是几。去掉目录的目的是和当前所在目录匹配。</p>
<p>那么我们更新一下“old.txt”文件，命令如下：</p>
<div><pre><code><span>[</span>root@localhost <span>test</span><span>)</span> patch -p3 <span>&lt;</span> txt.patch
patching <span>file</span> old.txt
<span>#给 o1d.txt 文件打补丁</span>
<span>[</span>root@localhost test<span>]</span><span># cat old.txt</span>
<span>#查看一下 old.txt 文件内容</span>
our
school
is
lampbrother
<span>in</span>
Beijing
<span>#多出了 in Beljing 两行</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><p>注意</p>
<ul>
<li>给旧文件打补丁依赖的不是新文件，而是补丁文件，所以即使新文件被删除也没有关系。</li>
<li>补丁文件中记录的目录和你当前所在目录是需要通过“-pn”选项来同步的。</li>
</ul>
</div>
<ol start="2">
<li><strong>给 apache 打入补丁</strong></li>
</ol>
<p>我们再举一个实际的例子。刚刚我们安装了 httpd-2.2.9 这个版本的程序，在官网上有这个版本的一个补丁“mod_proxy _ftp_CVE-2008-2939.diff”，这个补丁修补了 apache 代理 FTP 站点时，模块空指针引用拒绝服务攻击的漏洞。我们可以从 <a href="http://archive.apache.org/dist/httpd/patches/apply_to_2.2.9/" target="_blank" rel="noopener noreferrer">http://archive.apache.org/dist/httpd/patches/apply_to_2.2.9/</a> 网站上下载这个补丁。下面我们来看看如何安装这个补丁。</p>
<div><pre><code><span># 1. 下载补丁文件</span>
<span>[</span>root@localhost ~<span>]</span><span># wget http://archive.apache.org/dist/httpd/patches/apply_to_2.2.9/mod_proxy_ftp_CVE-2008-2939.diff</span>

<span># 2. 把补丁文件复制到 apache 源码包解压目录中。</span>
<span>[</span>root@localhost ~<span>]</span><span># cp mod_proxy_ftp_CVB-2008-2939.diff /usr/local/src/httpd-2.2.9</span>

<span># 3. 打入补丁</span>
<span>[</span>root@localhost ~<span>]</span><span># cd /usr/local/src/httpd-2.2.9</span>
<span>#进入 apache 源码目录</span>
<span>[</span>root@localhost httpd-2.2.9<span>]</span><span># vi mod_proxy_ftp_CVE-2008-2939.diff</span>
<span>#查看补丁文件</span>
--- modules/proxy/mod_proxy_ftp.c		<span>(</span>Revision <span>682869</span><span>)</span>
+++ modules/proxy/mod proxy_ftp.c		<span>(</span>Revision <span>682870</span><span>)</span>
<span>..</span>.省略部分输出<span>..</span>.
<span>#查看一下补下文件中记录的目录，以便一会儿和当前所在目录同步</span>
<span>[</span>root@localhost httpd-2.2.9<span>]</span><span># patch -p0 &lt; mod_proxy_ftp_CVE-2008-2939.dift</span>
<span>#打入补下</span>
<span>#为什么是“-p0”呢？因为我们当前在“/usr/local/src/httpd-2.2.9”目录中，但是补丁文件中记录的目录是“modules/proxy/mod_ proxy_Ap.c”，这就在我当前所在目录中，一个“/”都不需要去掉，所以是“-p0”。</span>

<span># 4. 重新编译</span>
<span>[</span>root@localhout httpd-2.2.9<span>]</span><span># make</span>

<span># 5. 重新安装</span>
<span>[</span>root@localhost httpd-2.2.9<span>]</span><span># make install</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>打补丁的方法会比重新安装少了 <code>./configure</code> 步骤，而且编译时也只是编译变化的地方，所以编译速度也更快。但是如果没有安装过 httpd-2.2.9，就需要先打入补丁，再依次执行 <code>./configure</code>、<code>make</code>、<code>make install</code> 命令。</p>
<p>如果我不想要补丁中的内容呢？可以恢复吗？当然可以，命令如下：</p>
<div><pre><code><span>[</span>root@localhost httpd-2.2.9<span>]</span><span># patch -R &lt; mod_proxy_ftp_CVE-2008-2939.diff</span>
选项：
	-R	：还原补丁
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="源码包卸载"> 源码包卸载</h3>
<p>我们在说源码包卸载之前，先回顾一下 Windows 系列操作系统中的软件卸载。在 Windows 系统中是不能用鼠标右键单击安装之后的软件，选择直接删除的，因为这样做会遗留大量的垃圾文件。这些垃圾文件越多，会导致 Windows 系统越不稳定。</p>
<p>那么我们在 Linux 中删除源码包应该怎样操作呢？太简单了，只要找到软件的安装位置（还记得我们要求在安装时必须指定安装位置吗），然后直接删除就可以了。比如删除 apache，只需要执行如下命令即可，而且不会遗留任何垃圾文件。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># rm -rf /usr/local/apache2/</span>
</code></pre>
<div><span>1</span><br></div></div><p>如果 apache 服务启动了，那么，记得先停止服务再删除。</p>
<h3 id="函数库管理"> 函数库管理</h3>
<ol>
<li><strong>什么是函数库</strong></li>
</ol>
<p>函数库其实就是函数，只不过是系统所调用的函数。这样说吧，我写了一个软件，所有的功能都需要我自己完成吗？其实是不需要的，因为很多功能是别人已经写好的，我只需要拿来使用就好了。这些有独立功能，可以被其他程序调用的程序就是函数。比如，我想打电话，那么我需要自己去制造和生产一部手机吗？当然不需要，我只需要明确我的需求，然后按照需求去买一部手机使用就可以了。</p>
<ol start="2">
<li><strong>函数库分类</strong></li>
</ol>
<p>当其他程序调用函数时，根据是否把函数直接整合到程序中而分<strong>为静态函数</strong>和<strong>动态函数</strong>，我们分别看看这两种函数的优缺点。</p>
<ul>
<li>静态函数库</li>
</ul>
<blockquote>
<p>函数库文件一般以“*.a”扩展名结尾，这种函数库在被程序调用时会被直接整合到程序当中。</p>
<p>优点：程序执行时，不需要再调用外部数据，可以直接执行。</p>
<p>缺点：因为把所有内容都整合到程序中，所以编译生成的文件会比较大，升级比较困难,需要把整个程序重新编译。</p>
</blockquote>
<ul>
<li>动态函数库</li>
</ul>
<blockquote>
<p>函数库文件通常以“*.so”扩展名结尾，这种函数库在被程序调用时，并没有直接整合到程序当中，当程序需要用到函数库的功能时，再去读取函数库，在程序中只保存了函数库的指向，如图12-2 所示。</p>
<p>优点：因为没有把整个函数库整合到程序中，所以文件较小，升级方便，不需要把整个程序重新编译，只需要重新编译安装函数库就好。</p>
<p>缺点：程序在执行时需要调用外部函数，如果这时函数出现问题，或指向位置不正确，那么程序将不能正确执行。</p>
</blockquote>
<div>
<p><img src="./assets/lib.png" alt="lib" loading="lazy"></p>
<p><strong>图12-2	<u>函数库调用</u></strong></p>
</div>
<p>目前 Linux 中的大多数函数库是动态函数库，主要是因为升级方便；但是函数的存放位置非常重要，而且不能更改。目前被系统程序调用的函数主要存放在 <code>/usr/lib</code> 和 <code>/lib</code> 中，而 Linux 内核所调用的函数库主要存放在 <code>lib/modules</code> 中。</p>
<ol start="3">
<li><strong>安装函数库</strong></li>
</ol>
<p>那么，系统中的可执行程序到底调用了哪些函数库呢？可以查询到吗？当然可以，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ldd -v 可执行文件名选项：</span>
选项：
	-v	：显示详细版本信息
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>比如，查看一下 <code>ls</code> 命令调用了哪些函数库，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ldd /bin/1s</span>
	linux-vdso.so.1 <span>=</span><span>></span>  <span>(</span>0x00007ffc5ebef000<span>)</span>
	libselinux.so.1 <span>=</span><span>></span> /lib64/libselinux.so.1 <span>(</span>0x00007fe85ab8a000<span>)</span>
	libcap.so.2 <span>=</span><span>></span> /lib64/libcap.so.2 <span>(</span>0x00007fe85a985000<span>)</span>
	libacl.so.1 <span>=</span><span>></span> /lib64/libacl.so.1 <span>(</span>0x00007fe85a77c000<span>)</span>
	libc.so.6 <span>=</span><span>></span> /lib64/libc.so.6 <span>(</span>0x00007fe85a3ae000<span>)</span>
	libpcre.so.1 <span>=</span><span>></span> /lib64/libpcre.so.1 <span>(</span>0x00007fe85a14c000<span>)</span>
	libdl.so.2 <span>=</span><span>></span> /lib64/libdl.so.2 <span>(</span>0x00007fe859f48000<span>)</span>
	/lib64/ld-linux-x86-64.so.2 <span>(</span>0x00007fe85adb1000<span>)</span>
	libattr.so.1 <span>=</span><span>></span> /lib64/libattr.so.1 <span>(</span>0x00007fe859d43000<span>)</span>
	libpthread.so.0 <span>=</span><span>></span> /lib64/libpthread.so.0 <span>(</span>0x00007fe859b27000<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>新安装了一个函数库，如何让它被系统识别？其实软件如果是正常安装的，则是不需要手工调整函数库的。但是万一没有安装正确，需要手工安装呢？那也很简单，只要把函数库放入指定位置，一般放在 <code>/usr/lib</code> 或 <code>/lib</code> 中，然后把函数库所在目录写入 <code>/etc/ld.so.conf</code> 文件中。注意是写入<strong>函数库所在目录</strong>，而不是写入函数库的文件名。比如:</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cp *.so /usr/lib/</span>
<span>#把函数库复制到 /usr/lib/目录中</span>
<span>[</span>root@localhost ~<span>]</span><span># vi /etc/ld.so.conf</span>
<span>#修改函数库配置文件</span>
include ld.so.conf.d/*.conf
/usr/lib
<span>#写入函数库所在目录（其实 /usr/lib/ 目录默认已经被识别）</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>接着使用 <code>ldconfig</code> 命令重新读取 <code>/etc/ld.so.conf</code> 文件，把新函数库读入缓存即可。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ldconfig</span>
<span>#从 /etc/1d.so.conf 文件中把函数库读入缓存</span>
<span>[</span>root@localhost ~<span>]</span><span># ldconfig -p</span>
<span>#列出系统缓存中所有识别的函数库</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="脚本程序包管理"> 脚本程序包管理</h2>
<h3 id="脚本程序简介"> 脚本程序简介</h3>
<p>脚本程序包并不多见，所以在软件包分类中并没有把它列为一类。它更加类似于 Windows 下的程序安装，有一个可执行的安装程序，只要运行安装程序，然后进行简单的功能定制选择（比如指定安装目录等），就可以安装成功，只不过是在字符界面下完成的。</p>
<p>目前常见的脚本程序以各类硬件的驱动居多，我们需要学习一下这类软件的安装方式，以备将来不时之需。</p>
<h3 id="webmin-安装"> Webmin 安装</h3>
<ol>
<li><strong>简介</strong></li>
</ol>
<p>我们来看看脚本程序如何安装和使用。安装一个叫作 Webmin 的工具软件，Webmin 是一个基于 Web 的系统管理界面。借助任何支持表格和表单的浏览器（和 File Manager 模块所需要的 Java），你就可以设置用户账号、apache、DNS、文件共享等。Webmin 包括一个简单的 Web 服务器和许多 CGI 程序，这些程序可以直接修改系统文件，比如 <code>/etc/inetd.conf</code> 和 <code>/etc/passwd</code>。 Web 服务器和所有的 CGI 程序都是用 Perl 语言编写的，没有使用任何非标准 Perl 模块。也就是说，Webmin 是一个用 Perl 语言写的、可以通过浏览器管理 Linux 的软件。</p>
<ol start="2">
<li><strong>安装步骤</strong></li>
</ol>
<p>首先下载 Webmin 软件，地址为<a href="https://github.com/webmin/webmin/releases" target="_blank" rel="noopener noreferrer">https://github.com/webmin/webmin/releases</a>，这里下载的是 webmin-1.610.tar.gz。</p>
<p>接下来解压缩软件，命令如下：</p>
<div><pre><code><span># 1) 首先下载 Webmin 软件</span>
<span>[</span>root@localhost ~<span>]</span><span># wget -O webmin-1.972.tar.gz https://github.com/webmin/webmin/archive/refs/tags/1.972.tar.gz</span>

<span># 2) 接下来解压缩软件</span>
<span>[</span>root@localhost ~<span>]</span><span># tar -zxvf webmin-1.972.tar.gz</span>

<span># 3) 进入解压目录</span>
<span>[</span>root@localhost ~<span>]</span> <span>cd</span> webmin-1.972

<span># 4) 执行安装程序 setup.sh，并指定功能选项</span>
<span>[</span>root@localhost webmin-1.610<span>]</span><span># ./setup.sh</span>
***********************************************************************
*            Welcome to the Webmin setup script, version <span>1.972</span>        *
***********************************************************************
Webmin is a web-based interface that allows Unix-like operating
systems and common Unix services to be easily administered.

Installing Webmin <span>in</span> /root/webmin-1.972 <span>..</span>.

***********************************************************************
Webmin uses separate directories <span>for</span> configuration files and log files.
Unless you want to run multiple versions of Webmin at the same <span>time</span>
you can just accept the defaults.

Config <span>file</span> directory <span>[</span>/etc/webmin<span>]</span>: /usr/local/webmin
<span>#选择安装位置，默认安装在 /etc/webmin 目录下，则直接回车；或者输入指定的位置</span>
Log <span>file</span> directory <span>[</span>/var/webmin<span>]</span>: 
<span>#日至文件保存位置，直接回车，选择默认位置</span>

***********************************************************************
Webmin is written entirely <span>in</span> Perl. Please enter the full path to the
Perl <span>5</span> interpreter on your system.

Full path to perl <span>(</span>default /usr/bin/perl<span>)</span>:
<span>#指定 perl 语言的安装位置，直接回车，选择默认位置，perl 默认就安装在这里</span>

Testing Perl <span>..</span>.
Perl seems to be installed ok

***********************************************************************
Operating system name:    CentOS Linux
Operating system version: <span>7.9</span>.2009

***********************************************************************
Webmin uses its own password protected web server to provide access
to the administration programs. The setup script needs to know <span>:</span>
 - What port to run the web server on. There must not be another
   web server already using this port.
 - The login name required to access the web server.
 - The password required to access the web server.
 - If the webserver should use SSL <span>(</span>if your system supports it<span>)</span>.
 - Whether to start webmin at boot time.

Web server port <span>(</span>default <span>10000</span><span>)</span>: 
<span>#指定 webmin 监听的端口，直接回车，默认选定 10000</span>
Login name <span>(</span>default admin<span>)</span>: admin
<span>#输入登入 webmin 的用户名</span>
Login password: 
<span>#输入登陆密码</span>
Password again:
<span>#再次输入登陆密码</span>
Use SSL <span>(</span>y/n<span>)</span>:n
<span>#是否启用 SSL 功能</span>
The Perl SSLeay library is not installed. SSL not available.
<span># apache 默认没有启动 SSL 功能，所以 SSL 没有被激活</span>
Start Webmin at boot <span>time</span> <span>(</span>y/n<span>)</span>: y
<span>#是否在开机的同时启动 webmin</span>
***********************************************************************
Creating web server config files<span>..</span>
<span>..</span>done

Creating access control file<span>..</span>
<span>..</span>done

Inserting path to perl into scripts<span>..</span>
<span>..</span>done

Creating start and stop scripts<span>..</span>
<span>..</span>done

Copying config files<span>..</span>
<span>..</span>done

Configuring Webmin to start at boot time<span>..</span>
<span>..</span>done

Creating uninstall script /usr/local/webmin/uninstall.sh <span>..</span>
<span>..</span>done

Changing ownership and permissions <span>..</span>
<span>..</span>done

Running postinstall scripts <span>..</span>
<span>..</span>done

Enabling background status collection <span>..</span>
<span>..</span>done

Attempting to start Webmin mini web server<span>..</span>
Starting Webmin server <span>in</span> /root/webmin-1.972
<span>..</span>done

***********************************************************************
Webmin has been installed and started successfully. Use your web
browser to go to

  http://localhost.localdomain:10000/

and login with the name and password you entered previously.
<span>#安装完成</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br></div></div><p>在浏览器地址栏中输入“http://192.168.122.55:10000/”（自己本机的 IP 地址），然后输入用户名和密码，就可以登录到 Webmin 界面，如图12-3 所示。</p>
<div>
<p><img src="./assets/webmin.png" alt="webmin" loading="lazy"></p>
<p><strong>图12-3	<u>Webmin 登录界面</u></strong></p>
</div>
<p>当然，我们并不是要讲解 Webmin 管理界面如何使用，而是要讲解脚本程序如何安装，所以工作已经完成。这种脚本安装简单快速，不过需要软件发行商发布安装脚本。但是 Limux中的绝大多数软件是没有这种脚本的。</p>
<h2 id="软件包的选择"> 软件包的选择</h2>
<p>至此，Linux 中的软件安装方式我们就讲完了，是不是比 Windows 中的软件安装要复杂一些。不过这也说明 Windows 下的病毒和木马是不能直接感染 Linux 的，因为它们的软件包是不一样的。</p>
<p>不过，在安装软件的时候，到底应该使用二进制包还是源码包？我们做一下总结和推荐，当然你也可以按照自己的意愿安装。</p>
<p>软件包安装注意事项：</p>
<ul>
<li>
<p>如果是 Linux 的底层模块和自带软件，则推荐使用 RPM（DPKG）包安装，比如 gcc、图形界面、开发库等。另外，不需要手工定制功能的软件，都推荐使用 RMP（DPKG）包安装，毕竟安装简单。</p>
</li>
<li>
<p>如果是在服务器上应用的服务程序，则推荐使用源码包安装，比如 apache、DNS、Mail 等服务程序。这样它们更适合你的服务器系统，性能更加优化，功能完全由你自由定义。</p>
</li>
<li>
<p>如果要安装二进制包程序，那么既可以手工使用 RPM （DPKG）包安装，也可以使用 yum（apt） 安装。但是如果要卸载程序，则最好不要使用 yum（apt可以） 卸载，因为容易在卸载某个软件依赖包的时候，把 Linux 系统依赖包也卸载掉，从而导致系统崩溃。</p>
</li>
</ul>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-05-06T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">linux其他权限管理命令</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_basic/13.linux_other_auth/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_basic/13.linux_other_auth/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="访问控制列表权限"> 访问控制列表权限</h2>
<h3 id="acl权限介绍"> ACL权限介绍</h3>
<p>在普通权限中，用户对文件只有三种身份，就是属主、属组和其他人；每种用户身份拥有读（read)、写（write）和执行（execute）三种权限。但是在实际工作中，这三种身份实在是不够用，我们举个例子来看看。先看看示意图，如图14-1 所示。</p>
<div>
<p><img src="./assets/ACL.jpg" alt="ACL" loading="lazy"></p>
<p><strong>图14-1	<u>ACL 权限简介</u></strong></p>
</div>
<p>上图的根目录中有一个 /project 目录，这是班级的项目目录。班级中的每个学员都可以访问和修改这个目录，老师也需要对这个目录拥有访问和修改权限，其他班级的学员当然不能访问这个目录。需要怎么规划这个目录的权限呢？应该这样：老师使用 root 用户，作为这个目录的属主，权限为 rwx；班级所有的学员都加入 tgroup 组，使 tgroup 组作为 <code>/project</code> 目录的属组，权限是 rwx；其他人的权限设定为 0。这样这个目录的权限就可以符合我们的项目开发要求了。</p>
<p>有一天，班里来了一位试听的学员 st，她必须能够访问 <code>/project</code> 目录，所以必须对这个目录拥有 r 和 x 权限；但是她又没有学习过以前的课程，所以不能赋予她 w 权限，怕她改错了目录中的内容，所以学员 st 的权限就是 r-x。可是如何分配她的身份呢？变为属主？当然不行，要不 root 该放哪里？加入 tgroup 组？也不行，因为 tgroup 组的权限是 rwx，而我们要求学员 st 的权限是 r-x。如果把其他人的权限改为 r-x 呢？这样一来，其他班级的所有学员都可以访问 /project 目录了。</p>
<p>当出现这种情况时，普通权限中的三种身份就不够用了。ACL 权限就是为了解决这个问题的。在使用 ACL 权限给用户 st 陚予权限时，st 既不是 /project 目录的属主，也不是属组，仅仅赋予用户 st 针对此目录的 r-x 权限。这有些类似于 Windows 系统中分配权限的方式，单独指定用户并单独分配权限，这样就解决了用户身份不足的问题。</p>
<p><strong>ACL 是 Access Control List</strong>（访问控制列表）的缩写，不过在 Linux 系统中，ACL 用于设定用户针对文件的权限，而不是在交换路由器中用来控制数据访问的功能（类似于防火墙）。</p>
<h3 id="开启-acl-权限"> 开启 ACL 权限</h3>
<p>在 CentOS 6.x 系统中 ACL 权限默认是开启的，不需要手工开启。不过，如果你的操作系统不是 CentOS 6.x，那该如何查看 ACL 权限是否开启了呢？可以这样查看：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mount</span>
/dev/sda1 on /boot <span>type</span> ext4 <span>(</span>rw<span>)</span>
/dev/sda3 on I <span>type</span> ext4 <span>(</span>rw<span>)</span>
…省略部分输出…
<span>#使用mount命令可以看到系统中已经挂载的分区，但是并没有看到ACL权限的设置</span>
<span>[</span>root@localhost ~<span>]</span><span># dumpe2fs -h /dev/sda3	</span>
<span>#dumpe2fs是查询指定分区文件系统详细信息的命令</span>
<span>#选项-h：仅显示超级块中的信息，而不显示磁盘块组的详细信息</span>
…省略部分输出…
Default <span>mount</span> options: user_xattr acl
…省略部分输出…
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>使用 <code>mount</code> 命令可以査看到系统中已经挂载的分区，而使用 <code>dumpe2fs</code> 命令可以査看到这个分区文件系统的详细信息。大家可以看到，我们的 ACL 权限是 <code>/dev/sda3</code> 分区的默认挂载选项，所以不需要手工挂载。</p>
<p>不过我的 Linux 系统如果没有默认挂载，则可以手工挂载吗？当然可以，执行如下命令：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mount -o remount, acl /</span>
<span>#重新挂载根分区，并加入ACL权限</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>使用 mount 命令重新挂载，并加入 ACL 权限。不过使用此命令是临时生效的。要想永久生效，需要修改 <code>/etc/fstab</code> 文件，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span>#vi /etc/fstab</span>
<span>UUID</span><span>=</span>c2ca6f57-b15c-43ea-bca0-f239083d8bd2 /ext4 defaults,acl <span>1</span> <span>1</span>
<span>#加入ACL权限</span>
<span>[</span>root@localhost ~<span>]</span><span># mount -o remount /</span>
<span>#重新挂载文件系统或重启系统，使修改生效</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>在你需要开启 ACL 权限的分区行上（也就是说 ACL 权限针对的是分区），手工在 defaults 后面加入&quot;, acl&quot;即可永久在此分区中开启 ACL 权限。</p>
<h3 id="acl权限管理命令"> ACL权限管理命令</h3>
<p>我们知道了 ACL 权限的作用，也知道了如何开启 ACL 权限，接下来学习如何査看和设定 ACL 权限。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># getfacl 文件名</span>
<span>#查看ACL权限</span>
<span>[</span>root@localhost ~<span>]</span><span># setfacl [选项] 文件名</span>
<span>#设定ACL权限</span>

选项：
	-m	：设定 ACL 权限。如果是给予用户 ACL 权限，则使用<span>"u:用户名:权限"</span>格式赋予；如果是给予组 ACL 权限，则使用<span>"g:组名:权限"</span> 格式赋予；
	-x	：删除指定的 ACL 权限；
	-b	：删除所有的 ACL 权限；
	-d	：设定默认 ACL 权限。只对目录生效，指目录中新建立的文件拥有此默认权限；
	-k	：删除默认 ACL 权限；
	-R	：递归设定 ACL 权限。指设定的 ACL 权限会对目录下的所有子文件生效；
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="添加-acl-权限"> 添加 ACL 权限</h3>
<p>举个例子，就来看看上图中的权限怎么分配。我们要求 root 是 /project 目录的属主，权限是 rwx；tgroup 是此目录的属组，tgroup 组中拥有班级学员 zhangsan 和 lisi，权限是 rwx；其他人的权限是 0。这时，试听学员 st 来了，她的权限是 r-x。我们来看具体的分配命令。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># useradd zhangsan</span>
<span>[</span>root@localhost ~<span>]</span><span># useradd lisi</span>
<span>[</span>root@localhost ~<span>]</span><span># useradd st</span>
<span>[</span>root@localhost ~<span>]</span><span># groupadd tgroup</span>
<span>#添加需要试验的用户和用户组，省略设定密码的过程</span>
<span>[</span>root@localhost ~<span>]</span><span># mkdir /project #建立需要分配权限的目录</span>
<span>[</span>root@localhost ~<span>]</span><span># chown root:tgroup /project/</span>
<span>#改变/project目录的属主和属组</span>
<span>[</span>root@localhost ~<span>]</span><span># chmod 770 /project/</span>
<span>#指定/project目录的权限</span>
<span>[</span>root@localhost ~<span>]</span><span># ll -d /project/</span>
drwxrwx--- <span>2</span> root tgroup <span>4096</span> <span>1</span>月19 04:21 /project/
<span>#查看一下权限，已经符合要求了</span>
<span>#这时st学员来试听了，如何给她分配权限</span>
<span>[</span>root@localhost ~<span>]</span><span># setfacl -m u:st:rx /project/</span>
<span>#给用户st赋予r-x权限，使用"u:用户名:权限" 格式</span>
<span>[</span>root@localhost /<span>]</span><span># cd /</span>
<span>[</span>root@localhost /<span>]</span><span># ll -d project/</span>
drwxrwx---+ <span>3</span> root tgroup <span>4096</span> <span>1</span>月19 05:20 project/
<span>#使用ls-l査询时会发现，在权限位后面多了一个"+"，表示此目录拥有ACL权限</span>
<span>[</span>root@localhost /<span>]</span><span># getfacl project</span>
<span>#查看/prpject目录的ACL权限</span>
<span># file: project			&lt;-文件名</span>
<span># owner: root			&lt;-文件的属主</span>
<span># group: tgroup			&lt;-文件的属组</span>
user::rwx				<span>&lt;</span>-用户名栏是空的，说明是属主的权限
user:st:r-x				<span>&lt;</span>-用户st的权限
group::rwx				<span>&lt;</span>-组名栏是空的，说明是属组的权限
mask::rwx				<span>&lt;</span>-mask权限
other::---				<span>&lt;</span>-其他人的权限
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>大家可以看到，st 用户既不是 /prpject 目录的属主、属组，也不是其他人，我们单独给 st 用户分配了 r-x 权限。这样分配权限太方便了，完全不用先辛苦地规划用户身份了。</p>
<p>我想给用户组赋予 ACL 权限可以吗？当然可以，命令如下：</p>
<div><pre><code><span>[</span>root@localhost /<span>]</span><span># groupadd tgroup2</span>
<span>#添加测试组</span>
<span>[</span>root@localhost /<span>]</span><span># setfacl -m g:tgroup2:rwx project/</span>
<span>#为组tgroup2纷配ACL权限，使用"g:组名:权限"格式</span>
<span>[</span>root@localhost /<span>]</span><span># ll -d project/</span>
drwxrwx---+ <span>2</span> root tgroup <span>4096</span> <span>1</span>月19 04:21 project/
<span>#属组并没有更改</span>
<span>[</span>root@localhost /<span>]</span><span># getfacl project/</span>
<span># file: project/</span>
<span># owner: root</span>
<span># group: tgroup</span>
user::rwx
user:st:r-x
group::rwx
group:tgroup2:rwx <span>&lt;</span>-用户组tgroup2拥有了rwx权限
mask::rwx
other::--
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="最大有效权限-mask"> 最大有效权限 mask</h3>
<p>mask 是用来指定最大有效权限的。mask 的默认权限是 rwx，如果我给 st 用户赋予了 r-x 的 ACL 权限，mj 需要和 mask 的 rwx 权限&quot;相与&quot;才能得到 st 的真正权限，也就是 r-x &quot;相与&quot;rwxtj 出的值是 r-x，所以 st 用户拥有 r-x 权限。</p>
<p>如果把 mask 的权限改为 r--，和 st 用户的权限相与，也就是 r--&quot;相与&quot;r-x 得出的值是 r--，st 用户的权限就会变为只读。大家可以这么理解：用户和用户组所设定的权限必须在 mask 权限设定的范围之内才能生效，mask权限就是最大有效权限。</p>
<p>不过我们一般不更改 mask 权限，只要给予 mask 最大权限 rwx，那么任何权限和 mask 权限相与，得出的值都是权限本身。也就是说，我们通过给用户和用户组直接赋予权限，就可以生效，这样做更直观。</p>
<div><p>补充</p>
<p>逻辑与运算的运算符是&quot;and&quot;。可以理解为生活中所说的&quot;并且&quot;。也就是相与的两个值都为真，结果才为真；有一个值为假，与的结果就为假。比如 A 相与 B，结果入表14-1 所示。</p>
</div>
<p><strong>表14-1	<u>逻辑与运算</u></strong></p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>and</th>
</tr>
</thead>
<tbody>
<tr>
<td>真</td>
<td>真</td>
<td>真</td>
</tr>
<tr>
<td>真</td>
<td>假</td>
<td>假</td>
</tr>
<tr>
<td>假</td>
<td>真</td>
<td>假</td>
</tr>
<tr>
<td>假</td>
<td>假</td>
<td>假</td>
</tr>
</tbody>
</table>
<p>那么两个权限相与和上面的结果类似，我们以读（r）权限为例，结果如表41-2 所示。</p>
<p><strong>表14-2	<u>读权限相与</u></strong></p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>and</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>r</td>
<td>r</td>
</tr>
<tr>
<td>r</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>-</td>
<td>r</td>
<td>-</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>所以，“rwx”相与“r-x”，结果是“r-x”；“r--”相与“r-x”，结果是“r--”。</p>
<p>修改最大有效权限的命令如下：</p>
<div><pre><code><span>[</span>root@localhost /<span>]</span><span># setfacl -m m:rx project/</span>
<span>#设定mask权限为r-x，使用"m:权限"格式</span>
<span>[</span>root@localhost /<span>]</span><span># getfacl project/</span>
<span># file：project/</span>
<span># owner：root</span>
<span># group：tgroup</span>
user::rwx
group::rwx <span>#effective:r-x</span>
mask::r-x
<span>#mask权限变为r-x</span>
other::--
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="默认-acl-权限和递归-acl-权限"> 默认 ACL 权限和递归 ACL 权限</h3>
<p>我们已经给 /project 目录设定了 ACL 权限，那么，在这个目录中新建一些子文件和子目录，这些文件是否会继承父目录的 ACL 权限呢？我们试试吧。</p>
<div><pre><code><span>[</span>root@localhost /<span>]</span><span># cd /project/</span>
<span>[</span>root@localhost project<span>]</span><span># touch abc</span>
<span>[</span>root@localhost project<span>]</span><span># mkdir d1</span>
<span>#在/project目录中新建了abc文件和d1目录</span>
<span>[</span>root@localhost project<span>]</span><span># ll</span>
总用量4
-rw-r--r-- <span>1</span> root root 01月19 05:20 abc
drwxr-xr-x <span>2</span> root root <span>4096</span> <span>1</span>月19 05:20 d1
<span>#这两个新建立的文件权限位后面并没有"+"，表示它们没有继承ACL权限</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>子文件 abc 和子目录 d1 因为是后建立的，所以并没有继承父目录的 ACL 权限。当然，我们可以手工给这两个文件分配 ACL 权限，但是如果在目录中再新建文件，都要手工指定，则显得过于麻烦。这时就需要用到默认 ACL 权限。</p>
<p>默认 ACL 权限的作用是：如果给父目录设定了默认 ACL 权限，那么父目录中所有新建的子文件都会继承父目录的 ACL 权限。默认 ACL 权限只对目录生效。命令如下：</p>
<div><pre><code><span>[</span>root@localhost /<span>]</span><span># setfacl -m d:u:st:rx /project/</span>
<span>#使用"d:u:用户名：权限"格式设定默认ACL权限</span>
<span>[</span>root@localhost project<span>]</span><span># getfacl project/</span>
<span># file: project/</span>
<span># owner: root</span>
<span># group: tgroup</span>
user:: rwx
user:st:r-x
group::rwx
group:tgroup2:rwx
mask::rwx
other::--
default:user::rwx 			<span>&lt;</span>-多出了default字段
default:user:st:r-x
default:group::rwx
default:mask::rwx
default:other::--
<span>[</span>root@localhost /<span>]</span><span># cd project/</span>
<span>[</span>root@localhost project<span>]</span><span># touch bcd</span>
<span>[</span>root@localhost project<span>]</span><span># mkdir d2</span>
<span>#新建子文件和子目录</span>
<span>[</span>root@localhost project<span>]</span><span># ll 总用量8</span>
-rw-r--r-- <span>1</span> root root 01月19 05:20 abc
-rw-rw----+ <span>1</span> root root 01月19 05:33 bcd
drwxr-xr-x <span>2</span> root root <span>4096</span> <span>1</span>月19 05:20 d1
drwxrwx---+ <span>2</span> root root <span>4096</span> <span>1</span>月19 05:33 d2
<span>#新建的bcd和d2已经继承了父目录的ACL权限</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>大家发现了吗？原先的 abc 和 d1 还是没有 ACL 权限，因为默认 ACL 权限是针对新建立的文件生效的。</p>
<p>再说说递归 ACL 权限。递归是指父目录在设定 ACL 权限时，所有的子文件和子目录也会拥有相同的 ACL 权限。</p>
<div><pre><code><span>[</span>root@localhost project<span>]</span><span># setfacl -m u:st:rx -R /project/</span>
<span>#-R递归</span>
<span>[</span>root@localhost project<span>]</span><span># ll</span>
总用量8
-rw-r-xr--+ <span>1</span> root root 01月19 05:20 abc
-rw-rwx--+ <span>1</span> root root 01月19 05:33 bcd
drwxr-xr-x+ <span>2</span> root root <span>4096</span> <span>1</span>月19 05:20 d1
drwxrwx--+ <span>2</span> root root <span>4096</span> <span>1</span>月19 05:33 d2
<span>#abc和d1也拥有了ACL权限</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><p>总结</p>
<p>默认 ACL 权限指的是针对父目录中新建立的文件和目录会继承父目录的 ACL 权限，格式是 <code>setfacl -m d:u:用户名:权限 文件名</code>；递归 ACL 权限指的是针对父目录中已经存在的所有子文件和子目录继承父目录的 ACL 权限，格式是 `setfacl -m u:用户名:权限 -R 文件名&quot;。</p>
</div>
<h3 id="删除-acl-权限"> 删除 ACL 权限</h3>
<p>我们来看看怎么删除 ACL 权限，命令如下：</p>
<p>删除指定的ACL权限：</p>
<div><pre><code><span>[</span>root@localhost /<span>]</span><span># setfacl -x u:st /project/</span>
<span>#删除指定用户和用户组的ACL权限</span>
<span>[</span>root@localhost /<span>]</span><span># getfacl project/</span>
<span># file:project/</span>
<span># owner: root</span>
<span># group: tgroup</span>
user::rwx
group::rwx
group:tgroup2:rwx
mask::rwx
other::--
<span>#st用户的权限已被删除</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>删除所有ACL权限：</p>
<div><pre><code><span>[</span>root@localhost /<span>]</span><span># setfacl -b project/</span>
<span>#会删除文件的所有ACL权限</span>
<span>[</span>root@localhost /<span>]</span><span># getfacl project/</span>
<span># file: project/</span>
<span># owner: root</span>
<span># group: tgroup</span>
user::rwx
group::rwx
other::--
<span>#所有ACL权限已被删除</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="文件特殊权限"> 文件特殊权限</h2>
<p>在复杂多变的生产环境中，单纯设置文件的rwx权限无法满足我们对安全和灵活性的需求，因此便有了 <strong>SetUID、SetGID 与 Sticky BIT</strong> 的特殊权限位。这是一种对文件权限进行设置的特殊功能，可以与一般权限同时使用，以弥补一般权限不能实现的功能。下面具体解释这 3 个特殊权限位的功能以及用法。</p>
<h3 id="文件特殊权限之-setuid"> 文件特殊权限之 SetUID</h3>
<ol>
<li>
<p>什么是 SetUID</p>
<p>在 Linux 系统中我们已经学习过 r（读）、w（写）、x（执行）这三种文件普通权限，但是我们在查询系统文件权限时会发现出现了一些其他权限字母，比如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ll /usz/bin/passwd</span>
-rwsr-xr-x <span>1</span> root root <span>25980</span> <span>2</span>月 <span>22</span> <span>2012</span> /usr/bin/passwd 
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>大家发现了吗？在属主本来应该写 ×（执行）权限的位置出现了一个小写 s，这是什么权限？我们把这种权限称作 SetUTD 权限，也叫作 SUID 的特殊权限。这种权限有什么作用呢？ 我们知道，在 Linux 系统中，每个普通用户都可以更改自己的密码，这是合理的设置。问题是， 普通用户的信息保存在<code>/etc/passwd</code>文件中，用户的密码实际保存在<code>/etc/shadow</code>文件中，也就是说，普通用户在更改自己的密码时修改了<code>/etc/shadow</code>文件中的加密密码，但是，看下面的 代码：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ll /etc/passwd</span>
-rw-r--r-- I root root <span>1728</span> <span>1</span>月 <span>19</span> 04:20 /etc/passwd
<span>[</span>root@localhost ~<span>]</span><span># ll /etc/shadow</span>
---------- <span>1</span> root root <span>1373</span> <span>1</span>月 <span>19</span> 04:21 /etc/shadow
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><code>/etc/passwd</code>文件的权限是 644，意味着只有超级用户 root 可以读/写，普通用户只有只读权限。<code>/etc/shadow</code>文件的权限是 000 ，也就是没有任何权限。这意味着只有超级用户可以读取文件内容，并且可以强制修改文件内容；而普通用户没有任何针对<code>/etc/shadow</code>文件的权限。也就是说，普通用户对这两个文件其实都是没有写权限的，那为什么普通用户可以修改自己的密码呢？</p>
<p>其实，普通用户可以修改自己的密码的秘密不在于<code>/etc/passwd</code>和<code>/etc/shadow</code>这两个文件， 而在于 <code>passwd</code> 命令。我们再来看看 <code>passwd</code> 命令的权限：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ll /usr/bin/passwd</span>
-rwsr-xr-x. <span>1</span> root root <span>25980</span> <span>2</span>月 <span>22</span> <span>2012</span> /usr/bin/passwd <span>passwd</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>passwd</code> 命令拥有特殊权限 SetUID，也就是在属主的权限位的执行权限上是 s。可以这样来理解它：当一个具有执行权限的文件设置 SetUID 权限后，用户在执行这个文件时将以文件所有者的身份来执行。<code>passwd</code> 命令拥有 SetUID 权限，所有者为 root（Linux 中的命令默认所有者都是 root），也就是说，当普通用户使用 <code>passwd</code> 命令更改自己的密码的时候，实际上是在用 <code>passwd</code> 命令所有者 root 的身份在执行 <code>passwd</code> 命令，root 当然可以将密码写入 <code>/etc/shadow</code> 文件，所以普通用户也可以修改 <code>/etc/shadow</code> 文件，命令执行完成后，该身份也随之消失。</p>
<p>SetUID 的功能可以这样理解：</p>
<blockquote>
<p>1）只有执行的二进制程序才能设定 SUID 权限</p>
<p>2）命令执行者要对该程序有用 x（执行）权限</p>
<p>3）命令执行者在执行该程序时获得该程序文件属主的身份执行</p>
<p>4）SetUID 权限只在该程序执行过程中有效，也就是说身份改变只在程序执行过程中有效</p>
</blockquote>
</li>
<li>
<p>危险的 SetUID</p>
</li>
</ol>
<p>如果把系统命令本身拥有的 SetUID 权限取消，这样会导致命令本身可以执行的功能失效。但是如果我们给默认没有 SetUID 权限的系统命令赋予了 SetUID 权限，那又 会出现什么情况呢？那样的话系统就会出现重大安全隐患，这种操作一定不要随意执行。</p>
<p>手工赋予 SetUTD 权限真有这么恐怖吗？我们试试给常见的命令 vim 赋予 SetUID 权限， 看看会发生什么事情。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># chmod u+s /usr/bin/vim</span>
<span>[</span>root@localhost ~<span>]</span><span># ll /usr/bin/vim</span>
-rwsr-xr-x <span>1</span> root root <span>1847752</span> <span>4</span>月 <span>5</span> <span>2012</span> /usr/bin/vim
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>当 vim 命令拥有了 SetUID 权限后，任何普通用户在使用 vim 命令时，都会暂时获得 root 的身份和权限，那么很多普通用户本身不能查看和修改的文件马上就可以查看了，包括 <code>/etcpasswd</code>和<code>etc/shadow</code>这两个重要的用户信息文件，这样我就可以轻易地把自己的 UID 改 为 0，升级为超级用户了。如果我修改了系统重要的启动文件，比如<code>/etc/inittab</code>或<code>/etc/fstab</code>，就 可以轻易地导致系统瘫痪。 其实任何只有管理员可以执行的命令，如果被赋予了 SetUID 权限，那么后果都是灾难性的。大家可以想象普通用户可以随时重启服务器、随时关闭看得不顺眼的服务、随时添加其他普通用户的服务器是什么样子的吗？ 所以，SetUTD 权限不能随便设置，同时要防止黑客的恶意修改。</p>
<h3 id="文件特殊权限之-setgid"> 文件特殊权限之 SetGID</h3>
<p>前面学了 SetUID，那什么是 SetGID 呢？当 s 标志在属主的 x 位置时是 SeUID，那么s 标志在属组的 x 位置时是 SetGID，简称为SGID。比如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ll/usr/bin/locate</span>
-rwx--s--x <span>1</span> root glocate <span>35612</span> <span>8</span>月 <span>24</span> <span>2010</span> /usr/bin/locate 
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ol>
<li>
<p>SetGID 针对文件的作用</p>
<p>SetGID 既可以针对文件生效，也可以针对目录生效，这和 SetUID 明显不同。如果针对文件，那么 SetGID 的含义如下：</p>
<ul>
<li>
<p>只有可执行的二进制程序才能设置 SetGID 权限。</p>
</li>
<li>
<p>命令执行者要对该程序拥有 x（执行）权限。</p>
</li>
<li>
<p>命令执行者在执行程序的时候，组身份升级为该程序文件的属组。</p>
</li>
<li>
<p>SetGID 权限同样只在该程序执行过程中有效，也就是说，组身份改变只在程序执行过程中有效。</p>
</li>
</ul>
<p>和 <code>passwd</code> 命令类似，普通用户在执行 <code>locate</code> 命令的时候，会获取 <code>locate</code> 属组的组身份。<code>locate</code> 命令是在系统中按照文件名查找符合条件的文件的，不过它不是直接搜索系统的，而是搜索 <code>varlib/mlocate/mlocate.db</code> 这个数据库的。我们来看看这个数据库的权限。</p>
<div><pre><code> <span>[</span>root@localhost ~<span>]</span><span># ll /var/lib/mlocate/mlocate.db</span>
 -rw-r----- <span>1</span> root <span>slocate</span> <span>1838850</span> <span>1</span>月 <span>20</span> 04:29 /var/lib/mlocate/mlocate.db
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>大家会发现，属主权限是 r、w，属组权限是 r，其他人的权限是 0。那是不是意味着普通用户不能使用 <code>locate</code> 命令呢？再看看 <code>locate</code> 命令的权限。</p>
<div><pre><code> <span>[</span>root@localhost ~<span>]</span><span># ll /usr/bin/locate</span>
 -rwx--s--x <span>1</span> root <span>slocate</span> <span>35612</span> <span>8</span>月 <span>24</span> <span>2010</span> /usr/bin/locate
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>当普通用户 lamp 执行 <code>locate</code> 命令时，会发生如下事情：</p>
<ul>
<li><code>/usr/bin/locate</code> 是可执行二进制程序，可以被赋予 SetGID 权限。</li>
<li>执行用户 lamp 对 <code>locate</code> 命令拥有执行权限。</li>
<li>执行 <code>locate</code> 命令时，组身份会升级为 slocate 组，而 slocate 组对<code>/var/lib/mlocate/mlocate.db</code>数据库拥有 r 权限，所以普通用户可以使用 <code>locate</code> 命令查询 mlocate.db 数据库。</li>
<li>命令结束，lamp 用户的组身份返回为 lamp 组。</li>
</ul>
</li>
<li>
<p>SetGID 针对目录的作用</p>
<p>如果 SetGID 针对目录设置，则其含义如下：</p>
<ul>
<li>普通用户必须对此目录拥有 r 和 x 权限，才能进入此目录。</li>
<li>普通用户在此目录中的有效组会变成此目录的属组。</li>
<li>若普通用户对此目录拥有 w 权限，则此目录内所新建的文件（或子目录）默认属组是这个目录的属组。</li>
</ul>
</li>
</ol>
<h3 id="文件特殊权限之-sticky-bit"> 文件特殊权限之 Sticky BIT</h3>
<p>Sticky BIT 意为粘着位，也简称为 SBIT。它的作用如下：</p>
<ul>
<li>
<p>粘着位目前只对目录有效。</p>
</li>
<li>
<p>普通用户对该目录拥有 w 和 x 权限，即普通用户可以在此目录中拥有写入权限。</p>
</li>
<li>
<p>如果没有粘着位，那么，因为普通用户拥有 w 权限，所以可以删除此目录下的所有文件，包括其他用户建立的文件。一旦被赋予了粘着位，除了 root 可以删除所有文件，普通用户就算拥有 w 权限，也只能刪除自己建立的文件，而不能删除其他用户建立的文件。</p>
</li>
</ul>
<p>举个例子，默认系统中 <code>/tmp/</code> 目录拥有 SBIT 权限。</p>
<div><pre><code> <span>[</span>root@localhost ~<span>]</span><span># ll -d /tmp/</span>
 drwxrwxrwt <span>4</span> root root <span>4096</span> <span>1</span>月: <span>20</span> 06:17 /tmp/
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>在其他人的 x 权限位，被 t 符号占用了，代表 <code>/tmp/</code> 目录拥有 SBIT 权限。</p>
<h3 id="特殊权限设置"> 特殊权限设置</h3>
<p>说了这么多，到底该如何设置特殊权限呢？其实还是依赖 chmod 命令的，只不过文件的普通权限只有三个数字，例如，“755”代表属主拥有读、写、执行权限；属组拥有读、执行权 限；其他人拥有读、执行权限。如果把特殊权限也考虑在内，那么权限就应该写成“4755”， 其中“4”就是特殊权限 SetUTD 了，“755”还是代表属主、属组和其他人的权限。这几个特 殊权限这样来表示：</p>
<ul>
<li>
<p>4 代表 SetUID。</p>
</li>
<li>
<p>2 代表 SetGID。</p>
</li>
<li>
<p>1 代表 SBIT。</p>
</li>
</ul>
<p>举个例子，我们手工赋予一下特殊权限。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># touch ftest</span>
<span>[</span>root@localhost ~<span>]</span><span># chmod 4755 ftest</span>
<span>#赋予 SetuID 权限</span>
<span>[</span>root@localhost ~<span>]</span><span># ll ftest</span>
-rwsr-xr-x l root root <span>0</span> <span>1</span>月 <span>20</span> <span>23</span>:54 ftest
<span>#查看一下，属主的 x 位变成了 s</span>
<span>[</span>root@localhost ~<span>]</span><span># chmod 2755 ftest</span>
<span>#赋于 SetGID 权展</span>
<span>[</span>root@localhost ~<span>]</span><span># ll ftest</span>
-rwxr-sr-x <span>1</span> root root <span>0</span> <span>1</span>月 <span>20</span> <span>23</span>:54 ftest
<span>#查看一下，属组的 × 位变成了 s </span>
<span>[</span>root@localhost ~<span>)</span><span># mkdir dtest</span>
<span>[</span>root@localhost ~<span>]</span><span># chmod 1755 dtest/</span>
<span># SBIT 只对目录有效，所以建立测试目录，并赋予 SBIT 权限 </span>
<span>[</span>root@localhost ~<span>]</span><span># ll -d dtest/ drwxr-xr-t 2 root root 4096 1月 20 23:56 dtest/ </span>
<span>#查看一下，其他人的 x 位变成了 t </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>我们可以把特殊权限设置为“7777”吗？命令执行是没有问题的，这样会把 SUID， SGID、SBIT 权限都赋予一个文件，命令如下：</p>
<div><pre><code> <span>[</span>root@localhost ~<span>]</span><span># chmod 7777 ftest </span>
 <span>#一次赋予 SetUID、SetGID 和 SBIT 权限</span>
 <span>[</span>root@localhost ~<span>]</span><span># ll ftest</span>
 -rwsrwsrwt <span>1</span> root root <span>0</span> <span>1</span>月 <span>20</span> <span>23</span>:54 ftest
 <span>[</span>root@localhost ~<span>]</span><span># chmod 0755 ftest</span>
 <span>#取消特殊权限 </span>
 <span>[</span>root@localhost ~<span>]</span><span># ll ftest</span>
 -rwxr-xr-x <span>1</span> root root <span>0</span> <span>1</span>月 <span>20</span> <span>23</span>:54 ftest 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>但是这样做没有任何意义，因为这几个特殊权限操作的对象不同，SetUID 只对二进制程序文件有效，SetGID 可以对二进制程序文件和目录有效，但是 SBIT 只对目录有效。所以，如果需要设置特殊权限，则还是需要分开设置的。</p>
<p>我们讲过，在赋予权限的时候可以采用字母的方式，这对特殊权限来讲是同样适用的。比如我们可以通过“ u+s ”赋予 SetUID 权限，通过“ g+s ”赋予 SetGID 权限，通过“ o+t ”赋予 SBIT 权限。命令如下：</p>
<div><pre><code> <span>[</span>root@localhost ~<span>]</span><span># chmod u+s,g+s,o+t ftest </span>
 <span>#设置特殊权限</span>
 <span>[</span>root@localhost ~<span>]</span><span># ll ftest</span>
 -rwsr-sr-t <span>1</span> root root <span>0</span> <span>1</span>月 <span>20</span> <span>23</span>:54 ftest 
 <span>[</span>root@localhost ~<span>]</span><span># chmod u-s,g-s,o-t ftest </span>
 <span>#取消特殊权限 </span>
 <span>[</span>root@localhost ~<span>]</span><span># ll ftest </span>
 -rwxr-xr-x <span>1</span> root root <span>0</span> <span>1</span>月 <span>20</span> <span>23</span>:54 ftest
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>最后，还有一个大家要注意的问题，特殊权限只针对具有可执行权限的文件有效，不具有 x 权限的文件被赋予了 SetUID 和 SetGID 权限会被标记为 S，SBIT 权限会被标记为 T，仔细想 一下，如果没有可执行权限，则设置特殊权限无任何意义。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># chmod 7666</span>
<span>[</span>root@localhost ~<span>]</span><span># ll ftest</span>
-rwSrwSrwT <span>1</span> root root <span>0</span> <span>1</span>月 <span>20</span> <span>23</span>:54 ftest 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>大家也可以这样理解：S 和 T代表“空的”，没有任何意义。</p>
<h2 id="文件系统属性权限"> 文件系统属性权限</h2>
<h3 id="设定文件系统属性-chattr"> 设定文件系统属性：chattr</h3>
<p><code>chatr</code> 只有 root 用户可以使用，用来修改文件系统的权限属性，建立凌驾于 rwx 基础权限之上的授权。命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># chattr [+-=] [选项] 文件或目录名</span>
选项：
	+	：增加权限
	-	：删除权限
	<span>=</span>	：等于某权限 
	i	：如果对文件设置 i 属性，那么不允许对文件进行删除、改名，也不能添加和修改数据；如果对目录设置 i 属性，那么只能修改目录下文件中的数据，但不允许建立和删除文件
	a	：如果对文件设置 a 属性，那么只能在文件中增加数据，但是不能删除和修改数据；如果对目录设置 a 属性，那么只允许在目录中建立和修改文件，但是不允许删除文件 
	e	：Linux 中的绝大多数文件都默认拥有 e 属性，表示该文件是使用 ext 文件系统进行 存储的，而且不能使用“chattr -e”命令取消 e 属性
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><code>chattr</code> 命令不宜对目录 <code>/</code>、<code>/dev/</code>、<code>tmp/</code>、<code>/var/</code>、等进行设置，严重者甚至容易导致系统无法启动。</p>
<h3 id="查看文件系统属性-lsattr"> 查看文件系统属性：lsattr</h3>
<p><code>lsattr</code> 命令比较简单，命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># lsattr [选项]文件名 </span>
选项：
	-a	：显示所有文件和目录
	-d	：如果目标是目录，则仅列出目录本身的属性，而不会列出文件的属性

<span>[</span>root@localhost ~<span>]</span><span># lsattr -d /back/log/</span>
 -----a------e- /back/log/ 
 <span>#查看/back/10g/目录，其拥有 a 和 e 属性</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="系统命令-sudo-权限"> 系统命令 sudo 权限</h2>
<h3 id="sudo-用法"> sudo 用法</h3>
<p>管理员作为特权用户，很容易误操作造成不必要的损失。再者，都由 root 管理也怪累的，管理员也是人，也需要留点时间去约约会、看看电影、装装傻、发发呆，不是吗？所以健康的管理方法是在 Linux 服务架构好后，可授权普通用户协助完成日常管理。现在较为流行的工具是 sudo，几乎所有 Linux 都已默认安装。还要注意一点，我们在前面介绍的所有权限，比如普通权限、默认权限、ACL 权限、特殊权限、文件系统属性权限等操作的对象都是文件和目 录，但是 sudo 的操作对象是系统命令，也就是 root 把本来只能由超级用户执行的命令赋予普通用户执行。 sudo 使用简单，管理员 root 使用 visudo 命令即可编辑其配置文件<code>/etc/sudoers</code>进行授权。 命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># visudo</span>
<span>..</span>.省略部分输出<span>..</span>.
root    <span>ALL</span><span>=</span><span>(</span>ALL<span>)</span>    ALL
<span># %wheell	ALI=(ALL)	ALL &lt;---此行是注释的，没有生效</span>
<span>#这两行是系统为我们提供的模板，我们参照它写自己的就可以了</span>
<span>..</span>.省略部分输出<span>..</span>. 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>解释一下文件的格式。</p>
<div><pre><code>root    <span>ALL</span><span>=</span><span>(</span>ALL<span>)</span>   ALI
<span>#用户名    被管理主机的地址=（可使用的身份）    授权命令（绝对路径）</span>
<span># %wheel    ALL=(ALL)    ALL</span>
<span># %组名    被管理主机的地址=（可使用的身份）    授权命令（绝对路径） </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>4 个参数的具体含义如下。</p>
<ul>
<li>用户名/组名：代表 root 给哪个用户或用户组赋予命令，注意组名前加“%”。</li>
<li>用户可以用指定的命令管理指定 IP 地址的服务器。如果写 ALL，则代表用户可以管理任何主机：如果写固定 IP，则代表用户可以管理指定的服务器。如果我们在这里写本机的 IP 地址，则不代表只允许本机的用户使用指定命令，而代表指定的用户可以从任何 IP 地址来管理当前服务器。</li>
<li>可使用的身份：就是把来源用户切换成什么身份使用，(ALL)代表可以切换成任意身份。这个字段可以省略。</li>
<li>授权命令：代表 root 把什么命令授权给普通用户。默认是 ALL，代表任何命令，这当然不行。如果需要给哪个命令授权，则只需写入命令名即可。不过需要注意，一定要写成绝对路径。</li>
</ul>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-05-05T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">linux文件系统管理</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_basic/14.linux_filesystem_manage/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_basic/14.linux_filesystem_manage/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>文件系统这个名词大家都很陌生，不过如果说成分区，大家就比较容易理解了。原先每个分区只能格式化为一个文件系统，所以我们可以认为文件系统就是指分区。不过随着技术的进步，现在一个文件系统可以由几个分区组成，或者一个分区可以格式化为几个不同的文件系统，所以我们已经不能把文件系统和分区等同对待了。不过，为了便于理解，大家可以把文件系统想象成分区。下面会介绍硬盘的基本结构、Linux 中常见的文件系统，<code>fdisk</code> 命令分区和 swap 分区的手工分配等内容。</p>
<h2 id="硬盘结构"> 硬盘结构</h2>
<p>硬盘是计算机的主要外部存储设备。计算机中的存储设备种类非常多，常见的主要有软盘、硬盘、光盘、U 盘等，甚至还有网络存储设备 SAN、NAS 等，不过我们使用最多的还是硬盘。</p>
<p>如果从存储数据的介质上来区分，那么硬盘可以分为<strong>机械硬盘</strong>（Hard Disk Drive，HDD）和<strong>固态硬盘</strong>（Solid State Disk，SSD），机械硬盘采用磁性碟片来存储数据，而固态硬盘是通过闪存颗粒来存储数据的。</p>
<h3 id="机械硬盘"> 机械硬盘</h3>
<ol>
<li><strong>机械硬盘的物理结构</strong></li>
</ol>
<p>我们先来看看最常见的机械硬盘。机械硬盘的外观大家可能都见过，那么机械硬盘拆开后是什么样子的呢？如图15-1 所示。</p>
<div>
<p><img src="./assets/hdd.jpg" alt="hdd" loading="lazy"></p>
<p><strong>图15-1	<u>机械硬盘结构</u></strong></p>
</div>
<p>机械硬盘主要由<strong>磁盘盘片、磁头、主轴与传动轴等</strong>组成，我们的数据就存放在磁盘盘片当中。大家见过老式的留声机吗？留声机上使用的唱片和我们的磁盘盘片非常相似，只不过留声机只有一个磁头，而硬盘是上下双磁头，盘片在两个磁头中间高速旋转，类似图15-2。</p>
<div>
<p><img src="./assets/hdd_1.jpg" alt="hdd1" loading="lazy"></p>
<p><strong>图15-2	<u>磁盘盘片</u></strong></p>
</div>
<p>也就是说，机械硬盘是上下盘面同时进行数据读取的。而且机械硬盘的旋转速度要远高于唱片（目前机械硬盘的常见转速是 7200 r/min），所以机械硬盘在读取或写入数据时，非常害怕晃动和磕碰。另外，因为机械硬盘的超高转速，如果内部有灰尘，则会造成磁头或盘片的损坏，所以机械硬盘内部是封闭的，如果不是在无尘环境下，则禁止拆开机械硬盘。</p>
<ol start="2">
<li><strong>机械硬盘的逻辑结构</strong></li>
</ol>
<p>我们已经知道数据是写入破盘盘片的，那么数据是按照什么结构写入的呢？机械硬盘的逻辑结构主要分为<strong>磁道、扇区和柱面</strong>。我们来看看图15-3。</p>
<div>
<p><img src="./assets/hdd_2.jpg" alt="hdd2" loading="lazy"></p>
<p><strong>图15-3	<u>磁道和扇区</u></strong></p>
</div>
<p><strong>什么是磁道呢</strong>？每个盘片都在逻辑上拥有很多的同心圆，最外面的同心圆就是 0 磁道。我们将每个同心圆称作磁道（注意，磁道只是逻辑结构，在盘面上并没有真正的同心圆）。硬盘的磁道密度非常高，通常一面上就有上千个磁道。但是相邻的磁道之间并不是紧挨着的，这是因为磁化单元相隔太近会相互产生影响。</p>
<p><strong>那扇区又是什么呢</strong>？扇区其实是很形象的，大家都见过折叠的纸扇吧，纸扇打开后是半圆形或扇形的，不过这个扇形是由每个扇骨组合形成的。在磁盘上每个同心圆是磁道，从圆心向外呈放射状地产生分割线（扇骨），将每个磁道等分为若干弧段，每个弧段就是一个扇区。每个扇区的大小是固定的，为 <strong>512 Byte</strong>。扇区也是磁盘的最小存储单位。</p>
<p><strong>那柱面又是什么呢</strong>？如果硬盘是由多个盘片组成的，每个盘面都被划分为数目相等的磁道，那么所有盘片都会从外向内进行磁道编号，最外侧的就是 0 磁道。具有相同编号的磁道会形成一个圆柱，这个圆柱就被称作磁盘的柱面，如图15-4 所示。</p>
<div>
<p><img src="./assets/hdd_3.jpg" alt="hdd3" loading="lazy"></p>
<p><strong>图15-4	<u>柱面</u></strong></p>
</div>
<p>硬盘的大小是使用“<strong>磁头数×柱面数×扇区数×每个扇区的大小</strong>”这样的公式来计算的。</p>
<p>其中，磁头数（Heads）表示硬盘共有几个磁头，也可以理解为硬盘有几个盘面，然后乘以 2；柱面数（Cylinders）表示硬盘每面盘片有几条磁道；扇区数（Sectons）表示每条磁道上有几个扇区；每个扇区的大小一般是 512 Byte。</p>
<ol start="3">
<li><strong>硬盘的接口</strong></li>
</ol>
<p>机械硬盘通过接口与计算机主板进行连接。硬盘的读取和写入速度与接口有很大关系。大家都见过大礼堂吧，大礼堂中可以容纳很多人，但是如果只有一扇很小的门，那么人是很难进入或出来的，这样会造成拥堵，甚至会出现事故。机械硬盘的读取和写入也是一样的，如果接口的性能很差，则同样会影响机械硬盘的性能。目前我们常见的机械硬盘接口有这样几种。</p>
<ul>
<li>IDE 硬盘接口（Integrated Drive Electronics，并口，即电子集成驱动器）也称作“ATA 硬盘”或“PATA 硬盘”，是早期机械硬盘的主要接口，ATA133 硬盘的理论速度可以达到 133MB/s（此速度为理论平均值)，IDE 硬盘接口如图15-5 所示。</li>
</ul>
<div>
<p><img src="./assets/hdd_4.jpg" alt="hdd4" loading="lazy"></p>
<p><strong>图15-5	<u>IDE 硬盘接口</u></strong></p>
</div>
<ul>
<li>SATA 接口（Serial ATA，串口）是速度更高的硬盘标准，具备了更高的传输速度，并具备了更强的纠错能力。目前已经是 SATA 三代，理论传输速度达到 600MB/s（此速度为理论平均值)，如图15-6 所示。</li>
</ul>
<div>
<p><img src="./assets/hdd_5.jpg" alt="hdd5" loading="lazy"></p>
<p><strong>图15-6	<u>SATA 硬盘接口</u></strong></p>
</div>
<ul>
<li>SCSI 接口（Small Computer System Interface，小型计算机系统接口）广泛应用在服务器上，具有应用范围广、多任务、带宽大、CPU 占用率低及支持热插拔等优点，理论传输速度达到 320MB/s，如图15-7 所示。</li>
</ul>
<div>
<p><img src="./assets/hdd_6.jpg" alt="hdd6" loading="lazy"></p>
<p><strong>图15-7	<u>SCSI 硬盘接口</u></strong></p>
</div>
<ul>
<li>M.2 接口（也就是以前经常提到的 NGFF，即 Next Generation Form Factor）是为超极本（Ultrabook）量身定做的新一代接口标准接口。无论规格尺寸，还是传输性能，都有很大的提升，理论带宽最大可达 4GB/s，如图15-8 所示。</li>
</ul>
<div>
<p><img src="./assets/hdd_7.jpg" alt="hdd7" loading="lazy"></p>
<p><strong>图15-8	<u>M.2 硬盘接口</u></strong></p>
</div>
<h3 id="固态硬盘"> 固态硬盘</h3>
<p>固态硬盘和传统的机械硬盘最大的区别就是不再采用盘片进行数据存储，而采用存储芯片进行数据存储。固态硬盘的存储芯片主要分为两种：一种是采用闪存作为存储介质的；另一种是采用 DRAM 作为存储介质的。目前使用较多的主要是采用闪存作为存储介质的固态硬盘，如图15-9 所示。</p>
<div>
<p><img src="./assets/ssd.jpg" alt="ssd" loading="lazy"></p>
<p><strong>图15-9	<u>固态硬盘</u></strong></p>
</div>
<p>固态硬盘和机械硬盘对比主要有以下一些特点，如表15-1 所示。</p>
<p><strong>表15-1	<u>固态硬盘和机械硬盘对比</u></strong></p>
<table>
<thead>
<tr>
<th>对比项目</th>
<th>固态硬盘</th>
<th>机械硬盘</th>
</tr>
</thead>
<tbody>
<tr>
<td>容量</td>
<td>较小</td>
<td><strong>大</strong></td>
</tr>
<tr>
<td>读/写速度</td>
<td><strong>极快</strong></td>
<td>—般</td>
</tr>
<tr>
<td>写入次数</td>
<td>5000〜100000 次</td>
<td><strong>没有限制</strong></td>
</tr>
<tr>
<td>工作噪声</td>
<td><strong>极低</strong></td>
<td>有</td>
</tr>
<tr>
<td>工作温度</td>
<td><strong>极低</strong></td>
<td>较高</td>
</tr>
<tr>
<td>防震</td>
<td><strong>很好</strong></td>
<td>怕震动</td>
</tr>
<tr>
<td>重量</td>
<td><strong>低</strong></td>
<td>高</td>
</tr>
<tr>
<td>价格</td>
<td>高</td>
<td><strong>低</strong></td>
</tr>
</tbody>
</table>
<p>大家可以发现，固态硬盘因为丢弃了机械硬盘的物理结构，所以相比机械硬盘具有了低能耗、无噪声、抗震动、低散热、体积小和速度快的优势；不过价格相比机械硬盘更高，而且使用寿命有限。</p>
<h2 id="linux-中常见的文件系统"> Linux 中常见的文件系统</h2>
<p>硬盘是用来存储数据的，我们可以将其想象成柜子，只不过柜子是用来存储衣物的。分区就是把一个大柜子按照要求分割成几个小柜子（组合衣柜）；格式化就是在每个小柜子中打入隔断，决定每个隔断的大小和位置，然后在柜门上贴上标签，标签中写清楚每件衣服保存的隔断的位置和这件衣服的一些特性（比如衣服是谁的，衣服的颜色、大小等）。很多人认为格式化的目的就是清空数据，其实格式化是为了写入文件系统（就是在硬盘中打入隔断并贴上标签）。</p>
<h3 id="文件系统的特性"> 文件系统的特性</h3>
<p>我们已经知道了，格式化是为了规划和写入文件系统。那么，Linux 中的文件系统到底是什么？它是什么样子的呢？在 CentOS 6.3 系统中默认的文件系统是 ext4，它是 ext3 文件系统的升级版。ext4 文件系统在性能、伸缩性和可靠性方面进行了大量改进。ext4 文件系统的变化可以说是翻天覆地的，比如向下兼容 ext3、最大 1EB 文件系统和 16TB 文件、无限数量子目录、Extents 连续数据块概念、多块分配、延迟分配、持久预分配、快速 FSCK、日志校验、无日志模式、在线碎片整理、inode 增强、默认启用 banier 等。ext4 文件系统是由 Theodore Tso（ext3 的维护者）领导的开发团队实现的，并引入 2.6.19 内核中。</p>
<p>那么，文件系统到底是如何运作的呢？文件系统中除要保存文件的数据外，还要保存文件的属性，如文件的权限、所有者、属组和时间参数等内容。文件系统把文件的数据和属性分开存放，把文件的数据放入 date block 中（数据块，保存文件的具体数据。类似衣柜的隔断，用来真正保存衣物），把文件的属性保存在 inode 中（i 节点，保存文件属性，如权限、所有者、属组和时间参数等。类似衣柜门上贴的标签，标签中写入衣物的特性）。每个 block 和 inode 都有序列号，用来区分和编码。另外，还有一个 super block（超级块）用于记录整个文件系统的信息，如 inode 和 block 的总量、已经使用量和剩余量。总结一下：</p>
<ul>
<li>
<p>super block（超级块）：记录整个文件系统的信息，包括 block 与 inode 的总量、已经使用的 inode 和 block 的数量、未使用的 inode 和 block 的数量、block 与 inode 的大小，文件系统的挂载时间、最近一次的写入时间、最近一次的磁盘检验时间等。</p>
</li>
<li>
<p>date block（数据块，也称作 block）：用来实际保存数据（柜子的隔断），block 的大小（1KB、2KB 或4KB）和数量在格式化后就已经决定，不能改变，除非重新格式化（在制作柜子的时候，隔断大小就已经决定，不能更改，除非重新制作柜子）。每个 block 只能保存一个文件的数据，如果文件数据小于一个 block 块，那么这个 block 的剩余空间不能被其他文件使用；如果文件数据大于一个 block 块，则要占用多个 block 块。Windows 中磁盘碎片整理工具的原理就是把一个文件占用的多个 block 块尽量整理到一起，这样可以加快读/写速度。</p>
</li>
<li>
<p>inode （i 节点，柜门上的标签）：用来记录文件的权限（r、w、x)、文件的所有者和属组、文件的大小、文件的状态改变时间（ctime)、文件的最近一次读取时间（atime）、文件的最近一次修改时间（mtime)、文件的数据真正保存的 block 编号。每个文件需要占用一个 inode。</p>
</li>
</ul>
<p>大家注意到了吗？在 inode 中并没有保存文件的文件名，那是因为文件名是文件所在目录的数据，所以保存在上一级目录的 block 中。还记得我们在讲权限命令的时候说过，要对文件的上一级目录拥有 w 权限，才能删除目录中的文件，就是因为文件名是保存在目录的 block 中的。</p>
<h3 id="linux-支持的常见文件系统"> Linux 支持的常见文件系统</h3>
<p>Linux 系统能够支持的文件系统非常多，除 Linux 默认文件系统 ext2、ext3 和 ext4 之外，还能支持 fat16、fat32、NTFS（需要重新编译内核）等 Windows 文件系统。也就是说，Linux 可以通过挂载的方式使用 Windows 文件系统中的数据。Linux 所能够支持的文件系统在 <code>/usr/src/kemels/当前系统版本/fs</code> 目录中（需要在安装时选择），该目录中的每个子目录都是一个可以识别的文件系统。我们介绍较为常见的 Linux 支持的文件系统，如表15-2 所示。</p>
<p><strong>表15-2	<u>常见的 Linux 支持的文件系统</u></strong></p>
<table>
<thead>
<tr>
<th>文件系统</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ext</td>
<td>Linux 中最早的文件系统，由于在性能和兼容性上具有很多缺陷，现在已经很少使用</td>
</tr>
<tr>
<td>ext2</td>
<td>是 ext 文件系统的升级版本，Red Hat Linux 7.2 版本以前的系统默认都是 ext2 文件系统。于 1993 年发布，支持最大 16TB 的分区和最大 2TB 的文件（1TB=1024GB=1024x1024KB）</td>
</tr>
<tr>
<td>ext3</td>
<td>是 ext2 文件系统的升级版本，最大的区别就是带日志功能，以便在系统突然停止时提高文件系统的可靠性。支持最大 16TB 的分区和最大 2TB 的文件</td>
</tr>
<tr>
<td>ext4</td>
<td>是 ext3 文件系统的升级版。ext4 在性能、伸缩性和可靠性方面进行了大量改进。ext4 的变化可以说是翻天覆地的，比如向下兼容 ext3、最大 1EB 文件系统和 16TB 文件、无限数量子目录、Extents 连续数据块 概念、多块分配、延迟分配、持久预分配、快速 FSCK、日志校验、无日志模式、在线碎片整理、inode 增强、默认启用 barrier 等。它是 CentOS 6.3 的默认文件系统</td>
</tr>
<tr>
<td>xfs</td>
<td>被业界称为最先进、最具有可升级性的文件系统技术，由 SGI 公司设计，目前最新的 CentOS 7 版本默认使用的就是此文件系统。</td>
</tr>
<tr>
<td>swap</td>
<td>swap 是 Linux 中用于交换分区的文件系统(类似于 Windows 中的虚拟内存)，当内存不够用时，使用交换分区暂时替代内存。一般大小为内存的 2 倍，但是不要超过 2GB。它是 Linux 的必需分区</td>
</tr>
<tr>
<td>NFS</td>
<td>NFS 是网络文件系统(Network File System)的缩写，是用来实现不同主机之间文件共享的一种网络服务，本地主机可以通过挂载的方式使用远程共享的资源</td>
</tr>
<tr>
<td>iso9660111</td>
<td>光盘的标准文件系统。Linux 要想使用光盘，必须支持 iso9660 文件系统</td>
</tr>
<tr>
<td>fat</td>
<td>就是 Windows 下的 fatl6 文件系统，在 Linux 中识别为 fat</td>
</tr>
<tr>
<td>vfat</td>
<td>就是 Windows 下的 fat32 文件系统，在 Linux 中识别为 vfat。支持最大 32GB 的分区和最大 4GB 的文件</td>
</tr>
<tr>
<td>NTFS</td>
<td>就是 Windows 下的 NTFS 文件系统，不过 Linux 默认是不能识别 NTFS 文件系统的，如果需要识别，则需要重新编译内核才能支持。它比 fat32 文件系统更加安全，速度更快，支持最大 2TB 的分区和最大 64GB 的文件</td>
</tr>
<tr>
<td>ufs</td>
<td>Sun 公司的操作系统 Solaris 和 SunOS 所采用的文件系统</td>
</tr>
<tr>
<td>proc</td>
<td>Linux 中基于内存的虚拟文件系统，用来管理内存存储目录 /proc</td>
</tr>
<tr>
<td>sysfs</td>
<td>和 proc —样，也是基于内存的虚拟文件系统，用来管理内存存储目录 /sysfs</td>
</tr>
<tr>
<td>tmpfs</td>
<td>也是一种基于内存的虚拟文件系统，不过也可以使用 swap 交换分区</td>
</tr>
</tbody>
</table>
<h3 id="硬盘分区"> 硬盘分区</h3>
<ol>
<li><strong>硬盘分区的类型</strong></li>
</ol>
<p>不管是 Windows 系统还是 Linux 系统，可以识别的分区类型就是以下三种，如图15-10 所示。</p>
<div>
<p><img src="./assets/disk_part.png" alt="disk_part" loading="lazy"></p>
<p><strong>图15-10	<u>分区示意图1</u></strong></p>
</div>
<ul>
<li>
<p>主分区：最多只能分为4个。</p>
</li>
<li>
<p>扩展分区：只能有一个，也算作主分区的一种，也就是说主分区加扩展分区最多有 4 个。但是扩展分区不能存储数据和进行格式化，必须再划分成逻辑分区才能使用。</p>
</li>
<li>
<p>逻辑分区：逻辑分区是在扩展分区中划分的。如果是 IDE 硬盘，那么 Linux 最多支持 59 个逻辑分区；如果是 SCSI 硬盘，那么 Linux 最多支持 11 个逻辑分区。</p>
</li>
</ul>
<h3 id="linux-中硬盘与分区的表示方式"> Linux 中硬盘与分区的表示方式</h3>
<p>我们知道，在 Linux 系统中，所有内容都是以文件方式保存的。硬盘和分区也是一样的。我们使用“sd”代表 SCSI 或 SATA 硬盘，使用“hd”代表 IDE 硬盘。使用“1～4”代表主分区或者扩展分区，使用“5～59”代表逻辑分区。也就是说，如果按照上图所示的方式来分区，那么分区的设备文件名就如表15-3 所示。</p>
<p><strong>表15-3	<u>分区的设备文件名1</u></strong></p>
<table>
<thead>
<tr>
<th>分区</th>
<th>设备文件名</th>
</tr>
</thead>
<tbody>
<tr>
<td>主分区 1</td>
<td><code>/dev/sda1</code></td>
</tr>
<tr>
<td>主分区 2</td>
<td><code>/dev/sda2</code></td>
</tr>
<tr>
<td>主分区 3</td>
<td><code>/dev/sda3</code></td>
</tr>
<tr>
<td>扩展分区</td>
<td><code>/dev/sda4</code></td>
</tr>
<tr>
<td>逻辑分区 1</td>
<td><code>/dev/sda5</code></td>
</tr>
<tr>
<td>逻辑分区 2</td>
<td><code>/dev/sda6</code></td>
</tr>
<tr>
<td>逻辑分区 3</td>
<td><code>/dev/sda7</code></td>
</tr>
</tbody>
</table>
<p>如果采用图15-11 所示的方式来分区，那么分区的设备文件名就如表15-4 所示。</p>
<div>
<p><img src="./assets/disk_part2.png" alt="disk_part2" loading="lazy"></p>
<p><strong>图15-11	<u>分区示意图2</u></strong></p>
</div>
<p><strong>表15-4	<u>分区的设备文件名2</u></strong></p>
<table>
<thead>
<tr>
<th>分区</th>
<th>设备文件名</th>
</tr>
</thead>
<tbody>
<tr>
<td>主分区 1</td>
<td><code>/dev/sda1</code></td>
</tr>
<tr>
<td>扩展分区</td>
<td><code>/dev/sda2</code></td>
</tr>
<tr>
<td>逻辑分区 1</td>
<td><code>/dev/sda5</code></td>
</tr>
<tr>
<td>逻辑分区 2</td>
<td><code>/dev/sda6</code></td>
</tr>
<tr>
<td>逻辑分区 3</td>
<td><code>/dev/sda7</code></td>
</tr>
</tbody>
</table>
<p>对于第二种分区方式，虽然主分区和扩展分区加起来只有两个，但是分区号 3 和分区号4 就算空着也不能被逻辑分区占用。也就是说，不管怎么分区，逻辑分区一定是从 <code>/dev/sda5</code>开始计算的。</p>
<h2 id="文件系统常用命令"> 文件系统常用命令</h2>
<p>我们先来学习一下文件系统相关的常用命令，只有知道了这些命令，才能有效地管理我们的文件系统。</p>
<h3 id="文件系统查看命令-df"> 文件系统查看命令：df</h3>
<p>通过 <code>df</code> 命令可以查看已经挂载的文件系统的信息，包括设备文件名、文件系统总大小、已经使用的大小、剩余大小、使用率和挂载点等。命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># df [选项] [挂载点或分区设备文件名]</span>
选项:
	-a	：显示所有文件系统信息，包括特殊文件系统，如 /proc、/sysfs
	-h	：使用习惯单位显示容量，如 KB、MB 或 GB 等
	-T	：显示文件系统类型
	-m	：以 MB 为单位显示容量
	-k	：以 KB 为单位显示容量。默认以 KB 为单位
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>举几个例子。</p>
<div><pre><code><span># 例子 1 ：显示系统内的文件系统信息</span>
<span>[</span>root@localhost ~<span>]</span><span># df</span>
文件系统		1K-块		已用		可用		已用%	挂载点
/dev/sda3	<span>28744836</span>	<span>2243516</span>	<span>25041148</span>	<span>9</span>%	/
tmpfs		<span>515396</span>		<span>515396</span>	<span>0</span>			<span>0</span>%	/dev/shm
<span>#内存虚拟出来的磁盘空间</span>
/dev/sdal	<span>198337</span>		<span>26333</span>	<span>161764</span>		<span>14</span>%	/boot
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>说明一下命令的输出结果。</p>
<blockquote>
<p>第一列：设备文件名。</p>
<p>第二列：文件系统总大小，默认以 KB 为单位。</p>
<p>第三列：已用空间大小。</p>
<p>第四列：未用空间大小。</p>
<p>第五列：空间使用百分比。</p>
<p>第六列：文件系统的挂载点。</p>
</blockquote>
<div><pre><code><span># 例子 2：</span>
<span>[</span>root@localhost ~<span>]</span><span># df -ahT</span>
<span>#	-a：显示特珠文件系统，这些文件系统几乎都是保存在内存中的，如 /proc。因为是挂载在内存中的，所以占用量都是0</span>
<span>#	-h：单位不再只用 KB，而是換算成习惯单位</span>
<span>#	-T：多出了文件系统类型一列</span>
文件系统			类型				容量		已用		可用		已用%	挂载点
/dev/sda3	  ext4				28G  	<span>2</span>.2G	24G		<span>9</span>% 		/
sysfs         sysfs         	<span>0</span>		<span>0</span>    	<span>0</span>     	- 		/sys
proc          proc          	<span>0</span>   	<span>0</span>     	<span>0</span>     	- 		/proc
devpts        devpts        	<span>0</span>		<span>0</span>       <span>0</span>    	- 		/dev/pts
tmpfs         tmpfs         	394M  	<span>1</span>.5M  	393M    <span>1</span>% 		/run
/dev/sda1     ext4          	194M   	26M   	158M   	<span>14</span>% 	/boot
none          binfmt_misc		<span>0</span>   	<span>0</span>   	<span>0</span>      	- 		/proc/sys/fs/bintmt_misc
sunrpe        rpe_pipersivar	<span>0</span>   	<span>0</span>   	<span>0</span>     	- 		/lib/nfs/rpe_pipefs
/dev/sro      iso9660       	<span>3</span>.5G 	<span>3</span>.5G	<span>0</span>  		<span>100</span>% 	/mnt/cdrom
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="统计目录或文件所占磁盘空间大小命令-du"> 统计目录或文件所占磁盘空间大小命令：du</h3>
<ol>
<li><strong>du命令</strong></li>
</ol>
<p><code>du</code> 是统计目录或文件所占磁盘空间大小的命令，需要注意的是，使用 <code>ls -l</code> 命令是可以看到文件的大小的。但是大家会发现，在使用 <code>ls -l</code> 命令查看目录大小时，目录的大小多数是 4KB，这是因为目录下的子目录名和子文件名是保存到父目录的 block （默认大小为 4KB）中的，如果父目录下的子目录和子文件并不多，一个 block 就能放下，那么这个父目录就只占用了一个 block 大小。大家可以将其想象成图书馆的书籍目录和实际书籍。如果我们用 <code>ls -l</code> 命令查看，则只能看到这些书籍占用了 1 页纸的书籍目录，但是实际书籍到底有多少是看不到的，哪怕它堆满了几个房间。</p>
<p>但是我们在统计目录时，不是想看父目录下的子目录名和子文件名到底占用了多少空间，而是想看父目录下的子目录和子文件的总磁盘占用量大小，这时就需要使用 <code>du</code> 命令才能统计目录的真正磁盘占用量大小。<code>du</code> 命令的格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># du [选项] [目录成文件名]</span>
选项：
	-a	：显示每个子文件的磁盘占用量。默认只统计子目录的磁盘占用量
	-h	：使用习惯单位显示磁盘占用量，如 KB、MB 或 GB 等
	-s	：统计息磁盘占用量，而不列出子目录和子文件的磁盘占用量
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>举几个例子。</p>
<div><pre><code><span># 例子 1：</span>
<span>[</span>root@localhost ~<span>]</span><span># du</span>
<span>#统计统计当前目录的总磁盘占用量的大小，同时会统计当前目录下所有子目录的磁盘占用量大小，不统计子文件磁盘占用量大小，默认单位为 KB1</span>
<span>20</span>		./.gnupg			<span>&lt;</span>---统计每个子目录的大小
<span>24</span>		./yum.bak
<span>8</span>		./dtest
<span>28</span>		./sh
<span>188</span>		<span>.</span>					<span>&lt;</span>---统计当前目录的大小

<span># 例子 2：</span>
<span>[</span>root@localhost ~<span>]</span><span># du -a</span>
<span>#统计当前目录的总大小，同时会统计当前目录下所有子文件和子目录磁盘占用量的大小。默认单位为 KB</span>
<span>4</span>		./.bash_logout
<span>36</span>		./install.l0g
<span>4</span>		./.bash_profile
<span>4</span>		./.cshrc
<span>..</span>.省略部分输出<span>..</span>.
<span>188</span>		<span>.</span>

<span># 例子 3：</span>
<span>[</span>root@localhost ~<span>]</span><span># du -sh</span>
<span>#只统计磁盘占用量总的大小，同时使用习惯单位显示</span>
188K	<span>.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><ol start="2">
<li><strong>du 命令和 df 命令的区别</strong></li>
</ol>
<p>有时我们会发现，使用 <code>du</code> 命令和 <code>df</code> 命令去统计分区的使用情况时，得到的数据是不一样的。那是因为 <code>df</code> 命令是从文件系统的角度考虑的，通过文件系统中未分配的空间来确定文件系统中已经分配的空间大小。也就是说，在使用 <code>df</code> 命令统计分区时，不仅要考虑文件占用的空间，还要统计被命令或程序占用的空间（最常见的就是文件已经删除，但是程序并没有释放空间）。而 <code>du</code> 命令是面向文件的，只会计算文件或目录占用的磁盘空间。也就是说，<code>df</code> 命令统计的分区更准确，是真正的空闲空间。</p>
<h3 id="挂载和卸载命令-mount-和-umount"> 挂载和卸载命令：mount 和 umount</h3>
<p>Linux 中所有的存储设备都必须在挂载之后才能使用，包括硬盘、U 盘和光盘（swap 分区是系统直接调用的，所以不需要挂载）。不过，硬盘分区在安装时就已经挂载了，而且会在每次系统启动时自动挂载，所以不需要手工参与。但是在 Linux 系统中要想使用光盘和 U 盘，就需要学一些挂载命令。</p>
<p>我们还需要复习一下，挂载是指把硬盘分区（如分区 <code>/dev/sdb1</code>，其实指的是文件系统）和挂载点（已经建立的空目录）联系起来的过程。这里需要注意，挂载点必须是目录，而且原则上应该使用空目录作为挂载点。</p>
<p>如果不使用空目录作为挂载点，而使用已经有数据的目录（如 <code>/etc/</code> 目录）作为挂载点，则会出现什么情况呢？很简单，原先 <code>/etc/</code> 目录下的数据就查找不到了，在 <code>/etc/</code> 目录中只能看到新的分区中的数据。这是因为 <code>/etc/</code> 目录原先并不是单独的分区，而是 <code>/</code> 分区的子目录，所以 <code>/etc/</code> 目录中的数据实际上保存在 <code>/</code> 分区的 block 中。但是现在给 <code>/etc/</code> 目录单独分区了，再向 <code>/etc/</code> 目录中保存数据，就会保存在 <code>/etc/</code> 目录的新分区的 blok 中，那么原始数据当然就不能看到了。如果还想访问原始数据，则只能把新分区卸载掉。</p>
<ol>
<li><strong>mount命令的基本格式</strong></li>
</ol>
<p>说了这么多，<code>mount</code> 命令的具体格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mount [-l]</span>
<span>#查询系统中已经挂载的设备，-l 会显示卷标名称</span>
<span>[</span>root@localhost ~<span>]</span><span># mount -a</span>
<span>#依据配置文件 /etc/fstab 的内容，自动挂载</span>

<span>[</span>root@localhost ~<span>]</span><span># mount [-t 文件系统] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点</span>
选项：
	-t 文件系统	：加入文件系统类型来指定挂载的类型，可以是 ext3、ext4、iso9660 等文件系统，具体可以参考---Linux 支持的常见文件系统的表
	-L 卷标名	：挂载指定卷标的分区，而不是安装设备文件名挂载
	-o 特殊选项	：可以指定挂载的额外选项，比如读写权限、同步/异步等，如果不指定,则默认值生效。具体的特殊选项参见表15-5
	
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>表15-5	<u>mount 命令挂载特殊选项</u></strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>atime/noatime</td>
<td>更新访问时间/不更新访问时间。在访问分区文件时，是否更新文件的访问时间，默认为更新</td>
</tr>
<tr>
<td>async/sync</td>
<td>异步/同步，默认为异步</td>
</tr>
<tr>
<td>auto/noauto</td>
<td>自动/手动。如 <code>mount -a</code> 命令执行时，是否会自动安装 <code>/etc/fstab</code> 文件内容挂载，默认为自动</td>
</tr>
<tr>
<td>default</td>
<td>定义默认值，相当于 rw、suid、dev、exec、auto，nouser、async 这 7个选项</td>
</tr>
<tr>
<td>exec/noexec</td>
<td>执行/不执行。设定是否允许在文件系统中执行可执行文件，默认是允许</td>
</tr>
<tr>
<td>remount</td>
<td>重新挂载已经挂载的文件系统，一般用于指定修改特殊权限</td>
</tr>
<tr>
<td>rw/ro</td>
<td>读写/只读。文件系统挂载时，是否拥有读写权限，默认是rw</td>
</tr>
<tr>
<td>suid/nosuid</td>
<td>具有/不具有 SetUID 权限。设定文件系统是否拥有 SetUID 和 SetGID 权限，默认是拥有</td>
</tr>
<tr>
<td>user/nouser</td>
<td>允许/不允许普通用户挂载。设定文件系统是否允许普通用户挂载，默认是不允许，只有 root 可以挂载分区</td>
</tr>
<tr>
<td>usrquota</td>
<td>代表文件系统支持用户磁盘配额，默认不支持</td>
</tr>
<tr>
<td>grpquota</td>
<td>代表文件系统支持组磁盘配额，默认不支持</td>
</tr>
</tbody>
</table>
<div><pre><code><span># 例子 1：</span>
<span>[</span>root@localhost ~<span>]</span><span># mount</span>
<span>#查看系统中已经挂载的文件系统，注意有虚拟文件系统</span>
/dev/sda3 on / <span>type</span> ext4 <span>(</span>rw,relatime,errors<span>=</span>remount-ro<span>)</span>
sysfs on /sys <span>type</span> sysfs <span>(</span>rw,nosuid,nodev,noexec,relatime,seclabel<span>)</span>
proc on /proc <span>type</span> proc <span>(</span>rw,nosuid,nodev,noexec,relatime<span>)</span>
devtmpfs on /dev <span>type</span> devtmpfs <span>(</span>rw,nosuid,seclabel,size<span>=</span>495400k,nr_inodes<span>=</span><span>123850</span>,mode<span>=</span><span>755</span><span>)</span>
tmpfs on /dev/shm <span>type</span> tmpfs <span>(</span>rw,nosuid,nodev,seclabel<span>)</span>
/dev/sda1 on /boot <span>type</span> xfs <span>(</span>rw,relatime,seclabel,attr2,inode64,noquota<span>)</span>
<span>#命令结果表示：将 /dev/sda3 分区挂载到 / 目录，文件系统是 etx4，权限是读写 rw</span>

<span># 例子 2：修改特殊权限</span>
<span>[</span>root@localhost ~<span>]</span><span># mount</span>
<span>#我们查看到 /boot 分区已经被挂载了，而且采用的是 defaults 选项，那么我们重新挂载分区，并采用 noexec 权限禁止执行文件执行，看看会出现什么情况（注意不要用 / 分区做实验，否则系统命令也就不能执行了</span>
<span>..</span>.省略部分输出<span>..</span>.
/dev/sdal on /boot <span>type</span> ext4 <span>(</span>rw<span>)</span>
<span>..</span>.省略部分输出<span>..</span>.
<span>[</span>root@localhost ~<span>]</span><span># mount -o remount,noexec /boot</span>
<span>#重新挂载 /boot 分区，并使用 noexec 权限</span>
<span>[</span>root@localhost ~<span>]</span><span># cd /boot/</span>
<span>[</span>root@localhost boot<span>]</span><span># vi hello.sh</span>
<span>#写一个 Shell 吧</span>
<span>#!/bin/bash </span>
<span>echo</span> <span>"hello!!"</span>
<span>[</span>root@localhost boot<span>]</span><span># chmod 755 hello.sh</span>
<span>[</span>root@localhost boot<span>]</span><span># ./hello.sh</span>
-bash: ./hello.sh: 权限不够
<span>#虽然赋予了 hello.sh 执行权限，但是仍然无法执行</span>
<span>[</span>root@localhost boot<span>]</span><span># mount -o remount,exec /boot</span>
<span>#记得改回来，否则会影响系统启动</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>如果我们做实验修改了特殊选项，那一定要记住，而且确定需要修改；否则非常容易出现系统问题，而且还找不到问题的根源。</p>
<div><pre><code><span># 例子 3：挂载分区</span>
<span>[</span>root@localhost ~<span>]</span><span># mkdir /mnt/diskl</span>
<span>#建立挂载点目录</span>
<span>[</span>root@localhost ~<span>]</span><span># mount /dev/sdbl /mnt/disk1</span>
<span>#挂载分区</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>/dev/sdb1</code> 分区还没有被划分。我们在这里只看看挂载分区的方式，非常简单，甚至不需要使用“-text4”命令指定文件系统，因为系统是可以自动检测的。</p>
<ol start="2">
<li><strong>挂载光盘</strong></li>
</ol>
<p>在 Windows 中如果想要使用光盘，则只需把光盘放入光驱，单击使用即可。但是在 Linux 中除了要把光盘放入光驱，而且必须在挂载之后才能正确使用。还要记得用完光盘后也不能像 Windows 一样，直接弹出光驱取出光盘，而必须先卸载才能取出光盘（确实不如 Windows 方便，不过这也只是一个操作习惯，习惯了就好）。挂载命令如下（当然要记得在 Linux 中放入光盘)：</p>
<div><pre><code><span>[</span>rootelocalhost ~<span>]</span><span># mkdir /mnt/cdrom/</span>
<span>#建立挂截点</span>
<span>[</span>root@localhost ~<span>]</span><span># mount -t iso9660 /dev/cdrom /mnt/cdrom/</span>
<span>#挂载光盘</span>

<span>#光盘的文件系统是 iso9660，不过这个文件系统可以省略不写，系统会自动检测，命令如下：</span>
<span>[</span>root@localhost ~<span>]</span><span># mount /dev/cdrom /mnt/cdrom/</span>
<span>#挂载光盘。两个挂载光盘的命令使用一个就可以了</span>
<span>[</span>root@localhost ~<span>]</span><span># mount</span>
<span>#查看已经挂载的设备</span>
<span>..</span>.省略部分输出<span>..</span>.
/dev/sr0 on /mnt/cdrom <span>type</span> iso9660 <span>(</span>ro<span>)</span>
<span>#光盘已经挂载了，但是挂载的设备文件名是 /dev/sr0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>我们已经知道挂载就是把光驱的设备文件和挂载点连接起来。挂载点 <code>/mn/cdrom</code> 是我们手工建立的空目录，我个人习惯把挂载点建立在 <code>/mnt</code> 目录中，因为我们在学习 Linux 的时候是没有 <code>/media/</code> 目录的，大家要是愿意也可以建立 <code>/media/cdrom</code> 作为挂载点，只要是已经建立的空目录都可以作为挂载点。那么 <code>/dev/cdrom</code> 就是光驱的设备文件名，不过注意 <code>/dev/cdrom</code> 只是一个软链接。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ll /dev/cdrom </span>
lrwxrwxrwx <span>1</span> root root <span>3</span> <span>1</span>月 <span>31</span> 01:13 /dev/cdrom -<span>></span> sro
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>/dev/cdrom</code> 的源文件是 <code>/dev/sr0</code>。<code>/dev/sr0</code> 是光驱的真正设备文件名，代表 SCSI 接口或 SATA接口的光驱，所以刚刚查询挂载时看到的光驱设备文件命令是 <code>/dev/sr0</code>。也就是说，挂载命令也可以写成这样：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mount /dev/sr0 /mnt/cdrom/</span>
</code></pre>
<div><span>1</span><br></div></div><p>其实光驱的真正设备文件名是保存在 <code>/proc/sys/dev/cdrom/info</code> 文件中的，所以可以通过查看这个文件来查询光盘的真正设备文件名，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cat /proc/sys/dev/cdrom/info</span>
CD-ROM information, Id: cdrom.c <span>3.20</span> <span>2003</span>/12/17
drive name:				sr0
<span>..</span>.省略部分输出<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ol start="3">
<li><strong>挂载 U 盘</strong></li>
</ol>
<p>其实挂载 U 盘和挂载光盘的方式是一样的，只不过光盘的设备文件名是固定的（<code>/dev/sr0</code> 或 <code>/dev/cdrom</code>），而 U 盘的设备文件名是在插入U盘后系统自动分配的。因为 U 盘使用的是硬盘的设备文件名，而每台服务器上插入的硬盘数量和分区方式都是不一样的，所以 U 盘的设备号需要单独检测与分配，以免和硬盘的设备文件名产生冲突。U 盘的设备文件名是系统自动分配的，我们只要查找出来然后挂载就可以了。</p>
<p>首先把 U 盘插入 Linux 系统中（注意：如果是虚拟机，则需要先把鼠标点入虚拟机再插入 U 盘)，然后就可以使用 <code>fdisk</code> 命令查看 U 盘的设备文件名了。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># fdisk -l</span>

Disk /dev/sda: <span>21.5</span> GB, <span>21474836480</span> bytes
<span>#系统硬盘</span>
<span>..</span>.省略部分输出<span>..</span>.
Disk /dev/sdb： <span>8022</span> MB, <span>8022654976</span> bytes
<span>#这就是识别的口盘，大小为 8GB</span>
<span>94</span> heads, <span>14</span> sectors/track, <span>11906</span> cylinders
Units <span>=</span> cylinders of <span>1316</span> * <span>512</span> <span>=</span> <span>673792</span> bytes
Sector size <span>(</span>logical/physical<span>)</span>: <span>512</span> bytes / <span>512</span> bytes
I/O size <span>(</span>minimum/optimal<span>)</span>: <span>512</span> bytes / <span>512</span> bytes
Disk identifier: Ox00000000
Device Boot		start		End		Bloks		Id		System
/dev/sab1		<span>1</span>			<span>11907</span>	<span>7834608</span>		b		W95 FAT32
<span>#系统给 U盘分配的设备文件名</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>查看到 U 盘的设备文件名，接下来就要创建挂载点了。命令如下：</p>
<div><pre><code><span>[</span>rootelocalhost ~<span>]</span><span># mkdir /mnt/usb</span>
</code></pre>
<div><span>1</span><br></div></div><p>然后就是挂载了，挂载命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mount -t vfat /dev/sdbl /mnt/usb/</span>
<span>#挂载U盘。因为是 Windows 分区，所以是 vfat 文件系统格式</span>
<span>[</span>root@localhost ~<span>]</span><span># cd /mnt/usb/</span>
<span>#去挂载点访问 U盘数据</span>
<span>[</span>root@localhost usb<span>]</span><span># ls </span>
??		?????	????<span>(</span><span>5</span><span>)</span>.xls			DSC_5843.jpg		??VCR<span>(</span>?<span>)</span>.mp4
??		<span>1111111</span>????????.xls		???????.BD??1280??????.rmvb		J02		????.wps
<span>#之所以出现乱码，是因为编码格式不同</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>之所以出现乱码，是因为 U 盘是 Windows 中保存的数据，而 Windows 中的中文编码格式和 Linux 中的不一致，只需在挂载的时候指定正确的编码格式就可以解决乱码问题，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mount -t vfat -o iocharset=utf8 /dev/sdbl /mnt/usb/</span>
<span>#挂载 U盘。指定中文编码格式为 UTF-8</span>
<span>[</span>root@localhost ~<span>]</span><span># cd /mnt/usb/</span>
<span>[</span>root@localhost usb<span>]</span><span># ls</span>
<span>1111111</span>		年度总结及计划表.xls	ZsyquMLToskarnodahsur6.mp4		协议书
<span>12</span>月21日.doc		恭喜发财（定）.mp4		新年VCR（定）.mp4
<span>#可以正确地查看中文了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>因为我们的 Linux 在安装时采用的是 UTTF-8 编码格式，所以要让 U 盘在挂载时也指定为 UTF-8 编码格式，才能正确显示。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># echo $LANG</span>
zh_CN.UTF-8
<span>#查看一下 Linux 默认的编码格式</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><p>注意</p>
<p>Linux 默认是不支持 NTFS 文件系统的，所以默认是不能挂载 NTFS 格式的移动硬盘的。</p>
<p>要想让 Linux 支持移动硬盘，主要有三种方法：</p>
<ul>
<li>一是重断编译内核，加入 ntfs 模块，然后安装 ntfs 模块即可；</li>
<li>二是不自己编译内核，而是下载已经编译好的内核，直接安装即可；</li>
<li>三是安装 NTFS 文件系统的第三方插件，也可以支持 NTFS 文件系统。</li>
</ul>
</div>
<ol start="4">
<li><strong>卸载命令</strong></li>
</ol>
<p>光盘和 U 盘使用完成后，在取出之前都要卸载。不过，硬盘分区是否需要卸载取决于你下次是否还需要使用，一般硬盘分区不用卸载。卸载命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># umount 设备文件名或挂载点</span>

<span>[</span>root@localhost ~<span>]</span><span># umount /mnt/usb</span>
<span>#卸载 U盘</span>
<span>[</span>root@localnost ~<span>]</span><span># umount /mnt/cdrom</span>
<span>#卸载光盘</span>
<span>[</span>root@localhost ~<span>]</span><span># umount /dev/sr0</span>
<span>#命令加设备文件名同样是可以卸载的</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>卸载命令后面既可以加设备文件名也可以加挂载点，不过只能加一个，如果加了两个，如 <code>umount /dev/sr0 /mnt/cdrom</code>，就会对光驱卸载两次，当然卸载第二次的时候就会报错。另外，我们在卸载时有可能会出现以下情况：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mount /dev/sr0 /mnt/cdrom/</span>
<span>#挂载光盘</span>
<span>[</span>root@localhost ~<span>]</span><span># cd /mnt/cdrom/</span>
<span>#进入光盘挂载点</span>
<span>[</span>root@localhost cdrom<span>]</span><span># umount /mnt/cdrom</span>
umount: /mnt/cdrom: device is busy.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>这种报错是因为我们已经进入了挂载点，这时如果要卸载，那么登录用户应该放在什么位置呢？所以卸载时必须退出挂载目录。这也很好理解，如果我们踩着梯子爬到了三楼这么高，这时给你一把锯，请你把二楼的梯子锯断，那么我估计谁都不愿意，因为如果锯断了二楼，那么已经爬到三楼的用户怎么下来呢？所以要记得在退出挂载目录之后再进行卸载。</p>
<h3 id="文件系统检测与修复命令-fsck"> 文件系统检测与修复命令： fsck</h3>
<p>计算机系统难免会因为人为的误操作或系统的原因而出现死机或突然断电的情况，这种情况下非常容易造成文件系统的崩溃，严重时甚至会造成硬件损坏。这也是我们一直在强调的服务器一定要先关闭服务再进行重启的原因所在。</p>
<p>如果真出现了文件系统损坏的情况，难道就没有修复的办法吗？我们现在要讲的 <code>fsck</code> 命令就是用来进行文件系统检测与修复的，命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># fsck [选项] 分区设备文件名</span>
选项：
	-t 文件系统	：指定分区的文件系统
	-A			：按照配置文件 /etc/fstab 检查所有分区
	-a			：不用显示用户提示，自动修复文件系统
	-C			：显示检查分区的进度条
	-f			：强制检测。一般 <span>fsck</span> 命令如果没有发现分区有问题，则是不会检测的。如果强制检测，那么不管是否发现问题，都会检测
	-y			：自动修复。和 -a 作用一致，不过有些文件系统只支持 -y
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>如果想要修复某个分区，则只需执行如下命令：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># fsck -y /dev/sdb1</span>
<span>#自动修复</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="显示磁盘状态命令-dumpe2fs"> 显示磁盘状态命令：dumpe2fs</h3>
<div><pre><code>root@localhost ~<span>]</span><span># dumpe2fs /dev/sda1</span>
dumpe2fs <span>1.44</span>.1 <span>(</span><span>24</span>-Mar-2018<span>)</span>
Filesystem volume name:   <span>&lt;</span>none<span>></span>									<span>&lt;</span>---卷标名
Last mounted on:          /										<span>&lt;</span>---挂载点
Filesystem UUID:          0a5e044f-60e0-4e15-af8f-c6c5882f3425		<span>&lt;</span>---UUID
Filesystem magic number:  0xEF53
Filesystem revision <span>#:    1 (dynamic)</span>
Filesystem features:      has_journal ext_attr resize_inode dir_index filetype needs_recovery extent 64bit flex_bg sparse_super large_file huge_file dir_nlink extra_isize metadata_csum
Filesystem flags:         signed_directory_hash 
Default <span>mount</span> options:    user_xattr acl							<span>&lt;</span>---挂载参数
Filesystem state:         clean									<span>&lt;</span>---文件系统状态，正常
Errors behavior:          Continue
Filesystem OS type:       Linux
Inode count:              <span>2621440</span>									<span>&lt;</span>---inode 总数
Block count:              <span>10485248</span>									<span>&lt;</span>---块总数
Reserved block count:     <span>524262</span>
Free blocks:              <span>6357559</span>
Free inodes:              <span>1946492</span>
First block:              <span>0</span>
Block size:               <span>4096</span>										<span>&lt;</span>---块大小
Fragment size:            <span>4096</span>
Group descriptor size:    <span>64</span>
Reserved GDT blocks:      <span>1024</span>
Blocks per group:         <span>32768</span>
Fragments per group:      <span>32768</span>
Inodes per group:         <span>8192</span>
Inode blocks per group:   <span>512</span>
Flex block group size:    <span>16</span>
Filesystem created:       Fri Apr <span>23</span> <span>16</span>:13:19 <span>2021</span>
Last <span>mount</span> time:          Mon May <span>24</span> <span>13</span>:48:59 <span>2021</span>
Last <span>write</span> time:          Mon May <span>24</span> <span>13</span>:48:58 <span>2021</span>
Mount count:              <span>12</span>
Maximum <span>mount</span> count:      -1
Last checked:             Fri Apr <span>23</span> <span>16</span>:13:19 <span>2021</span>
Check interval:           <span>0</span> <span>(</span><span>&lt;</span>none<span>></span><span>)</span>
Lifetime writes:          <span>61</span> GB
Reserved blocks uid:      <span>0</span> <span>(</span>user root<span>)</span>
Reserved blocks gid:      <span>0</span> <span>(</span>group root<span>)</span>
First inode:              <span>11</span>
Inode size:	          	  <span>256</span>										<span>&lt;</span>---inode 的大小
<span>..</span>.省略部分输出<span>..</span>.

组 <span>0</span>：<span>(</span>块 <span>0</span>-32767<span>)</span> 校验值 0x2929 <span>[</span>ITABLE_ZEROED<span>]</span>					<span>&lt;</span>---第一个数据组的内容
  主 超级块位于 <span>0</span>，组描述符位于 <span>1</span>-5
  保留的GDT块位于 <span>6</span>-1029
  块位图位于 <span>1030</span> <span>(</span>+1030<span>)</span>，校验值 0x30f35b5a
  Inode 位图位于 <span>1046</span> <span>(</span>+1046<span>)</span>，校验值 0x6b19aa45
  Inode表位于 <span>1062</span>-1573 <span>(</span>+1062<span>)</span>
  <span>19414</span> 个可用 块，8176 个可用inode，2 个目录 ，8175个未使用的inodes
  可用块数： <span>13354</span>-32767
  可用inode数： <span>15</span>, <span>18</span>-8192
<span>..</span>.省略部分输出<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br></div></div><p>可以看到，使用 <code>dumpe2fs</code> 命令可以查询到非常多的信息，以上信息大致可分为 2 部分。</p>
<ul>
<li>
<p>前半部分显示的是超级块的信息，包括文件系统名称、已使用以及未使用的 inode 和 block 的数量、每个 block 和 inode 的大小，文件系统的挂载时间等。</p>
</li>
<li>
<p>另外，Linux 文件系统（EXT 系列）在格式化的时候，会分为多个区块群组（block group），每 个区块群组都有独立的 inode/block/superblock 系统。此命令输出结果的后半部分，就是每个区块群组的详细信息（如 Group0、Group1）。</p>
</li>
</ul>
<h2 id="硬盘分区命令-fdisk"> 硬盘分区命令：fdisk</h2>
<p>我们在安装操作系统的过程中已经对系统硬盘进行了分区，但如果新添加了一块硬盘，想要正常使用，难道需要重新安装操作系统才可以分区吗？</p>
<p>当然不是，在 Linux 中有专门的分区命令 <code>fdisk</code> 和 <code>parted</code>。其中 <code>fdisk</code> 命令较为常用，但不支持大于 2TB 的分区；如果需要支持大于 2TB 的分区，则需要使用 <code>parted</code> 命令，当然 <code>parted</code> 命令也能分配较小的分区。我们先来看看如何使用 <code>fdisk</code> 命令进行分区。</p>
<h3 id="命令格式"> 命令格式</h3>
<p>fdisk 命令的格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># fdisk ~l</span>
<span>#列出系统分区</span>
<span>[</span>root@localhost ~<span>]</span><span># fdisk 设备文件名</span>
<span>#给硬盘分区</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>注意，千万不要在当前的硬盘上尝试使用 <code>fdisk</code>，这会完整删除整个系统，一定要再找一块硬盘，或者使用虚拟机。</p>
<ol>
<li><strong>查看所有分区信息</strong></li>
</ol>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># fdisk -l</span>
<span>#查询本机可以识别的硬盘和分区</span>
Disk /dev/sda:32.2 GB, <span>32212254720</span> bytes
<span>#硬盘文件名和硬盘大小</span>
<span>255</span> heads, <span>63</span> sectors/track, <span>3916</span> cylinders
<span>#共255个磁头、63个扇区和3916个柱面</span>
Units <span>=</span> cylinders of <span>16065</span> *512 <span>=</span> <span>8225280</span> bytes
<span>#每个柱面的大小</span>
Sector size <span>(</span>logical/physical<span>)</span>: <span>512</span> bytes/512 bytes
<span>#每个扇区的大小</span>
I/O size <span>(</span>minimum/optimal<span>)</span>: <span>512</span> bytes/512 bytes
Disk identifier: 0x0009e098

Device Boot Start End Blocks ld System
/dev/sda1 * <span>1</span> <span>26</span> <span>204800</span> <span>83</span> Linux
Partition <span>1</span> does not end on cylinder boundary.
<span>#分区1没有占满硬盘</span>
/dev/sda2 <span>26</span> <span>281</span> <span>2048000</span> <span>82</span> Linux swap / Solaris
Partition <span>2</span> does not end on cylinder boundary
<span>#分区2没有占满硬盘</span>
/dev/sda3 <span>281</span> <span>3917</span> <span>29203456</span> <span>83</span> Linux
<span>#设备文件名启动分区 起始柱面 终止柱面容量 ID 系统</span>

Disk /dev/sdb: <span>21.5</span> GB, <span>21474836480</span> bytes 
<span>#第二个硬盘识别，这个硬盘的大小</span>
<span>255</span> heads, <span>63</span> sectors/track, <span>2610</span> cylinders
Units <span>=</span> cylinders of <span>16065</span> * <span>512</span> <span>=</span> <span>8225280</span> bytes
Sector size <span>(</span>logical/physical<span>)</span>: <span>512</span> bytes / <span>512</span> bytes
I/O size <span>(</span>minimum/optimal<span>)</span>: <span>512</span> bytes/512 bytes
Disk identifier: 0x00000000
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>使用 <code>fdisk -l</code> 查看分区信息，能够看到我们添加的两块硬盘（<code>/dev/sda</code> 和 <code>/dev/sdb</code>）的信息。我们解释一下这些信息，其上半部分态是硬盘的整体状态，<code>/dev/sda</code> 硬盘的总大小是 32.2 GB，共有 3916 个柱面，每个柱面由 255 个磁头读/写数据，每个磁头管理 63 个扇区。每个柱面的大小是 8225280 Bytes，每个扇区的大小是 512 Bytes。</p>
<p>信息的下半部分是分区的信息，共 7 列，含义如下：</p>
<ul>
<li>
<p>Device：分区的设备文件名。</p>
</li>
<li>
<p>Boot：是否为启动引导分区，在这里 <code>/dev/sda1</code> 为启动引导分区。</p>
</li>
<li>
<p>Start：起始柱面，代表分区从哪里开始。</p>
</li>
<li>
<p>End：终止柱面，代表分区到哪里结束。</p>
</li>
<li>
<p>Blocks：分区的大小，单位是 KB。</p>
</li>
<li>
<p>id：分区内文件系统的 ID。在 <code>fdisk</code> 命令中，可以 使用 &quot;i&quot; 查看。</p>
</li>
<li>
<p>System：分区内安装的系统是什么。</p>
</li>
</ul>
<p>如果这个分区并没有占满整块硬盘，就会提示 &quot;Partition 1 does not end on cyl inder boundary&quot;，表示第一个分区没有到硬盘的结束柱面。大家发现了吗？<code>/dev/sda</code> 已经分配完了分区，没有空闲空间了。而第二块硬盘 <code>/dev/sdb</code> 已经可以被识别了，但是没有可分区。</p>
<ol start="2">
<li><strong>fdisk 交互命令</strong></li>
</ol>
<p>我们以硬盘 <code>/dev/sdb</code> 为例来做练习，命令如下:</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># fdisk /dev/sdb</span>
<span>#给 /dev/sdb 分区</span>
Device contains neither a valid DOS partition table, nor Sun, SGI or OSF disklabel
Building a new DOS disklabel with disk identifier 0xed7e8bc7.
Changes will remain <span>in</span> memory only, <span>until</span> you decide to <span>write</span> them.
After that, of course, the previous content won<span>'t be recoverable.
Warning: invalid flag 0x0000 of partition table 4 will be corrected by w(rite)
WARNING: DOS-compatible mode is deprecated.it'</span>s strongly recommended to switch off the mode <span>(</span>command <span>'c'</span><span>)</span> and change display <span>units</span> to sectors <span>(</span>command <span>'u'</span><span>)</span>.
Command <span>(</span>m <span>for</span> <span>help</span><span>)</span>:m
<span>#交互界面的等待输入指令的位置，输入 m 得到帮助</span>
Command action
<span>#可用指令</span>
a toggle a bootable flag
b edit bsd disklabel
c toggle the dos compatibility flag
d delete a partition
I list known partition types m print this menu
n <span>add</span> a new partition
o create a new empty DOS partition table
p print the partition table
q quit without saving changes
s create a new empty Sun disklabel
t change a partition's system <span>id</span>
u change display/entry <span>units</span>
<span>v</span> verity the partition table
w <span>write</span> table to disk and <span>exit</span>
x extra functionality <span>(</span>experts only<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>注意这里的分区命令是 <code>fdisk /dev/sdb</code>，这是因为硬盘并没有分区，使用 <code>fdisk</code> 命令的目的就是建立分区。</p>
<p>在 fdisk 交互界面中输入 m 可以得到帮助，帮助里列出了 fdisk 可以识别的交互命令，我们来解释一下这些命令，如表15-6 所示。</p>
<p><strong>表15-6	<u>fdisk 交互命令</u></strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>设置可引导标记</td>
</tr>
<tr>
<td>b</td>
<td>编辑 bsd 磁盘标签</td>
</tr>
<tr>
<td>c</td>
<td>设置 DOS 操作系统兼容标记</td>
</tr>
<tr>
<td>d</td>
<td>删除一个分区</td>
</tr>
<tr>
<td>1</td>
<td>显示已知的文件系统类型。82 为 Linux swap 分区，83 为 Linux 分区</td>
</tr>
<tr>
<td>m</td>
<td>显示帮助菜单</td>
</tr>
<tr>
<td>n</td>
<td>新建分区</td>
</tr>
<tr>
<td>0</td>
<td>建立空白 DOS 分区表</td>
</tr>
<tr>
<td>P</td>
<td>显示分区列表</td>
</tr>
<tr>
<td>q</td>
<td>不保存退出</td>
</tr>
<tr>
<td>s</td>
<td>新建空白 SUN 磁盘标签</td>
</tr>
<tr>
<td>t</td>
<td>改变一个分区的系统 ID</td>
</tr>
<tr>
<td>u</td>
<td>改变显示记录单位</td>
</tr>
<tr>
<td>V</td>
<td>验证分区表</td>
</tr>
<tr>
<td>w</td>
<td>保存退出</td>
</tr>
<tr>
<td>X</td>
<td>附加功能（仅专家）</td>
</tr>
</tbody>
</table>
<ol start="3">
<li><strong>新建主分区</strong></li>
</ol>
<p>下面我们实际建立一个主分区，看看过程是什么样子的。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># fdisk /dev/sdb</span>
<span>..</span>.省略部分输出<span>..</span><span>..</span>
Command <span>(</span>m <span>for</span> <span>help</span><span>)</span>: P					<span>&lt;</span>---显示当前硬盘的分区列表
Disk /dev/sdb: <span>21.5</span> GB, <span>21474836480</span> bytes
<span>255</span> heads, <span>63</span> sectors/track, <span>2610</span> cylinders
Units <span>=</span> cylinders of <span>16065</span> * <span>512</span> <span>=</span> <span>8225280</span> bytes
Sector size <span>(</span>logical/physical<span>)</span>: <span>512</span> bytes / <span>512</span> bytes
I/O size <span>(</span>minimum/optimal<span>)</span>:512 bytes / <span>512</span> bytes
Disk identifier： Oxb4b0720c

Device Boot		start		End		Blocks		Id		iSystem4
<span>#目前一个分区都没有</span>

Command <span>(</span>m <span>for</span> <span>help</span><span>)</span>: n					<span>&lt;</span>---那么我们新建一个分区
Command action							<span>&lt;</span>---指定分区类型
	e	extended						<span>&lt;</span>---扩展分区
    p	primary partition <span>(</span><span>1</span>-4<span>)</span>			<span>&lt;</span>---主分区
p										<span>&lt;</span>---这里选择 p，建立一个主分区
Partition number <span>(</span><span>1</span>-4<span>)</span>: <span>1</span>				<span>&lt;</span>---选择分区号，范围为1～4。这里选择 <span>1</span>
First cylinder <span>(</span><span>1</span>-2610, default <span>1</span><span>)</span>:	<span>&lt;</span>---分区的起始柱面，默认从 <span>1</span> 开始。因为要从硬盘头开始分区，所以直接回车了
Using default value <span>1</span>					<span>&lt;</span>---提示使用的是默认值 <span>1</span>
Last cylinder,+cylinders or +size<span>{</span>K,M,G<span>}</span><span>(</span><span>1</span>-2610, default <span>2610</span><span>)</span>：+5G
<span>#指定硬盘大小。可以按照柱面指定（1～2610）我们对柱面不熟悉，那么可以使用 +size(K,M,G)的方式指定硬盘大小。这里指定 +5G，建立一个 5GB 大小的分区</span>
Command <span>(</span>m <span>for</span> <span>help</span><span>)</span>:
<span>#主分区就建立了，又回到了 fdisk 交互界面的提示符</span>
Command <span>(</span>m <span>for</span> <span>help</span><span>)</span>:p					<span>&lt;</span>---查询一下新建立的分区
Disk /dev/sdb: <span>21.5</span> GB, <span>21474836480</span> bytes
<span>255</span> heads,63 sectors/track, <span>2610</span> cylinders
Units <span>=</span> cylinders of <span>16065</span> * <span>512</span>/<span>=</span> <span>8225280</span> bytes
Sector size <span>(</span>logical/physical<span>)</span>: <span>512</span> bytes / <span>512</span> bytes
I/O size <span>(</span>minimum/optimal<span>)</span>:512 bytes / <span>512</span> bytes
Disk identifier: Oxb4b0720c
Device Boot

Device Boot		start		End		Blocks		Id		System
/dev/sdb1			<span>1</span>		<span>654</span>		<span>5253223</span>+ 	<span>83</span> 		Linux
<span># /dev/sdb1 已经建立了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><p>建立主分区的过程就是这样的，总结一下就是 <code>fdisk 硬盘名 → n（新建）→ p（建立主分区）→ 1（指定分区号）→ 回车（默认从 1 柱面开始建立分区）→ +5G（指定分区大小)</code>。当然，我们的分区还没有格式化和挂载，所以还不能使用。</p>
<ol start="3">
<li><strong>新建扩展分区</strong></li>
</ol>
<p>这次我们建立一个扩展分区。还记得吗？主分区和扩展分区加起来最多只能建立4个，而扩展分区最多只能建立1 个。扩展分区的建立命令如下：</p>
<div><pre><code>Command <span>(</span>m <span>for</span> <span>help</span><span>)</span><span>;</span> n					<span>&lt;</span>---新建立分区
<span>command</span> action
	e	extended
	p	primary partition <span>(</span><span>1</span>-4<span>)</span>
e										<span>&lt;</span>---这次建立扩展分区
Partition number <span>(</span><span>1</span>-4<span>)</span>: <span>2</span>				<span>&lt;</span>---给扩展分区指定分区号 <span>2</span>
First cylinder <span>(</span><span>655</span>-2610, default <span>655</span><span>)</span>:
<span>#扩展分区的起始柱面。刚刚建立的主分区1 已经占用了1～654个柱面，所以我们从 655 开始建立</span>
<span>#注意：如果没有特殊要求，则不要跳开柱面建立分区，应该紧挨着建立分区</span>
using default value <span>655</span>					<span>&lt;</span>---提示使用的是默认值 <span>655</span>
Last cylinder, +cylinders or +sizelK,M,G<span>}</span><span>(</span><span>655</span>-2610, default <span>2610</span><span>)</span>:
<span>#这里把整块硬盘的剩余空间都建立为扩展分区</span>
Using default value <span>2610</span>
<span>#提示使用的是默认值 2610</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>这里把 <code>/dev/sdb</code> 硬盘的所有剩余空间都建立为扩展分区，就是建立一个主分区，剩余空间都建立成扩展分区，再在扩展分区中建立逻辑分区。</p>
<ol start="4">
<li><strong>新建逻辑分区</strong></li>
</ol>
<p>扩展分区是不能被格式化和直接使用的，所以还要在扩展分区内部再建立逻辑分区。我们来看看逻辑分区的建立过程，命令如下：</p>
<div><pre><code><span>command</span> <span>(</span>m <span>for</span> <span>help</span><span>)</span>： n				<span>&lt;</span>---建立新分区
Command action
	l	logical <span>(</span><span>5</span> or over<span>)</span>				<span>&lt;</span>---因为扩展分区已经建立，所以这里变成了 l（logic）
	p	primary partition <span>(</span><span>1</span>-4<span>)</span>
l										<span>&lt;</span>---建立逻辑分区
First cylinder <span>(</span><span>655</span>-2610, default <span>655</span><span>)</span>:
<span>#不用指定分区号，默认会从 5 开始分配，所以直接选择起始柱面</span>
<span>#注意：逻辑分区是在扩展分区内部再划分的，所以柱面是和扩展分区重叠的</span>
Using default value <span>655</span>
Last eylinder, +cylinders or +size<span>(</span>K,M,G<span>)</span><span>(</span><span>655</span>-2610, default <span>2610</span><span>)</span>:+2G
<span>#分配 2GB 大小</span>
Command <span>(</span>m <span>for</span> <span>help</span><span>)</span>： n				<span>&lt;</span>---再建立一个逻辑分区
Command action
	l	logical <span>(</span><span>5</span> or over<span>)</span>
	p	primary partition <span>(</span><span>1</span>-4<span>)</span>
l
First cylinder <span>(</span><span>917</span>-2610, default <span>917</span><span>)</span>：
Using default value <span>917</span>
Last cylinder, +cylinders or +size<span>(</span>K,M,G<span>}</span><span>(</span><span>917</span>-2610, default <span>2610</span><span>)</span>:+2G

Command <span>(</span>m <span>for</span> <span>help</span><span>)</span>：P					<span>&lt;</span>---查看一下已经建立的分区
Disk /dev/sab: <span>21.5</span> GB, <span>21474836480</span> bytea
<span>255</span> hends, <span>63</span> pectors/track, <span>2610</span> cylinders
Units <span>=</span> cylinders of <span>16065</span> * <span>512</span> <span>=</span> <span>8225280</span> bytes
sector sime <span>(</span>logical/physical<span>)</span>: <span>512</span> bytes / <span>512</span> bytes
I/O size <span>(</span>mininum/optimal<span>)</span>: <span>512</span> bytes / <span>512</span> bytes
Diek identifier: Oxb4b0720c

Device Boot		start		End		Blocks		Id		System
/dev/sdbl		<span>1</span>			<span>654</span>		<span>15253223</span>+ 	<span>83</span> 		Linux			<span>&lt;</span>---主分区
/dev/sdb2		<span>655</span>			<span>2610</span>	<span>15711570</span>	<span>5</span> 		Extended		<span>&lt;</span>---扩展分区
/dev/sdb5		<span>655</span>			<span>916</span>		<span>2104483</span>+	<span>83</span>		Linux			<span>&lt;</span>---逻辑分区1
/dev/sdb6		<span>917</span> 		<span>1178</span>	<span>2104483</span>+ 	<span>83</span> 		Linux			<span>&lt;</span>---逻辑分区2

Command <span>(</span>m <span>for</span> <span>help</span><span>)</span>: w					<span>&lt;</span>---保存并退出
The partition cable has been aitered<span>!</span>

calling loctl<span>(</span><span>)</span> to re-read partition table.
Syncing disks.
<span>[</span>root@localhost ~<span>]</span><span>#</span>
<span>#退回到提示符界面</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><p>所有的分区在建立过程中如果不保存并退出是不会生效的，所以建立错了也没有关系，使用 q 命令不保存退出即可。如果使用了 w 命令，就会保存退出。有时因为系统的分区表正忙，所以需要重新启动系统才能使新的分区表生效。命令如下：</p>
<div><pre><code>Command <span>(</span>m <span>for</span> <span>help</span><span>)</span>: w							<span>&lt;</span>---保存并退出
The partition table has been altered<span>!</span>

Calling loctl<span>(</span><span>)</span> to re-read partition table.

WARNING: Re-reading the partition table failed with error <span>16</span>:


Device or resource busy.
The kernel still uses the old table.
The new table will be used at the next reboot.	<span>&lt;</span>---要求重新启动，才能格式化
Syncing disks.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>看到了吗？必须重新启动！可是重新启动很浪费时间。如果不想重新启动，则可以使用 <code>partprobe</code> 命令。这个命令的作用是让系统内核重新读取分区表信息，这样就可以不用重新启动了。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># partprobe</span>
</code></pre>
<div><span>1</span><br></div></div><p>如果这个命令不存在，则请安装 partied-2.1-18.el6.i686 这个软件包。<code>pariprobe</code> 命令不是必需的，如果没有提示重启系统，则直接格式化即可。</p>
<h3 id="格式化分区"> 格式化分区</h3>
<p>分区完成后，如果不格式化写入文件系统，则是不能正常使用的。所以我们需要使用 <code>mkfs</code> 命令进行格式化。命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mkfs [选项] 分区设备文件名</span>
选项：
	-t 文件系统	：指定格式化的文件系统，如 ext3、ext4
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>我们刚刚建立了 <code>/dev/sdb1</code>（主分区)、<code>/dev/sdb2</code>（扩展分区）、<code>/dev/sdb5</code>（逻辑分区）和 <code>/dev/sdb6</code>（逻辑分区）这几个分区，其中 <code>/dev/sdb2</code> 不能被格式化。剩余的三个分区都需要格式化之后使用，这里我们格式化一个分区 <code>/dev/sdb6</code> 作为演示，其余分区的格式化方法一样。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mkfs -t ext4 /dev/sdb6</span>
<span>mke2fs</span> <span>1.41</span>.12 <span>(</span><span>17</span>-May-2010<span>)</span>
<span>#文件系统标签=						&lt;---这里指的是卷标名，我们没有设置卷标</span>
操作系统:Linux
块大小<span>=</span><span>4096</span>（log<span>=</span><span>2</span><span>)</span>
分块大小<span>=</span><span>4096</span> （log<span>=</span><span>2</span>）
<span>Stride</span><span>=</span>O blocks, Stripe <span>width</span><span>=</span><span>0</span> blocks
<span>131648</span> inodes, <span>526120</span> blocks
<span>26306</span> blocks <span>(</span><span>5.00</span>%<span>)</span> reserved <span>for</span> the super user
第一个数据块<span>=</span><span>0</span>
Maximum filesystem <span>blocks</span><span>=</span><span>541065216</span>
<span>17</span> block <span>groups</span>
<span>32768</span> blocks per group, <span>32768</span> fragments per group
<span>7744</span> inodes per group
Superblock backups stored on blocks:
		<span>32768</span>， <span>98304</span>，163840，229376，294912
正在写入 inodes 表：完成
Creating journal <span>(</span><span>16384</span> blocks<span>)</span>：完成
Writing superblocks and filesystem accounting information:完成

This filesystem will be automatically checked every <span>39</span> mounts or <span>180</span> days, whichever comes first. Use tune2fs -c or -i to override.

<span>[</span>root@localhost ~<span>]</span><span># mkfs -t ext4 /dev/sdb5</span>
<span>#把 /dev/sdb5 也格式化</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p><code>mkfs</code> 命令非常简单易用，不过是不能调整分区的默认参数的（比如块大小是 4096 Bytes），这些默认参数除非特殊情况，否则不需要调整。如果想要调整，就需要使用 <code>mke2fs</code> 命令重新格式化。命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mke2fs [选项」分区设备文件名</span>
选项：
	-t 文件系统	：指定格式化成哪个文件系统，如ext2、ext3、ext4
	-b 字节		：指定 block 的大小
	-l 字节		：指定“字节/inode”的比例，也就是多少字节分配一个 inode
	-j			：建立带有 ext3 日志功能的文件系统
	-L 卷标名	：给文件系统设置卷标名，就不使用 e2label 命令设定了
	
<span># 例如：</span>
<span>[</span>root@localhost ~<span>]</span><span># mke2fs -t ext4 -b 2048 /dev/sdb6</span>
<span>#格式化分区，并指定 block 的大小为 2048 Bytes</span>
<span>mke2fs</span> <span>1.41</span>.12 <span>(</span><span>27</span>-May-2010<span>)</span>
文件系统标签<span>=</span>
操作系统:Linux
块大小<span>=</span><span>2048</span> （log<span>=</span><span>1</span>）			<span>&lt;</span>--block 的大小就不再是 <span>4096</span> Bytes 了
分块大小<span>=</span><span>2048</span><span>(</span>log<span>=</span><span>1</span><span>)</span>
<span>Stride</span><span>=</span><span>0</span> blocks, Stripe <span>width</span><span>=</span><span>0</span> blocks
<span>131560</span> inodes, <span>1052240</span> blocks
<span>52612</span> blocks <span>(</span><span>5.00</span>%<span>)</span> reserved <span>for</span> the super user
第一个数据块<span>=</span><span>0</span>
Maximum filesystem <span>blocks</span><span>=</span><span>538968064</span>
<span>65</span> block <span>groups</span>
<span>16384</span> blocks per group, <span>16384</span> fragments per group
<span>2024</span> Lnodes per group
Superblock backups stored on blocks:
		<span>16384</span>， <span>49152</span>，81920，114688，147456，409600，442368，802816
		
正在写入 inode 表：完成
creating journal <span>(</span><span>32768</span> blocks<span>)</span>：完成
Writing superblocks and filesystem accounting information:完成
This filesystem will be automatically checked every <span>38</span> mounts or <span>180</span> days, whichever comes First. Use tune2fs,-c or -i to override.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>如果没有特殊需要，那么还是 <code>mkfs</code> 命令简单易用。</p>
<h3 id="建立挂载点并挂载"> 建立挂载点并挂载</h3>
<p>硬盘已经准备完毕，接下来就是和光盘、U盘一样的步骤，建立挂载点并挂载使用了。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mkdir /disk5</span>
<span>[</span>root@localhost ~<span>]</span><span># mkdir /disk6</span>
<span>#建立两个目录，作为 /dev/sdb5 和 /dev/sdb6 两个分区的挂载点</span>
<span>[</span>rootelocalhost ~<span>]</span><span># mount /dev/sdb5 /disk5/</span>
<span>[</span>rootelocalhost ~<span>]</span><span># mount /dev/sdb6 /disk6/</span>
<span>#挂载两个分区，文件系统 Linux 会自动查找</span>
<span>[</span>root@localhost ~<span>]</span><span># mount</span>
<span>#查看一下</span>
/dev/sda3 on / <span>type</span> ext4 <span>(</span>rw<span>)</span>
proc on /proc <span>type</span> proc <span>(</span>rw<span>)</span>
sysfs on /sys <span>type</span> sysfs <span>(</span>rw<span>)</span>
devpts on /dev/pts <span>type</span> devpts <span>(</span>rw,gid<span>=</span><span>5</span>,mode<span>=</span><span>620</span><span>)</span>
tmpfs on /dev/shm <span>type</span> tmpfs <span>(</span>rw,rootcontext<span>=</span><span>"system_u:object_r:tmpfs_t:s0"</span><span>)</span>
/dev/sda1 on /boot <span>type</span> ext4 <span>(</span>rw<span>)</span>
none on /proc/sys/fs/binfmt_misc <span>type</span> binfmt_misc <span>(</span>rw<span>)</span>
sunrpc on /var/lib/nfs/rpe pipefs <span>type</span> rpc_pipefs <span>(</span>rw<span>)</span>
/dev/sdb5 on /disk5 <span>type</span> ext4 <span>(</span>rw<span>)</span>
/dev/sdb6 on /disk6 <span>type</span> ext4 <span>(</span>rw<span>)</span>
<span>#两个分区已经挂载上了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>挂载非常简单吧，不过注意这种挂载只是临时挂载，重启系统后还需要手工挂载。</p>
<h3 id="实现开机后自动挂载"> 实现开机后自动挂载</h3>
<p>如果要实现开机后自动挂载，就需要修改系统的自动挂载文件 <code>/etc/fstab</code>。不过要小心这个文件会影响系统的启动，因为系统就是依赖这个文件决定启动时加载的文件系统的。我们打开这个文件看看吧。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span> <span>vi</span> /etc/fstab
<span>UUID</span><span>=</span>c2ca6f57-b15c-43ea-bca0-f239083d8bdz	/			ext4	defaults		<span>1</span> <span>1</span>
<span>UUID</span><span>=</span>0b23d315-33a7-48a4-bd37-9248e5c44345	/boot		ext4	defaults		<span>1</span> <span>2</span>
<span>UUID</span><span>=</span>4021be19-2751-4dd2-98ca-383368c39eab	swap		swap	defaults		<span>0</span> <span>0</span>
<span>#只有这三个是真正的硬盘分区，下面的都是虚拟文件系统或交换分区</span>
tmpfs										/dev/shm	tmpfs	defaults		<span>0</span> <span>0</span>
devpts										/dev/pts	devpts	gid-5,mode-620 	<span>0</span> <span>0</span>
sysfs										/sys		sysfs	defaults		<span>0</span> <span>0</span>
proc										/proc		Proc	defaults		<span>0</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>这个文件共有 6 个字段，我们一一说明。</p>
<ul>
<li>
<p>第一个字段：分区设备文件名或 UUID（硬盘通用唯一识别码，可以理解为硬盘的 ID）。</p>
<blockquote>
<p>这个字段在 CentOS 5.5 系统中是写入分区的卷标名或分区设备文件名的，现在变成了硬盘的 UUID。这样做的好处是当硬盘增加了新的分区，或者分区的顺序改变，或者内核升级后，仍然能够保证分区能够正确地加载，而不至于造成启动障碍。</p>
</blockquote>
<blockquote>
<p>那么，每个分区的 UUID 到底是什么呢？用我们讲过的 <code>dumpe2fs</code> 命令是可以查看到的，命令如下：</p>
</blockquote>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># dumpe2fs /dev/sdb5</span>
dumpe2fs <span>1.41</span>.12 <span>(</span><span>17</span>-May-2010<span>)</span>
Filesystem volume name:		test_label
Last mounted on:			<span>&lt;</span>not available<span>></span>
Fileaystem UUID:			63f238f0-2715-4821-8ed1-b3d18756a3ef			<span>&lt;</span>---UUID
<span>..</span>.省略部分输出<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><blockquote>
<p>也可以通过查看每个硬盘的 UUID 的链接文件名来确定 UUID，命令如下：</p>
</blockquote>
<div><pre><code>[root@localhost ~]# ls -l /dev/disk/by-uuid/
总用量 0
1rwxrwarwx. 1 root root 10 4 月 11 00:17 0b23d315-33a7-4Ba4-bd37-9248e5c44345 -&gt; ../../sda1
1rwxrwxrwx. 1 root root 10 4 月 11 00:17 4021be19-2751-4dd2-98cc-383368c39aab -&gt; ../../sda2
lrwxrwxrwx. 1 root root 10 4 月 11 00:17 63f238f0-a715-4821-8ed1-b3d18756a3c0 -&gt; ../../sdb5
1rwxrwxrwx. 1 root root 10 4 月 11 00:17 6858b440-ad9e-45cb-b411-963c5419e0e6 -&gt; ../../sdb6
1rwxrwxrwx. I root root 10 4 月 11 00:17 c2ca6f57-b15c-43ea-bca0-f239083d8bd2 -&gt; ../../sda3
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>
<p>第二个字段：挂载点。再强调一下，挂载点应该是已经建立的空目录。</p>
</li>
<li>
<p>第三个字段：文件系统名称，CentOS 6.3 的默认文件系统应该是 ext4。</p>
</li>
<li>
<p>第四个字段：挂载参数，这个参数和 <code>mount</code> 命令的挂载参数一致。</p>
</li>
<li>
<p>第五个字段：指定分区是否被 dump 备份，0 代表不备份，1 代表每天备份，2 代表不定期备份。</p>
</li>
<li>
<p>第六个字段：指定分区是否被 <code>fsck</code> 检测，0 代表不检测，其他数字代表检测的优先级，1 的优先级比 2 高。所以先检测 1 的分区，再检测 2 的分区。一般根分区的优先级是 1，其他分区的优先级是 2。</p>
</li>
</ul>
<p>能看懂这个文件了吧？我们把 <code>/dev/sdb5</code> 和 <code>/dev/sdb6</code> 两个分区加入 <code>/etc/fstab</code> 文件,命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vi /etc/fstab</span>
<span>UUID</span><span>=</span>c2ca6f57-b15c-43ea-bca0-f239083d8bd2	/			ext4	defaults		<span>1</span> <span>1</span>
<span>UUID</span><span>=</span>0b23d315-33a7-48a4-bd37-9248e5c44345	/boot		vext4	defaults		<span>1</span> <span>2</span>
<span>UurD</span><span>=</span>4021be19-2751-4dd2-98cc-383368c39edb	swap		swap	defaults		<span>0</span> <span>0</span>
tmpfs										/dev/shm	tmpfs	defaults		<span>0</span> <span>0</span>
devpts										/dev/pts	devpts	gid-5,mode<span>=</span><span>620</span>	<span>0</span> <span>0</span>
sysfs										/sys		sysfs	defaults		<span>0</span> <span>0</span>
Proc										/proc		proc	defaults		<span>0</span> <span>0</span>
/dev/sdb5									/disk5		ext4	defaults		<span>1</span> <span>2</span>
/dev/sdb6									/disk6		ext4	defaults		<span>1</span> <span>2</span>
<span>#这里没有写分区的 UUID，而是直接写人分区设备文件名，这也是可以的。不过。如果不写UIID，就要注意，在修改了磁盘顺序后，/etc/fstab 文件也要做相应的改变</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>这里直接使用分区的设备文件名作为此文件的第一个字段，当然也可以写分区的 UUID。</p>
<p>只不过 UUID 更加先进，设备文件名稍微简单一点。</p>
<p>至此，分区就建立完成了，接下来只要重新启动，测试一下系统是否可以正常启动就可以了。只要 <code>/etc/fstab</code> 文件修改正确，就不会出现任何问题。</p>
<h3 id="etc-fstab-文件修复"> /etc/fstab 文件修复</h3>
<p>如果把 <code>/etc/fstab</code> 文件修改错了，也重启了，系统崩溃启动不了了，那该怎么办？比如？</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vi /etc/fstab</span>
<span>UUID</span><span>=</span>c2ca6f57-b15c-43ea-bca0-f239083d8bd2	/			ext4	defaults		<span>1</span> <span>1</span>
<span>UUID</span><span>=</span>0b23d315-33a7-48a4-bd37-9248e5c44345	/boot		vext4	defaults		<span>1</span> <span>2</span>
<span>UurD</span><span>=</span>4021be19-2751-4dd2-98cc-383368c39edb	swap		swap	defaults		<span>0</span> <span>0</span>
tmpfs										/dev/shm	tmpfs	defaults		<span>0</span> <span>0</span>
devpts										/dev/pts	devpts	gid-5,mode<span>=</span><span>620</span>	<span>0</span> <span>0</span>
sysfs										/sys		sysfs	defaults		<span>0</span> <span>0</span>
Proc										/proc		proc	defaults		<span>0</span> <span>0</span>
/dev/sdb5									/disk5		ext4	defaults		<span>1</span> <span>2</span>
/dev/sdb									/disk6		ext4	defaults		<span>1</span> <span>2</span>
<span>#故意把 /dev/sdb6 写成了 /dev/sdb</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>我们重新启动系统，真的报错了，如图15-12 所示。</p>
<div>
<p><img src="./assets/fstable1.png" alt="fstable1" loading="lazy"></p>
<p><strong>图15-12	<u>系统启动报错</u></strong></p>
</div>
<p>先别急，仔细看看，系统提示输入 root 密码，我们输入密码试试，如图15-13 所示。</p>
<div>
<p><img src="./assets/fstable2.png" alt="fstable2" loading="lazy"></p>
<p><strong>图15-13	<u>root 登录</u></strong></p>
</div>
<p>我们又看到了系统提示符，赶快把 <code>/etc/fstab</code> 文件修改回来吧。又报错了，提示 “fstab readonly“。别慌，分析一下原因提示是没有写权限，那么只要把 <code>/</code> 分区重新挂载上读写权限不就可以修改了吗？命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mount -o remount,rw /</span>
</code></pre>
<div><span>1</span><br></div></div><p>再去修改 <code>/etc/fstab</code> 文件，把它改回来就可以正常启动了。</p>
<h2 id="parted-命令分区"> parted 命令分区</h2>
<p>在 Linux 系统中有两种常见的分区表：MBR 分区表（主引导记录分区表）和 GPT 分区表（GUID 分区表）。</p>
<ul>
<li>
<p>MBR 分区表：支持的最大分区是 2TB （1TB=1024GB）；最多支持 4 个主分区，或 3 个主分区 1 个扩展分区。</p>
</li>
<li>
<p>GPT 分区表：支持最大 18EB 的分区（1EB=1024PB=1024×1024TB）；最多支持 128个分区，其中 1 个系统保留分区，127 个用户自定义分区。</p>
</li>
</ul>
<p><code>fdisk</code> 工具不能支持 GPT 分区表，所以最大只能支持 2TB 的分区。不过随着硬盘容量的不断增加，总有一天 2TB 的分区会不够用，这时就必须使用 <code>parted</code> 命令来进行系统分区了。不过 <code>parted</code> 命令也有一点小问题，就是命令自身分区的时候只能格式化成 ext2 文件系统，不支持 ext3 文件系统，更不用说 ext4 文件系统了（这里只是指不能用 parted 命令把分区格式化成 ext4 文件系统，但是 parted 命令还是可以识别 ext4 文件系统的）。不过这没有太大的影响，因为我们可以先分区再用 <code>mkfs</code> 命令进行格式化。</p>
<h3 id="parted-交互模式"> parted 交互模式</h3>
<p><code>parted</code> 命令是可以在命令行直接分区和格式化的，不过 <code>parted</code> 交互模式才是更加常用的命令方式。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># parted 硬盘设备文件名</span>
<span>#进入交互模式</span>

<span># 例如：</span>
<span>[</span>root@localhost ~<span>]</span><span># parted /dev/sdb</span>
<span>#打算继续划分/dev/sdb硬盘</span>
GNU Parted <span>2.1</span>
使用/dev/sdb
Welcome to GNU Parted<span>!</span> Type <span>'help'</span> to view a list of commands.
<span>(</span>parted<span>)</span> <span>help</span>				<span>&lt;</span>--parted 的等待输入交互命令的位置，输入 help，可以看到在交互模式下支持的所有命令
  align-check TYPE N					   check partition N <span>for</span> TYPE<span>(</span>min<span>|</span>opt<span>)</span> alignment
  <span>help</span> <span>[</span>COMMAND<span>]</span>                           print general help, or <span>help</span> on COMMAND
  mklabel,mktable LABEL-TYPE               create a new disklabel <span>(</span>partition table<span>)</span>
  mkpart PART-TYPE <span>[</span>FS-TYPE<span>]</span> START END     <span>make</span> a partition
  name NUMBER NAME                         name partition NUMBER as NAME
  print <span>[</span>devices<span>|</span><span>free</span><span>|</span>list,all<span>|</span>NUMBER<span>]</span>     display the partition table, available devices, <span>free</span> space, all found partitions, or a 											 particular partition
  quit                                     <span>exit</span> program
  rescue START END                         rescue a lost partition near START and END
  resizepart NUMBER END                    resize partition NUMBER
  <span>rm</span> NUMBER                                delete partition NUMBER
  <span>select</span> DEVICE                            choose the device to edit
  disk_set FLAG STATE                      change the FLAG on selected device
  disk_toggle <span>[</span>FLAG<span>]</span>                       toggle the state of FLAG on selected device
  <span>set</span> NUMBER FLAG STATE                    change the FLAG on partition NUMBER
  toggle <span>[</span>NUMBER <span>[</span>FLAG<span>]</span><span>]</span>                   toggle the state of FLAG on partition NUMBER
  unit UNIT                                <span>set</span> the default unit to UNIT
  version                                  display the version number and copyright information of GNU Parted
<span>(</span>parted<span>)</span>                                                                                                                           
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p><code>parted</code> 交互命令比较多，我们介绍常见的命令，如表15-7 所示。</p>
<p><strong>表15-7	<u>parted 常见的交互命令</u></strong></p>
<table>
<thead>
<tr>
<th>parted 交互命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>check NUMBER</td>
<td>做一次简单的文件系统检测</td>
</tr>
<tr>
<td>cp [FROM-DEVICE] FROM-NUMBER TO-NUMBER</td>
<td>复制文件系统到另一个分区</td>
</tr>
<tr>
<td>help [COMMAND]</td>
<td>显示所有的命令帮助</td>
</tr>
<tr>
<td>mklabel,mktable LABEL-TYPE</td>
<td>创建新的磁盘卷标（分区表）</td>
</tr>
<tr>
<td>mkfs NUMBER FS-TYPE</td>
<td>在分区上建立文件系统</td>
</tr>
<tr>
<td>mkpart PART-TYPE [FS-TYPE] START END</td>
<td>创建一个分区</td>
</tr>
<tr>
<td>mkpartfs PART-TYPE FS-TYPE START END</td>
<td>创建分区，并建立文件系统</td>
</tr>
<tr>
<td>move NUMBER START END</td>
<td>移动分区</td>
</tr>
<tr>
<td>name NUMBER NAME</td>
<td>给分区命名</td>
</tr>
<tr>
<td>print [devices|free|list,all|NUMBER]</td>
<td>显示分区表、活动设备、空闲空间、所有分区</td>
</tr>
<tr>
<td>quit</td>
<td>退出</td>
</tr>
<tr>
<td>rescue START END</td>
<td>修复丢失的分区</td>
</tr>
<tr>
<td>resize NUMBER START END</td>
<td>修改分区大小</td>
</tr>
<tr>
<td>rm NUMBER</td>
<td>删除分区</td>
</tr>
<tr>
<td>select DEVICE</td>
<td>选择需要编辑的设备</td>
</tr>
<tr>
<td>set NUMBER FLAG STATE</td>
<td>改变分区标记</td>
</tr>
<tr>
<td>toggle [NUMBER [FLAG]]</td>
<td>切换分区表的状态</td>
</tr>
<tr>
<td>unit UNIT</td>
<td>设置默认的单位</td>
</tr>
<tr>
<td>Version</td>
<td>显示版本</td>
</tr>
</tbody>
</table>
<h3 id="parted-命令的使用"> parted 命令的使用</h3>
<ol>
<li><strong>查看分区表</strong></li>
</ol>
<div><pre><code><span>(</span>parted<span>)</span> print										<span>&lt;</span>---输入 print 指令
Model: VMware, VMware Virtual S <span>(</span>scsi<span>)</span>				<span>&lt;</span>---硬盘参数，是虚拟机
Disk/dev/sdb: <span>21</span>.5GB								<span>&lt;</span>---硬盘大小
Sector size <span>(</span>logical/physical<span>)</span>: 512B/512B			<span>&lt;</span>---扇区大小
Partition Table: msdos								<span>&lt;</span>---分区表类型，是MBR分区表
Number Start End Size Type File system 标志
<span>1</span> <span>32</span>.3kB 5379MB 5379MB primary
<span>2</span> 5379MB <span>21</span>.5GB <span>16</span>.1GB extended
<span>5</span> 5379MB 7534MB 2155MB logical ext4
<span>6</span> 7534MB 9689MB 2155MB logical ext4
<span>#看到了我们使用 fdisk 命令创建的分区，其中 1 分区没被格式化；2 分区是扩展分区，不能被格式化</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>使用 print 命令可以査看分区表信息，包括硬盘参数、硬盘大小、扇区大小、分区表类型和分区信息。分区信息共有 7 列，分别如下：</p>
<ul>
<li>
<p>Number：分区号，比如，1号就代表 <code>/dec/sdb1</code>；</p>
</li>
<li>
<p>Start：分区起始位置。这里不再像 fdisk 那样用柱面表示，使用字节表示更加直观；</p>
</li>
<li>
<p>End：分区结束位置；</p>
</li>
<li>
<p>Size：分区大小；</p>
</li>
<li>
<p>Type：分区类型，有 primary、extended、logical 等类型；</p>
</li>
<li>
<p>Filesystem：文件系统类型；</p>
</li>
<li>
<p>标志：分区的标记。</p>
</li>
</ul>
<ol start="2">
<li><strong>修改成 GPT 分区表</strong></li>
</ol>
<div><pre><code><span>(</span>partcd<span>)</span> mklabel gpt
<span>#修改分区表命令</span>
警告：正在使用/dev/sdb上的分区。					<span>&lt;</span>---由于/dev/sdb分区已经挂载，所以有警告。注意，如果强制修改，那么原有分区及数据会消失
忽略/Ignore/放弃/Cancel? ignore				 	<span>&lt;</span>---输入ignore忽略报错
警告：The existing disk label on /dev/sdb will be destroyed and all data on this disk will be lost. Do you want to continue?
是/Yes/否/No? <span>yes</span>								<span>&lt;</span>---输入 <span>yes</span>
警告：WARNING: the kernel failed to re-read the partition table on /dev/sdb <span>(</span>设备或资源忙）.
As a result, it may not reflect all of your changes <span>until</span> after reboot.			 	 <span>&lt;</span>---下次重启后才能生效
<span>(</span>parted<span>)</span> print									<span>&lt;</span>---查看一下分区表
Model: VMware, VMware Virtual S <span>(</span>scsi<span>)</span>
Disk /dev/sdb: <span>21</span>.5GB
Sector size <span>(</span>logical/physical<span>)</span>: 512B/512B
Partition Table: gpt							<span>&lt;</span>---分区表已经变成 GPT
Number Start End Size File system Name 标志		<span>&lt;</span>---所有的分区都消失了
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>修改了分区表，如果这块硬盘上已经有分区了，那么原有分区和分区中的数据都会消失，而且需要重启系统才能生效。</p>
<p>另外，我们转换分区表的目的是支持大于 2TB 的分区，如果分区并没有大于 2TB，那么这一步是可以不执行的。</p>
<div><p>注意</p>
<p>一定要把 <code>/etc/fstab</code> 文件和原有分区中的内容删除才能重启，否则会报错。</p>
</div>
<ol start="3">
<li><strong>建立分区</strong></li>
</ol>
<p>因为修改过了分区表，所以 <code>/dev/sdb</code> 硬盘中的所有数据都消失了，我们就可以重新对这块硬盘分区了。不过，在建立分区时，默认文件系统就只能是 ext2 了。命令如下：</p>
<div><pre><code><span>(</span>parted<span>)</span>mkpart
<span>#输入创建分区命令，后面不要参数，全部靠交互</span>
指定
分区名称？ <span>[</span><span>]</span>?disk1							<span>&lt;</span>---分区名称，这里命名为disk <span>1</span>
文件系统系统？ <span>[</span>ext2<span>]</span>?						<span>&lt;</span>---文件系统类型，直接回车，使用默认文件系统ext2
起始点？ 1MB									<span>&lt;</span>---分区从1MB开始
结束点？5GB									<span>&lt;</span>---分区到5GB结束
<span>#分区完成</span>
<span>(</span>parted<span>)</span> print								<span>&lt;</span>---查看一下
Model: VMware, VMware Virtual S <span>(</span>scsi<span>)</span>
Disk/dev/sdb: <span>21</span>.5GB
Sector size <span>(</span>logical/physical<span>)</span>: 512B/512B
Partition Table: gpt

Number Start End Size <span>file</span> system Name 标志
<span>1</span> 1049kB 5000MB 4999MB disk1	<span>&lt;</span>---分区1已经出现
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>不知道大家有没有注意到，我们现在用 print 查看的分区和第一次查看 MBR 分区表的分区时有些不一样了，少了 Type 这个字段，也就是分区类型字段，多了 Name（分区名）字段。分区类型是用于标识主分区、扩展分区和逻辑分区的，不过这种标识只在 MBR 分区表中使用，现在已经变成了 GPT 分区表，所以就不再有 Type 类型了。</p>
<ol start="4">
<li><strong>建立文件系统</strong></li>
</ol>
<p>分区分完后，还需要进行格式化。我们知道，如果使用 parted 交互命令格式化，则只能格式化成 ext2 文件系统。我们在这里要演示一下 parted 命令的格式化方法，所以就格式化成 ext2 文件系统。命令如下：</p>
<div><pre><code><span>(</span>parted<span>)</span> <span>mkfs</span>
<span>#格式化命令（很奇怪，也是mkfs，但是这只是parted的交互命令）</span>
WARNING: you are attempting to use <span>parted</span> to operate on <span>(</span>mkfs<span>)</span> a <span>file</span> system.
<span>parted</span><span>'s file system manipulation code is not as robust as what you'</span>ll <span>find</span> <span>in</span>
dedicated, file-system-specific packages like e2fsprogs. We recommend
you use <span>parted</span> only to manipulate partition tables, whenever possible.
Support <span>for</span> performing <span>most</span> operations on <span>most</span> types of <span>file</span> systems
will be removed <span>in</span> an upcoming release.
警告：The existing <span>file</span> system will be destroyed and all data on the partition will be lost. Do you want to continue?
是/Yes/否/No? <span>yes</span>
<span>#警告你格式化丟失，没关系，已经丢失过了</span>
分区编号？ <span>1</span>
文件系统类型 <span>[</span>ext2<span>]</span>?
<span>#指定文件系统类型，写别的也没用，直接回车</span>
<span>(</span>parted<span>)</span> print <span>#格式化完成，查看一下</span>
Model: VMware, VMware Virtual S <span>(</span>scsi<span>)</span>
Disk/dev/sdb: <span>21</span>,5GB
Sector size <span>(</span>logical/physical<span>)</span>: 512B/512B
Partition Table: gpt

Number Start End Size File system Name标志
<span>1</span> 1049kB 5000MB 4999MB ext2 diski
<span>#拥有了文件系统</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>如果要格式化成 ext4 文件系统，那么请 mkfs 命令帮忙吧（注意：不是 <code>parted</code> 交互命令中的 <code>mkfs</code>，而是系统命令 <code>mkfs</code>）。</p>
<ol start="5">
<li><strong>调整分区大小</strong></li>
</ol>
<p>parted 命令还有一大优势，就是可以调整分区的大小（在 Windows 中也可以实现，不过要么需要转换成动态磁盘，要么需要依赖第三方工具，如硬盘分区魔术师）。起始 Linux 中 LVM 和 RAID 是可以支持分区调整的，不过这两种方法也可以看成动态磁盘方法，使用 parted 命令调整分区更加简单。</p>
<div><p>注意</p>
<p>parted 调整已经挂载使用的分区时，是不会影响分区中的数据的，也就是说，数据不会丢失。但是一定要先卸载分区，再调整分区大小，否则数据是会出现问题的。另外，要调整大小的分区必须已经建立了文件系统（格式化），否则会报错。</p>
</div>
<p>命令如下：</p>
<div><pre><code><span>(</span>parted<span>)</span> resize
分区编号？ <span>1</span>
<span>#指定要修改的分区编号</span>
起始点？ <span>[</span>1049kB<span>]</span>? 1MB
<span>#分区起始位置</span>
结束点？ <span>[</span>5000MB<span>]</span>? 6GB
分区结束位置
<span>(</span>parted<span>)</span> print
<span>#查看一下</span>
Model: VMware, VMware Virtual S <span>(</span>scsi<span>)</span>
Disk/dev/sdb: <span>21</span>,5GB
Sector size <span>(</span>logical/physical<span>)</span>: 512B/512B
Partition Table: gpt
Number Start End Size File system Name标志
<span>1</span> 1049kB 6000MB 5999MB ext2 diski
<span>#分区大小改变</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><ol start="6">
<li><strong>删除分区</strong></li>
</ol>
<p>命令如下：</p>
<div><pre><code><span>(</span>parted<span>)</span> <span>rm</span>
<span>#删除分区命令</span>
分区编号？ <span>1</span>
<span>#指定分区编号</span>
<span>(</span>parted<span>)</span> print
<span>#查看一下</span>
Model: VMware, VMware Virtual S <span>(</span>scsi<span>)</span>
Disk/dev/sdb: <span>21</span>.5GB
Sector size <span>(</span>logical/physical<span>)</span>: 512B/512B
Partition Table: gpt
Number Start End Size File system Name 标志
<span>#分区消失</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>要注意的是，<code>parted</code> 中所有的操作都是立即生效的，没有保存生效的概念。这一点和 <code>fdisk</code> 交互命令明显不同，所以做的所有操作大家要加倍小心。</p>
<p>那么，到底是使用 <code>fdisk</code> 命令，还是使用 <code>parted</code> 命令进行分区呢？这完全看个人习惯，我们更加习惯使用 <code>fdisk</code> 命令。</p>
<h2 id="分配-swap-分区"> 分配 swap 分区</h2>
<h3 id="虚拟内存和物理内存"> 虚拟内存和物理内存</h3>
<p>我们都知道，直接从内存读写数据要比从硬盘读写数据快得多，因此更希望所有数据的读取和写入都在内存中完成，然而内存是有限的，这样就引出了物理内存与虚拟内存的概念。</p>
<p>物理内存就是系统硬件提供的内存大小，是真正的内存，相对于物理内存。<strong>在 Linux 下还有一个虚拟内存的概念，虚拟内存是为了满足物理内存的不足而提出的策略，它是利用磁盘空间虚拟出的一块逻辑内存。用作虚拟内存的磁盘空间被称为交换空间（又称 swap 空间）。</strong></p>
<p>作为物理内存的扩展，Linux 会在物理内存不足时，使用交换分区的虚拟内存，更详细地说，就是内核会将暂时不用的内存块信息写到交换空间，这样一来，物理内存得到了释放，这块内存就可以用于其他目的，当需要用到原始的内容时，这些信息会被重新从交换空间读入物理内存。</p>
<p>Linux 的内存管理采取的是分页存取机制，为了保证物理内存能得到充分的利用，内核会在适当的时候将物理内存中不经常使用的数据块自动交换到虚拟内存中，而将经常使用的信息保留到物理内存。</p>
<p>要深入了解 Linux 内存运行机制，需要知道下面提到的几个方面：</p>
<ul>
<li>
<p>首先，Linux 系统会不时地进行页面交换操作，以保持尽可能多的空闲物理内存，即使并没有什么事情需要内存，Linux 也会交换出暂时不用的内存页面，因为这样可以大大节省等待交换所需的时间。</p>
</li>
<li>
<p>其次，Linux 进行页面交换是有条件的，不是所有页面在不用时都交换到虚拟内存，Linux 内核根据“最近最经常使用”算法，仅仅将一些不经常使用的页面文件交换到虚拟内存。</p>
</li>
</ul>
<p>有时我们会看到这么一个现象，Linux 物理内存还有很多，但是交换空间也使用了很多，其实这并不奇怪。例如，一个占用很大内存的进程运行时，需要耗费很多内存资源，此时就会有一些不常用页面文件被交换到虚拟内存中，但后来这个占用很多内存资源的进程结束并释放了很多内存时，刚才被交换出去的页面文件并不会自动交换进物理内存（除非有这个必要），那么此时系统物理内存就会空闲很多，同时交换空间也在被使用，就出现了刚才所说的现象了。</p>
<p>最后，交换空间的页面在使用时会首先被交换到物理内存，如果此时没有足够的物理内存来容纳这些页面，它们又会被马上交换出去，如此一来，虚拟内存中可能没有足够的空间来存储这些交换页面，最终会导致 Linux 出现假死机、服务异常等问题。Linux 虽然可以在一段时间内自行恢复，但是恢复后的系统己经基本不可用了。</p>
<p>因此，合理规划和设计 Linux 内存的使用是非常重要的，关于物理内存和交换空间的大小设置问题，取决于实际所用的硬盘大小，但大致遵循这样一个基本原则：</p>
<ol>
<li>如果内存较小（根据经验，物理内存小于 4GB），一般设置 swap 分区大小为内存的 2 倍；</li>
<li>如果物理内存大于 4GB，而小于 16GB，可以设置 swap 分区大小等于物理内存；</li>
<li>如果内存大小在 16GB 以上，可以设置 swap 为 0，但并不建议这么做，因为设置一定大小的 swap 分区是有一定作用的。</li>
</ol>
<h3 id="分区"> 分区</h3>
<p>有时候服务器的访问量却是很大，有可能出现 swap 分区不够用的情况，所以我们需要学习 swap 分区的构建方法。建立新的 swap 分区，只需要执行以下几个步骤。</p>
<ul>
<li>分区：不管是 <code>fdisk</code> 命令还是 <code>parted</code> 命令，都需要先建立一个分区。</li>
<li>格式化：格式化命令稍有不同，使用 <code>mkswap</code> 命令把分区格式化成 swap 分区。</li>
<li>使用 swap 分区。</li>
</ul>
<p>我们一步一步来实现。</p>
<ol>
<li><strong>分区</strong></li>
</ol>
<p>命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># fdisk /dev/sdb</span>
<span>#以/dev/sdb 分区为例</span>
WARNING: DOS-compatible mode is deprecated. It<span>'s strongly recommended to switch off the mode (command '</span>c<span>') and change display units to sectors (command '</span>u'<span>!</span><span>)</span>.

Command <span>(</span>m <span>for</span> <span>help</span><span>)</span>: n													<span>&lt;</span>---新建
Command action
	e	extended
	p	primary partition <span>(</span><span>1</span>-4<span>)</span>
p																																					<span>&lt;</span>---主分区
Partition number <span>(</span><span>1</span>-4<span>)</span>: <span>1</span>												<span>&lt;</span>---分区编号
First cylinder <span>(</span><span>1</span>-2610, default <span>1</span><span>)</span>:									<span>&lt;</span>---起始柱面
Using default value <span>1</span>
Last cylinder, +cylinders or +size<span>{</span>K,M,G<span>}</span> <span>(</span><span>1</span>-2610, default <span>2610</span><span>)</span>：+500M<span>&lt;</span>---大小

Command <span>(</span>m <span>for</span> <span>help</span><span>)</span>：p													<span>&lt;</span>---查看一下

Disk /dev/sdb：21.5 GB，21474836480 bytes
<span>255</span> heads, <span>63</span> sectors/track, <span>2610</span> cylinders
<span>units</span> <span>=</span> cylinders of <span>16065</span> * <span>512</span> <span>=</span> <span>8225280</span> bytes
Sector size <span>(</span>logical/physical<span>)</span>: <span>512</span> bytes / <span>512</span> bytes
I/O size <span>(</span>minimum/optimal<span>)</span>: <span>512</span> bytes / <span>512</span> bytes
Disk identifier: Ox00000ebd

Device Boot		Start		End		Blocks		Id		System
/dev/sdb1		<span>1</span>			<span>65</span>		<span>522081</span>		<span>83</span>		Linux
<span>#刚分配的分区 ID 是 83，是 Linux 分区，我们在这里要分配 swap 分区</span>

<span>command</span> <span>(</span>m <span>for</span> <span>help</span><span>)</span>: t													<span>&lt;</span>---修改分区的系统 ID
Selected partition <span>1</span>													<span>&lt;</span>---只有一个分区，所以不用选择分区了
Hex code <span>(</span>type I to list codes<span>)</span>: <span>82</span>									<span>&lt;</span>---改为 swap 分区的 ID
Changed system <span>type</span> of partition I to <span>82</span> <span>(</span>Linux swap / Solaris<span>)</span>
Command <span>(</span>m <span>for</span> <span>help</span><span>)</span>： P												<span>&lt;</span>---再查看一下

Disk /dev/sdb: <span>21.5</span> GB, <span>21474836480</span> bytes
<span>255</span> heads, <span>63</span> sectors/track, <span>2610</span> cylinders
Units <span>=</span> cylinders of <span>16065</span> * <span>512</span> <span>=</span> <span>8225280</span> bytes
Sector size <span>(</span>logical/physical<span>)</span>: <span>512</span> bytes / <span>512</span> bytes
I/O size <span>(</span>minimum/optimal<span>)</span>: <span>512</span> bytes / <span>512</span> bytes
Disk identifier: 0x00000ebd
Device Boot		start		End		Blocks		Id		System
/dev/sdb1		<span>1</span>			<span>65</span>		<span>522081</span>		<span>82</span>		Linux swap / Solaris
<span>#修改过来了</span>
<span>command</span> <span>(</span>m <span>for</span> <span>help</span><span>)</span>: w													<span>&lt;</span>---记得保存退出
The partition table has been altered<span>!</span>

Calling ioct1<span>(</span><span>)</span> to re-read partition table.
syncing disks.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><ol start="2">
<li><strong>格式化</strong></li>
</ol>
<p>因为要格式化成 swap 分区，所以格式化命令是 <code>mkswap</code>。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mkswap /dev/sdb1</span>
Setting up swapspace version <span>1</span>, size <span>=</span> <span>522076</span> KiB
no label, <span>UUID</span><span>=</span>c3351dc3-f403-419a-9666-c24615e170fb
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ol start="3">
<li><strong>使用 swap 分区</strong></li>
</ol>
<p>在使用 swap 分区之前，我们先来说说 <code>free</code> 命令。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># free</span>
              total        used        <span>free</span>      shared  buff/cache   available
Mem:        <span>1030796</span>			<span>30792</span>	<span>900004</span>           <span>0</span>       <span>15292</span>       <span>55420</span>
-/+ buffers/cache:			<span>60080</span>	<span>970716</span>
Swap:       <span>2047792</span>				<span>0</span>	<span>2047792</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>free</code> 命令主要是用来查看内存和 <code>swap</code> 分区的使用情况的，其中，total 是指总数，used 是指已经使用的，free 是指空闲的，shared 是指共享的，buffers 是指缓冲内存数，cached 是指缓存内存数，单位是 KB。</p>
<p>我们需要解释一下 buffers（缓冲）和 cached（缓存）的区别。简单来讲，cached 是给读取数据时加速的，buffers 是给写入数据加速的。cached 是指把读取出来的数据保存在内存中，当再次读取时，不用读取硬盘而直接从内存中读取，加速了数据的读取过程；buffers 是指在写入数据时，先把分散的写入操作保存到内存中，当达到一定程度后再集中写入硬盘，减少了磁盘碎片和硬盘的反复寻道，加速了数据的写入过程。</p>
<p>我们已经看到，在加载进新的 swap 分区之前，swap 分区的大小是 2000MB，接下来只要加入 swap 分区就可以了，使用命令 <code>swapon</code>。命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># swapon 分区设备文件名</span>

<span># 例如 ：</span>
<span>[</span>root@localhost ~<span>]</span><span># swapon /dev/sdb1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>swap 分区已经加入，我们查看一下。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># free</span>
              total        used        <span>free</span>      shared  buff/cache   available
Mem:		<span>1030796</span>		 <span>131264</span>		 <span>899532</span>			  <span>0</span>		  <span>15520</span>		  <span>55500</span>
-/+ buffers/cache:		  <span>60244</span>		 <span>970552</span>
Swap:		<span>2570064</span>			  <span>0</span>		<span>2570064</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>swap 分区的大小变成了 2500MB，加载成功了。如果要取消新加入的 swap 分区，则也很简单，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># swapoff /dev/sdb1</span>
</code></pre>
<div><span>1</span><br></div></div><p>如果想让 swap 分区开机之后自动挂载，就需要修改 <code>/etc/fstab</code> 文件，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vi /ete/fstab</span>
<span>UUID</span><span>=</span>c2ca6f57-b15c-43ea-bca0-f239083d8bd2	/			ext4	defaults		<span>1</span> <span>1</span>
<span>UUID</span><span>=</span>0b23d315-33a7-48a4-bd37-9248e5c44345	/boot		ext4 	defaults		<span>1</span> <span>2</span>
<span>UUID</span><span>=</span>4021be19-2751-4dd2-98cc-363368c39edb	swap		swap	defaults		<span>0</span> <span>0</span>
tmpfs										/dev/shm	tmpfs	defaults		<span>0</span> <span>0</span>
devpts										/dev/pts	devpts	<span>gid</span><span>=</span><span>5</span>,mode-620	<span>0</span> <span>0</span>
sysfs										/sys		sysfs	defaults		<span>0</span> <span>0</span>
proc										/proc		proc	defaults		<span>0</span> <span>0</span>
/dev/sdb1									swap		swap	defaults		<span>0</span> <span>0</span>
<span>#加入新 swap 分区的相关内容，这里直接使用分区的设备文件名，也可以使用 UUID</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div>]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-05-06T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">linux介绍</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_basic/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_basic/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="什么是操作系统"> 什么是操作系统</h2>
<p>要讲明白 Linux 是什么，首先得说说什么是操作系统。计算机系统是指按用户的要求，接收和存储信息、自动进行数据处理并输出结果信息的系统，它由硬件子系统（计算机系统赖以工作的实体，包括显示屏、键盘、鼠标、硬盘等）和软件子系统（保证计算机系统按用户指定的要求协调工作，如 Windows 操作系统、Office 办公 软件等）组成。</p>
<p>而操作系统（ Operating System，OS ）是软件子系统的一部分，是硬件基础上的第一层软件，是硬件与其他软件的接口，就好似吃饭的桌子，有了桌子才能摆放碟子、碗、筷子、勺子 等。它控制其他程序运行，管理系统资源，提供最基本的计算功能，如管理及配置内存、决定系统资源供需的优先次序等件，同时还提供一些基本的服务程序，例如：</p>
<p>（1）文件系统。提供计算机存储信息的结构，信息存储在文件中，文件主要存储在计算机的内部硬盘里，在目录的分层结构中组织文件。文件系统为操作系统提供了组织管理数据的 方式。</p>
<p>（2）设备驱动程序。提供连接计算机的每个硬件设备的接口，设备驱动器使程序能够写 入设备，而不需要了解执行每个硬件的细节。简单来说，就是让你能吃到鸡蛋，但不用养一 只鸡。</p>
<p>（3）用户接口。操作系统需要为用户提供一种运行程序和访问文件系统的方法。如常用的 Windows 图形界面，可以理解为一种用户与操作系统交互的方式；智能手机的 Android 或 iOS 系统，也是一种操作系统的交互方式。</p>
<p>（4）系统服务程序。当计算机启动时，会自启动许多系统服务程序，执行安装文件系统，启动网络服务、运行预定任务等操作。</p>
<p>目前流行的服务器和 PC 端操作系统有 Linux、Windows、UNIX 等。</p>
<h2 id="从-unix-到-linux"> 从 UNIX 到 Linux</h2>
<p>UNIX 与 Linux 之间的关系是一个很有意思的话题。在目前主流的服务器端操作系统中，UNIX 诞生于 20 世纪 60 年代末，Windows 诞生于 20 世纪 80 年代中期，Linux 诞生于 20 世纪 90 年代初，可以说 UNIX 是操作系统中的&quot;老大哥&quot;，后来的 Windows 和 Linux 都参考了 UNIX。</p>
<div><p>说明</p>
<p>现代的 Windows 系统已经朝着“图形界面”的方向发展了，和 UNIX 系统有了巨大的差异，从表面上甚至看不出两者的关联。</p>
</div>
<h3 id="unix-的坎坷历史"> UNIX 的坎坷历史</h3>
<p>UNIX 操作系统由肯·汤普森(Ken Thompson)和丹尼斯·里奇(Dennis Ritchie)发明。它的部分技术来源可追溯到从 1965 年开始的 Multics 工程计划，该计划由贝尔实验室、美国麻省理工学院和通用电气公司联合发起，目标是开发一种交互式的、具有多道程序处理能力的分时操作系统，以取代当时广泛使用的批处理操作系统。</p>
<div><p>说明</p>
<p>分时操作系统使一台计算机可以同时为多个用户服务，连接计算机的终端用户交互式发出命令，操作系统采用时间片轮转的方式处理用户的服务请求并在终端上显示结果(操作系统将 CPU 的时间划分成若干个片段，称为时间片)。操作系统以时间片为单位，轮流为每个终端用户服务，每次服务一个时间片。</p>
</div>
<p>可惜，由于 Multics 工程计划所追求的目标太庞大、太复杂，以至于它的开发人员都不知道要做成什么样子，最终以失败收场。</p>
<p>以肯 • 汤普森为首的贝尔实验室研究人员吸取了 Multics 工程计划失败的经验教训，于 1969 年实现了一种分时操作系统的雏形，1970 年该系统正式取名为 UNIX。想一下英文中的前缀 Multi 和 Uni，就明白了 UNIX 的隐意。Multi 是大的意思，大而且繁；而 Uni 是小的意思，小而且巧。这是 UNIX 开发者的设计初衷，这个理念一直影响至今。</p>
<p>有意思的是，肯 • 汤普森当年开发 UNIX 的初衷是运行他编写的一款计算机游戏 Space Travel，这款游戏模拟太阳系天体运动，由玩家驾驶飞船，观赏景色并尝试在各种行星和月亮上登陆。他先后在多个系统上试验，但运行效果不甚理想，于是决定自己开发操作系统，就这样，UNIX 诞生了。</p>
<p>自 1970 年后，UNIX 系统在贝尔实验室内部的程序员之间逐渐流行起来。1971-1972 年，肯 • 汤普森的同事丹尼斯 • 里奇发明了传说中的 C 语言，这是一种适合编写系统软件的高级语言，它的诞生是 UNIX 系统发展过程中的一个重要里程碑，它宣告了在操作系统的开发中，汇编语言不再是主宰。到了 1973 年，UNIX 系统的绝大部分源代码都用 C 语言进行了重写，这为提高 UNIX 系统的可移植性打下了基础（之前操作系统多采用汇编语言，对硬件依赖性强），也为提高系统软件的开发效率创造了条件。可以说，UNIX 系统与 C 语言是一对孪生兄弟，具有密不可分的关系。</p>
<p>20 世纪 70 年代初，计算机界还有一项伟大的发明——TCP/IP 协议，这是当年美国国防部接手 ARPAnet 后所开发的网络协议。美国国防部把 TCP/IP 协议与 UNIX 系统、C 语言捆绑在一起，由 AT&amp;T 发行给美国各个大学非商业的许可证，这为 UNIX 系统、C 语言、TCP/IP 协议的发展拉开了序幕，它们分别在操作系统、编程语言、网络协议这三个领域影响至今。肯•汤普森和丹尼斯•里奇因在计算机领域做出的杰出贡献，于 1983 年获得了计算机科学的最高奖——图灵奖。</p>
<p>随后出现了各种版本的 UNIX 系统，目前常见的有 Sun Solaris、FreeBSD、IBM AIX、HP-UX 等。</p>
<h3 id="linux-的那些往事"> Linux 的那些往事</h3>
<p>Linux 内核最初是由李纳斯 • 托瓦兹（Linus Torvalds）在赫尔辛基大学读书时出于个人爱好而编写的，当时他觉得教学用的迷您版 UNIX 操作系统 Minix 太难用了，于是决定自己开发一个操作系统。第 1 版本于 1991 年 9 月发布，当时仅有 10000 行代码。</p>
<p>李纳斯 • 托瓦兹没有保留 Linux 源代码的版权，公开了代码，并邀请他人一起完善 Linux。与 Windows 及其他有专利权的操作系统不同，Linux 开放源代码，任何人都可以免费使用它。</p>
<p>据估计，现在只有 2% 的 Linux 核心代码是由李纳斯 • 托瓦兹自己编写的，虽然他仍然拥有 Linux 内核（操作系统的核心部分），并且保留了选择新代码和需要合并的新方法的最终裁定权。现在大家所使用的 Linux，我更倾向于说是由李纳斯 • 托瓦兹和后来陆续加入的众多 Linux 好者共同开发完成的。</p>
<p>李纳斯 • 托瓦兹无疑是这个世界上最伟大的程序员之一，何况，他还搞出了全世界最大的程序员交友社区 GitHub （开源代码库及版本控制系统）。</p>
<p>关于 Linux Logo 的由来是一个很有意思的话题，它是一只企鹅。企鹅是南极洲的标志性动物，根据国际公约，南极洲为全人类共同所有，不属于世界上的任何国家，任何国家都无权将南极洲纳入其版图。Linux 选择企鹅图案作为 Logo，其含义是：开放源代码的 Linux 为全人类共同所有，任何公司无权将其私有。</p>
<h3 id="unix-与-linux-的关系"> UNIX 与 Linux 的关系</h3>
<p>二者的关系，不是大哥和小弟，“UNIX 是 Linux 的父亲”这个说法更怡当。之所以要介绍它们的关系，是因为要告诉大家，在学习的时候，其实 Linux 与 UNIX 有很多的共通之处，简单地说，如果您已经熟练掌握了 Linux，那么再上手使用 UNIX 会非常容易。</p>
<p>二者也有两个大的区别：</p>
<ul>
<li>
<p>UNIX 系统大多是与硬件配套的，也就是说，大多数 UNIX 系统如 AIX、HP-UX 等是无法安装在 x86 服务器和个人计算机上的，而 Linux 则可以运行在多种硬件平台上；</p>
</li>
<li>
<p>UNIX 是商业软件，而 Linux 是开源软件，是免费、公开源代码的。</p>
</li>
</ul>
<p>Linux 受至旷大计算机爱好者的喜爱，主要原因也有两个：</p>
<ul>
<li>
<p>它属于开源软件，用户不用支付可费用就可以获得它和它的源代码，并且可以根据自己的需要对它进行必要的修改，无偿使用，无约束地继续传播；</p>
</li>
<li>
<p>它具有 UNIX 的全部功能，任何使用 UNIX 操作系统或想要学习 UNIX 操作系统的人都可以从 Linux 中获益。</p>
</li>
</ul>
<p>开源软件是不同于商业软件的一种模式，从字面上理解，就是开放源代码，大家不用担心里面会搞什么猫腻，这会带来软件的革新和安全。</p>
<p>另外，开源其实并不等同于免费，而是一种新的软件盈利模式。目前很多软件都是开源软件，对计算机行业与互联网影响深远。</p>
<p>近年来，Linux 已经青出于蓝而胜于蓝，以超常的速度发展，从一个丑小鸭变成了一个拥有庞大用户群的真正优秀的、值得信赖的操作系统。历史的车轮让 Linux 成为 UNIX 最优秀的传承者。</p>
<div><p>总结</p>
<p>Linux 是一个类似 Unix 的操作系统，Unix 要早于 Linux，Linux 的初衷就是要替代 UNIX，并在功能和用户体验上进行优化，所以 Linux 模仿了 UNIX（但并没有抄袭 UNIX 的源码），使得 Linux 在外观和交互上与 UNIX 非常类似。</p>
<p>相比于 UNIX，Linux 最大的创新是开源免费，这是它能够蓬勃发展的最重要原因；而目前的 UNIX 大部分都是收费的，小公司和个人都难以承受。</p>
<p>正是由于 Linux 和 UNIX 有着千丝万缕的联系，所以人们把 Linux 叫做“类 UNIX 系统”。</p>
</div>
<h2 id="unix-linux-系统结构"> UNIX/Linux 系统结构</h2>
<p>UNIX/Linux 系统可以粗糙地抽象为 3 个层次（所谓粗糙，就是不够细致、精准，但是便于初学者抓住重点理解），如图1-1 所示。底层是 UNIX/Linux 操作系统，即系统内核（Kernel）；中间层是 Shell 层，即命令解释层；高层则是应用层。</p>
<div>
<p><img src="./assets/structure.jpg" alt="Structrure" loading="lazy"></p>
<p><strong>图1-1	<u>UNIX/Linux 系统结构层次概要</u></strong></p>
</div>
<ol>
<li>
<p><strong>内核层</strong></p>
<p>内核层是 UNIX/Linux 系统的核心和基础，它直接附着在硬件平台之上，控制和管理系统内各种资源（硬件资源和软件资源），有效地组织进程的运行，从而扩展硬件的功能，提高资源的利用效率，为用户提供方便、高效、安全、可靠的应用环境。</p>
</li>
<li>
<p><strong>Shell 层</strong></p>
<p>Shell 层是与用户直接交互的界面。用户可以在提示符下输入命令行，由 Shell 解释执行并输出相应结果或者有关信息，所以我们也把 Shell 称作命令解释器，利用系统提供的丰富命令可以快捷而简便地完成许多工作。</p>
</li>
<li>
<p><strong>应用层</strong></p>
<p>应用层提供基于 X Window 协议的图形环境。X Window 协议定义了一个系统所必须具备的功能（就如同 TCP/IP 是一个协议，定义软件所应具备的功能），可系统能满足此协议及符合 X 协会其他的规范，便可称为 X Window。</p>
</li>
</ol>
<p>现在大多数的 UNIX 系统上（包括 Solaris、HP-UX、AIX 等）都可以运行 CDE（Common Desktop Environment，通用桌面环境，是运行于 UNIX 的商业桌面环境）的用户界面；而在 Linux 上广泛应用的有 Gnome、KDE 等。</p>
<div><p>说明</p>
<p>X Window 与微软的 Windows 图形环境有很大的区别：UNIX/Linux 系统与 X Window没有必然捆绑的关系，也就是说，UNIX/Linux 可以安装 X Window，也可以不安装；而微软的 Windows 图形环境与内核捆绑密切。UNIX/Linux 系统不依赖图形环境，依然可以通过命令行完成 100% 的功能，而且因为不使用图形环境还会节省大量的系统资源。作为服务器部署，绝大多数 Linux 并不安装或并不启用图形环境，我们学习的也基本上为 Linux 命令行下的操作。</p>
</div>
<h2 id="linux-的优势"> Linux 的优势</h2>
<p>相比 Windows 系统，Linux 系统有更好的稳定性。此外，Linux 还有如下优势：</p>
<ol>
<li>
<p><strong>大量的可用软件及免费软件</strong></p>
<p>Linux 系统上有着大量的可用软件，且绝大多数是免费的，比如声名赫赫的 Apache、Samba、PHP、MySQL 等，构建成本低廉，是 Linux 被众多企业青睐的原因之一。当然，这和 Linux 出色的性能是分不开的，否则，节约成本就没有任何意义。</p>
<p>但不可否认的是，Linux 在办公应用和游戏娱乐方面的软件相比 Windows 系统还很匮乏，所以，即便打游戏、看影片用的也是 Windows，至于 Linux，就把它用在擅长的服务器领域吧。</p>
</li>
<li>
<p><strong>良好的可移植性及灵活性</strong></p>
<p>Linux 系统有良好的可移植性，它几乎支持所有的 CPU 平台，这使得它便于裁剪和定制。我们可以把 Linux 放在 U 盘、光盘等存储介质中，也可以在嵌入式领域广泛应用。</p>
<p>如果大家希望不进行安装就体验 Linux 系统，则可以在网上下载一个 Live DVD 版的 Linux 镜像，刻成光盘放入光驱或者用虚拟机软件直接载入镜像文件，设置 CMOS/BIOS 为光盘启动，系统就会自动载入光盘文件，启动进入 Linux 系统。</p>
</li>
<li>
<p><strong>优良的稳定性和安全性</strong></p>
<p>著名的黑客埃里克 • 雷蒙德（EricS.Raymond）有一句名言： “足够多的眼睛，就可让所有问题浮现”。举个例子，假如你在演讲，台下人山人海，你中午吃饭不小心，有几个饭粒粘在衣领上了，分分钟就会被大家发现，因为看的人太多了；如果台下就稀稀落落两三个人且离得很远，那就算你衣领上有一大块油渍也不会被发现。</p>
<p>Linux 开放源代码，将所有代码放在网上，全世界的程序员都看得到，有什么缺陷和漏洞，很快就会被发现，从而成就了它的稳定性和安全注。</p>
</li>
<li>
<p><strong>支持几乎所有的网络协议及开发语言</strong></p>
<p>经常有初学的朋友会问，Linux 是不是对 TCP/IP 协议支持不好、是不是 Java 开发环境不灵之类的问题。前面在 UNIX 发展史中已经介绍了，UNIX 系统是与 C 语言、TCP/IP 协议一同发展起来的，而 Linux 是 UNIX 的一种，C 语言又衍生出了现今主流的语言 PHP、Java、C++ 等，而哪一个网络协议与 TCP/IP 无关呢? 所以，Linux 对网络协议和开发语言的支持很好。</p>
</li>
</ol>
<p>Linux 的优点在此不一一举例，只说明这几点供参考。诚然，Linux 不可能没有缺点，如桌面应用还有待完善、Linux 的标准统一还需要推广、开源软件的盈利模式与发展还有待考验等，不过，瑕不掩瑜。</p>
<h2 id="linux-的应用领域"> Linux 的应用领域</h2>
<p>Linux 似乎在我们平时的生活中很少看到，那么它应用在哪些领域呢？其实，在生活中随时随地都有 Linux 为我们服务着······</p>
<ol>
<li><strong>网站服务器</strong></li>
</ol>
<p>用事实说话！访问国际知名的 Netcraft 网站 <a href="http://www.inetcraf.com" target="_blank" rel="noopener noreferrer">http://www.inetcraf.com</a>，在“What's that site running?”的地址栏内输入想了解信息的网站地址，单击箭头图标即可搜索到相关信息。</p>
<p>在搜索结果中会看到网站的操作系统信息。例如，搜索兄弟连网站“www.itxd.cn”，可以看到 OS 显示为 Linux。 Netcraft 可以理解为一个基于 Web 页面的扫描器。</p>
<p>验证一下哪些大型网站在使用 Linux。 大家常用的购物网站淘宝用的就是 Linux。如果搜索结果中的 OS 项显示 “unknown”，可能是由于安装了防火墙或代理，无法准确地获取信息。</p>
<p>世界知名的网站 google.com、qq.com、新浪、网易等，无一例外地应用着 Linux。就连你输入 microsoft.com，会发现微软的下载站等也在使用 Linux。 为什么这么多大型网站会采用 Linux 而不使用 UNIX 或 Windows？其中一个重要的原因就是使用 Linux 成本较低，而 UNIX 和 Windows 都是商业软件；另一个更重要的原因是出于安全和性能方面的考虑。</p>
<ol start="2">
<li><strong>电影工业</strong></li>
</ol>
<p>1998 年，看了一部电影《泰坦尼克号》，那些看起来真实、恐怖的豪华巨轮与冰山相撞最终沉没的场面要归功于 Linux，归功于电影特技效果公司里终日处理数据的 100 多台 Linux 服务器。 在过去，SGI 图形工作站支配了整个电影产业，20 世纪 90 年代的影片《侏罗纪公园》中生动的恐龙正是从 SGI 上孕育出来的，SGI 的操作系统 Irix 就是 UNIX 的一种。当时所有动画制作公司都得看 SGI 的脸色。然而，从 1997 年开始，Linux 开始全面占领好莱坞，娱乐业巨擘迪士尼宣布全面采用 Linux，宣告了 SGI 时代的没落，Linux 时代走向辉煌。 好莱坞精明的电影人热情地拥抱 Linux，其中的原因不言而喻。首先，Linux 作为开源软件，可以节省大量成本；其次，Linux 具有商业软件不具备的功能定制化特点，各家电影厂商都可依据自己的制片需要铺设相关平台。到现在为止，使用 Linux 制作的好莱坞大片已经有几百部。</p>
<ol start="3">
<li><strong>嵌入式应用</strong></li>
</ol>
<p>嵌入式系统是以应用为中心，以计算机技术为基础，并且软硬件可定制，适用于各种应用场合，对功能、可靠性、成本、体积、功耗有严格要求的专用计算机系统。它一般由嵌入式微处理器、外围硬件设备、嵌入式操作系统及用户的应用程序 4 部分组成，用于实现对其他设备的控制、监视或管理等。嵌入式系统几乎涵盖了生活中的所有电器设备，如手机、平板电脑、电视机顶盒、游戏机、智能电视、汽车、数码相机、自动售货机、工业自动化仪表与医疗仪 器等。不得不提的是安卓系统（Android）。安卓是基于 Linux 的开源系统，主要适用于便携设备， 如智能手机和平板电脑等，是 Google 公司为移动终端打造的真正开放和完整的移动软件。在如今的智能手机操作系统市场上，安卓系统的占有率已然是傲视群雄。 从安卓手机到智能机器人，从大型网站到美国太空站，Linux 都已涉足其中。Linux 的发展震动了整个科技界，动摇了微软一贯以来的霸权，并且为科技界贡献了一种软件制造的新方式。 <a href="www.top500.org">Top500</a> 是评定全球 500 台最快的超算系统性能榜单，连续多届，在世界上 500 台超级计算机里，超过 9 成是 Linux 系统！如果你还关在家里面，认为全世界都是 Windows，则无异于坐井观天。世界那么大，出去看看吧！</p>
<h2 id="linux-的发行版本"> Linux 的发行版本</h2>
<p>Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包。</p>
<div>
<p><img src="./assets/intro.jpg" alt="intro" loading="lazy"></p>
<p><strong>图1-2	<u>Linux 的发行版</u></strong></p>
<div>
<p>事实上，已经孵化出专属 Linux 各发行版的巨大生态系统。一个发行版（ distribution ，有时缩写为 distro ）是一个定制的软件包，它将 Linux 内核以及用户计算机 Linux 运行版的安装工具一起发布。</p>
<p>在 Linux 内核的发展过程中，各种 Linux 发行版本起了巨大的作用，正是它们推动了 Linux 的应用，从而让更多的人开始关注 Linux。因此，把 Red Hat、Ubuntu、SUSE 等直接说成 Linux 其实是不确切的，它们是 Linux 的发行版本，更确切地说，应该叫作“以 Linux 为核心的操作系统软件包”。</p>
<p>Linux 的各个发行版本使用的是同一个 Linux 内核，因此在内核层不存在什么兼容性问题，每个版本有不一样的感觉，只是在发行版本的最外层（由发行商整合开发的应用）才有所体现。</p>
<p>目前市面上较知名的发行版有: Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等。如图1-2 所示。</p>
<p>Linux 的发行版本可以大体分为两类：</p>
<ul>
<li>商业公司维护的发行版本，以著名的 Red Hat 为代表；</li>
<li>社区组织维护的发行版本，以 Debian 为代表。</li>
</ul>
<p>很难说大量 Linux 版本中哪一款更好，每个版本都有自己的特点。</p>
<h3 id="red-hat-linux"> Red Hat Linux</h3>
<p>Red Hat（红帽公司）创建于 1993 年，是目前世界上资深的 Linux 厂商，也是最获认可的 Linux 品牌。</p>
<p>Red Hat 公司的产品主要包括 RHEL（Red Hat Enterprise Linux，收费版本）和 CentOS（ RHEL 的社区克隆版本，免费版本）、Fedora Core（由 Red Hat 桌面版发展而来，免费版本）。</p>
<p>Red Hat 是在我国国内使用人群最多的 Linux 版本，资料丰富，如果您有什么不明白的地方，则容易找到人来请教，而且大多数 Linux 教程是以 Red Hat 为例来讲解的（包括本教程）。</p>
<p>CentOS 是基于 Red Hat Enterprise Linux 源代码重新编译、去除 Red Hat 商标的产物，各种操作使用和付费版本没有区别，且完全免费。缺点是不向用户提供技术支持，也不负任何商业责任。</p>
<div><p>说明</p>
<p>CentOS 项目最近宣布了 CentOS 的战略转变，CentOS 以前是作为上游供应商的下游构建版本存在的（即它会在上游供应商之后收到补丁和更新），而现在它将转移为一个上游构建版本（即它会在上游供应商纳入之前测试补丁和更新）。另外，对 CentOS Linux 8 的支持也已从 2029年 5 月 31 日缩短至 2021 年 12 月 31 日。</p>
<p>Rocky Linux 的目标是像 CentOS 以前那样作为一个下游构建版本，在被上游供应商纳入包更新之后（而不是之前）构建发行。</p>
<p>Rocky Linux 是一个社区化的企业级操作系统。其设计为的是与美国顶级企业 Linux 发行版实现 100％ Bug 级兼容，而原因是后者的下游合作伙伴转移了发展方向。目前社区正在集中力量发展有关设施。Rocky Linux 由 CentOS 项目的创始人 Gregory Kurtzer 领导。</p>
<p>Rocky Linux 以社区驱动为导向，为您带来企业级、可生产的 Linux 系统。以后可代替 CentOS 。</p>
</div>
</div>
</div>
<h3 id="ubuntu-linux"> Ubuntu Linux</h3>
<p>Ubuntu 基于知名的 Debian Linux 发展而来，界面友好，容易上手，对硬件的支持非常全面，是目前最适合做桌面系统的 Linux 发行版本，而且 Ubuntu 的所有发行版本都免费提供。</p>
<p>Ubuntu 的创始人 Mark Shuttleworth 是非常具有传奇色彩的人物。他在大学毕业后创建了一家安全咨询公司，1999 年以 5.75 亿美元被收购，由此一跃成为南非最年轻有为的本土富翁。作为一名狂热的天文爱好者，Mark Shuttleworth 于 2002 年自费乘坐俄罗斯联盟号飞船，在国际空间站中度过了 8 天的时光。之后，Mark Shuttleworth 创立了 Ubuntu 社区，2005 年 7 月 1 日建立了 Ubuntu 基金会，并为该基金会投资 1000 万美元。他说，太空的所见正是他创立 Ubuntu 的精神之所在。如今，他最热衷的事情就是到处为自由开源的 Ubuntu 进行宣传演讲。</p>
<h3 id="suse-linux"> SuSE Linux</h3>
<p>SuSE Linux 以 Slackware Linux 为基础，原来是德国的 SuSE Linux AG 公司发布的 Linux 版本，1994 年发行了第一版，早期只有商业版本，2004 年被 Novell 公司收购后，成立了 OpenSUSE 社区，推出了自己的社区版本 OpenSUSE。</p>
<p>SuSE Linux 在欧洲较为流行，在我国国内也有较多应用。值得一提的是，它吸取了 Red Hat Linux 的很多特质。</p>
<p>SuSE Linux 可以非常方便地实现与 Windows 的交互，硬件检测非常优秀，拥有界面友好的安装过程、图形管理工具，对于终端用户和管理员来说使用非常方便。</p>
<h3 id="gentoo-linux"> Gentoo Linux</h3>
<p>Gentoo 最初由 Daniel Robbins（FreeBSD 的开发者之一）创建，首个稳定版本发布于 2002 年。Gentoo 是所有 Linux 发行版本里安装最复杂的，到目前为止仍采用源码包编译安装操作系统。</p>
<p>不过，它是安装完成后最便于管理的版本，也是在相同硬件环境下运行最快的版本。自从 Gentoo 1.0 面世后，它就像一场风暴，给 Linux 世界带来了巨大的惊喜，同时也吸引了大量的用户和开发者投入 Gentoo Linux 的怀抱。</p>
<p>有人这样评价 Gentoo：快速、设计干净而有弹性，它的出名是因为其高度的自定制性（基于源代码的发行版）。尽管安装时可以选择预先编译好的软件包，但是大部分使用 Gentoo 的用户都选择自己手动编译。这也是为什么 Gentoo 适合比较有 Linux 使用经验的老手使用。</p>
<h3 id="发行版选择"> 发行版选择</h3>
<p>Linux 的发行版本众多，在此不逐一介绍，下面给选择 Linux 发行版本犯愁的朋友一点建议：</p>
<ul>
<li>
<p>如果您需要的是一个服务器系统，而且已经厌烦了各种 Linux 的配置，只是想要一个比较稳定的服务器系统，那么建议您选择 CentOS 或 RHEL。</p>
</li>
<li>
<p>如果您只是需要一个桌面系统，而且既不想使用盗版，又不想花大价钱购买商业软件，不想自己定制，也不想在系统上浪费太多时间，则可以选择 Ubuntu 。</p>
</li>
<li>
<p>如果您想深入摸索一下 Linux 各个方面的知识，而且还想非常灵活地定制自己的 Linux 系统，那就选择 Gentoo 吧，尽情享受 Gentoo 带来的自由快感。</p>
</li>
<li>
<p>如果您对系统稳定性要求很高，则可以考虑 FreeBSD 。</p>
</li>
<li>
<p>如果您需要使用数据库高级服务和电子邮件网络应用，则可以选择 SuSE 。</p>
</li>
</ul>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-05-06T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">linux用户和用户组管理</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_basic/12.linux_user_group/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_basic/12.linux_user_group/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>用户和用户组管理，顾名思义就是添加用户和用户组、更改密码和设定权限等操作。可能有很多人觉得用户管理没有意义，因为我们在使用个人计算机的时候，不管执行什么操作，都以管理员账户登录，而从来没有添加和使用过其他普通用户。这样做对个人计算机来讲问题不大，不过在服务器上是行不通的。大家想象一下，我们是一个管理团队，共同维护一组服务器，难道每个人都能够被赋子管理员权限吗？显然是不行的，因为不是所有的数据都可以对每位管理员公开，而且如果在运维团队中有某位管理员对 Linux 不热悉，那么赋子他管理员权限的后果可能是灾难性的。所以，越是对安全性要求高的服务器，越需要建立合理的用户权限等级制度和服务器操作规范。</p>
<h2 id="用户配置文件和管理相关文件"> 用户配置文件和管理相关文件</h2>
<p>我们已经知道 Linux 中的所有内容都是文件，所有内容如果想要永久生效，都需要保存到文件中，那么用户信息当然也要保存到文件中。我们需要先掌握这些和用户管理相关的文件。</p>
<h3 id="用户信息文件-etc-passwd"> 用户信息文件 <code>/etc/passwd</code></h3>
<p>这个文件中保存的就是系统中所有的用户和用户的主要信息。我们打开这个文件来看看内容到底是什么。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vi /etc/passwd</span>
<span>#查看一下文件内容</span>
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
<span>..</span>.省略部分输出<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这个文件的内容非常规律，每行代表一个用户。大家可能会比较惊讶，Linux 系统中默认怎么会有这么多的用户啊！这些用户中的绝大多数是系统或服务正常运行所必需的用户，我们把这种用户称为<strong>系统用户或伪用户</strong>。系统用户是不能登录系统的，但是这些用户同样也不能被删除，因为一旦删除，依赖这些用户运行的服务或程序就不能正常执行，会导致系统问题。</p>
<p>那么我们就把 root 用户这一行拿出来，看看这个文件中的内容具体代表的含义吧。我们会注意到，这个文件用“<strong>:</strong>”作为分隔符，划分为7 个字段，我们逐个来看具体的含义。</p>
<ol>
<li><strong>用户名称</strong></li>
</ol>
<p>第一个字段中保存的是用户名称。不过大家需要注意，用户名称只是为了方便管理员记忆，Linux 系统是通过用户 ID（UID）来区分不同用户、分配用户权限的。而用户名称和 UID 的对应正是通过 <code>/etc/passwd</code> 这个文件来定义的。</p>
<ol start="2">
<li><strong>密码标志</strong></li>
</ol>
<p>这里我们说“x”代表的是密码标志，而不是真正的密码，真正的密码是保存在 <code>/etc/shadow</code> 文件中的。在早期的 UNIX 中，这里保存的就是真正的加密密码串，但是这个文件的权限是644，查询命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ll /etc/passwd</span>
-rw-r--r-- <span>1</span> root root <span>1648</span> <span>12</span>月 <span>29</span> 00:17 /etc/passwd
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>所有用户都可以读取 <code>/etc/passwd</code> 文件，这样非常容易导致密码的泄露。虽然密码是加密的，但是采用暴力破解的方式也是能够进行破解的。所以现在的 Linux 系统把真正的加密密码串放置在影子文件 <code>/etc/shadow</code> 中，而影子文件的权限是 000，查询命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ll /etc/shadow</span>
---------- <span>1</span> root root <span>1028</span> <span>12</span>月 <span>29</span> 00:18 /etc/shadow
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这个文件是没有任何权限的，但因为我是 root 用户，所以读取权限不受限制。当然，用强制修改的方法也是可以手工修改这个文件的内容的。只有 root 用户可以浏览和操作这个文件，这样就最大限度地保证了密码的安全。</p>
<p>所以在 <code>/etc/passwd</code> 中只有一个“x”代表用户是拥有密码的，我们把这个字段称作密码标志，具体的密码要去 <code>/etc/shadow</code> 文件中查询。但是这个密码标志“x”也是不能被删除的，如果删除了密码标志“x”，那么系统会认为这个用户没有密码，从而导致只输入用户名而不用输入密码就可以登录（当然只能在本机上使用无密码登录，远程是不可以的），除非特殊情况（如破解用户密码），这当然是不可行的。</p>
<ol start="3">
<li><strong>UID</strong></li>
</ol>
<p>第三个字段就是 用户ID（UID），我们已经知道系统是通过 UID 来识别不同的用户和分配用户权限的。这些 UID 是有使用限制和要求的，我们需要了解。</p>
<ul>
<li>0：超级用户 UID。如果用户 UID 为 0，则代表这个账号是管理员账号。在 Linux 中如何把普通用户升级成管理员呢？只需把其他用户的 UID 修改为 0 就可以了，这一点和 Windows 是不同的。不过不建议建立多个管理员账号。</li>
<li>1～499：系统用户（伪用户）UID。这些 UID 是系统保留给系统用户的 UID，也就是说 UID 是1~499 范围内的用户是不能登录系统的，而是用来运行系统或服务的。其中，1~99 是系统保留的账号，系统自动创建；100～499 是预留给用户创建系统账号的。</li>
<li>500～65535：普通用户 UID。建立的普通用户 UID 从 500 开始，最大到 65535。</li>
</ul>
<p>这些用户足够使用了，但是如果不够也不用害怕，2.6.x 内核以后的 Linux 系统用户 UID 已经可以支持 2^32个用户了。</p>
<ol start="4">
<li><strong>GID</strong></li>
</ol>
<p>第四个字段就是用户的 组ID（GID），也就是这个用户的初始组的标志号。这里需要解释一下初始组和附加组的概念。</p>
<p>所谓<strong>初始组</strong>，指用户一登录就立刻拥有这个用户组的相关权限。每个用户的初始组只能有一个，一般就是将和这个用户的用户名相同的组名作为这个用户的初始组。举例来说，我们手工添加用户 lamp，在建立用户 lamp 的同时就会建立 lamp 组作为 lamp 用户的初始组。</p>
<p>所谓<strong>附加组</strong>，指用户可以加入多个其他的用户组，并拥有这些组的权限。每个用户只能有一个初始组，除初始组要把用户再加入其他的用户组外，这些用户组就是这个用户的附加组。</p>
<p>附加组可以有多个，而且用户可以有这些附加组的权限。举例来说，刚刚的 lamp 用户除属于初始组 lamp 外，我又把它加入了 users 组，那么 lamp 用户同时属于 lamp 组、users 组，其中 lamp 是初始组，users 是附加组。当然，初始组和附加组的身份是可以修改的，但是我们在工作中一般不修改初始组，只修改附加组，因为修改了初始组有时会让管理员逻辑混乱。</p>
<div><p>注意</p>
<p>在 <code>/etc/passwd</code> 文件的第四个字段中看到的 ID 是这个用户的初始组。</p>
</div>
<ol start="5">
<li><strong>用户说明</strong></li>
</ol>
<p>第五个字段是这个用户的简单说明，没有什么特殊作用，可以不写。</p>
<ol start="6">
<li><strong>家目录</strong></li>
</ol>
<p>第六个字段是这个用户的家目录，也就是用户登录后有操作权限的访问目录，我们把这个目录称为用户的家目录。超级用户的家目录是 <code>/root</code> 目录，普通用户在 <code>/home/</code> 目录下建立和用户名相同的目录作为家目录，如 lamp 用户的家目录就是 <code>/home/lamp/</code> 目录。</p>
<ol start="7">
<li><strong>登录之后的 Shell</strong></li>
</ol>
<p>Shell 就是 Linux 的命令解释器。管理员输入的密码都是 ASCII 码，也就是类似 abed 的英文。但是系统可以识别的编码是类似 0101 的机器语言。Shell 的作用就是把 ASCII 编码的命令翻译成系统可以识别的机器语言，同时把系统的执行结果翻译为用户可以识别的 ASCI 编码。Linux 的标准 Shell 就是 <code>/bin/bash</code>。</p>
<p>在 <code>/etc/passwd</code> 文件中，大家可以把这个字段理解为用户登录之后所拥有的权限。如果写入的是 Linux 的标准 Shell，<code>/bin/bash</code> 就代表这个用户拥有权限范围内的所有权限。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vi /etc/passwd</span>
lamp:x:502:502::/home/lamp:/bin/bash
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>我手工添加了 lamp 用户，它的登录 Shell 是 <code>/bin/bash</code>，那么这个用户就可以使用普通用户的所有权限。如果我把 lamp 用户的 Shell 修改为 <code>/sbin/nologin</code>，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vi /etc/passwd</span>
lamp:x:502:502::/home/lamp:/sbin/nologin
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>那么这个用户就不能登录了，因为 <code>/sbin/nologin</code> 就是禁止登录的 Shell。这样说明白了吗？如果我在这里放入的是一个系统命令，如 <code>/usr/bin/passwd</code>，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vi /etc/passwd</span>
Lamp:x:502:502::/home/lamp:/usr/bin/passwd
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>那么这个用户可以登录，但是登录之后就只能修改自己的密码了。但是在这里不能随便写入和登录没有关系的命令，如 <code>ls</code>，否则系统不会识别这些命令，也就意味着这个用户不能登录。</p>
<h3 id="影子文件-etc-shadow"> 影子文件 <code>/etc/shadow</code></h3>
<p>这个文件中保存着用户的实际加密密码和密码有效期等参数。我们已经知道这个文件的权限是 000，所以保存的实际加密密码除 root 用户外，其他用户是不能查看的，这样做有效地保证了密码的安全。如果这个文件的权限发生了改变，则需要注意是否是恶意攻击。我们打开这个文件看看，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span> <span>vi</span> /etc/shadow root:<span>$6</span><span>$m2MwR08L48jY6YN5</span><span>$lmq0B9ruMxCUesmDvDs2vFDAG0adTlbfgWHAxlwxEa8388</span>/yyC2WY/p9tMQSrfrjxNOsSnOIjRlGHxuYNkeJI1:18642:0:99999:7:::
bin:*:18353:0:99999:7:::
daemon:*:18353:0:99999:7:::
<span>..</span>.省略部分输出<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这个文件的每行代表一个用户，同样使用“<strong>:</strong>”作为分隔符，划分为 9 个字段。我们以 root 行为例，这 9 个字段的作用如下。</p>
<ol>
<li><strong>用户名称</strong></li>
</ol>
<p>第一个字段中保存的是用户名称，和 <code>/etc/passwd</code> 文件的用户名称相对应。</p>
<ol start="2">
<li><strong>密码</strong></li>
</ol>
<p>第二个字段中保存的是真正加密的密码。目前 Linux 的密码采用的是 SHA512 散列加密算法，而原来采用的是 MDS 或 DES 加密算法。SHASI2 散列加密算法的加密等级更高，也更加安全。注意：这串密码产生的乱码不能手工修改，如果手工修改，就会算不出原密码，导致密码失效。当然，我们也可以在密码前人为地加入“1”或“*”改变加密值让密码暂时失效，使这个用户无法登录，达到暂时禁止用户登录的效果。</p>
<div><p>注意</p>
<p>所有伪用户的密码都是“<strong>!!</strong>”或“<strong>*</strong>”，代表这些用户都没有密码，是不能登录的。当然，新创建的用户如果不设定密码，那么它的密码项也是“!!”，代表这个用户没有密码，不能登录。</p>
</div>
<ol start="3">
<li><strong>密码最后一次修改日期</strong></li>
</ol>
<p>第三个字段是密码的修改日期，可是这里怎么是 18768 啊？代表什么意思呢？其实 Linux 更加习惯使用时间戳代表时间，也就是说，以 <u><strong>1970 年 1 月 1 日</strong></u> 作为标准时间，每过去一天，时间戳加 1，那么 366 代表的就是 1971 年1 月 1 日。我们这里的时间戳是 18768，也就是说，是在 1970 年1 月 1 日之后的第 15775 天修改的 root 用户密码。好隐晦的表示啊！那么，到底 18768 的时间戳代表的是哪一天呢？我们可以使用如下命令进行换算：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># date -d "1970-01-01 18768 days"</span>
<span>2013</span>年 05月 <span>21</span>日 星期五 00:00:00 EDT
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>用以上命令可以把时间戳换算为我们习惯的系统日期，那么我们可以把系统日期换算为时间戳吗？当然可以，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># echo $(($(date --date="2013/05/20" +%s)/86400+1))</span>
<span>18768</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这里的 2013/05/20 是你要计算的日期，+%s 是把当前日期换算成自 <u>1970 年 1 月 1</u> 日以来的总秒数，除以 86400（每天的秒数），最后加上 1 补齐 <u>1970 年 1 月 1 日</u> 当天就能计算出时间戳了。其实不需要理解这里的命令，只要知道时间戳的概念就好，如果需要换算就套用命令。</p>
<ol start="4">
<li><strong>密码的两次修改间隔时间</strong></li>
</ol>
<p>第四个字段是密码的两次修改间隔时间。这个字段要<u><em>和第三个字段相比</em></u>，也就是说密码被修改后多久不能再修改密码。如果是 0，则密码可以随时修改。如果是 10，则代表密码修改后10 天之内不能再次修改这个密码。</p>
<ol start="5">
<li><strong>密码的有效期</strong></li>
</ol>
<p>第五个字段是密码的有效期。这个字段也要</u><em>和第三个字段相比</em></u>，也就是说密码被修改后可以生效多少天。默认值是 99999，也就是 273 年，大家可以认为永久生效。如果改为 90，那么密码被修改 90 天之后就必须再次修改，否则该用户就不能登录了。我们在管理服务器的时候可以通过这个字段强制用户定期修改密码。</p>
<ol start="6">
<li><strong>密码修改到期前的警告天数</strong></li>
</ol>
<p>第六个字段是密码修改到期前的警告天数。这个字段要<u><em>和第五个字段相比</em></u>，就是密码到期前需提前几天修改。默认值是 7，也就是说从密码到期前的7 天开始，每次登录系统都会警告该用户修改密码。</p>
<ol start="7">
<li><strong>密码过期后的宽限天数</strong></li>
</ol>
<p>第七个字段是密码过期后的宽限天数。这个字段要<u><em>和第五个字段相比</em></u>，也就是密码过期后，用户如果还是没有修改密码，那么在宽限天数内用户还是可以登录系统的；如果过了宽限天数，那么用户就无法再使用该器码登录了。天数如果是 10，则代表密码过期 10 天后失效；如果是 0，则代表密码过期后立叫失效；如果是 -1，则代表密码永远不会失效。</p>
<ol start="8">
<li><strong>账号失效时间</strong></li>
</ol>
<p>第八个字段是用户的账号失效时间。这里同样要写时间戳，也就是用 <u>1970 年1 月 1日</u> 进行时间换算。如果超过了失效时间，就算密码没有过期，用户也就失效，无法使用了。</p>
<ol start="9">
<li><strong>保留</strong></li>
</ol>
<p>这个字段目前没有使用。</p>
<div><p>小提示</p>
<p>在 Linux 中，如果遗忘了密码，则可以启动进入单用户模式。这时既可以删除 <code>/etc/passwd</code> 文件中的密码标识字段，也可以删除 <code>/etc/shadow</code> 文件中的密码标识字段，都可以达到清空密码的目的。</p>
</div>
<h3 id="组信息文件-etc-group"> 组信息文件 <code>/etc/group</code></h3>
<p>这个文件是记录 组ID（GID）和组名的对应文件。<code>/etc/passwd</code> 文件的第四个字段记录的是每个用户的 初始组ID，那么这个 GID 的组名到底是什么呢？就要从 <code>/etc/group</code> 文件中查找。这个文件的内容如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vi /etc/group</span>
root:x:0:
bin:x:1:bin,daemon
daemon:x:2:bin,daemon
<span>..</span>.省略部分输出<span>..</span>.
lamp:x:502:
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>我们手工添加的用户 lamp 也会默认生成一个 lamp 用户组，GID 是 502，作为 lamp 用户的初始组。这个文件和上面两个文件一样，用“<strong>:</strong>”作为分隔符，划分为 4 个字段。我们同样以 root 行作为例子讲解，每个字段的具体含义如下：</p>
<ol>
<li><strong>组名</strong></li>
</ol>
<p>第一个字段是组名字段，也就是用户组的名称字段。</p>
<ol start="2">
<li><strong>组密码标志</strong></li>
</ol>
<p>第二个字段是组密码标志字段。和 <code>/etc/passwd</code> 文件一样，这里的“x”仅仅是密码标识，真正的加密之后的组密码保存在 <code>/etc/gshadow</code> 文件中。不过，用户设置密码是为了验证用户的身份，但是用户组设置密码是用来做什么的呢？用户组密码主要是用来指定组管理员的，由于系统中的账号可能会非常多，root 用户可能没有时间进行用户的组调整，这时可以给用户组指定组管理员，如果有用户需要加入或退出某用户组，则可以由该组的组管理员替代 root 进行管理。但是这项功能目前很少使用，我们也很少设置组密码。如果需要赋予某用户调整某个用户组的权限，则可以使用 <code>sudo</code> 命令代替。</p>
<ol start="3">
<li><strong>组ID（GID）</strong></li>
</ol>
<p>第三个字段是用户组 ID，和 UID 一样，Linux 系统是通过 GID 来区别不同的用户组的，组名只是为了便于管理员识别。所以，在 <code>/etc/group</code> 文件中可以查看对应的组名和 GID。</p>
<ol start="4">
<li>
<p><strong>组中的用户</strong></p>
<p>第四个字段表示的就是这个用户组中到底包含了哪些用户。需要注意的是，如果该用户组是这个用户的初始组，则该用户不会写入这个字段。也就是说，写入这个字段的用户是这个用户组的附加用户。比如 lamp 组就是这样写的<code>lamp:x:502:</code>，并没有在第四个字段中写入 lamp 用户，因为 lamp 组是 lamp 用户的初始组。如果要查询这些用户的初始组，则需要先到 <code>/etc/passwd</code> 文件中查看 GID（第四个字段)，然后到 <code>/etc/group</code> 文件中比对组名。</p>
</li>
</ol>
<p>每个用户都可以加入多个附加组，但是只能属于一个初始组。所以我们在实际工作中，如果需要把用户加入其他组，则需要添加附加组。一般情况下，用户的初始组就是在建立用户的同时建立的和用户名相同的组。</p>
<div><p>注意</p>
<p>我们讲了三个用户配置文件 <code>/etc/passwd</code>、<code>/etc/shadow</code>、<code>/etc/group</code>，它们之间的关系是这样的——先在 <code>/etc/group</code> 文件中查询用户组的 GID 和组名；然后在 <code>/etc/passwd</code> 文件中查找该 GID 是哪个用户的初始组，同时提取这个用户的用户名和 UID；最后通过 UID 到 <code>/etc/shadow</code> 文件中提取和这个用户相匹配的密码。</p>
</div>
<h3 id="组密码文件-etc-gshadow"> 组密码文件 <code>/etc/gshadow</code></h3>
<p>这个文件就是保存组密码的文件。如果我们给用户组设定了组管理员，并给该用户组设定了组密码，那么组密码就保存在这个文件中，组管理员就可以利用这个密码管理这个用户组了，该文件的内容如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vi /etc/gshadow</span>
root:::
bin:::bin,daemon
daemon:::bin,daemon
<span>..</span>.省略部分输出<span>..</span>.
lamp:<span>!</span>::
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>这个文件同样使用“<strong>:</strong>”作为分隔符，把文件划分为 4 个字段，每个字段的含义如下。</p>
<ol>
<li><strong>组名</strong></li>
</ol>
<p>第一个字段是这个用户的组名。</p>
<ol start="2">
<li><strong>组密码</strong></li>
</ol>
<p>第二个字段就是实际加密的组密码。大家已经注意到，对于大多数用户来说，这个字段不是空就是“!”，代表这个组没有合法的组密码。</p>
<ol start="3">
<li><strong>组管理员用户名</strong></li>
</ol>
<p>第三个字段表示这个组的管理员是哪个用户。</p>
<ol start="4">
<li><strong>组中的附加用户</strong></li>
</ol>
<p>第四个字段用于显示这个用户组中有哪些附加用户。</p>
<h3 id="用户管理相关文件"> 用户管理相关文件</h3>
<p>上面介绍的 4 个文件是用户的配置文件，每个用户的信息、权限和密码都保存在这 4 个文件中。下面要介绍的几个文件虽然不是用户的配置文件，但也是在创建用户时所自动建立或者和用户创建相关的文件。</p>
<ol>
<li><strong>用户的家目录</strong></li>
</ol>
<p>每个用户在登录 Linux 系统时，必须有一个默认的登录位置，该用户对这个目录应该拥有一定的权限，我们把这个目录称作用户的家目录。普通用户的家目录位于 <code>/home/</code> 下，目录名和用户名相同。例如，lamp 用户的家目录就是 <code>/home/lamp/</code>，这个目录的权限如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ll -d /home/lamp/</span>
drwx------ <span>3</span> lamp 1amp <span>4096</span> <span>1</span>月 <span>4</span> 05:40 /home/lamp/
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>目录的属主是 lamp 用户，属组是 lamp 用户组，权限是 700，lamp 用户对 <code>/home/lampl</code> 家目录拥有读、写和执行权限。</p>
<p>超级用户的家目录位于 <code>/</code> 下。例如，超级用户的家目录就是 <code>/root/</code>，这个目录的权限如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ll -d /root/</span>
dr-xr-x--- <span>6</span> root root <span>4096</span> <span>12</span>月 <span>29</span> 00:17 /root/
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>在 Linux 中，家目录用“<strong>~</strong>”表示，当前命令的提示符是“<strong>[root@localhost ~]#</strong>”，表示当前所在目录就是家目录。而我当前是超级用户，所以我的家目录就是 <code>/root/</code>。</p>
<ol start="2">
<li><strong>用户邮箱目录</strong></li>
</ol>
<p>在建立每个用户的时候,系统会默认给每个用户建立一个邮箱。这个邮箱在 <code>/var/spool/mail</code> 目录中，如 lamp 用户的邮箱就是 <code>/var/spool/mail/lamp</code>。</p>
<ol start="3">
<li><strong>用户模板目录</strong></li>
</ol>
<p>刚刚我们说了每个用户都有一个家目录，比如 lamp 用户的家目录就是 <code>/home/lamp/</code>，我们进入这个目录，看看里面有什么内容。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cd /home/lamp/</span>
<span>[</span>root@localhost lamp<span>]</span><span># ls</span>
<span>[</span>root@localhost lamp<span>]</span><span>#</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这个用户因为是新建立的，所以家目录中没有保存任何文件，是空的。但真的是空的吗？有没有隐藏文件呢？我们再来看看。</p>
<div><pre><code><span>[</span>root@localhost lamp<span>]</span><span># ls -a</span>
<span>.</span>	<span>..</span>	.bash_Logout	.bash_profile	.bashrc		.gnome2
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>原来这个目录中还是有文件的，只不过这些文件都是隐藏文件。那么这些文件都是做什么的？是从哪里来的呢？这些文件都是当前用户 lamp 的环境变量配置文件，这里保存的都是该用户的环境变量参数。那么，什么是环境变量配置文件呢？我们这么说吧，在 Windows 中虽然只有一台计算机，但是如果使用不同的用户登录，那么每个用户的操作环境（如桌面背景、分辨率、桌面图标）都是不同的。因为每个用户的操作习惯不同，所以 Windows 运行用户自行定义的操作环境。在 Linux 中可以吗？当然可以，只不过 Windows 是通过更直观的图形界面来进行设置和调整的，而 Linux 是通过文件来进行调整的。我们将这些根据用户习惯调整操作系统环境的配置文件称作环境变量配置文件。<code>/home/lamp/</code> 目录中的这些环境变量配置文件所定义的操作环境只对 lamp 用户生效，其他每个用户的家目录中都有相应的环境变量配置文件。</p>
<p>那么，这些环境变量配置文件都是从哪里来的呢？其实有一个模板目录，这个模板目录就是 <code>/etc/skel/</code> 目录，每创建一个用户，系统会自动创建一个用户家目录，同时把模板目录 <code>/etc/skel/</code> 中的内容复制到用户家目录中。我们看看 <code>/etc/skel/</code> 目录中有一些什么内容。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cd /etc/skel/</span>
<span>[</span>root@localhost skel<span>]</span><span># ls -a</span>
<span>.</span>	<span>..</span>	.bash_logout	.bash_profile	.bashrc		gnome2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>是不是和 <code>/home/lamp/</code> 目录中的内容一致呢？我们做一个实验，在 <code>/etc/skel/</code> 目录中随意创建一个文件，我们看看新建立的用户的家目录中是否也会把这个文件复制过来。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cd /etc/skel/</span>
<span>#进入模板目录</span>
<span>[</span>root@localhost skel<span>]</span><span># touch test</span>
创建一个临时文件 <span>test</span>
<span>[</span>root@localhost skel<span>]</span><span># ls -a</span>
<span>.</span>	<span>..</span>	.bash_logout	.bash_profile	.bashrc		gnome2		<span>test</span>
<span>#查看文件，除环境变量配置文件之外，多了一个 test 文件</span>
<span>[</span>root@localhost skel<span>]</span><span># useradd userl</span>
<span>#添加用 userl</span>
<span>[</span>root@localhost skel<span>]</span> <span>cd</span> /home/user1
<span>#进入 user1 的家目录</span>
<span>[</span>root@localhost userl<span>]</span><span># ls -a</span>
<span>.</span>	<span>..</span>	.bash_logout	.bash_profile	.bashrc		gnome2		<span>test</span>
<span>#看到了吗？系统自动建立的家目录中是不是也多出了 test 文件</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>这样大家就明白模板目录的作用了吧。如果需要让每个用户的家目录中都有某个目录或文件，就可以修改模板目录。</p>
<div><p>总结</p>
<p>Linux 系统中和用户相关的文件主要有 7 个。其中 4 个是用户配置文件，分别是 <code>/etc/passwd</code>、<code>/etc/shadow</code>、<code>/etc/group</code>、<code>/etc/gshadow</code>。这几个文件主要定义了用户的相关参数，我们可以通过手工修改这几个文件来建立或修改用户的相关信息，当然也可以通过命令修改。还有 3 个文件是用户管理相关文件，分别是用户的<strong>家目录</strong>、<strong>用户邮箱目录</strong>、<strong>用户模板目录</strong>，这些目录在建立用户的时候都会起到相应的作用，一般不需要修改。</p>
</div>
<h2 id="用户管理命令"> 用户管理命令</h2>
<p>前面我们讲了用户相关文件，如果要添加或删除用户，则通过手工修改配置文件的方法也是可以的。但是这样做太麻烦了，Linux 系统为我们准备了完善的用户管理命令，我们现在就来学习一下这些命令吧。</p>
<h3 id="添加用户-useradd"> 添加用户：useradd</h3>
<ol>
<li><strong>命令格式</strong></li>
</ol>
<p>添加用户的命令是 <code>useradd</code>，命令格式如下：</p>
<div><pre><code><span>useradd</span> <span>[</span>选项<span>]</span> 用户名
选项：
	-u <span>UID</span>		：手工指定用户的 <span>UID</span>，注意手工添加的用户的 <span>UID</span> 不要小于 <span>500</span>
	-d 家目录	：手工指定用户的家目录。家目录必须写绝对路径，而且如果需要手工指定家目录，则一定要注意权限
	-c 用户说明	：手工指定用户说明。还记得 /etc/passwd 文件的第五个字段吗？这里就是指定该字段内容的
	-g 组名		：手工指定用户的初始组。一般以和用户名相同的组作为用户的初始组，在创建用户时会默认建立初始组。如果不想使用默认初始组，则可以用 -g 手工指定。不建议手工修改
	-G 组名		：指定用户的附加组。我们把用户加入其他组，一般都使用附加组
	-s shell	：手工指定用户的登录 Shell。默认是/bin/bash
	-e 日期		：指定用户的失效日期，格式为“YYYY-MM-DD”。也就是/etc/shadow 文件的第八个字段
	-o			：允许创建的用户的 <span>UID</span> 相同。例如，执行“inoraad -u <span>0</span> -o usertest”命令建立用户 usertest。它的 <span>UID</span> 和 root 用户的 <span>UID</span> 相同，都是 <span>0</span>
	-m			：建立用户时强制建立用户的家目录。在建立系统用户时，该选项是默认的
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ol start="2">
<li><strong>添加默认用户</strong></li>
</ol>
<p>如果我们只是创建用户，则可以不使用任何选项，系统会按照默认值帮我们指定这些选项。只需要最简单的命令就可以了。命令如下：</p>
<div><pre><code><span># 例子1：添加默认用戶</span>
<span>[</span>root@localhost ~<span>]</span><span># useradd lamp</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>那么，这条命令到底做了什么呢？我们依次来看看。</p>
<p>1）在 <code>/etc/passwd</code> 文件中按照文件格式添加 lamp 用户的行。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># grep "lamp" /ete/passwd</span>
lamp:x:500:500::/home/lamp:/bin/bash
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><p>注意</p>
<p>用户的 UID 是从 500 开始计算的。同时默认指定了用户的家目录为 <code>/home/lamp/</code>，用户的登录 Shell 为 <code>/bin/bash</code>。</p>
</div>
<p>2）在 <code>/etc/shadow</code> 文件中建立用户 lamp 的相关行。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># grep "lamp" /etc/shadow</span>
lamp:<span>!</span><span>!</span>:15710:0:99999:7:::
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>当然，这个用户还没有设置密码，所以密码字段是“<strong>!!</strong>”，代表这个用户没有合理密码，不能正常登录。同时会按照默认值设定时间字段。</p>
<p>3）在 <code>/etc/group</code> 文件中建立和用户 lamp 相关的行。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span> <span>grep</span> <span>"lamp"</span> /etc/group
lamp:x:500:
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>因为 lamp 组是 lamp 用户的初始组，所以 lamp 用户名不会写入第四个字段。</p>
<p>4）在 <code>/etc/gshadow</code> 文件中建立和用户 lamp 相关的行。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># grep "lamp" /etc/gshadow</span>
lamp:<span>!</span>::
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>当然，我们没有设定组密码，所以这里没有密码，也没有组管理员。</p>
<p>5）默认建立用户的家目录和邮箱。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ll -d /home/lamp/</span>
drwx------ <span>3</span> lamp Lamp <span>4096</span> <span>1</span>月 <span>6</span> 00:19 /home/lamp/
<span>[</span>root@localhost ~<span>]</span><span># ll /var/spool/mail/lamp</span>
-rw-rw---- <span>1</span> lamp mail <span>0</span> <span>1</span>月 <span>6</span> 00:19 /var/spool/mail/lamp
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>注意这两个文件的权限，都要让 lamp 用户拥有相应的权限。</p>
<p>大家看到了吗？<code>useradd</code> 命令在添加用户的时候，其实就是修改了我们在前面介绍的 7个文件或目录，那么我们可以通过手工修改这些文件来添加或删除用户吗？当然可以了，我们在后面会演示如何通过手工修改文件来删除用户。那什么时候需要手工建立用户？什么时候需要用命令建立用户？其实在任何情况下都不需要手工修改文件来建立用户，我们用命令来建立用户既简便又快捷。我们在这里只是为了说明 Linux 中的所有内容都是保存在文件中的。</p>
<ol start="3">
<li><strong>手工指定选项添加用户</strong></li>
</ol>
<p>刚刚我们在添加用户的时候全部采用的是默认值，那么我们使用选项来添加用户会有什么样的效果？</p>
<div><pre><code><span># 例子2：手工指定选项添加用户</span>
<span>[</span>root@localhost ~<span>]</span><span># groupadd lamp1</span>
<span>#先手工添加 lamp1 用户组，因为我一会儿要把 lamp1 用户的初始组指定过来，如果不事先建立，则会报告用户组不存在</span>
<span>[</span>root@localhost ~<span>]</span><span># useradd -u 550 -g lamp1 -G root -d /home/lamp1 -c "test user" -s /bin/bash lamp1</span>
<span>#在建立用户 lamp1 的同时指定了 UID（550）、初始组（lamp1）、附加组（root）、家目录（/home/lamp1/）、用户说明（test user）和用户登录Shell（/bin/bash）</span>
<span>[</span>root@localhost ~<span>]</span><span># grep "lamp1" /etc/passwd /etc/shadow /etc/group</span>
<span>#同时查看三个文件</span>
/etc/passwd:lamp1:x:550:502:test user:/home/lamp1:/bin/bash
<span>#用户的 UID、初始组、用户说明、家目景和登录 She11 都和命令手工指定的一致</span>
/etc/shadow:lamp1:<span>!</span><span>!</span>:15710:0:99999:7:::
<span>#lamp1 用户还没有设定密码</span>
/etc/group:root:x:0:lamp1
<span>#lamp1 用户加入了 root 组，root 组是 lamp1 用户的附加组</span>
/etc/group:lamp1:x:502:
<span>#GID 为 502 的组是 lamp1 组</span>
（Vetc/group:1amp1:x:502:4
<span>[</span>root@localhost ~<span>]</span><span># ll -d /home/lamp1/</span>
drwx------ <span>3</span> lamp1 lamp1 <span>4096</span> <span>1</span>月 <span>6</span> 01:13 /home/lamp1/
<span>#家目录也建立了，不需要手工建立</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>例子有点复杂，其实如果可以看懂还是很简单的，就是添加了用户，但是不再使用用户的默认值，而是手工指定了用户的 UID （是 550，而不再是 501)、初始组、附加组、家目录、用户说明和用户登录 Shell。这里还要注意一点，虽然手工指定了用户的家目录，但是家目录不需要手工建立，在添加用户的同时会自动建立家目录。如果手工建立了家目录，那么一定要修改目录的权限和从 <code>/etc/skel/</code> 模板目录中复制环境变量文件，反而更加麻烦。</p>
<ol start="4">
<li><strong>useradd 命令的默认值设定</strong></li>
</ol>
<p>大家发现了吗？在添加用户时，其实不需要手工指定任何内容，都可以使用 <code>useradd</code> 命令默认创建，这些默认值已经可以满足我们的要求。但是 <code>useradd</code> 命令的这些默认值是保存在哪里的呢？能否手工修改呢？</p>
<p><code>useradd</code> 命令在添加用户时参考的默认值文件主要有两个，分别是 <code>/etc/default/useradd</code> 和 <code>/etc/login.defs</code>。我们先看看 <code>/etc/default//useradd</code> 文件的内容。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vi /etc/default/useradd</span>
<span># useradd defaults file</span>
<span>GROUP</span><span>=</span><span>100</span>
<span><span>HOME</span></span><span>=</span>/home
<span>INACTIVE</span><span>=</span>-1
<span>EXPIRE</span><span>=</span>
<span><span>SHELL</span></span><span>=</span>/bin/bash
<span>SKEL</span><span>=</span>/etc/skel
<span>CREATE_MAIL_SPOOL</span><span>=</span>yes
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><code>/etc/default//useradd</code> 的默认值解释如表13-1：</p>
<p><strong>表13-1	<u>useradd 命令的默认值</u></strong></p>
<table>
<thead>
<tr>
<th>默认值</th>
<th>解释说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>GROUP=100</td>
<td>用于建立用户的默认组。<br />在添加每个用户时，用户的初始组就是 GID 为 100 的这个用户组</td>
</tr>
<tr>
<td>HOME=/home</td>
<td>用户的家目录的默认位置。<br />所有新建用户的家目录默认都在 <code>/home/</code> 下</td>
</tr>
<tr>
<td>INACTIVE=-1</td>
<td>密码过期后的宽限天数。也就是 <code>/etc/shadow</code> 文件的第七个字段，<br />-1：代表所有新建立的用户密码永远不会失效</td>
</tr>
<tr>
<td>EXPIRE=</td>
<td>密码失效时间。也就是/etc/shadow 文件的第八个字段，<br />默认值是空，代表所有新建用户没有失效时间，永久有效</td>
</tr>
<tr>
<td>SHELL=/bin/bash</td>
<td>用户的默认 Shell。<code>/bin/bash</code> 是 Linux 的标准 Shell，<br />代表所有新建立的用户默认 Shell 都是 <code>/bin/bash</code></td>
</tr>
<tr>
<td>SKEL=/etc/skel</td>
<td>定义用户的模板目录的位置。<br /><code>/etc/skel/</code> 目录中的文件都会复制到新建用户的家目录中</td>
</tr>
<tr>
<td>CREATE_MAIL_SPOOL=yes</td>
<td>是否给新建用户建立邮箱。默认是创建，<br />新建用户，系统会新建一个和用户名相同邮箱，在 <code>/var/spool/mail/</code> 目录下</td>
</tr>
</tbody>
</table>
<p>当然，这个文件也可以直接通过命令进行查看，结果是一样的（和 <code>/etc/default/useradd</code> 内容一样）。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># useradd -D</span>
选项：
	-D	：查看新建用户的默认值
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>通过 <code>/etc/default/useradd</code> 文件大家已经能够看到我们新建用户的部分默认值，但是还有一些内容并没有在这个文件中出现，比如用户的 UID 为什么默认从 500 开始计算，<code>/etc/shadow</code> 文件中除第一、二、三个字段不用设定默认值外，还有第四、五、六个字段没有指定默认值（第七、八个字段的默认值在 <code>/etc/default/useradd</code> 文件中指定了）。那么，这些默认值就需要第二个默认值文件 <code>/etc/login.defs</code> 了，这个文件的内容如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vi /etc/login.defs</span>
<span>#这个文件有一些注释，把注释删除，文件内容就变成下面这个样子了</span>
MAIL_DIR	/var/spool/mail

PASS_MAX_DAYS	<span>99999</span>
PASS_MIN_DAYS	<span>0</span>
PASS_MIN_LEN	<span>5</span>
PASS_WARN_AGE	<span>7</span>

UID_MIN			<span>500</span>
UID_MAX			<span>60000</span>

GID_MIN			<span>500</span>
GID_MAX			<span>60000</span>

CREATE_HOME		<span>yes</span>

UMASK			077

USERGROUPS_ENAB <span>yes</span>

ENCRYPT_METHOD	SHA512
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p><code>/etc/login.defs</code> 的默认值解释如下表：</p>
<p><strong>表13-2	<u>/etc/login.defs 的默认值</u></strong></p>
<table>
<thead>
<tr>
<th>默认值</th>
<th>解释说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>MAIL_DIR</td>
<td>指定了新建用户的默认邮箱位置。默认在<code>/var/spool/mail/</code>目录下</td>
</tr>
<tr>
<td>PASS_MAX_DAYS</td>
<td>指定的是密码的有效期。也就是 <code>/etc/shadow</code> 文件的第五个字段，<br />代表多少天之后必须修改密码</td>
</tr>
<tr>
<td>PASS_MIN_DAYS</td>
<td>指定的是密码的两次修改间隔时间。也就是 <code>/etc/shadow</code> 文件的第四个字段，<br />代表上次修改密码后，几天后才能再次修改密码</td>
</tr>
<tr>
<td>PASS_MIN_LEN</td>
<td>密码的最小长度。默认不小于 5 位。<br />但是现在用户登录时验证已经被 PAM 模块取代，所以这个选项并不生效</td>
</tr>
<tr>
<td>PASS_WARN_AGE</td>
<td>密码修改到期前的警告天数。也就是 <code>/etc/shadow</code> 文件的第六个字段。<br />代表密码到达有效期前多少天开始进行警告提醒</td>
</tr>
<tr>
<td>UID_MIN<br />UID_MAX</td>
<td>指定了创建用户时最小 UID 和最大 UID 的范围</td>
</tr>
<tr>
<td>GID_MIN<br />GID_MAX</td>
<td>指定了 GID 的最小值和最大值的范围</td>
</tr>
<tr>
<td>CREATE_HOME</td>
<td>指定建立用户时是否自动建立用户的家目录，默认是建立</td>
</tr>
<tr>
<td>UMASK</td>
<td>指定建立的用户家目录的默认权限，<br />因为 umask 值是 077，所以新建的用户家目录的权限是 700</td>
</tr>
<tr>
<td>USERGROUPS_ENAB</td>
<td>指定使用命令 <code>userdel</code> 删除用户时，是否删除用户的初始组，默认是删除</td>
</tr>
<tr>
<td>ENCRYPT_METHOD</td>
<td>指定 Linux 用户的密码使用 SHA512 散列模式加密。</td>
</tr>
</tbody>
</table>
<p>我们现在已经知道了，系统在默认添加用户时，是靠 <code>/etc/default/useradd</code>  和 <code>/etc/login.defs</code> 文件定义用户的默认值的。如果我们想要修改所有新建用户的某个默认值，就可以直接修改这两个文件，而不用每个用户单独修改了。</p>
<h3 id="修改用户密码-passwd"> 修改用户密码：passwd</h3>
<ol>
<li><strong>命令格式</strong></li>
</ol>
<p>我们在上一小节中介绍了添加用户的命令，但是新添加的用户如果不设定密码是不能够登录系统的，那么我们来学习一下密码设置命令 <code>passwd</code>。</p>
<div><pre><code>paaswd <span>[</span>选項<span>]</span> 用户名
选项：
	-S		：查询用户密码的状态，也就是 /etc/shadow 文件中的内容。仅 root 用户可用
	-l		：暂时锁定用户。仅 root 用户可用
	-u		：解锁用户。仅 root 用户可用
	--stdin	：可以将通过管道符输出的数据作为用户的密码。主要在批量添加用户时使用
	
<span>[</span>rootelocalhost ~<span>]</span><span># passwd</span>
<span>#passwd 直接回车代表修改当前用戶的密码</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ol start="2">
<li><strong>root 用户修改密码</strong></li>
</ol>
<p>下面举几个例子，我们给新用户 lamp 设定密码，让 lamp 用户可以登录系统。</p>
<div><pre><code><span># 例子1：</span>
<span>[</span>root@localhost ~<span>]</span><span># pasawd lamp</span>
更改用户 1amp 的密码。
新的 密码：											<span>&lt;</span>---输入新的密码
无效的密码： 密码少于 <span>8</span> 个字符						<span>&lt;</span>---有报错提示
无效的密码： 密码未通过字典检查 - 它基于字典单词			
重新输入新的 密码：									<span>&lt;</span>---第二次输入宿码
passwd：所有的身份验证令牌已经成功更新。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>注意，要想给其他用户设定密码，只有两种用户可行：一种是 root 用户：另一种是 root 通过 sudo 命令赋予权限的普通用户。也就是说，普通用户只能修改自己的密码，而不能设定其他用户的密码。</p>
<p>还要注意一件事，设定用户密码时一定要遵守“<strong>复杂性、易记性、时效性</strong>”的密码规范。<u>简单来讲就是密码要大于 8 位，包含大写字母、小写字母、数字和特殊符号中的 3 种，并且容易记忆和定期更换</u>。但是 root 用户在设定密码时却可以不遵守这些规则，比如我刚刚给 lamp 用户设定的密码是“123”，系统虽然会提示密码过短和过于简单，但是依然可以设置成功。不过普通用户在修改自己的密码时，一定要遵守密码规范。当然，在生产服务器上，就算是 root身份，在设定密码时也要严格遵守密码规范，因为只有好的密码规范才是服务器安全的基础。</p>
<ol start="3">
<li><strong>普通用户修改密码</strong></li>
</ol>
<p>那么我们看看普通用户 lamp 是如何修改密码的。</p>
<div><pre><code><span># 例子 2：</span>
<span>[</span>lamp@localhost ~<span>]</span><span># whoami</span>
lamp
<span>#先看看我的身份</span>
<span>[</span>lamp@localhost ~<span>]</span>$ <span>passwd</span> lamp1
passwd： 只有根用户才能指定用户名称
<span>#尝试修改 lamp1 用户的密码，系统提示普通用户不能修改其他用户的密码</span>
<span>[</span>lamp@localhost ~<span>]</span>$ <span>passwd</span> lamp
passwd： 只有根用户才能指定用户名称。
<span>#怎么修改自己的密码也报错呢？这里其实说得很情楚，要想指定用户名修改密码，只有管理员可以，哪怕是修改自己的密码。那么修改自己的密码就只能像下面这样了</span>
<span>[</span>lamp@localhost ~<span>]</span>$ <span>passwd</span>
<span>#使用 passwd 直接回车，就是修改自己的密码</span>
更改用户 lamp 的密码。
为 lamp 更改 STRESS 密码。
（当前）UNTX 密码：									<span>&lt;</span>---注意，普通用户需要先输入自己的密码
新的密码：
无效的密码：密码未通过字典检查 - 它基于字典单词		<span>&lt;</span>---好吧，又报错了，因为我输入的密码在字典中能够找到
新的密码：											<span>&lt;</span>---密码必須符合密码规范重新输入新的密码：
passwd：所有的身份验证令牌已经成功更新。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>大家发现了吗？对普通用户来讲，密码设定就要严格得多了。首先，只能使用 <code>passwd</code> 来修改自己的密码，而不能使用 <code>passwd 用户名</code> 的方式。不过，如果你是 root 用户，则建议用 <code>passwd 用户名</code> 的方式来修改密码，因为这样不容易搞混。其次，在修改密码之前，需要先输入旧密码。最后，设定密码一定要严格遵守密码规范。</p>
<ol start="4">
<li><strong>查看用户密码状态</strong></li>
</ol>
<div><pre><code><span># 例子 3：</span>
<span>[</span>root@localhost ~<span>]</span><span># passwd -S lamp</span>
lamp PS <span>2013</span>-01-06 <span>0</span> <span>99999</span> <span>7</span> -1 （密码已设置，使用 SHA512 加密。<span>)</span>
<span>#上面这行代码的意思是：</span>
<span>#用户名密码设定时间（2013-01-06）	密码修改间隔时间（0）	密码有效期（99999）	警告时间（7）	密码不失效（-1）</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>“-S”选项会显示出密码状态，这里的密码修改间隔时间、密码有效期、警告时间、密码宽限时间，其实分别是 <code>/etc/shadow</code> 文件的第四、五、六、七个字段的内容。当然，<code>passwd</code> 命令是可以通过命令选项修改这几个字段的值的，不过我个人认为还是直接修改 <code>/etc/shadow</code> 文件简单一些。再次提醒一下，CentOS 6.3 的加密方式已经从 MD5 加密更新到 SHA512 加密，我们不用了解具体的加密算法，只要知道这种加密算法更加可靠和先进就足够了。</p>
<ol start="5">
<li><strong>锁定和解锁用户使用</strong></li>
</ol>
<p>使用 <code>passwd</code> 命令可以很方便地锁定和解索某个用户，我们来试试。</p>
<div><pre><code><span># 例子 4：</span>
<span>[</span>root@localhost ~<span>]</span><span># passwd -l lamp</span>
锁定用户 lamp 的密码。
passwd：操作成功
<span>#锁定用户</span>
<span>[</span>root@localhost ~<span>]</span><span># passwd -S lamp</span>
lamp PS <span>2013</span>-01-06 <span>0</span> <span>99999</span> <span>7</span> -1（密码已被锁定）
<span>#用“-S”选项查看状态，很清楚地提示密码已被锁定</span>
<span>[</span>root@localhost ~<span>]</span><span># grep "lamp" /etc/shadow</span>
lamp:<span>!</span><span>!</span><span>$6</span><span>$ZTq7o</span>/96<span>$1jO7120bzW</span>.D1zBa9CsY43d04onskUczjwiFMNt8px4GxJoHx9zA1SC9.iYzh9LZAAfEM21g92hM9w/p6NS50.:15711:0:99999:7:::
<span>#其实锁定就是在加密密码之前加入了“!!”，让密码失效而已</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>[</span>root@localhost ~<span>]</span><span># passwd -u lamp</span>
解锁用户 lamp 的密码。
passwd：操作成功
<span>#解信用户</span>
<span>[</span>root@localhost ~<span>]</span><span># passwd -S lamp</span>
lamp PS <span>2013</span>-01-06 <span>0</span> <span>99999</span> <span>7</span> -1（密码已设置，使用 SHA512 加密。）
<span>#锁定状态消失</span>
<span>[</span>root@localhost ~<span>]</span><span># grep "lamp" /etc/shadow</span>
lamp:<span>$6</span><span>$ZTq7o</span>/96<span>$1jO7120bzW</span>.D1zBa9CsY43d04onskUczjwiFMNt8px4GxJoHx9zA1SC9.iYzh9LZAAfEM21g92hM9w/p6NS50.:15711:0:99999:7:::
<span>#密码前面的“!!”删除了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ol start="6">
<li><strong>使用字符串作为用户的密码</strong></li>
</ol>
<p>这种做法主要是在批量添加用户时，给所有的用户设定一个初始密码。但是需要注意的是，这样设定的密码会把密码明文保存在历史命令中，会有安全隐患。所以，如果使用了这种方式修改密码，那么应该记住两件事情：第一，手工清除历史命令；第二，强制这些新添加的用户在第一次登录时必须修改密码（具体方法参考 <code>chage</code> 命令）。</p>
<div><pre><code><span># 例子 5：</span>
<span>[</span>root@localhost ~<span>]</span><span># echo "123" | passwd --stdin lamp</span>
更改用户 lamp 的密码。
passwd：所有的身份验证令牌已经成功更新。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>命令很简单，调用管道符，让 <code>echo</code> 的输出作为 <code>passwd</code> 命令的输入，就可以把 lamp 用户的密码设定为“123”了。</p>
<h3 id="修改用户信息-usermod"> 修改用户信息：usermod</h3>
<p>在添加了用户之后，如果不小心添加错了用户的信息，那么是否可以修改呢？当然可以了，我们可以直控使用编辑器修改用户相关文件，也可以使用 <code>usermod</code> 命令进行修改。我们就来学习下 <code>usermod</code>	 命令。该命令的格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># usermod [选项] 用户</span>
选项：
	-u <span>UID</span>		：修改用户的 <span>UID</span>
	-d 家目录	：修改用户的家目录。家目录必须写绝对路径
	-c 用户说明	：修改用户的说明信息，就是 /etc/passwd 文件的第五个字段
	-g 组名		：修改用户的初始组，就是 /etc/passwd 文件的第四个字段
	-G 组名		：修改用户的附加组，其实就是把用户加入其他用户组
	-s shell	：修改用户的登录 Shell。默认是 /bin/bash
	-e 日期		：修改用户的失效日期，格式为“YYYY-MM-DD”。也就是 /etc/shadow 文件的第八个字段
	-L			：临时锁定用户（Lock）
	-U			：解锁用户（Unlock<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>可以看到，<code>usermod</code> 和 <code>useradd</code> 命令的选项非常类似，因为它们都是用于定义用户信息的。不过需要注意的是，<code>useradd</code> 命令用于在添加新用户时指定用户信息，而 <code>usermod</code> 命令用于修改已经存在的用户的用户信息，千万不要搞混。</p>
<p><code>usermod</code> 命令多出了几个选项，其中，-L 可以临时锁定用户，不让这个用户登录。其实锁定的方法就是在 <code>/etc/shadow</code> 文件的密码字段前加入“!”。大家已经知道密码项是加密换算的，所以加入任何字符都会导致密码失效，所以这个用户就会被禁止登录。而解锁（-U）其实就是把密码字段前的“!”取消。举个例子：</p>
<div><pre><code><span># 例子 1：</span>
<span>[</span>root@localhost ~<span>]</span><span># usermod -L lamp</span>
<span>#锁定用户</span>
<span>[</span>root@localhost ~<span>]</span><span># grep "lamp” /etc/shadow</span>
lamp:<span>!</span><span>$6SYrPjBgowschRvAsybEncu24hkYFqxREH3NnzhAVDJSQLwRwTSbcA2N8UbPD9bBKvoskyxIaMGs</span>/Eg5AQwO.UokonKqaHFa/:15711:0:99999:7:::
<span>#查看发现锁定就是在密码宇段前加入“!”，这时 lamp 用户就暂时不能登录了</span>
<span>[</span>root@localhost ~<span>]</span><span># usermod -U lamp</span>
<span>#解锁用户</span>
<span>[</span>root@localhost ~<span>]</span><span># grep "lamp" /etc/shadow</span>
lamp:<span>$6SYrPjBgowschRvAsybEncu24hkYFqxREH3NnzhAVDJSQLwRwTSbcA2N8UbPD9bBKvoskyxIaMGs</span>/Eg5AQwO.UokonKqaHFa/:15711:0:99999:7:::
<span>#取消了密码字段前的“!”</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>再举几个其他的例子：</p>
<div><pre><code><span># 例子 2：</span>
<span>[</span>root@localhost ~<span>]</span><span># usermod -G root lamp</span>
<span>#把 lamp 用户加入 root 组</span>
<span>[</span>root@localhost ~<span>]</span><span># grep "lamp" /etc/group</span>
root:x:0:lamp
lamp:x:501:
<span>#lamp 用户已经加入了 root 组</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><pre><code><span># 例子 3：</span>
<span>[</span>root@localhost ~<span>]</span><span># usermod -c "test user" lamp</span>
<span>#修改用户说明</span>
<span>[</span>root@localhost ~<span>]</span><span># grep "lamp" /etc/passwd</span>
lamp:x:501:501:test user:/home/lamp:/bin/bash
<span>#查看一下，用户说明已经被修改了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="修改用户密码状态-chage"> 修改用户密码状态：chage</h3>
<p>通过 <code>chage</code> 命令可以查看和修改 <code>/etc/shadow</code> 文件的第三个字段到第八个字段的密码状态。我个人建议直接修改 <code>/etc/shadow</code> 文件更加直观和简单，那么为什么还要讲解 <code>chage</code> 命令呢？因为 <code>chage</code> 命令有一种很好的用法，就是强制用户在第一次登录时必须修改密码。<code>chage</code> 命令的格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># chage [选项] 用户名</span>
选项：
	-l		：列出用户的详细密码状态
	-d 日期	：密码最后一次修改日期（ /etc/shadow 文件的第三个字段<span>)</span>。格式为 YYYY-MM-DD
	-m 天数	：密码的两次修改间隔时间（第四个字段）
	-M 天数	：密码的有效期（第五个字段）
	-W 天数	：密码修改到期前的警告天数（第六个字段）
	-I 天数	：密码过期后的宽限天数（第七个字段）
	-E 日期	：账号失效时间（第八个字段<span>)</span>，格式为 YYYY-MM-DD
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>举几个例子，先看看查看状态。</p>
<div><pre><code><span># 例子 1：</span>
<span>[</span>root@localhost ~<span>]</span><span># chage -l lamp</span>
<span>#查看一下用户密码状态</span>
Last password change								<span>:</span> Jan 06, <span>2013</span>
Password expires									<span>:</span> never
Password inactive									<span>:</span> never
Account expires										<span>:</span> never
Minimum number of days between password change		<span>:</span> <span>0</span>
Maximum number of days between password change		<span>:</span> <span>99999</span>
Number of days of warning before password expires	<span>:</span> <span>7</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>我们强制 lamp 用户在第一次登录时必须修改密码。</p>
<div><pre><code><span># 例子 2:</span>
<span>[</span>root@localhost ~<span>]</span><span># chage -d O lamp</span>
<span>#这个命令其实是把密码修改日期归零了，这样用户一登录就要修改密码</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>然后我们以 lamp 用户登录一下系统。</p>
<div><pre><code>localhost login: lamp
Password:
<span>#输入密码登录</span>
You are required to change your password immediately <span>(</span>root enforced<span>)</span>
changing password <span>for</span> lamp.
<span>#有一些提示，就是说明 root 强制你登录后修改密码</span>
<span>(</span>current<span>)</span> UNIX password:
<span>#输入旧密码</span>
New password:
Retype new password:
<span>#输入两次新密码</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>这项功能在进行批量用户管理时还是非常有用的。</p>
<h3 id="删除用户-userdel"> 删除用户：userdel</h3>
<p>这个命令比较简单，就是删除用户。命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span> <span>userdel</span> <span>[</span>-r<span>]</span> 用户名
选项：
	-r	：在删除用户的同时删除用户的家目录

<span># 例如：</span>
<span>[</span>root@localhost ~<span>]</span><span># userdel -r lamp</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>在删除用户的同时如果不删除用户的家目录，那么家目录就会变成没有属主和属组的目录，也就是垃圾文件。</p>
<p>前面我们说过，可以手工修改用户的相关文件来建立用户，但在实际工作中，这样做没有实际的意义，因为用户管理命令可以更简单地完成这项工作。在学习时，手工添加用户是有助于加深我们对用户相关文件的理解的。不过手工添加用户还是比较麻烦的，我们变通一下，手工删除用户，原理是一样的，能够手工删除当然也可以手工建立。</p>
<div><pre><code><span># 例如：</span>
<span>[</span>root@localhost ~<span>]</span><span># useradd lamp</span>
<span>[</span>root@localhost ~<span>]</span><span># passwd lamp</span>
<span>#重新建立 lamp 用户</span>
<span>[</span>root@localhost ~<span>]</span><span># vi /etc/passwd</span>
lamp:x:501:501::/home/lamp:/bin/bash			<span>&lt;</span>---删除此行
<span>#修改用户信息文件，删除 lamp 用户行</span>
<span>[</span>root@localhost ~<span>]</span><span># vi /etc/shadow</span>
lamp:<span>$6</span><span>$KooYtcQJ</span><span>$56Xk9vp3D2vMRBxibNon</span>,21cVJ9onbW81Hx4WrOx6qBqfGa9u3mjMsGjqYnjL/4t3zt3YxElce2X8rbb12x4a0:15716:0:99999:7:::		<span>&lt;</span>---删除此行
<span>#修改影子文件，删除 lamp 用户行。注意：这个文件的权限是 000，所以要强制保存</span>
<span>[</span>root@localhost ~<span>]</span><span># vi /etc/group</span>
lamp<span>;</span>x:501:										<span>&lt;</span>---删除此行
<span>#修改组信息文件，删除 lamp 组的行</span>
<span>[</span>root@localhost ~<span>]</span><span># vi /etc/gshadow</span>
lamp:<span>!</span>::										<span>&lt;</span>---删除此行
<span>#修改组影子文件，删除 lamp 组的行。同样注意需要强制保存</span>
<span>[</span>root@localhost ~<span>]</span><span># rm -rf /var/spool/mail/lamp</span>
<span>#删除用户邮箱</span>
<span>[</span>root@localhost ~<span>]</span><span># rm -rf /home/lamp/</span>
<span>#删除用户的家目录</span>
<span>#至此，用户彻底删除，再新建用户lamp。如果可以正常建立，则说明我们手工删除干净了</span>
<span>[</span>root@localhost ~<span>]</span><span># useradd lamp</span>
<span>[</span>root@localhost ~<span>]</span><span># passwd lamp</span>
<span>#重新建立同名用户，没有报错，说明前面的手工删除是可以完全删除用户的</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>这个实验很有趣吧，不过命令比较多，大家通过这个实验应该可以清楚地了解到这几个用户相关文件的作用。</p>
<h3 id="查看用户的-uid-和-gid-id"> 查看用户的 UID 和 GID：id</h3>
<p><code>id</code> 命令可以查询用户的 UID、GID 和附加组的信息。命令比较简单，格式如下:</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># id 用户名</span>

<span># 例子 1：</span>
<span>[</span>root@localhost ~<span>]</span><span># id lamp</span>
<span>uid</span><span>=</span><span>501</span><span>(</span>lamp<span>)</span>	<span>gid</span><span>=</span><span>501</span><span>(</span>lamp<span>)</span>	<span>groups</span><span>=</span><span>501</span><span>(</span>lamp<span>)</span>
<span>#能看到 uid（用户ID）、gid（初始组ID）、groups 是用户所在组，这里既可以看到初始组，如果有附加组，则也能看到附加组</span>

<span># 例子 2：</span>
<span>[</span>root@localhost ~<span>]</span><span># usermod -G root lamp</span>
<span>#把用户加入 root 组</span>
<span>[</span>root@localnost ~<span>]</span><span># id lamp</span>
<span>uid</span><span>=</span><span>501</span><span>(</span>lamp<span>)</span>	<span>gid</span><span>=</span><span>501</span><span>(</span>lamp<span>)</span>	<span>groups</span><span>=</span><span>501</span><span>(</span>lamp<span>)</span>,0<span>(</span>root<span>)</span>
<span>#大家发现 root 组中加入了 lamp 用户的附加组信息</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="切换用户身份-su"> 切换用户身份：su</h3>
<p><code>su</code> 命令可以切换成不同的用户身份，命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># su [选项] 用户名</span>
选项：
	-		：选项只使用“-”代表连带用户的环境变量一起切换
	-c 命令	：仅执行一次命令，而不切换用户身份
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>“-”不能省略，它代表切换用户身份时，用户的环境变量也要切换成新用户的环境变量。大家知道环境变量是用来定义用户的操作环境的，如果环境变量没有随用户身份切换，那么很多操作将无法正确执行。比如普通用户 lamp 切换成超级用户 root，但是没有加入“-”，那么虽然是 root 用户，但是 <code>$PATH</code> 环境变量还是 lamp 用户的，不包含 <code>/sbin</code>、<code>/usr/sbin</code> 等超级用户命令保存路径，所以无法使用管理员命令；而且 root 用户在接收邮件时，还会发现收到的是 lamp 用户的邮件，因为环境变量 <code>$MAIL</code> 没有切换过来。</p>
<div><pre><code><span># 例子 1：</span>
<span>[</span>lamp@localhost ~<span>]</span>$ <span>whoami</span>
lamp
<span>#查询用户身份，我是lamp</span>
<span>[</span>lamp@localhost ~<span>]</span>$ <span>su</span> root
密码：								<span>&lt;</span>---输入 root 密码
<span>#切換到 root，但是没有切换环境变量。注意：普通用户切换到 root 需要密码</span>
<span>[</span>root@localhost ~<span>]</span><span># env | grep lamp</span>
<span>#查看环境变量，提取包含 lamp 的行</span>
<span><span>USER</span></span><span>=</span>lamp 
<span>#用户名还是 lamp，而不是 root</span>
<span><span>PATH</span></span><span>=</span>/usr/lib/qt-3.3/bin:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/lamp/bin
<span>#命令查找的路径不包含超级用户路径</span>
<span>MAIL</span><span>=</span>/var/spool/mail/lamp
<span><span>PWD</span></span><span>=</span>/home/lamp
<span><span>LOGNAME</span></span><span>=</span>lamp
<span>#邮箱、家目录、目前用户名还是 lamp</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>通过例子 ！ 我们已经注意到，切换用户时如果没有加入“-”，那么切换是不完全的。要想完整切换，可以使用如下命令：</p>
<div><pre><code><span># 例子 2：</span>
<span>[</span>lamp@localhost ~<span>]</span>$ <span>su</span> - root
密码：
<span>#”-”代表连带环境变量一起切換，不能有省略</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>有些系统命令只有 root 可以执行，比如添加用户的命令 <code>useradd</code>，所以我们需要使用 root 身份执行。但是我们只想执行一次，而不想切换身份，可以做到吗？当然可以，命令如下：</p>
<div><pre><code><span># 例子 3：</span>
<span>[</span>lamp@localhost ~<span>]</span>$ <span>whoami</span>
lamp
<span>#当前我是 lamp</span>
<span>[</span>lamp@localhout ~<span>]</span>$ <span>su</span> - root -c <span>"uneradd user1"</span>
密码：
<span>#不切換成 root，但是执行 useradd 命今添加 userl 用户</span>
<span>[</span>lamp@localhost ~<span>]</span>$ <span>whoami</span>
lamp
<span>#我还是1amp</span>
<span>[</span>lamp@localhost ~<span>]</span>$ <span>grep</span> <span>"userl"</span> /etc/passwd
user1:x:502:504::/home/user1:/bin/bash
<span>#user1 用户已经添加了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>总之，切换用户时“-”代表连带环境变量一起切换，不能省略，否则用户身份切换不完全。</p>
<h2 id="用户组管理命令"> 用户组管理命令</h2>
<h3 id="添加用户组-groupadd"> 添加用户组：groupadd</h3>
<p>添加用户组的命令是 <code>groupadd</code>，命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># groupadd [选项] 组名</span>
选项：
	-g GID		：指定组ID
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>添加用户组的命令比较简单，举个例子：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># groupadd groupl</span>
<span>#添加 group1 组</span>
<span>[</span>root@localhost ~<span>]</span><span># grep "groupl" /etc/group</span>
group1:x:502:
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="修改用户组-groupmod"> 修改用户组：groupmod</h3>
<p><code>groupmod</code> 命令用于修改用户组的相关信息，命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># groupmod [选项] 组名</span>
选项：
	-g GID		：修改组ID
	-n 新组名	：修改组名

例子：
<span>[</span>root@localhost ~<span>]</span><span># groupmod -n testgrp group1</span>
<span>#把组名 group1 修改为 testgrp</span>
<span>[</span>root@localhost ~<span>]</span><span># grep "testgrp" /etc/group</span>
testgrp:x:502：
<span>#注意 GID 还是 502，但是组名已经改变</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>不过大家还是要注意，用户名不要随意修改，组名和 GID 也不要随意修改，因为非常容易导致管理员逻辑混乱。如果非要修改用户名或组名，则建议大家先删除旧的，再建立新的。</p>
<h3 id="删除用户组-groupdel"> 删除用户组：groupdel</h3>
<p><code>groupdel</code> 命令用于删除用户组，命令格式如下：</p>
<div><pre><code>[root@localhost ~]# groupdel 组名

#例子：
[root@localhost ~]# groupdel testgrp
#删除 testgrp 组
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>不过大家要注意，要删除的组不能是其他用户的初始组，也就是说这个组中没有初始用户才可以删除。如果组中有附加用户，则删除组时不受影响。</p>
<h3 id="把用户添加进组或从组中删除-gpasswd"> 把用户添加进组或从组中删除：gpasswd</h3>
<p>其实 <code>gpasswd</code> 命令是用来设定组密码并指定组管理员的，不过我们在前面已经说了，组密码和组管理员功能很少使用，而且完全可以被 <code>sudo</code> 命令取代，所以 <code>gpasswd</code> 命令现在主要用于把用户添加进组或从组中删除。命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># gpasswd [选项] 组名</span>
选项：
	-a 用户名		：把用户加入组
	-d 用户名		：把用户从组中删除

<span># 例子：</span>
<span>[</span>root@localhost ~<span>]</span><span># groupadd grouptest</span>
<span>#添加组 grouptest</span>
<span>[</span>root@localhost ~<span>]</span><span># gpasswd -a lamp grouptest</span>
Adding user lamp to group grouptest 
<span>#把用户 lamp 加入 grouptest 组</span>
<span>[</span>root@localhost ~<span>]</span><span># grep "lamp" /etc/group</span>
lamp:x:501：
grouptest:x:505:lamp
<span>#查看一下，lamp 用户已经作为附加用户加入 grouptest 组</span>
<span>[</span>root@localhost ~<span>]</span><span># gpasswd -d lamp grouptest</span>
Removing user lamp from group grouptest
<span>#把用户 lamp 从组中删除</span>
<span>[</span>root@localhost ~<span>]</span><span># grep "grouptest" /etc/group</span>
grouptest:x:505:
<span>#组中没有 lamp 用户了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>大家注意，也可以使用 <code>usermod</code> 命令把用户加入某个组，不过 <code>usermod</code> 命令的操作对象是用户，命令是 <code>usenmod -G grouptest lamp</code>，把用户名作为参数放在最后；而 <code>gpasswd</code> 命令的操作对象是组，命令是 <code>gpasswd -a lamp grouptest</code>，把组名作为参数放在最后。</p>
<p>推荐大家使用 <code>gpasswd</code> 命令，因为这个命令不仅可以把用户加入用户组，也可以把用户从用户组中删除。</p>
<h3 id="改变有效组-newgrp"> 改变有效组：newgrp</h3>
<p>我们说过，每个用户可以属于一个初始组（用户是这个组的初始用户），也可以属于多个附加组（用户是这个组的附加用户）。既然用户可以属于这么多用户组，那么用户在创建文件后，默认生效的组身份是哪个呢？当然是初始用户组的组身份生效了，因为初始组是用户一旦登录就直接获得的组身份。也就是说，用户在创建文件后，文件的属组是用户的初始组，因为用户的有效组默认是初始组。既然用户属于多个用户组，那么能不能改变用户的有效组呢？使用命令 <code>newgrp</code> 就可以切换用户的有效组。命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># newgrp 组名</span>
</code></pre>
<div><span>1</span><br></div></div><p>举个例子，我们已经有了普通用户 lamp，默认会建立 lamp 用户组，lamp 组是 lamp 用户的初始组。我们再把 lamp 用户加入 group1 组，那么 group1 组就是 lamp 用户的附加组。当 lamp 用户创建文件 test1 时，test1 文件的属组是 lamp 组，因为 lamp 组是 lamp 用户的有效组。通过 <code>newgp</code> 命令就可以把 lamp 用户的有效组变成 group1 组，当 lamp 用户创建文件 test2 时，就会发现 test2 文件的属组就是 group1 组。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># groupadd group1</span>
<span>#添加组 group1</span>
<span>[</span>root@localhost ~<span>]</span><span># gpasswd -a lamp groupl</span>
Adding user lamp to group groupl
<span>#把 lamp 用户加入 group1 组</span>
<span>[</span>root@localhost ~<span>]</span><span># grep "lamp" /ete/group</span>
lamp:x<span>;</span><span>501</span>：
group1:x:503:lamp
<span># lamp 用户既属于 lamp 组，也属于 group1 组</span>
<span>[</span>root@localhost ~<span>]</span><span># su - lamp</span>
<span>#切換成 lamp 身份，超级用户切换成普通用户不用密码</span>
<span>[</span>lamp@localhost ~<span>]</span>$ <span>touch</span> test1
<span>#创建文件 test1</span>
<span>[</span>lamp@localhost ~<span>]</span>$ ll testl
-rw-rw-r-- <span>1</span> lamp lamp <span>0</span> <span>1</span>月 <span>14</span> 05:43 test1
<span># test1 文件的默认属组是 lamp 组</span>
<span>[</span>lamp@localhost ~<span>]</span>$ newgrp groupl
<span>#切换 lamp 用户的有效组为 group1 组</span>
<span>[</span>lamp@localhost ~<span>]</span>$ <span>touch</span> test2
<span>#创建文件 test2</span>
<span>[</span>lamp@localhost ~<span>]</span>$ <span>11</span> test2
-rw-r--r-- <span>1</span> lamp groupl <span>0</span> <span>1</span>月 <span>14</span> 05:44 test2
<span>#test2 文件的默认属组是 group1 组</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>通过这个例子明白有效组的作用了吗？其实就是当用户属于多个组时，在创建文件是哪个组身份生效。使用 <code>nwegrp</code> 命令可以在多个组身份之间切换。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2013-05-06T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">linux系统启动管理</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_manage/01.linux_boot/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_manage/01.linux_boot/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>Linux 系统的启动是不需要人为参与和控制的，只要按下电源，系统就会按照设定好的方式进行启动。不过，了解系统的启动有助于我们在系统出现问题时能够快速地修复 Linux 系统。</p>
<p>在 CentOS 6.x 中，系统的启动过程和以前的系统相比变化较大，CentOS 6.x 系统使用 Upstart 启动服务取代了原先的  System V init 启动服务。Upstart 是事件驱动类型的，使用事件来启动和关闭系统服务；而 System V init  则基于运行级别的系统，使用运行级别和链接来启动和关闭系统服务。Upstart 启动方式比原先的 System V init 启动方式要更快速。</p>
<p>因此，虽然 CentOS 6.x 比 CentOS 5.x 更加庞大，但是 CentOS 6.x 的启动速度却快于 CentOS 5.x。</p>
<h2 id="linux-系统启动流程"> Linux 系统启动流程</h2>
<p>Linux 系统的启动，从计算机开机通电自检开始，一直到登陆系统，需要经历多个过程。学习 Linux 的启动过程，有助于了解 Linux 系统的结构，也对系统的排错有很大的帮助。</p>
<p>CentOS 6.x 系统启动过程发生了较大的变化，使用 Upstart 启动服务取代了原先的 System V init 启动服务。Upstart 启动服务的效率更高，启动速度更快。</p>
<p>Linux 系统启动过程比较复杂，我们先整理一下基本的启动过程，有一个整体的印象，然后再进一步说明。</p>
<p>目前，CentOS 6.x 的启动流程经历以下几步：</p>
<ol>
<li>服务器加电，加载 BIOS 信息，BIOS 进行系统检测。依照 BIOS 设定，找到第一个可以启动的设备（一般是硬盘）；</li>
<li>读取第一个启动设备的 MBR (主引导记录），加载 MBR 中的 Boot Loader（启动引导程序，最为常见的是 GRUB）。</li>
<li>依据 Boot Loader 的设置加载内核，内核会再进行一遍系统检测。系统一般会采用内核检测硬件的信息，而不一定采用 Bios 的自检信息。内核在检测硬件的同时，还会通过加载动态模块的形式加载硬件的驱动。</li>
<li>内核启动系统的第一个进程，也就是 <code>/sbin/init</code>。</li>
<li>由 <code>/sbin/init</code> 进程调用 <code>/etc/init/rcS.conf</code> 配置文件，通过这个配置文件调用 <code>/etc/rc.d/rc.sysinit</code> 配置文件。而 <code>/etc/rc.d/rc.sysinit</code> 配置文件是用来进行系统初始化的，主要用于配置计算机的初始环境。</li>
<li>还是通过 <code>/etc/init/rcS.conf</code> 配置文件调用 <code>/etc/inittab</code> 配置文件。通过 <code>/etc/inittab</code> 配置文件来确定系统的默认运行级别。</li>
<li>确定默认运行级别后，调用 <code>/etc/init/rc.conf</code> 配置文件。</li>
<li>通过 <code>/etc/init/rc.conf</code> 配置文件调用并执行 <code>/etc/rc.d/rc</code> 脚本，并传入运行级别参数。</li>
<li><code>/etc/rc.d/rc</code> 确定传入的运行级别，然后运行相应的运行级别目录 <code>/etc/rc[0-6].d/</code> 中的脚本。</li>
<li><code>/etc/rc[0-6].d/</code> 目录中的脚本依据设定好的优先级依次启动和关闭。</li>
<li>最后执行 <code>/etc/rc.d/rc.local</code> 中的程序。</li>
<li>如果是字符界面启动，就可以看到登录界面了。如果是图形界面启动，就会调用相应的 X Window 接口。</li>
</ol>
<p>总的来说，Linux 系统的启动，要经历 <strong><code>BIOS自检 -&gt; 启动 GRUB -&gt; 加载内核 -&gt; 执行第一个进程 -&gt; 配置系统初始环境</code></strong>。当然，这里只是简单地看启动过程，接下来分别详解介绍每步启动过程。</p>
<h3 id="bios-开机自检"> BIOS 开机自检</h3>
<p>前面提到，服务器通电后，会直接进入 BIOS，BIOS 全称 Basic Input/Output System，中文可译为基本输入/输出系统。</p>
<p>简单地理解 BIOS，它就是固化在主板上一个 ROM（只读存储器）芯片上的程序，主要保存计算机的基本输入/输出信息、系统设置信息、开机自检程和系统自启动程序，用来为 计算机提供最底层和最直接的硬件设置与控制。</p>
<p>也就是说，BIOS 是硬件与软件之间的接口，而且是非常基本的接口，BIOS 提供了一组基本的操作系统使用的指令，系统启动的成功与否，依赖于 BIOS。</p>
<p>BIOS 的初始化主要完成以下 3 项工作：</p>
<ol>
<li>第一次检查计算机硬件和外围设备（第二次自检由内核完后，后续会讲），例如 CPU、内存、风扇灯。当 BIOS 一启动，就会做一个自我检测的工作，整个自检过程也被称为 POST（Power On Self Test）自检。</li>
<li>如果自检没有问题，BIOS 开始对硬件进行初始化，并规定当前可启动设备的先后顺序，选择由那个设备来开机。</li>
<li>选择好开启设备后，就会从该设备的 MBR（主引导目录）中读取 Boot Loader（启动引导程序）并执行。启动引导程序用于引导操作系统启动，Linux 系统中默认使用的启动引导程序是 GRUB。</li>
</ol>
<p>当 MBR 被加载到 RAM 之后，BIOS 就会将控制权交给 MBR，进入系统引导的第二阶段。</p>
<h3 id="主引导目录-mbr-结构及作用"> 主引导目录（MBR）结构及作用</h3>
<p>MBR 也就是主引导记录，位于硬盘的 0 磁道、0 柱面、1 扇区中，主要记录了启动引导程序和磁盘的分区表。我们通过图2-1 来看看 MBR 的结构。</p>
<div>
<p><img src="./assets/mbr.jpg" alt="mbr" loading="lazy"></p>
<p><strong>图2-1	<u>MBR 的结构</u></strong></p>
</div>
<p>MBR 共占用了一个扇区，也就是 512 Byte。其中 446 Byte 安装了启动引导程序，其后 64 Byte 描述分区表，最后的 2  Byte 是结束标记。我们已经知道，每块硬盘只能划分 4 个主分区，原因就是在 MBR 中描述分区表的空间只有 64  Byte。其中每个分区必须占用 16 Byte，那么 64 Byte 就只能划分 4 个主分区。每个分区的 16 字节的规划如表2-1 所示。</p>
<p><strong>表2-1 <u>分区表内容</u></strong></p>
<table>
<thead>
<tr>
<th>存储字节</th>
<th>数据内容及含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>第 1 字节</td>
<td>引导标志</td>
</tr>
<tr>
<td>第 2 字节</td>
<td>本分区的起始磁道号</td>
</tr>
<tr>
<td>第 3 字节</td>
<td>本分区的起始扇区号</td>
</tr>
<tr>
<td>第 4 字节</td>
<td>本分区的起始柱面号</td>
</tr>
<tr>
<td>第 5 字节</td>
<td>分区类型，可以识别主分区和扩展分区</td>
</tr>
<tr>
<td>第 6 字节</td>
<td>本分区的结束磁道号</td>
</tr>
<tr>
<td>第 7 字节</td>
<td>本分区的结束扇区号</td>
</tr>
<tr>
<td>第 8 字节</td>
<td>本分区的结束柱面号</td>
</tr>
<tr>
<td>第 9~12 字节</td>
<td>本分区之前已经占用的扇区数</td>
</tr>
<tr>
<td>第 13~16 字节</td>
<td>本分区的总扇区数</td>
</tr>
</tbody>
</table>
<p>大家注意到了吧，MBR 中最主要的功能就是存储启动引导程序。</p>
<h3 id="启动引导程序的作用"> 启动引导程序的作用</h3>
<p>BIOS 的作用就是自检，然后从 MBR 中读取出启动引导程序。那么，启动引导程序最主要的作用就是加载操作系统的内核。当然，每种操作系统的启动引导程序都是不同的。</p>
<p>每种操作系统的文件格式不同，因此，每种操作系统的启动引导程序也不一样。不同的操作系统只有使用自己的启动引导程序才能加载自己的内核。如果我的服务器上只安装了一个操作系统，那么这个操作系统的启动引导程序就会安装在 MBR 中。BIOS 调用 MBR 时读取出启动引导程序，就可以加载内核了。</p>
<p>但是在有些时候，我的服务器中安装了多个操作系统，而 MBR 只有一 个，那么在 MBR 中到底安装哪个操作系统的启动引导程序呢？</p>
<p>很明显，一个 MBR 是不够用的。每块硬盘只能有一个 MBR 是不能更改的，所以不可能増加 MBR  的数量。系统只能在每个文件系统（可以看成分区）中单独划分出一个扇区，称作引导扇区（Boot  Sector)。每个分区的引导扇区中也能安装启动引导程序，也就是说，在 MBR  和每个单独分区的引导扇区中都可以安装启动引导程序。这样多个操作系统才能安装在同一台服务器中（每个操作系统要安装在不同的分区中），而且每个操作系统都是可以启动的。</p>
<p>还有一个问题，BIOS 只能找到 MBR 中的启动引导程序，而找不到在分区的引导扇区中的启动引导程序。那么，要想完成多系统启动，我们的方法是増加启动引导程序的功能，让安装到 MBR 中的启动引导程序（GRUB）可以调用在分区的引导扇区中的其他启动引导程序。</p>
<p>因此，启动引导程序拥有以下功能：</p>
<ol>
<li>加载操作系统的内核。这是启动引导程序最主要的功能。</li>
<li>拥有一个可以让用户选择的菜单，来选择到底启动哪个系统。大家如果在服务器上安装过双 Windows 系统，就应该见过类似的选择菜单，不过这个选择菜单是由 Windows 的启动引导程序提供的，而不是 GRUB。</li>
<li>可以调用其他的启动引导程序，这是多系统启动的关键。不过需要注意的是，Windows 的启动引导程序不能调用 Linux  的启动引导程序，所以我们一般建议先安装 Windows，后安装 Linux，是为了将 Linux 的启动引导程序安装到 MBR 中，覆盖  Windows 的启动引导程序。</li>
</ol>
<p>当然，这个安装顺序不是绝对的，就算最后安装了 Windows，我们也可以通过手工再安装 GRUB 的方法，来保证 MBR 中安装的还是 Linux 的启动引导程序。</p>
<p>图2-2 为我们展示了启动引导程序的作用。</p>
<div>
<p><img src="./assets/grub.jpg" alt="grub" loading="lazy"></p>
<p><strong>图2-2	<u>启动引导程序的作用</u></strong></p>
</div>
<h3 id="内核-内核模块-的加载过程"> 内核（内核模块）的加载过程</h3>
<ol>
<li><strong>内核的加载和内核模块</strong></li>
</ol>
<p>GRUB 加载了内核之后，内核首先会再进行二次系统的自检，而不一定使用 BIOS 检测的硬件信息。这时内核终于开始替代 BIOS 接管 Linux 的启动过程了。</p>
<p>内核完成再次系统自检之后，开始采用动态的方式加载每个硬件的模块，这个动态模块大家可以想象成硬件的驱动（默认 Linux  硬件的驱动是不需要手工安装的，如果是重要的功能，则会直接编译到内核当中；如果是非重要的功能，比如硬件驱动会编译为模块，则在需要时由内核调用。不过，如果没有被内核识别的硬件，要想驱动，就需要手工安装这个硬件的模块了。具体的安装方法会在后续会介绍）。</p>
<p>那么，Linux 的内核到底放在了哪里呢？当然是 <code>/boot</code> 的启动目录中了，我们来看看这个目录下的内容吧。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span>#ls /boot/</span>
config-2.6.32-279.el6.i686
<span>#内核的配置文件，内核编译时选择的功能与模块</span>
efi
<span>#可扩展固件接口，为英特尔为全新PC固件的体系结构、接口和服务提出的建议标准</span>
grub
<span>#启动引导程GRUB的数据目录</span>
initramfs-2.6.32-279.el6.i686.img
<span>#虚拟文件系统（CentOS 6.x 中用initramfs替代了initrd,但功能是一样的）</span>
lost+found
<span>#故boot分区的备份目录</span>
symvers-2_6.32-279.el6.i686.gz
<span>#模块符号信息</span>
System.map-2.6.32-279.el6.i686
<span>#内核功能和内存地址的对应列表</span>
vmlinuz-2.6.32-279.el6.i686
<span>#用于启动的Linux内核。这个文件是一个压缩的内核镜像</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>我们已经知道，Linux 会把不重要的功能编译成内核模块，在需要时再调用，从而保证了内核不会过大。在多数 Linux  中，都会把硬件的驱动程序编译为模块， 这些模块保存在 <code>/lib/modules</code> 目录中。常见的 USB、SATA 和 SCSI  等硬盘设备的驱动，还有一些特殊的文件系统（如 LVM、RAID 等）的驱动，都是以模块的方式来保存的。</p>
<p>如果 Linux 安装在 IDE 硬盘之上，并且采用的是默认的 ext3/4  文件系统，那么内核启动后加载根分区和模块的加载都没有什么问题，系统会顺利启动。但是，如果 Linux 安装在 SCSI 硬盘之上，或者采用的是  LVM 文件系统，那么内核（内核载入内存是启动引导程序 GRUB 调用的，并不存在硬盘驱动不识别的问题）在加载根目录之前是需要加载 SCSI  硬盘或 LVM 文件系统的驱动的。</p>
<p>SCSI 硬盘和 LVM 文件系统的驱动都放在硬盘的 <code>/lib/modules</code> 目录中，既然内核没有办法识别 SCSI 硬盘或 LVM  文件系统，那怎么可能读取 <code>/lib/modules</code> 目录中的驱动呢？Linux 给出的解决办法是使用 initramfs  这个虚拟文件系统来处理这个问题。</p>
<ol start="2">
<li><strong>initramfe 虚拟文件系统</strong></li>
</ol>
<p>CentOS 6.x 中使用 initramfs 虚拟文件系统取代了 CentOS 5.x 中的 initrd RAM Disk。它们的作用类似，可以通过启动引导程序加载到内存中，然后会解压缩并在内存中仿真成一个根目录，并且这个仿真的文件系统能够提供一个可执行程序，通过该程序来加载启动过程中所需的内核模块，比如 USB、SATA. SCSI 硬盘的驱动和 LVM、RAID 文件系统的驱动。</p>
<p>也就是说，通过 initramfs 虚拟文件系统在内存中模拟出一个根目录，然后在这个模拟根目录中加载 SCSI 等硬件的驱动，就可以加载真正的根目录了，之后才能调用 Linux 的第一个进程 <code>/sbin/init</code>。</p>
<p>initramfs 虚拟文件系统主要有以下优点：</p>
<ul>
<li>initramfs 随着其中数据的増减自动増减容量。</li>
<li>在 initramfs 和页面缓存之间没有重复数据。</li>
<li>initramfs 重复利用了 Linux caching 的代码，因此几乎没有増加内核尺寸，而 caching 的代码已经经过良好测试，所以 initramfs 的代码质量也有保证。</li>
<li>不需要额外的文件系统驱动。</li>
</ul>
<p>其实大家只需要知道 initramfs 是为了在内核中建立一个模拟根目录，这个模拟根目录是为了可以调用  USB、SATA、SCSI、LVM、RAID 等硬盘接口或文件系统的驱动模块，加载了驱动模块后才可以加载真正的系统根目录。我们可以通过图2-3 来表示这个过程。</p>
<div>
<p><img src="./assets/kernelload.jpg" alt="kernelload" loading="lazy"></p>
<p><strong>图2-3	<u>内核启动流程</u></strong></p>
</div>
<p>那么既然 initramfs 是一个仿真根目录，那么我们是否可以看看这个仿真根目录中到底是什么样子的呢？当然可以，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mkdir /tmp/initramfs</span>
<span>#建立测试目录</span>
<span>[</span>root@localhost ~<span>]</span><span># cp /boot/initramfs-2.6.32-279.el6.i686.img /tmp/initramfs/</span>
<span>#复制initramfs文件</span>
<span>[</span>root@localhost ~<span>]</span><span># cd /tmp/initramfs/</span>
<span>[</span>root@localhost initramfs<span>]</span><span># file initramfs-2.6.32-279.el6.i686.img</span>
initramfe-2.6.32-279.el6.i686.img: <span>gzip</span> compressed data, from Unix, last modified: Wed Apr <span>10</span> <span>21</span>:49:34 <span>2013</span>, max compression
<span>#查看文件类型，发现这个文件是一个使用gzip命令打包的压缩包</span>
<span>[</span>root@localhost initramfs<span>]</span><span># mv initramfs-2.6.32-279.el6.i686.img initramfs-2.6.32-279.el6.i686.img.gz</span>
<span>#修改文件的扩展名为.gz</span>
<span>[</span>root@localhost initramfs<span>]</span><span># gunzip initramfs-2.6.32-279.el6.i686.img.gz</span>
<span>#解压缩</span>
<span>[</span>root@localhost initramfs<span>]</span><span># ls</span>
initramfs-2.6.32-279.el6.i686.img
<span>[</span>root@localhost initramfs<span>]</span><span># file initramfs-2.6.32-279.el6.i686.img</span>
initramfe-2.6.32-279.el6.i686.img: ASCII cpio archive <span>(</span>SVR4withnoCRC<span>)</span>
<span>#查看文件类型，使用cpio命令的压缩文件</span>
<span>[</span>root@localhost initramfs<span>]</span><span># cpio -ivcdu &lt; initramfs-2.6.32-279.el6.i686.img</span>
<span>#解压缩</span>
<span>[</span>root@localhost initramfs<span>]</span><span># ll</span>
总用量34512
drwxr-xr-x. <span>2</span> root root <span>4096</span> <span>4</span>月 <span>2412</span>:10 bin
drwxr-xr-x. <span>2</span> root root <span>4096</span> <span>4</span> 月 <span>24</span> <span>12</span>:10 cmdline
drwxr-xr-x. <span>3</span> root root <span>4096</span> <span>4</span>月 <span>24</span> <span>12</span>:10 dev
-rw-r--r--. <span>1</span> root root <span>19</span> <span>4</span> 月 <span>24</span> <span>12</span>:10 dracut-004-283.el6
drwxr-xr-x. <span>2</span> root root <span>4096</span> <span>4</span> 月 <span>24</span> <span>12</span>:10 emergency
drwxr-xr-x. <span>7</span> root root <span>4096</span> <span>4</span>月 <span>24</span> <span>12</span>:10 etc
-rwxr-xr-x. <span>1</span> root root <span>8962</span> <span>4</span>月 <span>24</span> <span>12</span>:10 init
drwxr-xr-x. <span>2</span> root root <span>4096</span> <span>4</span> 月 <span>24</span> <span>12</span>:10 initqueue
drwxr-xr-x. <span>2</span> root root <span>4096</span> <span>4</span> 月 <span>24</span> <span>12</span>:10 initqueue-finished
drwxr-xr-x. <span>2</span> root root <span>4096</span> <span>4</span> 月 <span>24</span> <span>12</span>:10 initqueue-settled
drwxr-xr-x. <span>2</span> root root <span>4096</span> <span>4</span> 月 <span>24</span> <span>12</span>:10
initqueue-timeout
-rw-r--r--. <span>1</span> root root <span>35235328</span> <span>4</span> 月 <span>24</span> <span>12</span>:09 initramfs-2.6.32-279.el6.i686.img
drwxr-xr-x. <span>9</span> root root <span>4096</span> <span>4</span>月 <span>2412</span>:10 lib
<span>..</span>.省略部分输出<span>..</span>.
<span>#这就是initramfs虚拟文件系统中的内容，和根目录是不是很像</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><h3 id="sbin-init-进程调用"> <code>/sbin/init</code> 进程调用</h3>
<p>在内核加载完毕，并完成硬件检测与驱动程序加载后，此时主机硬件已经准备完毕，内核会主动呼叫第一个进程，也就是 <code>/sbin/init</code>，此配置文件最主要的功能就是准备软件执行的环境，包括系统的主机名、网络设定、语言、文件系统格式及其他服务的启动等。</p>
<p>这里和 CentOS 5.x 系统相比也有较大变化。在 CentOS 5.x 系统中，主要通过 init 进程的配置文件 <code>/etc/inittab</code> 来设定系统，并启动 Linux。但是在 CentOS 6.x 系统中，由于用 Upstart 启动服务来替换以前的 init，所以在 <code>/etc/inittab</code> 配置文件中只能定义系统的默认运行级别，而其他的功能是靠 <code>/etc/init/</code> 目录中的其他配置文件实现的。</p>
<p>大家可以把 <code>/etc/init/</code> 目录中的配置文件看成以前 <code>/etc/inittab</code> 这个文件功能的分拆。</p>
<p>前面提到，由 <code>/sbin/init</code> 进程可通过 <code>/etc/init/rcS.conf</code> 配置文件，分别找到  <code>/etc/rc.d/rc.sysinit</code> 配置文件和 <code>/etc/inittab</code> 配置文件，前者用于初始化系统，配置计算机的初始环境；后者用于确定系统的默认运行级别。</p>
<h3 id="etc-rc-d-rc-sysinit-系统初始化"> <code>/etc/rc.d/rc.sysinit</code>：系统初始化</h3>
<p>接下来，先介绍 <code>/etc/rc.d/rc.sysinit</code> 配置文件。如果我们使用 Vim 查看 <code>/etc/rc.d/rc.sysinit</code> 配置文件，就会发现这个这个配置文件主要进行了以下几项工作：</p>
<ul>
<li>获得网络环境和主机类型；</li>
<li>测试设备：除了挂载内存设备 /proc 之外，还会主动侦测系统上是否具有 usb 设备，如果有，则会主动加载 usb 的驱动程序，并尝试挂载 usb 文件系统；</li>
<li>开机启动画面 Plymouth（代替了以往的 RHGB）；</li>
<li>判断是否启用 SELinux；</li>
<li>显示开机过程中的欢迎画面；</li>
<li>初始化硬件；</li>
<li>用户自定义模块的加载，用户可以在 /etc/sysconfig/modules/*.modules 加入自订的模块，则此时会被加载到系统当中；</li>
<li>配置内核的参数，系统会主动去读取 /etc/sysctl.conf 这个文件的配置参数，使内核的功能成为我们想要的样子。</li>
<li>设置主机名。</li>
<li>同步存储器。</li>
<li>设备映射器及相关的初始化。</li>
<li>初始化软件磁盘阵列 (RAID)。</li>
<li>初始化 LVM 的文件系统功能。</li>
<li>检验磁盘文件系统 (fsck)。</li>
<li>设置磁盘配额 (quota)。</li>
<li>重新以可读写模式挂载系统磁盘。</li>
<li>更新 quota (非必要)。</li>
<li>启动系统虚拟随机数生成器。</li>
<li>配置机器（非必要）。</li>
<li>清除开机过程中的临时文件。</li>
<li>创建 ICE 目录。</li>
<li>启动交换分区（swap）。</li>
<li>将开机信息写入 /var/log/dmesg 文件中。</li>
</ul>
<p>在以上过程中，比较值得注意的是自定模块的加载。在 CentOS 中，如果我们想要加载核心模块的话，就可以将整个模块写入到 <code>/etc/sysconfig/modules/*.modules</code>  中。当然，此过程并不是必须的，通常我们的默认模块已经够用，除非对硬件太新，不得不自己加载模块，否则无需刻意添加任何模块。</p>
<p>可以看到，<code>/etc/rc.d/rc.sysinit</code> 配置文件已经将基本的系统配置数据都写好了，我们可以查询 <code>/var/log/dmesg</code> 文件或使用 <code>dmesg</code> 命令查看系统在启动时到底发生了什么。当然，我们也可以通过这个命令来看看 Linux 服务器的硬件信息。</p>
<h3 id="etc-inittab-设置系统默认运行级别"> <code>/etc/inittab</code>：设置系统默认运行级别</h3>
<p>在 CentOS 6.x 中，<code>/etc/inittab</code> 配置文件只能用来设置系统的默认运行级别。</p>
<ol>
<li><strong>运行级别</strong></li>
</ol>
<p>那么，什么是运行级别呢？其实 Linux 是通过运行级别来确定系统启动时到底启动哪些服务的。Linux 默认有 7 个运行级别，具体如表2-2 所示。</p>
<p><strong>表2-2	<u>运行级别</u></strong></p>
<table>
<thead>
<tr>
<th>运行级别</th>
<th>含 义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>关机</td>
</tr>
<tr>
<td>1</td>
<td>单用户模式，可以想象为 Windows 的安全模式，主要用于系统修复</td>
</tr>
<tr>
<td>2</td>
<td>不完全的命令行模式，不含 NFS 服务</td>
</tr>
<tr>
<td>3</td>
<td>完全的命令行模式，就是标准字符界面</td>
</tr>
<tr>
<td>4</td>
<td>系统保留</td>
</tr>
<tr>
<td>5</td>
<td>图形模式</td>
</tr>
<tr>
<td>6</td>
<td>重新启动</td>
</tr>
</tbody>
</table>
<p>在 Linux 系统中可以使用 <code>runlevel</code> 命令来查看系统的运行级别，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># runlevel</span>
N <span>3</span>
<span>#N代表在进入这个级别前，上一个级别是什么；3代表当前级别</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>在这个命令的结果中，&quot;N 3&quot;中的 N 代表在进入这个级别前，上一个级别是什么；3 代表当前级别。&quot;N&quot; 就是 None 的意思，也就是说，系统是开机直接进入 3 运行级别的，没有上一个运行级别。那如果从图形界面切换到字符界面，再查看运行级别，就应该是这样的：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># runlevel</span>
<span>5</span> <span>3</span>
<span>#代表由5级别进入3级别</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>那么，可以手工改变当前的运行级别吗？当然可以了，只需使用 <code>init</code> 命令（注意这不是 init 进程）即可，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># init 5</span>
<span>#进入图形界面，当然要已经安装了图形界面才可以</span>
<span>[</span>root@localhost ~<span>]</span><span># init 0</span>
<span>#关机</span>
<span>[</span>root@localhost ~<span>]</span><span># init 6</span>
<span>#重新启动</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>不过要注意，使用 <code>init</code> 命令关机和重启并不是太安全，容易造成数据丟失。所以推荐大家使用 <code>shutdown</code> 命令进行关机和重启。</p>
<ol start="2">
<li><strong>系统默认运行级别</strong></li>
</ol>
<p>知道了运行级别的作用，我们回到系统启动过程中来。<code>/etc/inittab</code> 配置文件的功能就是确定系统的默认运行级别，也就是系统开机后会进入那个运行级别。此文件的内容如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vim /etc/inittab</span>
<span># inittab is only used by upstart for the default runlevel.</span>
<span>#</span>
<span># ADDING OTHER CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.</span>
<span>#</span>
<span># System initialization is started by /etc/init/rcS.conf</span>
<span>#系统会先调用/etc/init/rcS.conf</span>
<span># Individual runlevels are started by /etc/init/rc.conf</span>
<span>#在调用/etc/init/rc.conf,在不同的运行级别启动不同的服务</span>
<span># Ctrl-Alt-Delete is handled by/etc/init/control-alt-delete.conf</span>
<span>#通过这个配置文件判断Ctri+Alt+Delete热启动键是否可用</span>
<span># Terminal gettys are handled by /etc/init/tty.conf and /etc/init/serial.conf,</span>
<span># with configuration in /etc/sysconfig/init.</span>
<span>#判断系统可以启动的本地终端数量及终端的基本设置（如颜色）</span>
<span># For information on how to write upstart event handlers, or how</span>
<span># upstart works, see init(5), init(8), and initctl(8).</span>
<span>#</span>
<span># Default runlevel. The runlevels used are:</span>
<span># 0 - halt (Do NOT set initdefault to this)</span>
<span># 1 - Single user mode</span>
<span># 2 - Multiuser, without NFS (The same as 3, if you do not have networking)</span>
<span># 3 - Full multiuser mode</span>
<span># 4 - unused</span>
<span># 5-X11</span>
<span># 6 - reboot (Do NOT set initdefault to this)</span>
<span>#很眼熟吧，就是刚刚的 0~6运行级别的说明</span>
id:3:initdefault:
<span>#这就是系统的默认运行级别，也就是系统开机后直接进入哪个运行级别</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>注意，这里的默认运行级别只能写 3 或 5，其他的级别要么是关机重启，要么是保留或单用户，都不能作为系统默认运行级别。</p>
<h3 id="先-etc-initrc-conf-后-etc-rc-drc-脚本文件"> 先 <code>/etc/initrc.conf</code> 后 <code>/etc/rc.drc</code> 脚本文件</h3>
<p>一旦确定了默认运行级别，系统就会调用 <code>/etc/init/rc.conf</code> 配置文件，传入默认级别作为参数。而 <code>/etc/init/rc.conf</code> 配置文件的作用是调用 <code>/etc/rc.d/rc</code> 脚本文件。</p>
<p>运行级别参数传入 <code>/etc/rc.d/rc</code> 这个脚本文件之后，由这个脚本文件按照不同的运行级别启动 <code>/etce/rc[0-6]d/</code> 目录中相应的程序。而 <code>/etc/re[0-6]d/</code> 目录中的程序已经设定好了优先级顺序。</p>
<p>按照优先级顺序依次启动相应的程序即可。比如我们的默认运行级别是 3，那么这个默认运行级别会先传入 <code>/etc/init/rc.conf</code> 配置文件，然后再传入 <code>/etc/rc.d/rc</code> 脚本文件，由此脚本文件调用 <code>/etc/rc3.d/</code> 目录中所有的程序。这个目录中的程序一般如下：</p>
<ul>
<li>
<p>以 <code>/etc/rc3.d/k??</code> 开头的文件（??是数字），会按照数字顺序依次关闭。</p>
</li>
<li>
<p>以 <code>/etc/rc3.d/S??</code> 开头的文件（??是数字），会按照数字顺序依次启动。</p>
</li>
</ul>
<p>这些数字就是设定好的优先级，按照数字顺序依次启动和关闭相应的程序，系统就会启动。</p>
<p>另外，<code>/etc/rc3.d/</code> 目录中的程序都是链接文件。例如：</p>
<div><pre><code><span>[</span>root@localhont rc3.d<span>]</span><span># ll /etc/re3.d/s10network</span>
lrwxrwxtwx. <span>1</span> root root <span>17</span> <span>4</span>月 <span>10</span> <span>21</span>:46 /etc/rc3.d/s10network-<span>></span><span>..</span>/init.d/network
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>所以，启动了这些文件，实际上启动了 <code>/etc/init.d/</code> 目录中的系统服务。</p>
<h3 id="etc-rc-d-rc-local-配置文件"> <code>/etc/rc.d/rc.local</code> 配置文件</h3>
<p>在 <code>/etc/rc[0-6].d/</code>  目录中的程序启动之后，系统的启动就已经完成。不过，我们总有一些程序是需要在系统启动之后随着系统一起启动的。这时我们并不需要自己把需要启动的服务链接到 <code>/etc/rc3.d/</code> 目录中，因为系统给我们准备了 <code>/etc/rc.d/rc.local</code> 配置文件。</p>
<p>这个配置文件会在用户登陆之前读取，这个文件中不管写入了什么命令，在每次系统启动时都会执行一次。**也就是说，如果有任何需要在系统启动时运行的工作，则只需写入 <code>/etc/rc.d/rc.local</code> 配置文件即可。**这个文件的内容如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ll /etc/rc.local</span>
lrwxrwxrwx. <span>1</span> root root <span>13</span> <span>4</span>月10 <span>21</span>:46 /etc/rc.local -<span>></span> rc.d/rc.local
<span>#有一个链接文件，两个文件修改哪一个都可以</span>
<span>[</span>root@localhost ~<span>]</span><span># vi /etc/rc.d/rc.local</span>
<span>#!/bin/sh</span>
<span>#</span>
<span>#This script will be executed *after* all the other init scripts.</span>
<span>#You can put your own initialization stuff in here if you don't</span>
<span>#want to do the full Sys V style init stuff.</span>
<span>touch</span> /var/lock/subsys/local
<span>#默认会touch这个文件，每次系统启动时都会touch这个文件，这个文件的修改时间就是系统的启动时间</span>
/etc/rc.d/init.d/httpd start
<span>#如果写入RPM包安装的apache服务的启动命令，apache服务就会在开机时自动启动</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>Linux 的启动过程基本上就是这样的，我们把启动流程图补充完整，如图2-4 所示。</p>
<div>
<p><img src="./assets/bootloader.jpg" alt="bootloader" loading="lazy"></p>
<p><strong>图2-4	<u>Linux 启动流程</u></strong></p>
</div>
<p>系统的启动过程就是这样的，最终我们就能登录字符界面的 Linux 了。不过，如果需要启动图形界面的 Linux，则还需要调用 X Window 接口。</p>
<p>在启动过程中还有一个配置文件会生效，就是 <code>/etc/init/start-ttys.conf</code>，这个文件主要定义了 Linux 支持的 1~6  个本地终端（tty[1-6])。如果在本机，则可以使用快捷键 <kbd>Alt</kbd>+<kbd>F1 ~ F6</kbd> 来切换这 6 个本地终端；如果安装并启动了图形界面，则可以使用快捷键 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>F7</kbd> 来切换图形终端。</p>
<p>至此，字符界面的启动过程就介绍完了。是不是非常复杂？如果你是初学者，则只需了解，不需要彻底掌握。但是掌握了 Linux 系统的启动过程，会更加了解 Linux 的结构。当然，如果你非常自信，则可以尝试安装 gentoo Linux 这个版本，因为这个 Linux  版本到目前为止还是纯源码安装的，如果能够安装成功，就会对 Linux 系统的结构及启动过程有更深入的理解。</p>
<h2 id="启动引导程序-bootloader"> 启动引导程序（BootLoader）</h2>
<p>在刚刚的启动过程中，我们已经知道启动引导程序（Boot Loader，也就是 GRUB）会在启动过程中加载内核，之后内核才能取代 BIOS 接管启动过程。如果没有启动引导程，那么内核是不能被加载的。</p>
<p>我们来看看启动引导程序加载内核的过程，当然 initramfs 这个虚拟文件系统也是要靠启动引导程序调用的。在 CentOS 6.x  中，启动引导程序默认是 GRUB，GRUB 是现在最为流行的启动引导程序，我们也用 GRUB 来说明启动引导程序的作用。</p>
<p>早期的 LILO 引导程序已经不是很常见了，GRUB 相比来讲有很多优势，主要有：</p>
<ul>
<li>支持更多的文件系统。</li>
<li>GRUB 的主程序可以直接在文件系统中查找内核文件。</li>
<li>在系统启动时，可以利用 GRUB 的交互界面编辑和修改启动选项。</li>
<li>可以动态修改 GRUB 的配置文件，这样在修改配置文件之后不需要重新安装 GRUB，而只需重新启动就可以生效。</li>
</ul>
<h3 id="grub-加载内核的过程"> GRUB 加载内核的过程</h3>
<p>GRUB 的作用有以下几个：</p>
<ul>
<li>加载操作系统的内核；</li>
<li>拥有一个可以让用户选择的的菜单，来选择到底启动哪个系统；</li>
<li>可以调用其他的启动引导程序，来实现多系统引导。</li>
</ul>
<p>按照启动流程，BIOS 在自检完成后，会到第一个启动设备的 MBR 中读取 GRUB。在 MBR 中用来放置启动引导程序的空间只有 446  Byte，那么 GRUB 可以放到这里吗？答案是空间不够，GRUB 的功能非常强大，MBR 空间是不够使用的。那么 Linux 的解决办法是把 GRUB 的程序分成了三个阶段来执行。</p>
<p><strong>Stage 1：执行 GRUB 主程序</strong></p>
<p>第一阶段是用来执行 GRUB 主程序的，这个主程序必须放在启动区中（也就是 MBR 或者引导扇区中）。但是 MBR 太小了，所以只能安装  GRUB 的最小的主程序，而不能安装 GRUB 的相关配置文件。这个主程序主要是用来启动 Stage 1.5 和 Stage 2 的。</p>
<p><strong>Stage 1.5：识别不同的文件系统</strong></p>
<p>Stage 2 比较大，只能放在文件系统中（分区），但是 Stage 1 不能识别不同的文件系统，所以不能直接加载 Stage 2。这时需要先加载 Stage 1.5，由 Stage 1.5 来加载不同文件系统中的 Stage 2。</p>
<p>还有一个问题，难道 Stage 1.5 不是放在文件系统中的吗？如果是，那么 Stage 1 同样不能找到 Stage 1.5。其实，Stage 1.5 还真没有放在文件系统中，而是在安装 GRUB 时，直接安装到紧跟 MBR 之后的 32KB  的空间中，这段硬盘空间是空白无用的，而且是没有文件系统的，所以 Stage 1 可以直接读取 Stage 1.5。读取了 Stage 1.5  就能识别不同的文件系统，才能加载 Stage 2。</p>
<p><strong>Stage 2：加载 GRUB 的配置文件</strong></p>
<p>Stage 2 阶段主要就是加载 GRUB 的配置文件 <code>/boot/grub/grub.conf</code>，然后根据配置文件中的定义，加载内核和虚拟文件系统。接下来内核就可以接管启动过程，继续自检与加载硬件模块了。</p>
<h3 id="boot-grub-目录"> <code>/boot/grub/</code> 目录</h3>
<p>BIOS 在进行完成系统检测之后，就会找到第一个可以启动的设备，并读取该设备的 MBR（主引导记录）以及加载 MBR 中的 boot loader（启动引导程序），这个启动引导程序可以具有菜单功能、直接加载核心文件以及控制权移交的功能等。</p>
<p>另外我们还知道，系统必须要借助启动引导程序，才能加载内核，那么问题来了，MBR 只是占据整个设备的第一个扇区中，其大小也就只有 446 字节而已，但启动引导程序功能这么强大，光程序代码即配置数据就肯定不止 446 字节，是怎么安装的吗？</p>
<p>是这样的，Linux 系统将启动引导程序的程序代码运行与配置数据加载分为以下 2 个阶段：</p>
<ol>
<li>第一个阶段负责运行启动引导的主程序，该主程序必须要被安装在启动区，或者是 MBR，或者是引导扇区，但我们说过，MBR 的容量实在太小啦，因此，MBR 或引导扇区通常只安装启动引导程序的最小主程序，并不安装相关的配置数据；</li>
<li>第二个阶段是为主程序加载配置文件，包括相关的环境参数文件（文件系统定义以及主要配置文件 menu.1st）；</li>
</ol>
<p>其中，与 GRUB（启动引导程序）相关的配置文件，都放置在 <code>/boot/grub</code> 目录中。我们来看看这个目录下到底有哪些文件。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cd /boot/grub/</span>
<span>[</span>root@localhost grub<span>]</span><span># ll -h</span>
总用量274K
-rw-r--r--. <span>1</span> root root <span>63</span> <span>4</span>月 <span>10</span> <span>21</span>:49 device.map
<span>#GRUB中硬盘的设备文件名与系统的设备文件名的对应文件</span>
-rw-r--r--. <span>1</span> root root 14K <span>4</span>月 <span>10</span> <span>21</span>:49 e2fs_stage1_5
<span>#ext2/ext3文件系统的 Stage 1.5文件</span>
-rw-r--r--. <span>1</span> root root 13K <span>4</span>月 <span>10</span> <span>21</span>:49 fat_stage1_5
<span>#FAT文件系统的 Stage 1.5文件</span>
-rw-r--r--. <span>1</span> root root 12K <span>4</span>月 <span>10</span> <span>21</span>:49 ffs_stage1_5
<span>#FFS文件系统的 Stage 1.5文件</span>
-rw-------.1 root root <span>737</span> <span>4</span>月 <span>10</span> <span>21</span>:49 grub.conf
<span>#GRUB的配置文件</span>
-rw-r--r--. <span>1</span> root root 12K <span>4</span> 月 <span>10</span> <span>21</span>:49 iso9660_stage1_5
<span>#iso9660文件系统的 Stage 1.5文件</span>
-rw-r--r--. <span>1</span> root root 13K <span>4</span>月 <span>10</span> <span>21</span>:49 jfs_stage1_5
<span>#JFS文件系统的 Stage 1.5文件</span>
lrwxrwxrwx. <span>1</span> root root <span>11</span> <span>4</span>月 <span>10</span> <span>21</span>:49 menu.lst -<span>></span>./grub.conf
<span>#GRUB的配置文件。和grub.conf是软链接，所以两个文件修改哪一个都可以</span>
-rw-r--r--. <span>1</span> root root 12K <span>4</span> 月 <span>10</span> <span>21</span>:49 minix_stage1_5
<span>#MINIX文件系统的 Stage 1.5文件</span>
-rw-r--r--. <span>1</span> root root 15K <span>4</span> 月 <span>10</span> <span>21</span>:49 reiserfs_stage1_5
<span>#ReiserFS文件系统的 Stage 1.5文件</span>
-rw-r--r--. <span>1</span> root root <span>1</span>.4K <span>11</span> 月 <span>15</span> <span>2010</span> splash.xpm.gz
<span>#系统启动时，GRUB程序的背景图像</span>
-rw-r--r--. <span>1</span> root root <span>512</span> <span>4</span>月 <span>10</span> <span>21</span>:49 stage1
<span>#安装到引导扇区中的 Stage 1的备份文件</span>
-rw-r--r--. <span>1</span> raot root 124K <span>4</span>月 <span>10</span> <span>21</span>:49 stage2
<span>#Stage2的备份文件</span>
-rw-r--r--. <span>1</span> root root 12K <span>4</span>月 <span>10</span> <span>21</span>:49 ufs2_stage1_5
<span>#UFS文件系统的Stage 1.5文件</span>
-rw-r--r--. <span>1</span> root root 12K <span>4</span> 月 <span>10</span> <span>21</span>:49 vstafs_stage1_5
<span>#vstafs文件系统的 Stage 1.5文件</span>
-rw-r--r--. <span>1</span> root root 14K <span>4</span>月 <span>10</span> <span>21</span>:49 xfs_stage1_5
<span>#XFS文件系统的 Stage 1.5文件</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><p>可以看到，这个目录中主要就是 GRUB 的配置文件和各种文件系统的 Stage1.5 文件。不过 GRUB 的配置文件有两个：<code>/boot/grub/grub.conf</code> 和  <code>/boot/grub/menu.lst</code>，这两个配置文件是软链接，所以修改哪一个都可以。</p>
<h3 id="grub-配置文件"> GRUB 配置文件</h3>
<ol>
<li><strong>GRUB 中分区的表示方法</strong></li>
</ol>
<p>我们已经知道 Linux 系统分区的设备文件名的命名是有严格规范的，类似于 <code>/dev/sda1</code> 代表第一块 SCSI 硬盘的第一个主分区。但是在 GRUB 中分区的表示方法却完全不同，采用了类似 <strong>hd(0,0)</strong> 的方式来表示分区。</p>
<p>其实也很好理解，其中：</p>
<ul>
<li>hd 代表硬盘，不再区分是 SCSI 接口硬盘，还是 IDE 接口硬盘，都用 hd 代表；</li>
<li>第一个 0 代表 Linux 系统查找到的第一块硬盘，第二块硬盘为 1，以此类推；</li>
<li>第二个 0 代表这块硬盘的第一个分区，以此类推；</li>
</ul>
<p>也就是说，hd(0,0) 代表的是第一块硬盘的第一个分区，和 Linux 系统中 <code>/dev/sda1</code> 的含义类似，只是不再区分是 SCSI 硬盘还是 IDE 硬盘。我们用表2-3 来说明一下 Linux 系统对分区的描述和 GRUB 中对硬盘的描述。</p>
<p><strong>表2-3	<u>分区表示</u></strong></p>
<table>
	<tr>
        <td><b>硬 盘</b></td>
		<td><b>分 区</b></td>
		<td><b>Linux 中的设备文件名</b></td>
		<td><b>GRUB 中的设备文件名</b></td>
	</tr>
	<tr>
		<td rowspan="4">第一块 SCSI 硬盘</td>
		<td>第一个主分区</td>
		<td>/dev/sda1</td>
		<td>hd(0,0)</td>
	</tr>
	<tr>
		<td>第二个主分区</td>
		<td>/dev/sda2</td>
		<td>hd(0,1)</td>
	</tr>
	<tr>
		<td>扩展分区</td>
		<td>/dev/sda3</td>
		<td>hd(0,2)</td>
	</tr>
	<tr>
		<td>第一个逻辑分区</td>
		<td>/dev/sda5</td>
		<td>hd(0,4)</td>
	</tr>
    	<tr>
		<td rowspan="4">第二块 SCSI 硬盘</td>
		<td>第一个主分区</td>
		<td>/dev/sdb1</td>
		<td>hd(1,0)</td>
	</tr>
	<tr>
		<td>第二个主分区</td>
		<td>/dev/sdb2</td>
		<td>hd(1,1)</td>
	</tr>
	<tr>
		<td>扩展分区</td>
		<td>/dev/sdb3</td>
		<td>hd(1,2)</td>
	</tr>
	<tr>
		<td>第一个逻辑分区</td>
		<td>/dev/sdb5</td>
		<td>hd(1,4)</td>
	</tr>
</table>
<p>在这张表中要注意，逻辑分区不能占用主分区与扩展分区的分区号，所以第一个逻辑分区在 Linux 系统中应该用 <code>/dev/sda5</code> 表示，在  GRUB 中应该用 hd(0,4) 表示，还要注意 GRUB 的表示方式只在 GRUB 的配置文件中生效，一旦离开了 GRUB  的配置文件，就要使用 Linux 中的设备文件名来表示分区了。</p>
<ol start="2">
<li><strong>GRUB 配置文件的内容</strong></li>
</ol>
<p>我们来看看 GRUB 的配置文件 <code>/boot/gmb/grub.conf</code> 中到底写了什么。命令如下：</p>
<div><pre><code><span>[</span>rootdlocalhost ~<span>]</span><span># vi /boot/grub/grub.conf</span>
<span>default</span><span>=</span><span>0</span>
<span>timeout</span><span>=</span><span>5</span>
<span>splashimage</span><span>=</span><span>(</span>hd0,0<span>)</span>/grub/splash.xpm.gz
hiddenmenu
<span>#以上为GRUB的整体设置</span>

title CentOS <span>(</span><span>2.6</span>.32-279.el6.i686<span>)</span>
	root <span>(</span>hdO,0<span>)</span>
	kernel /vmlinuz-2.6.32-279.el6.i686 ro  <span>root</span><span>=</span>OOID<span>=</span>b9a7ala8-767f-4a87-8a2b-a535edb362c9 rd_NO_LUKS  <span>KEYBOARDTYPE</span><span>=</span>pc <span>KEYTABLE</span><span>=</span>us rd_NO_MD <span>crashkernel</span><span>=</span> auto <span><span>LANG</span></span><span>=</span>zh_CN.UTF-8  rd_NO_LVM rd_NO_DM rhgb quiet
	initrd /initramfs-2.6.32-279.el6.i686.img
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>这个文件的内容可以分成两部分：前 4 行为 GRUB 的整体设置；title 以下 4 行为要启动的 CentOS 系统的具体配置。这里只安装了一个系统，如果多系统并存，那么每个系统都会有类似的 title 行存在。</p>
<p>们先看整体设置：</p>
<ul>
<li>default=0：默认启动第一个系统。也就是说，如果在等待时间结束后，用户没有选择进入哪个系统，那么系统会默认进入第一个系统。如果有多系统并存，那么每个系统都会有自己的 title 字段，如果想要默认进入第二个系统，这里就可以设为 default=1。</li>
<li>timeout=5：等待时间，默认是 5 秒。也就是在进入系统时，如果 5 秒内用户没有按下任意键，那么系统会进入 default  字段定义的系统。当然，也可以手工修改这个等待时间，如果timeout=0，则不会等待直接进入系统；如果  timeout=-1，则会一直等待用户输入，而不会自动进入系统。</li>
<li>splashimage=(hd0,0)/grub/splash.xpm.gz：用来指定 GRUB 启动时的背景图像的保存位置。记得 CentOS 6.x 启动时后台的蓝色图像吧，就是这个文件的作用。不过这个文件具体在哪里呢？我们已经说过，hd(0,0)  代表第一块硬盘的第一个分区，而笔者的系统在安装时 <code>/boot</code> 分区就是第一个分区，所以这个背景图像的实际位置就是  <code>/boot/gmb/splash.xpm.gz</code>。</li>
<li>hiddenmenu：隐藏菜单。启动时默认只能看到读秒，而不能看到菜单。如果想要看到菜单，则需要按任意键。如果注释了这句话，那么启动时就能直接看到菜单了。</li>
</ul>
<p>再来介绍 CentOS 系统的具体配置：</p>
<ul>
<li>
<p>title CentOS(2.6.32-279.d6.i686)：title 就是标题的意思，也就是说，在 title 后面写入的是什么，系统启动时在 GRUB 的启动菜单中看到的就是什么。</p>
</li>
<li>
<p>root（hd0,0）：是指启动程序的保存分区。这里要注意，这个 root 并不是管理员。在我的系统中，<code>/boot</code> 分区是独立划分的，而且设备文件名为 <code>/dev/sda1</code>，所以在 GRUB 中就被描述为 hd(0,0)。</p>
</li>
<li>
<p>kernel /vmlinuz-2.6.32-279.el6.i686 ro  root=UUID=b9a7a1a8-767f-4a87-8a2b-a535edb362c9 rd_NO_LUKS  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_MD crashkernel=auto LANG=zh_CN.UTF-8  rd_NO_LVM rd_NO_DM rhgb quiet。其中：</p>
<ul>
<li><code>/vmlinuz-2.6.32-279.el6.i686</code>：指定了内核文件的位置，这里的 / 是指 boot 分区。</li>
<li>ro：启动时以只读方式挂载根文件系统，这是为了不让启动过程影响磁盘内的文件系统。</li>
<li>root=UUID=b9a7a1 a8-767f-4a87-8a2b-a535edb362c9：指定根文件系统的所在位置。这里和以前的 Linux 版本不太一样了，不再通过分区的设备文件名或卷标号来指定，而是通过分区的 UUID 来指定的。</li>
</ul>
</li>
</ul>
<p>那么，如何査询分区的 UUID 呢？方法有很多种，最简单的办法就查询 <code>/ec/fstab</code> 文件。命令如下：</p>
<div><pre><code>[root@localhost ~]# cat /etc/fetab | grep &quot;/ &quot;
UUID=b9a7a1a8-767f-4a87-8a2b-a535edb362c9 / ext4 defaults 1 1
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>可以看到 <code>/</code>分区的 UUID 和 kernel 行中的 UUID 是匹配的。注意一下 grep 后的&quot;/&quot;，在&quot;/&quot;后是有空格的。</p>
<p>以下禁用都只是在启动过程中禁用，是为了加速系统启动的：</p>
<ul>
<li>
<p>rd_NO_LUKS：禁用 LUKS，LUKS 用于给磁盘加密。</p>
</li>
<li>
<p>rd_NO_MD：禁用软 RAID。</p>
</li>
<li>
<p>rd_NO_DM：禁用硬 RAID。</p>
</li>
<li>
<p>rd_NO_LVM：禁用 LVM。</p>
</li>
</ul>
<p>除了以上这样，命令输出信息中还包含以下内容：</p>
<ul>
<li>
<p>KEYBOARDTYPE=pc KEYTABLE=us：键盘类型。</p>
</li>
<li>
<p>crashkernel=auto：自动为 crashkernel 预留内存。</p>
</li>
<li>
<p>LANG=zh_CN.UTF-8：语言环境。</p>
</li>
<li>
<p>rhgb：（redhatgraphics boot）用图片来代替启动过程中的文字信息。启动完成之后可以使用 <code>dmesg</code> 命令来查看这些文字信息。</p>
</li>
<li>
<p>quiet：隐藏启动信息，只显示重要信息。</p>
</li>
<li>
<p>initrd/initramfs-2.6.32-279.el6.i686.img：指定了 initramfs 虚拟文件系统镜像文件的所在位置。</p>
</li>
</ul>
<p>GRUB 的配置文件的内容就是这样的，主要是 kernel 行较为复杂。不过，在这个 <code>/boot/gmb/grub.conf</code> 配置文件中，只启动了一个 Linux 系统。如果在 Linux 服务器中 既安装了 Linux 系统，又安装了 Windows 系统，那么  GRUB 的配置文件又是什么样子的呢？</p>
<ol start="3">
<li><strong>多系统启动</strong></li>
</ol>
<p>其实每个系统都是用 title 字段来表示的，如果在服务器中又多了一个 Windows 系统，那么在 GRUB 的配置文件中只不过就是多了一个 title 字段而已。不过要注意，我们一般建议先安装 Windows 系统，后安装 Linux 系统。</p>
<p>原因是 Windows 系统的启动引导程序无法把启动过程转交到 Linux 系统的 GRUB 中，自然就不能启动 Linux 系统了。如果我们后安装 Linux 系统，GRUB 就会安装到 MBR 中，覆盖 Windows 系统的启动引导程序。而 GRUB 是可以把启动过程转交到 Windows 系统的启动引导程序中的，所以 Windows 系统和 Linux 系统都可以顺利启动。</p>
<p>当然，如果真的是后安装 Windows 系统，则也可以通过手工再安装一次 GRUB 来覆盖 MBR 中的 Windows 系统的启动引导程序。</p>
<p>那么我们就来看看 Windows 和 Linux 双系统并存的 GRUB 的配置文件是什么样子的。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span>#vi /boot/gmb/gmb.conf</span>
default:0
<span>timeout</span><span>=</span>-1
<span>splashimage</span><span>=</span><span>(</span>hd0,0<span>)</span>/grub/splash.xpm.gz
hiddenmenu

title WinXp
rootnoverify <span>(</span>hd0,0<span>)</span>
<span>#指定Windows XP的启动分区。是第一块硬盘的第一个分区</span>
<span>#rootnoverify是不检测此分区的意思</span>
makeactive
<span>#设定分区为激活状态</span>
chainloader +1
<span>#把启动过程转交给此分区的第一个扇区</span>

title CentOS <span>(</span><span>2.6</span>.32-279.el6.i686<span>)</span>
	root <span>(</span>hd0,5<span>)</span>
	<span>#Linux系统的/boot分区安装到了第一块硬盘的第六个分区中</span>
	kemel/vmlinuz-2.6.32-279.el6.i686 ro
	<span>root</span><span>=</span>UUID<span>=</span>23e5c9d6-77a8-403a-8c0e2bfeffcab5ef rd_NO_LUKS <span>KEYBOARDTYPE</span><span>=</span>pc <span>KEYTABLE</span><span>=</span>us rd_NO_MD <span>crashkernel</span><span>=</span>auto <span><span>LANG</span></span><span>=</span>zh_CN.UTF-8 rd_NO_LVM  rd_NO_DM rhgb quiet
	initrd/initramfs-2.6.32-279.el6.i686.img
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>配置文件的变化主要是多了 WinXP 这一段。rootnoverify(hd0,0) 字段说明这个分区不检测，同时标称了 Windows  系统的启动分区在第一块硬盘的第一个分区中。也就是 Windows 系统的 C: 盘在第一块硬盘的第一个分区中。chainloader+1  的意思是，GRUB 会把启动过程转交到位于这个分区的第一个扇区（启动扇区）中的引导程序中。</p>
<p>我们已经知道，为了实现多系统启动，除 MBR 中可以安装启动引导程序外，每个分区的第一个扇区也可以安装启动引导程序。在这个例子中，Windows 系统的启动引导程序就被安装到了 C: 盘所在分区的启动扇区中，chainloader+1 就是 GRUB 把启动过程交给了 Windows  系统的启动引导程序，所以可以启动 Windows 系统。</p>
<h2 id="内核模块管理"> 内核模块管理</h2>
<p>Linux 的内核会在启动过程中自动检验和加载硬件与文件系统的驱动。一般这些驱动都是用模块的形式加载的，使用模块的形式保存驱动，可以不直接把驱动放入内核，有利于控制内核大小。</p>
<p>模块的全称是动态可加载内核模块，它是具有独立功能的程序，可以被单独编译，但不能独立运行。模块是为内核或其他模块提供功能的代码集合。这些模块可以是 Linux  源码中自带的，也可以是由硬件厂商开发的（可以想象成驱动）。不过内核因为发布时间较长，所以自带的模块可能版本较低，还有一些新硬件可能就不自带模块了，只能由硬件厂商在发布硬件的同时发布新模块。</p>
<p>也就是说，安装模块一般有两种方法：</p>
<ul>
<li>第一种方法在编译内核时，手工调整内核模块功能，加入所需的模块。这种方法有一个问题，就是内核必须支持这个硬件或功能才可以通过编译内核加入模块。如果硬件比内核新，内核本身并不支持硬件，就不能通过重新编译内核来加入新的硬件的支持。</li>
<li>第二种方法就是下载厂商发布的新硬件的驱动模块，或下载驱动程序，再编译成驱动模块，然后手工安装。</li>
</ul>
<p>我们主要来学习第二种方法，也就是如果我已经得到了一个模块，该如何手工安装？这个模块该如何得到呢？</p>
<p>如果是新硬件的驱动，则可以到硬件官方网站下载内核驱动或内核模块。如果下载的是内核模块，则直接安装即可；如果下载的是内核驱动源码，则只需要编译源码包，就会生成模块（具体编译过程和源码包安装非常类似，可以查看驱动的说明）。如果需要加入的模块不是硬件的驱动，而只是内核中的某项功能，那么，只要部分重新编译内核，就可以生成新功能的模块（我们会通过 NTFS 文件系统支持来学习这种方法），然后安装这个模块即可。</p>
<h3 id="内核模块保存位置与模块保存文件"> 内核模块保存位置与模块保存文件</h3>
<p>内核模块的保存位置在什么地方？其实在 <code>/lib/modules/内核版本/kernel/</code> 目录中，在 CentOS 6.x 中这个目录就是：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cd /lib/modules/2.6.32-279.el6.i686/kemel/</span>
</code></pre>
<div><span>1</span><br></div></div><p>查看一下目录内容：</p>
<div><pre><code><span>[</span>root@localhost kernel<span>]</span><span>#ls</span>
arch			<span>&lt;</span>---与硬件相关的模块
crypto			<span>&lt;</span>---内核支持的加密技术的相关模块
drivers			<span>&lt;</span>---硬件的驱动程序模块，如显卡、网卡等
fs				<span>&lt;</span>---文件系统模块，如 fat、vfat、nfs等
lib				<span>&lt;</span>---函数库
net				<span>&lt;</span>---网络协议相关模块
sound			<span>&lt;</span>---音效相关模块
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>Linux 中所有的模块都存放在 <code>/lib/modules/2.6.32-279.el6.i686/modules.dep</code>  文件中，在安装模块时，依赖这个文件査找所有的模块，所以不需要指定模块所在位置的绝对路径，而且也依靠这个文件来解决模块的依赖性。如果这个文件丢失了怎么办？不用担心，使用 <code>depmod</code> 命令会自动扫描系统中已有的模块，并生成 <code>modules.dep</code> 文件。命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># depmod [选项]</span>
<span>#不加选项，depmod命令会扫描系统中的内核模块，并写入modules.dep文件</span>
选项：
	-a：扫描所有模块；
	-A：扫描新模块，只有有新模块时，才会更新modules.dep文件；
	-n：把扫描结果不写入modules.dep文件，而是输出到屏幕上；
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>我们把 modules.dep文件删除，看看使用 <code>depmod</code> 命令是否可以重新生成这个文件。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cd /lib/modules/2.6.32-279.el6.i686/</span>
<span>#进入模块目录</span>
<span>[</span>root@localhost <span>2.6</span>.32-279.el6.i686<span>]</span><span># rm -rf modules.dep</span>
<span>#删除 modules.dep文件</span>
<span>[</span>raot@localhost <span>2.6</span>.32-279.el6.i686<span>]</span><span># depmod</span>
<span>#重新扫描模块</span>
<span>[</span>root@localhost <span>2.6</span>.32-279.el6.i686<span>]</span><span># ls -l modules.dep</span>
-rw-r--r--. <span>1</span> root root <span>191899</span> <span>5</span> 月 <span>23</span> 07:09 modules.dep
<span>#再查看一下，modules.dep文件又生成了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><code>depmod</code> 命令会扫描系统中所有的内核模块，然后把扫描结果放入 modules.dep 文件。后续的模块安装或删除就依赖这个文件中的内容。也就是说，如果我们要手工安装一个模块，则需要先把模块复制到指定位置，一般复制至  <code>/lib/modules/2.6.32-279.el6.i686/kernel/</code> 目录中，使用 <code>depmod</code> 命令扫描之后，才能继续安装。</p>
<h3 id="内核模块的查看"> 内核模块的查看</h3>
<p>使用 <code>lsmod</code> 命令可以查看系统中到底安装了哪些内核模块。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># lsmod</span>
Module				Size		Used by
autofs4 			<span>20981</span>		<span>3</span>
sunrpc				<span>215000</span>		<span>1</span>
ipt_REJECT			<span>1867</span>		<span>2</span>
nf_conntrack_ipv4	<span>7694</span>		<span>2</span>
nf_defrag_ipv4		<span>1039</span>		<span>1</span> nf_conntrack_ipv4
<span>..</span>.省略部分输出<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><code>lsmod</code> 命令的指定结果共有三列。</p>
<ul>
<li>Module：模块名。</li>
<li>Size：模块大小。</li>
<li>Used by：模块是否被其他模块调用。</li>
</ul>
<p>我们还可以使用 <code>modinfo</code> 命令来查看这些模块的说明，命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># modinfo 模块名</span>

<span>#例如：</span>
<span>[</span>root@localhost ~<span>]</span><span># modinfo autofs4</span>
filename:	/lib/modules/2.6.32-279.el6.i686/kernel/fs/autofs4/autofs4.ko
license:	GPL
srcversion:	4F798AD1AD66D2CBBB5D953
depends:
vermagic:	<span>2.6</span>.32-279.el6.i686 SMP mod_unload modversions <span>686</span>
<span>#能够看到模块名，来源和简易说明</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="内核模块的添加与删除"> 内核模块的添加与删除</h3>
<p>其实，如果模块已经下载到本机了，那么安装模块的方法非常简单。首先需要把模块复制到指定位置，一般复制到 <code>/lib/modules/2.6.32-279.el6.i686/kemel/</code> 目录中，模块的扩展名一般是 *<strong>.ko</strong>；然后需要执行 <code>depmod</code> 命令扫描这些新模块，并写入 modules.dep 文件；最后就可以利用 <code>modprobe</code> 命令安装这些模块了。命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># modprobe [选项] 模块名</span>
选项：
	-l：列出所有模块的文件名，依赖 modules.dep 文件
	-f：强制加载模块
	-r：删除模块
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>举个例子，我们需要安装 vfat 模块（fat32 文件系统的模块)，那么需要执行如下命令即可：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># modprobe vfat</span>
<span>#安装vfat模块</span>
<span>[</span>root@localhost ~<span>]</span><span># lsmod | grep vfat</span>
vfat	<span>8575</span>	<span>0</span>
fat		<span>47049</span>	<span>1</span>	vfat
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>vfat 模块是系统中的默认模块，所以不需要执行 <code>depmod</code> 命令进行扫描。如果是外来模块，则必须执行 <code>depmod</code> 命令。因为已经把模块的完整文件名写入了 modules.dep 文件，所以安装模块的命令不需要写绝对路径。</p>
<p>那么，如何删除这个模块呢？命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># modprobe -r vfat</span>
<span>[</span>root@localhost ~<span>]</span><span># lsmod | grep vfat</span>
<span>#查找为空</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="安装ntfs文件系统模块"> 安装NTFS文件系统模块</h3>
<p>在 CentOS 6.x 中，默认 NTFS 文件系统是没有安装的，也就是说在 CentOS 6.x 中是不能直接挂载 NTFS 分区的。但是目前 Windows 的分区绝大多数是 NTFS 分区，这就需要在 CentOS 6.x 中安装 NTFS 文件系统的模块之后，才能使用 NTFS 分区。</p>
<p>安装 NTFS 文件系统模块的方法有三种：</p>
<ul>
<li>第一种方法是完整地重新编译内核，然后在内核中选择 NTFS 功能，但这种方法过于麻烦，如果只是为了加入 NTFS 支持，则不建议采用这么复杂的方法；</li>
<li>第二种方法是得到 NTFS 文件系统模块（可以到互联网上下载，也可以利用本机的内核部分编译之后产生，不用完整地编译内核，要简单方便得多），然后使用 <code>modprobe</code> 命令安装，本小节就来介绍这种方法；</li>
<li>第三种方法是安装 NTFS 文件系统的第三方插件，如 NTFS-3G，这种插件安装简单、功能完整，我们也会讲讲这种方法；</li>
</ul>
<h4 id="得到-ntfs-文件系统模块后-手动安装"> 得到 NTFS 文件系统模块后，手动安装</h4>
<p>如果使用这种方法，则首先需要得到 NTFS 文件系统模块，这些模块一般是用 *<strong>.ko</strong> 作为扩展名的。我们可以直接在互联网上找到 ntfs.ko 的模块文件下载之后安装；也可以下载完整的内核源码，自己编译生成 ntfs.ko 模块，然后安装。</p>
<p>我们采用第二种方法。具体步骤如下。</p>
<ol>
<li><strong>下载内核</strong></li>
</ol>
<p>我们可以到内核的官方网站下载和本机安装的内核版本相同的内核源码。本机内核的版本可以使用 uname -r 命令查看，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># uname -r</span>
<span>2.6</span>.32-279.el6.i686
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这里下载的是 linux-2.6.32.tar.bz2 这个内核源码。我们可能会发现，在内核官网上找到的内核源码的版本可能和本机内核的版本不完全相同，这不会有太大影响，只需找到和本机版本差不多的内核源码即可。</p>
<p>另外，在 2.4.x 内核版本中，我们可以通过 RPM 包安装完整的内核源码到本机，而不用去官网下载。但是在 2.6.x 内核版本之后，如果采用 RPM 包的方式安装内核源码，则只会安装部分源码文件，而不会安装完整的内核源码文件。RPM  包安装的内核源码是不能进行正常编译和安装的，所以只能到内核的官方网站上下载完整的内核源码。</p>
<ol start="2">
<li><strong>解压内核</strong></li>
</ol>
<p>下载的内核是压缩包，需要解压。解压命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># tar -jxvf linux-2.6.32.tar.bz2</span>
<span>[</span>root@localhost ~<span>]</span><span># cp -r linux-2.6.32 /usr/src/kernels/</span>
<span>#复制内核源码到默认内核源码保存位置</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ol start="3">
<li><strong>生成内核编译所需的 .config 文件</strong></li>
</ol>
<p>在进行内核编译时，是需要依赖 <code>.config</code> 配置文件来配置内核功能的，这个文件是通过 <code>make menuconfig</code> 命令生成的。</p>
<p>不过，我们在这里不讲解完整的内核编译过程，只是为了生成 ntfs.ko 文件，那么我们就不需要执行复杂的 <code>make menuconfig</code>  命令了。我们可以安装 RPM 包的内核，虽然 RPM 包安装的内核源码并不完整（早期 Linux 版本会安装完整的内核源码），但是有  <code>.config</code> 配置文件，我们可以直接利用这个配置文件，而不需要使用 <code>make menuconfig</code> 命令自己生成 <code>.config</code>  配置文件（在进行真正的内核编译时，是需要使用 <code>make menuconfig</code> 命令来配置自己需要的功能，并生成 <code>.config</code> 配置文件的）。  命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mount /dev/cdrom /mnt/cdrom/</span>
<span>[</span>root@localhost ~<span>]</span><span># rpm -ivh /mnt/cdrom/Packages/ kemel-devel-2.6.32-279.el6.i686.rpm</span>
<span>#安装RPM包的不完整的内核源码</span>
<span>[</span>root@localhost ~<span>]</span><span># cp /usr/src/kemels/2.6.32-279.el6.i686/.config /usr/src/kemels/linux-2.6.32/</span>
<span>#从RPM包的内核源码中复制.config配置文件到源码包的内核源码中</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这样我们就有了 <code>.config</code> 配置文件，当然也可以通过 <code>make menuconfig</code> 命令生成这个配置文件。不过我们现在还没有学习内核的编译过程，所以采用了这种简单的办法。当然，还要修改一下 <code>.config</code> 配置文件，让它支持  NTFS 文件系统。需要把 <u>#CONFIG_NTFS_FS is not set</u> 这行代码改为  <u>CONFIG_NTFS_FS=m</u>，意思是用模块形式加载 NTFS 文件系统。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vi /usr/src/kernels/ linux-2.6.32/.config</span>
<span>..</span>.省略部分输出<span>..</span>.
<span># CONFIG_NTFS_FS is not set</span>
<span>#改为</span>
<span>CONFIG_NTFS_FS</span><span>=</span>m
<span>..</span>省略部分输出<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ol start="4">
<li><strong>编译模块</strong></li>
</ol>
<p>使用 <code>make modules</code> 命令来编译所有的模块，因为我们开启了 NTFS 文件系统模块，所以会生成 ntfs.ko 文件。当然，编译要想正确进行，gcc 编译器是必须安装的。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cd /usr/src/kernels/linux-2.6.32/</span>
<span>#编译命令一定要进入内核目录才能执行，因为编译命令编译的是模块当前所在目录</span>
<span>[</span>root@localhost linux-2.6.32<span>]</span><span># make modules</span>
<span>#在命令执行过程中，需要选择安装哪些模块，这时只选择NTFS相关模块，其他模块都不安装，这样能加快安装速度。注意：需要选择的选项较多，不要漏选</span>
<span>..</span>.省略部分输出<span>..</span>.
NTFS <span>file</span> system support <span>(</span>NTFS_FS<span>)</span> <span>[</span>M/n/y/?<span>]</span> m
NTFS debugging support <span>(</span>NTFS_DEBUG<span>)</span> <span>[</span>N/y/?<span>]</span> <span>(</span>NEW<span>)</span>y
NTFS <span>write</span> support <span>(</span>NTFS_RW<span>)</span> <span>[</span>N/y/?<span>]</span> <span>(</span>NEW<span>)</span>y
<span>#只有这几个功能选择y(安装)或m(安装成模块),其他功能都不需要安装</span>
<span>..</span>.省略部分输出<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>接下来需要等待编译过程结束，就能看到 ntfs.ko 模块了。命令如下：</p>
<div><pre><code><span>[</span>root@localhost linux-2.6.32<span>]</span><span># ll /usr/src/kemels/linux-2.6.32/fe/ntfs/ntfs.ko</span>
-rw-r--r--. <span>1</span> root root <span>3175255</span> <span>6</span> 月 <span>4</span> <span>18</span>:57 /usr/src/ kemels/linux-2.6.32/
fs/ntfs/ntfs.ko
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ol start="5">
<li><strong>模块安装</strong></li>
</ol>
<p>我们有了 ntfs.ko 模块，接下来的安装过程就比较简单了。先把 ntfs.ko 复制到指定位置，命令如下：</p>
<div><pre><code><span>[</span>root@localhost linux-2.6.32<span>]</span><span># cp ./fe/ntfs/ntfe.ko /lib/modules/2.6.32-279.el6.i686/kemel/fs/</span>
</code></pre>
<div><span>1</span><br></div></div><p>然后开始模块安装，命令如下：</p>
<div><pre><code><span>[</span>root@localhost linux-2.6.32<span>]</span><span># depmod -a</span>
<span>#扫描所有模块</span>
<span>[</span>root@localhost linux-2.6.32<span>]</span><span># modprobe ntfs</span>
<span>#安装ntfs模块</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果 <code>modprobe ntfs</code> 命令报错，那是因为版本不符。这个问题很好解决，只要执行如下命令：</p>
<div><pre><code><span>[</span>root@localhost linux-2.6.32<span>]</span><span># modprobe -f ntfs</span>
<span>#-f：强制</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>强制安装 ntfs 模块即可。然后查询一下：</p>
<div><pre><code><span>[</span>root@localhost linux-2.6.32<span>]</span><span>#lsmod | grep ntfs</span>
ntfs <span>93874</span> <span>0</span> <span>[</span>permanent<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这样 ntfs 模块就安装成功了，我们就可以尝试挂载和使用 NTFS 的分区或移动硬盘了。</p>
<p>注意，虽然我们使用了部分内核编译命令，但是我们的目的不是编译内核，而只是生成 ntfs.ko  模块，所以不需要完成内核的完整编译与安装过程。而且，如果执行了 <code>make install</code> 命令，那么安装的新内核有 ntfs  功能，其他功能都不存在，新内核是不能正确使用的。</p>
<h4 id="利用-ntfs-3g-插件安装-ntfs-文件系统模块"> 利用 NTFS-3G 插件安装 NTFS 文件系统模块</h4>
<p>我们已经学习了利用 ntfs.ko 模块安装 NTFS 文件系统，这种方法生成 ntfs.ko 模块比较麻烦。如果采用安装 NTFS-3G 插件的方式安装 NTFS 文件系统，则更加简单和方便。具体步骤如下。</p>
<ol>
<li><strong>下载 NTFS-3G 插件</strong></li>
</ol>
<p>首先，下载 NTFS-3G 插件到 Linux 服务器上。</p>
<ol start="2">
<li><strong>安装 NTFS-3G 插件</strong></li>
</ol>
<p>在编译安装 NTFS-3G 插件之前，要保证 gcc 编译器已经安装。具体安装命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># tar -zxvf ntfs-3g_ntfsprogs-2013.1.13.tgz</span>
<span>#解压</span>
<span>[</span>root@localhost ~<span>]</span><span># cd ntfs-3g_ntfeprogs-2013.1.13</span>
<span>#进入解压目录</span>
<span>[</span>root@localhost ntfs-3g_ntfsprogs-2013.1.13<span>]</span><span># ./configure</span>
<span>#编译器准备。没有指定安装目录，安装到默认位置</span>
<span>[</span>root@localhost ntfs-3g_ntfsprogs-2013.1.13<span>]</span><span># make</span>
<span>#编译</span>
<span>[</span>root@localhost ntfs-3g_ntfsprogs-2013.1.13<span>]</span><span># make install</span>
<span>#编译安装</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>这样安装就完成了，可以挂载和使用 Windows 的 NTFS 分区了。不过需要注意，挂载分区时的文件系统不是 NTFS，而是 NTFS-3G。挂载命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mount -t ntfs-3g 分区设备文件名 挂载点</span>

<span>#例如：</span>
<span>[</span>root@localhost ~<span>]</span><span># mount -t ntfe-3g /dev/sdb1 /mnt/win</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这样看来，使用安装 NTFS-3G 插件的方式比安装 NTFS 文件系统更加简便方便。</p>
<h2 id="系统修复模式"> 系统修复模式</h2>
<p>在操作系统的使用过程中，因为人为的误操作，或者系统非正常关机，都有可能造成系统错误，从而导致系统不能正常启动。Linux 为我们准备了完善的修复手段。本节主要介绍单用户模式和光盘修复模式这两种修复手段。</p>
<h3 id="单用户模式"> 单用户模式</h3>
<p>Linux 的单用户模式有些类似 Windows 的安全模式，只启动最少的程序用于系统修复。在单用户模式（运行级别为 1）中，Linux 引导进入根 Shell，网络被禁用，只有少数进程运行单用户模式可以用来修改文件系统损坏、还原配置文件、移动用户数据等。</p>
<ol>
<li><strong>如何进入单用户模式</strong></li>
</ol>
<p>当然不能直接执行命令 <code>init 1</code> 了，因为我们的假设是系统出现了问题，已经不能正常登录了。那么，如何进入单用户模式呢？首先需要重启服务器，在 GRUB 读秒界面按任意键，进入 GRUB 菜单界面，如图2-5 所示。</p>
<div>
<p><img src="./assets/s1.png" alt="s1" loading="lazy"></p>
<p><strong>图2-5	<u>GRUB 菜单界面</u></strong></p>
</div>
<p>在想要进入单用户模式的 Linux 菜单上按 <kbd>e</kbd> 键，就会进入 GRUB 编辑界面，如图2-6 所示。</p>
<div>
<p><img src="./assets/s2.png" alt="s2" loading="lazy"></p>
<p><strong>图2-6	<u>GRUB 编辑界面</u></strong></p>
</div>
<p>在 GRUB 编辑界面中，移动光标到第二行 kernel 行，然后继续按 <kbd>e</kbd> 键，进入行编辑界面。在此行最后输入“空格 single”（或者“空格 1”），代表启动进入单用户模式（注意：空格必须存在），如图2-7 所示。</p>
<div>
<p><img src="./assets/s3.png" alt="s3" loading="lazy"></p>
<p><strong>图2-7	<u>GRUB 行编辑界面</u></strong></p>
</div>
<p>然后按回车键，就会回到上一个界面。再按 <kbd>b</kbd> 键（启动），就会启动进入单用户模式。单用户模式是不需要输入用户名和密码就能直接进入提示符界面的，如图2-8 所示。</p>
<div>
<p><img src="./assets/s4.png" alt="s4" loading="lazy"></p>
<p><strong>图2-8	<u>单用户模式提示符界面</u></strong></p>
</div>
<p>我们已经登录了 Linux 系统的单用户模式，而且是不需要输入用户名和密码就可以直接进入的。这时如果有系统问题，就可以在单用户模式中进行修复了。</p>
<ol start="2">
<li><strong>单用户模式常见的错误修复</strong></li>
</ol>
<p>我们已经进入了单用户模式，那么我们在单用户模式中主要可以修复哪些系统错误呢？下面举几个例子。</p>
<ul>
<li>遗忘 root 密码</li>
</ul>
<p>这是管理员最容易犯的错误，应该如何修复呢？当然是使用单用户模式进行修复了，因为 Linux 启动管理进入单用户模式的最大特点就是不需要输入用户名和密码。既然已经登录了单用户模式，那么直接给 root 用户设定新密码即可。命令如下：</p>
<div><pre><code><span>[</span>root@localhost /<span>]</span><span># passwd root</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>修改系统默认运行级别</li>
</ul>
<p>如果我们把系统的默认运行级别修改错误，比如改为了 0 或 6，系统就不能正常启动了。</p>
<p>这时也可以利用单用户模式进行修复，只需直接修改默认运行级别配置文件 <code>/etc/inittab</code>，把系统默认运行级别修改回来即可。命令如下：</p>
<div><pre><code><span>[</span>root@localhost /<span>]</span><span># vi /etc/inittab</span>
id:3:initdefault:
<span>#把默认运行级别修改为 3 或 5。注意：系统的默认运行级别只能使用 3 或 5</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>理论上，只要能够进入单用户模式，那么系统错误就可以在单用户模式中进行修复。当然，判断系统到底哪里出现了问题，是需要大量的经验积累的。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2022-01-26T06:11:29.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">linux系统服务管理</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_manage/02.linux_service/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_manage/02.linux_service/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>什么是系统服务？服务是在后台运行的应用程序，并且可以提供一些本地系统或网络的功能。</p>
<p>那么，Linux 中常见的服务有那些，这些服务怎么分类，服务如何启动，服务如何自启动，服务如何查看？</p>
<p>其实服务管理并不难，但是 Linux 中服务的分类比较多，而且每种服务又有多种启动和自启动方法，所以容易混淆。同时，常见网络服务的端口号也是必须掌握的基础知识。</p>
<h2 id="服务的简介与分类"> 服务的简介与分类</h2>
<p>我们知道，系统服务是在后台运行的应用程序，并且可以提供一些本地系统或网络的功能。我们把这些应用程序称作服务，也就是 Service。不过，我们有时会看到 Daemon 的叫法，Daemon 的英文原意是&quot;守护神&quot;，在这里是&quot;守护进程&quot;的意思。</p>
<p>那么，什么是守护进程？它和服务又有什么关系呢？守护进程就是为了实现服务、功能的进程。比如，我们的 apache 服务就是服务（Service），它是用来实现 Web 服务的。那么，启动 apache 服务的进程是哪个进程呢？就是 httpd 这个守护进程（Daemon）。也就是说，守护进程就是服务在后台运行的真实进程。</p>
<p>如果我们分不清服务和守护进程，那么也没有什么关系，可以把服务与守护进程等同起来。在 Linux 中就是通过启动 httpd 进程来启动 apache 服务的，你可以把 httpd 进程当作 apache 服务的别名来理解。</p>
<h3 id="服务的分类和区分"> 服务的分类和区分</h3>
<ol>
<li><strong>服务的分类</strong></li>
</ol>
<p>Linux 中的服务按照安装方法不同可以分为 RPM 包默认安装的服务和源码包安装的服务两大类。其中，RPM 包默认安装的服务又因为启动与自启动管理方法不同分为独立的服务和基于 xinetd 的服务。服务分类的关系图如图3-1 所示。</p>
<div>
<p><img src="./assets/service.jpg" alt="service" loading="lazy"></p>
<p><strong>图3-1	<u>服务分类的关系图</u></strong></p>
</div>
<p>我们知道，Linux 中常见的软件包有两种：一种是 RPM 包；另一种是源码包。那么，通过 RPM 包安装的系统服务就是 RPM  包默认安装的服务（因为 Linux 光盘中全是 RPM 包，Linux 系统也是通过 RPM 包安装的，所以我们把 RPM 包又叫作系统默认包），通过源码包安装的系统服务就是源码包安装的服务。</p>
<p>源码包是开源的，自定义性强，通过编译安装更加适合系统，但是安装速度较慢，编译时容易报错。RPM 包是经过编译的软件包，安装更快速，不易报错，但不再是开源的。</p>
<p>以上这些特点都是软件包本身的特点，但是软件包一旦安装到 Linux 系统上，它们的区别是什么呢？</p>
<p>最主要的区别就是安装位置不同，源码包安装到我们手工指定的位置当中，而 RPM 包安装到系统默认位置当中（可以通过 <code>rpm -ql 包名</code> 命令查询）。也就是说，RPM  包安装到系统默认位置，可以被服务管理命令识别；但是源码包安装到手工指定位置，当然就不能被服务管理命令识别了（可以手工修改为被服务管理命令识别）。</p>
<p>所以，RPM 包默认安装的服务和源码包安装的服务的管理方法不同，我们把它们当成不同的服务分类。服务分类说明如下。</p>
<p>RPM 包默认安装的服务。这些服务是通过 RPM 包安装的，可以被服务管理命令识别。</p>
<p>这些服务又可以分为两种：</p>
<ul>
<li>独立的服务：就是独立启动的意思，这种服务可以自行启动，而不用依赖其他的管理服务。因为不依赖其他的管理服务，所以，当客户端请求访问时，独立的服务响应请求更快速。目前，Linux 中的大多数服务都是独立的服务，如 apache 服务、FTP 服务、Samba 服务等。</li>
<li>基于 xinetd 的服务：这种服务就不能独立启动了，而要依靠管理服务来调用。这个负责管理的服务就是 xinetd 服务。xinetd  服务是系统的超级守护进程，其作用就是管理不能独立启动的服务。当有客户端请求时，先请求 xinetd 服务，由 xinetd 服务去唤醒相对应的服务。当客户端请求结束后，被唤醒的服务会关闭并释放资源。这样做的好处是只需要持续启动 xinetd 服务，而其他基于 xinetd 的服务只有在需要时才被启动，不会占用过多的服务器资源。但是这种服务由于在有客户端请求时才会被唤醒，所以响应时间相对较长。</li>
</ul>
<p>源码包安装的服务。这些服务是通过源码包安装的，所以安装位置都是手工指定的。由于不能被系统中的服务管理命令直接识别，所以这些服务的启动与自启动方法一般都是源码包设计好的。每个源码包的启动脚本都不一样，一般需要查看说明文档才能确定。</p>
<ol start="2">
<li><strong>查询已经安装的服务和区分服务</strong></li>
</ol>
<p>我们已经知道 Linux 服务的分类了，那么应该如何区分这些服务呢？首先要区分 RPM 包默认安装的服务和源码包安装的服务。源码包安装的服务是不能被服务管理命令直接找到的，而且一般会安装到 <code>/usr/local/</code> 目录中。</p>
<p>也就是说，在 <code>/usr/local/</code> 目录中的服务都应该是通过源码包安装的服务。RPM 包默认安装的服务都会安装到系统默认位置，所以是可以被服务管理命令（如 <code>service</code>、<code>chkconfig</code>）识别的。</p>
<p>其次，在 RPM 包默认安装的服务中怎么区分独立的服务和基于 xinetd 的服务？这就要依靠 <code>chkconfig</code> 命令了。<code>chkconfig</code> 是管理 RPM 包默认安装的服务的自启动的命令，这里仅利用这条命令的查看功能。使用这条命令还能看到 RPM 包默认安装的所有服务。命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># chkconfig --list [服务名]</span>
选项：
	--list：列出 RPM 包默认安装的所有服务的自启动状态；

<span>#例如：</span>

<span>[</span>root@localhost ~<span>]</span><span># chkconfig -list</span>
<span>#列出系统中RPM包默认安装的所有服务的自启动状态</span>
abrt-ccpp	<span>0</span>:关闭 <span>1</span>:关闭 <span>2</span>:关闭 <span>3</span>:启用	<span>4</span>:关闭 <span>5</span>:启用 <span>6</span>:关闭
abrt-oops	<span>0</span>:关闭 <span>1</span>:关闭 <span>2</span>:关闭 <span>3</span>:启用 <span>4</span>:关闭 <span>5</span>:启用 <span>6</span>:关闭
<span>..</span>.省略部分输出<span>..</span>.
udev-post	<span>0</span>:关闭 <span>1</span>:启用 <span>2</span>:启用 <span>3</span>:启用 <span>4</span>:启用 <span>5</span>:启用 <span>6</span>:关闭
ypbind		<span>0</span>:关闭 <span>1</span>:关闭 <span>2</span>:关闭 <span>3</span>:关闭 <span>4</span>:关闭 <span>5</span>:关闭 <span>6</span>:关闭
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>这条命令的第一列为服务的名称，后面的 0~6  代表在不同的运行级别中这个服务是否开启时自动启动。这些服务都是独立的服务，因为它们不需要依赖其他任何服务就可以在相应的运行级别启动或自启动。但是没有看到基于 xinetd 的服务，那是因为系统中默认没有安装 xinetd 这个超级守护进程，需要我们手工安装。</p>
<p>安装命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># rpm -ivh /mnt/cdrom/Packages/xinetd-2.3.14-34.el6.i686.rpm</span>
Preparing<span>..</span>.
<span>###############</span>
<span>[</span><span>100</span>%<span>]</span>
<span>1</span>:xinetd
<span>###############</span>
<span>[</span><span>100</span>%<span>]</span>
<span>#xinetd超级守护进程</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>这里需要注意的是，在 Linux 中基于 xinetd 的服务越来越少，原先很多基于 xinetd 的服务在新版本的 Linux 中已经变成了独立的服务。安装完 xinetd 超级守护进程之后，我们再查看一下，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># chkconfig --list</span>
abrt-ccpp	<span>0</span>:关闭 <span>1</span>:关闭 <span>2</span>:关闭 <span>3</span>:启用 <span>4</span>:关闭 <span>5</span>:启用 <span>6</span>:关闭
abrt-oops	<span>0</span>:关闭 <span>1</span>:关闭 <span>2</span>:关闭 <span>3</span>:启用 <span>4</span>:关闭 <span>5</span>:启用 <span>6</span>:关闭
<span>..</span>.省略部分输出<span>..</span>.
udev-post 	<span>0</span>:关闭 <span>1</span>:启用 <span>2</span>:启用 <span>3</span>:启用 <span>4</span>:启用 <span>5</span>:启用 <span>6</span>:关闭
xinetd 		<span>0</span>:关闭 <span>1</span>:关闭 <span>2</span>:关闭 <span>3</span>:启用 <span>4</span>:启用 <span>5</span>:启用 <span>6</span>:关闭
ypbind 		<span>0</span>:关闭 <span>1</span>:关闭 <span>2</span>:关闭 <span>3</span>:关闭 <span>4</span>:关闭 <span>5</span>:关闭 <span>6</span>:关闭
基于 xinetd 的服务：
	chargen-dgram：		关闭
	chargen-stream：	关闭
	cvs：				关闭
	daytime-dgram：		关闭
	daytime-stream：	关闭
	discard-dgram：		关闭
	discard-stream：	关闭
	echo-dgram：		关闭
	echo-stream：		关闭
	rsync：				关闭
	tcpmux-server：		关闭
	time-dgram：		关闭
	time-stream：		关闭
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>在刚刚的独立的服务之下出现了一些基于 xinetd 的服务，这些服务没有自己的运行级别，因为它们不是独立的服务，到底在哪个运行级别可以自启动，则要看 xinetd 服务是在哪个运行级别自启动的。</p>
<h3 id="服务和端口"> 服务和端口</h3>
<ol>
<li><strong>端口简介</strong></li>
</ol>
<p>服务是给系统提供功能的，在系统中除了有系统服务，还有网络服务。而每个网络服务都有自己的端口，一般端口号都是固定的。那么，什么是端口呢？</p>
<p>我们知道，IP 地址是计算机在互联网上的地址编号，每台联网的计算机都必须有自己的 IP 地址，而且必须是唯一的，这样才能正常通信。也就是说，在互联网上是通过 IP 地址来确定不同计算机的位置的。</p>
<p>大家可以把 IP 地址想象成家庭的&quot;门牌号码&quot;，不管你住的是大杂院、公寓楼还是别墅，都有自己的门牌号码，而且门牌号码是唯一的。</p>
<p>如果知道了一台服务器的 IP 地址，我们就可以找到这台服务器。但是这台服务器上有可能搭建了多个网络服务，比如 WWW 服务、FTP  服务、Mail 服务，那么我们到底需要服务器为我们提供哪个网络服务呢？这时就要靠端口（Port）来区分了，因为每个网络服务对应的端口都是固定的。</p>
<p>比如，WWW 服务对应的端口是 80，FTP 服务对应的端口是 20 和 21，Mail 服务对应的端口是 25 和 110。也就是说，IP 地址可以想象成&quot;门牌号码&quot;，而端口可以想象成&quot;家庭成员&quot;，找到了 IP 地址只能找到你们家，只有找到了端口，寄信时才能找到真正的收件人。</p>
<p>为了统一整个互联网的端口和网络服务的对应关系，以便让所有的主机都能使用相同的机制来请求或提供服务，同一个服务使用相同的端口，这就是协议。</p>
<p>计算机中的协议主要分为两大类：</p>
<ul>
<li>面向连接的可靠的 TCP 协议（Transmission Control Protocol，传输控制协议）；</li>
<li>面向无连接的不可靠的 UDP 协议（User Datagram Protocol，用户数据报协议）；</li>
</ul>
<p>这两种协议都支持 2<sup>16</sup>，也就是 65535 个端口。这么多端口怎么记忆呢？系统给我们提供了服务与端口的对应文件 <code>/etc/services</code>。 查看—下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vi /etc/services</span>
<span>..</span>.省略部分输出<span>..</span>.
ftp-data <span>20</span>/tcp
ftp-data <span>20</span>/udp
<span># 21 is registered to ftp, but also used by fsp</span>
<span>ftp</span> <span>21</span>/tcp
<span>ftp</span> <span>21</span>/udp
fsp fspd
<span>#FTP服务的端口</span>
<span>..</span>.省略部分输出<span>..</span>.
smtp <span>25</span>/tcp mail
smtp <span>25</span>/udp mail
<span>#邮件发送信件的端口</span>
<span>..</span>.省略部分输出<span>..</span>.
http <span>80</span>/tcp www www-http	<span>#WorldWideWeb HTTP</span>
http <span>80</span>/udp www www-http	<span>#HyperText Transfer Protocol</span>
<span>#WWW服务的端口</span>
<span>..</span>.省略部分输出<span>..</span>.
pop3 <span>110</span>/tcp pop-3			<span># POP version 3</span>
pop3 <span>110</span>/udp pop-3
<span>#邮件接收信件的端口</span>
<span>..</span>.省略部分输出<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>网络服务的端口能够修改吗？当然是可以的，不过一旦修改了端口，那么客户机在访问服务器时很难知道服务器对应的端口是什么，也就不能正确地获取服务了。所以，除非在实验环境下，否则不要修改网络服务对应的端口。</p>
<ol start="2">
<li><strong>查询系统中已经启动的服务</strong></li>
</ol>
<p>既然每个网络服务对应的端口是固定的，那么是否可以通过查询服务器中开启的端口，来判断当前服务器开启了哪些服务？</p>
<p>当然是可以的。虽然判断服务器中开启的服务还有其他方法（如通过 <code>ps</code> 命令），但是通过端口的方法查看最为准确。命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># netstat 选项</span>
选项：
	-a：列出系统中所有网络连接，包括已经连接的网络服务、监听的网络服务和 Socket 套接字
	-t：列出 TCP 数据
	-u：列出 UDF 数据
	-l：列出正在监听的网络服务（不包含已经连接的网络服务）
	-n：用端口号来显示而不用服务名
	-p：列出该服务的进程 ID <span>(</span>PID<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>举个例子：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># netstat -tlunp</span>
<span>#列出系统中所有已经启动的服务（已经监听的端口），但不包含已经连接的网络服务</span>
Active Internet connections <span>(</span>only servers<span>)</span>
Proto	Recv-Q	Send-Q	Local Address	Foreign Address	State	PID/Program	name
tcp		<span>0</span>		<span>0</span>		<span>0.0</span>.0.0:53575	<span>0.0</span>.0.0:*		LISTEN	<span>1200</span>/rpc.statd
tcp		<span>0</span>		<span>0</span>		<span>0.0</span>.0.0:111		<span>0.0</span>.0.0:* 		LISTEN	<span>1181</span>/rpcbind
tcp		<span>0</span>		<span>0</span>		<span>0.0</span>.0.0:22		<span>0.0</span>.0.0:*		LISTEN	<span>1405</span>/sshd
tcp		<span>0</span>		<span>0</span>		<span>127.0</span>.0.1:631	<span>0.0</span>.0.0:*		LISTEN	<span>1287</span>/cupsd
tcp		<span>0</span>		<span>0</span>		<span>127.0</span>.0.1:25	<span>0.0</span>.0.0:*		LISTEN	<span>1481</span>/master
tcp		<span>0</span>		<span>0</span>		:::57454		:::*			LISTEN	<span>1200</span>/rpc.statd
tcp		<span>0</span>		<span>0</span>		:::111			:::*			LISTEN	<span>1181</span>/rpcbind
tcp		<span>0</span>		<span>0</span>		:::22			:::*			LISTEN	<span>1405</span>/sshd
tcp		<span>0</span>		<span>0</span>		::1:631			:::*			LISTEN	<span>1287</span>/cupsd
tcp		<span>0</span>		<span>0</span>		::1:25			:::*			LISTEN	<span>1481</span>/master
udp		<span>0</span>		<span>0</span>		<span>0.0</span>.0.0:58322	<span>0.0</span>.0.0:*				<span>1276</span>/avahi-daemon
udp		<span>0</span>		<span>0</span>		<span>0.0</span>.0.0:5353	O.O.O.O:*				<span>1276</span>/avahi-daemon
udp		<span>0</span>		<span>0</span>		<span>0.0</span>.0.0:111		O.O.O.O:*				<span>1181</span>/rpcbind
udp		<span>0</span>		<span>0</span>		<span>0.0</span>.0.0:631		<span>0.0</span>.0.0:*				<span>1287</span>/cupsd
udp		<span>0</span>		<span>0</span>		<span>0.0</span>.0.0:56459	<span>0.0</span>.0.0:*				<span>1200</span>/rpc.statd
udp		<span>0</span>		<span>0</span>		<span>0.0</span>.0.0:932		<span>0.0</span>.0.0:*				<span>1181</span>/rpcbind
udp 	<span>0</span>		<span>0</span>		<span>0.0</span>.0.0:952		<span>0.0</span>.0.0:*				<span>1200</span>/rpc.statd
udp		<span>0</span>		<span>0</span>		:::111			:::*					<span>1181</span>/rpcbind
udp		<span>0</span>		<span>0</span>		:::47858		:::*					<span>1200</span>/rpc.statd
udp		<span>0</span>		<span>0</span>		:::932			:::*					<span>1181</span>/rpcbind
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>执行这条命令会看到服务器上所有已经开启的端口，也就是说，通过这些端口就可以知道当前服务器上开启了哪些服务。</p>
<p>解释一下命令的执行结果：</p>
<ul>
<li>Proto：数据包的协议。分为 TCP 和 UDP 数据包；</li>
<li>Recv-Q：表示收到的数据已经在本地接收缓冲，但是还没有被进程取走的数据包数量；</li>
<li>Send-Q：对方没有收到的数据包数量；或者没有 Ack 回复的，还在本地缓冲区的数据包数量；</li>
<li>Local Address：<u>本地IP:端口</u>。通过端口可以知道本机开启了哪些服务；</li>
<li>Foreign Address：<u>远程主机:端口</u>。也就是远程是哪个 IP、使用哪个端口连接到本机。由于这条命令只能查看监听端口，所以没有 IP 连接到到本机；</li>
<li>State：连接状态。主要有已经建立连接（ESTABLISED）和监听（LISTEN）两种状态，当前只能查看监听状态；</li>
<li>PID/Program name：进程 ID 和进程命令；</li>
</ul>
<p>再举个例子：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># netstat -an</span>
<span>#查看所有的网络连接，包括已连接的网络服务、监听的网络服务和Socket套接字</span>
Active Internet connections <span>(</span>servers and established<span>)</span>
Proto	Recv-Q	Send-Q	Local Address		Foreign Address		State
tcp		<span>0</span>		<span>0</span>		<span>0.0</span>.0.0:53575		<span>0.0</span>.0.0:*			LISTEN
tcp		<span>0</span>		<span>0</span>		<span>0.0</span>.0.0:111			<span>0.0</span>.0.0:* 			LISTEN
tcp		<span>0</span>		<span>0</span>		<span>0.0</span>.0.0:22			<span>0.0</span>.0.0:*			LISTEN
tcp		<span>0</span>		<span>0</span>		<span>127.0</span>.0.1:631		<span>0.0</span>.0.0:*			LISTEN
tcp		<span>0</span>		<span>0</span>		<span>127.0</span>.0.1:25		<span>0.0</span>.0.0:*			LISTEN
tcp		<span>0</span>		<span>0</span>		<span>192.168</span>.0.210:22	<span>192.168</span>.0.105:4868	ESTABLISHED
tcp		<span>0</span>		<span>0</span>		:::57454			:::*				LISTEN
<span>..</span>.省略部分输出<span>..</span>.
udp		<span>0</span>		<span>0</span>		:::932				:::*
Active UNIX domain <span>[</span>socket<span>]</span> <span>(</span>servers and established<span>)</span>
Proto	RefCnt	Flags		Type	State		I-Node	Path
<span>#Socket套接字输出,后面有具体介绍</span>
unix	<span>2</span>		<span>[</span> ACC <span>]</span>		STREAM	LISTENING	<span>11712</span>	/var/run/dbus/system_bus_socket
unix	<span>2</span>		<span>[</span> ACC <span>]</span>		STREAM	LISTENING	<span>8450</span>	@/com/ubuntu/upstart
unix	<span>7</span>		<span>[</span> <span>]</span>			DGRAM				<span>8651</span>	@/org/kernel/udev/udevd
unix	<span>2</span>		<span>[</span> ACC <span>]</span>		STREAM	LISTENING	<span>11942</span>	@/var/run/hald/dbus-b4QVLkivf1
<span>..</span>.省略部分输出<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>执行 <code>netstat -an</code> 命令能査看更多的信息，在 Stated 中也看到了已经建立的连接（ESTABLISED）。这是 ssh 远程管理命令产生的连接，ssh 对应的端口是 22。</p>
<p>而且我们还看到了 Socket  套接字。在服务器上，除网络服务可以绑定端口，用端口来接收客户端的请求数据外，系统中的网络程序或我们自己开发的网络程序也可以绑定端口，用端口来接收客户端的请求数据。这些网络程序就是通过 Socket 套接字来绑定端口的。也就是说，网络服务或网络程序要想在网络中传递数据，必须利用 Socke 套接字绑定端口，并进行数据传递。</p>
<p>使用 <code>netstat -an</code> 命令查看到的这些 Socke 套接字虽然不是网络服务，但是同样会占用端口，并在网络中传递数据。</p>
<p>解释一下 Socket 套接字的输出：</p>
<ul>
<li>Proto：协议，一般是 unix；</li>
<li>RefCnt：连接到此Socket的进程数量；</li>
<li>Flags：连接标识；</li>
<li>Type：Socket访问类型；</li>
<li>State：状态，LISTENING 表示监听，CONNECTED 表示已经建立连接；</li>
<li>I-Node：程序文件的 i 节点号；</li>
<li>Path：Socke 程序的路径，或者相关数据的输出路径；</li>
</ul>
<h2 id="rpm-包默认安装的服务管理"> RPM 包默认安装的服务管理</h2>
<p>我们先来讲解 RPM 包默认安装的服务如何管理，这里的管理主要指的是启动管理和自启动管理。启动很好理解，就是在当前系统中让服务运行，并提供功能。自启动是指在系统开机或重新启动之后，随着系统的启动而自动启动服务。</p>
<p>我们一直说 RPM 包默认安装的服务和源码包安装的服务最主要的区别就是程序的安装位置不同。源码包安装的服务安装到了用户的指定位置，那么 RPM 包默认安装的服务到底安装到了哪里呢？这些位置是固定的，我们分别来看。</p>
<ul>
<li>
<p><code>/etc/init.d/</code>：RPM 包默认安装的服务中所有独立服务的启动脚本都放置在这里。在 <code>/etc/re.d/init.d/</code> 目录中放置的也是独立服务的启动脚本，这两个目录中的脚本文件是软链接，所以使用哪一个都可以。</p>
</li>
<li>
<p><code>/etc/sysconfig/</code>：这个目录用于放置 RPM 包默认安装的服务的初始化环境配置文件。服务会把自己在初始化过程中的一些参数设置写入这个目录中的文件。</p>
</li>
<li>
<p><code>/etc/</code>：这个目录用于放置 RPM 包默认安装的服务的配置文件。注意：源码包安装的服务的配置文件不在这里，而在源码包的安装目录中（源码包安装的服务的所有相关文件都在自己指定的安装目录中，所以删除源码包时可以直接删除安装目录）。</p>
</li>
<li>
<p><code>/etc/xinetd.conf</code>：超级守护进程 xinetd 的配置文件，这个文件基本不需要修改，因为 xinetd 进程是用来调用其他依赖它的服务的。</p>
</li>
<li>
<p><code>/etc/xinetd.d/</code>：这个目录中的文件就是基于 xinetd 服务的启动脚本。我们如果想要启动基于 xinetd 的服务，则需要修改这个目录中的文件。</p>
</li>
<li>
<p><code>/var/lib/</code>：RPM 包默认安装的服务如果产生了数据，就会把数据记录在这个目录中。如 RPM 包默认安装的 mysql 服务的数据库会存放在 <code>/var/lib/mysql/</code> 目录中。</p>
</li>
<li>
<p><code>/var/log/</code>：RPM 包默认安装的服务的日志都会放置在这个目录中。如 <code>/var/log/httpd/</code>目录就用于保存默认安装的 htpd 服务的日志。</p>
</li>
</ul>
<p>RPM 包默认安装的服务的主要安装位置就是这些，某些服务可能会有一些特殊文件没有安装到这里，如默认安装的 apache 服务的网页主目录 <code>/var/www/html/</code>，这些特殊文件在学到时再具体对待。</p>
<h3 id="独立服务管理"> 独立服务管理</h3>
<p>我们知道，RPM 包默认安装的服务分为**<u>独立的服务</u><strong>和</strong><u>基于 xinetd 的服务</u>**，那我们先来学习独立服务的管理。</p>
<ol>
<li><strong>独立服务的启动管理</strong></li>
</ol>
<p>独立的服务要想启动，主要有两种方法。</p>
<p><strong>1) 使用 <code>/etc/init.d/</code> 目录中的启动脚本来启动独立的服务</strong></p>
<p>既然所有独立服务的启动脚本都存放在 <code>/etc/init.d/</code> 目录中，那么，调用这些脚本就可以启动独立的服务了。这种启动方式是推荐启动方式，命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span>#/etc/init.d/独立服务名 start|stop|status|restart|...</span>
参数：
	start	：启动服务
	stop	：停止服务
	status	：查看服务状态
	restart	：重启动服务
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>我们以启动 RPM 包默认安装的 httpd 服务为例，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># /etc/init.d/httpd start</span>
正在启动httpd:										<span>[</span>确定<span>]</span>
<span>#启动httpd服务</span>
<span>[</span>root@localhost ~<span>]</span><span># /etc/init.d/httpd status</span>
httpd <span>(</span>pid <span>13313</span><span>)</span>正在运行<span>..</span>.
<span>#查询httpd服务状态，并能够看到httpd服务的PID</span>
<span>[</span>root@localhost ~<span>]</span><span>#/etc/init.d/httpd stop</span>
停止 httpd:											<span>[</span>确定<span>]</span>
<span>#停止httpd服务</span>
<span>[</span>root@localhost ~<span>]</span><span>#/etc/init.d/httpd restart</span>
停止httpd:											<span>[</span>失败<span>]</span>
正在启动httpd:										<span>[</span>确定<span>]</span>
<span>#重启动httpd服务</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><strong>2) 使用 <code>service</code> 命令来启动独立的服务</strong></p>
<p>在 CentOS 系统中，我们还可以依赖 <code>service</code> 命令来启动独立的服务。<code>service</code> 命令实际上只是一个脚本，这个脚本仍然需要调用 <code>/etc/init.d/</code> 中的启动脚本来启动独立的服务。而且 <code>service</code> 命令是红帽系列 Linux 的专有命令，其他的 Linux 发行版本不一定拥有这条命令，所以我们并不推荐使用 <code>service</code> 命令来启动独立的服务。</p>
<p><code>service</code> 命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># service 独立服务名 start|stop|restart|...</span>

例如：

<span>[</span>root@localhost ~<span>]</span><span># service httpd restart</span>
停止httpd:											<span>[</span>确定<span>]</span>
正在启动httpd:										<span>[</span>确定<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>命令比输入 <code>/etc/init.d/</code> 目录要稍微简单。<code>service</code> 命令还可以查看所有独立服务的启动状态，这是一个常用功能，命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># service --status-all</span>
选项：
	--status-all：列出所有独立服务的启动状态<span>;</span>

例如：
abrtd<span>(</span>pid <span>1505</span><span>)</span>正在运行…
abrt-dumpoops<span>(</span>pid <span>1513</span><span>)</span>正在运行…
acpid<span>(</span>pid <span>1312</span><span>)</span>正在运行<span>..</span>.
<span>..</span>.省略部分输出<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>随着 httpd 服务的启动和停止，使用 <code>netstat -tlun</code> 命令就会看到 80 端口出现和消失。这也就说明 apache 服务绑定的口就是 80，所以我们可以端口是否在服务器中出现来判断 apache 服务是否启动。</p>
<p><strong>2. 独立服务的自启动管理</strong></p>
<p>自启动指的是在系统之后，服务是否随着系统的启动而自动启动。如果启动了某个服务，那么这个服务会在系统重启之后启动吗？答案是不知道，因为启动命令只负责启动服务，而和服务的自启动完全没有关系。同样地，自启动命令只管服务是否会在系统重启之后启动，而和当前系统中的服务是否启动没有关系。</p>
<p>独立服务的自启动方法有三种，我们分别来学习。</p>
<p><strong>1) 使用 <code>chkconfig</code> 服务自启动管理命令</strong></p>
<p>第一种方法是利用 <code>chkconfig</code> 服务自启动管理命令来管理独立服务的自启动，这条命令的用法如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># chkconfig --list</span>
</code></pre>
<div><span>1</span><br></div></div><p>使用 <code>chkconfig</code> 命令除了可以查看所有 RPM 包默认安装服务的自启动状态，也可以修改和设置 RPM 包默认安装服务的自启动状态，只是独立的服务和基于 xinetd 的服务的设定方法稍有不同。我们先来看看独立的服务如何设置。命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># chkconfig [--level 运行级别] [独立服务名] [on|off]</span>
选项：
	--level: 设定在哪个运行级别中开机自启动（on），或者关闭自启动（off）；

例如：
<span>[</span>root@localhost ~<span>]</span><span># chkconfig --list | grep httpd</span>
httpd	<span>0</span>:关闭 <span>1</span>:关闭 <span>2</span>:关闭 <span>3</span>:关闭 <span>4</span>:关闭 <span>5</span>:关闭 <span>6</span>:关闭
<span>#查询httpd的自启动状态。所有的级别都是不自启动的</span>
<span>[</span>root@localhost ~<span>]</span><span># chkconfig --level 2345 httpd on</span>
<span>#设置apache服务在进入2、3、4、5级别时自启动</span>
<span>[</span>root@localhost ~<span>]</span><span># chkconfig --list | grep httpd</span>
httpd	<span>0</span>:关闭 <span>1</span>:关闭 <span>2</span>:启用 <span>3</span>:启用 <span>4</span>:启用 <span>5</span>:启用 <span>6</span>:关闭
<span>#查询apache服务的自启动状态。发现在2、3、4、5这4个运行级别中变为了"启用"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>还记得 0~6 这 7 个 Linux 的运行级别吗？如果在 0~6 这 7 个运行级别中服务都显示“关闭”，则该服务不自启动。如果在某个运行级别中显示“启用”，则代表在进入这个运行级别时，该服务开机自启动。</p>
<p>服务的自启动方法和服务的启动方法是不通用的，我们做一个实验验证一下。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># /etc/init.d/httpd status</span>
httpd已停
<span>#查询apache服务状态，是已经停止的</span>
<span>[</span>root@localhost ~<span>]</span><span># chkconfig --level 2345 httpd on</span>
<span>#设置apache服务在进入2、3、4、5级别时自启动</span>
<span>[</span>root@localhost ~<span>]</span><span># chkconfig --list | grep httpd</span>
httpd <span>0</span>:关闭 <span>1</span>:关闭 <span>2</span>:启用 <span>3</span>:启用 <span>4</span>:启用 <span>5</span>:启用 <span>6</span>:关闭
<span>#查看一下，自启动已经生效</span>
<span>[</span>root@localhost ~<span>]</span><span># /etc/init.d/httpd status</span>
httpd已停
<span>#但是apache服务在当前系统中还是关闭的</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>大家看到了吗？虽然 apach 被设置为自启动，但是当前系统中的 apache 是没有启动的，所以启动和自启动是独立的。</p>
<p><strong>2) 修改 <code>/etc/rc.d/rc.local</code> 文件，设置服务自启动</strong></p>
<p>第二种方法就是修改 <code>/etc/rc.d/rc.local</code> 文件，在文件中加入服务的启动命令。这个文件是在系统启动时，在输入用户名和密码之前最后读取的文件（注意：<code>/etc/rc.d/rc.local</code> 和 <code>/etc/rc.local</code> 文件是软链接，修改哪个文件都可以）。这个文件中有什么命令，都会在系统启动时调用。</p>
<p>如果我们把服务的启动命令放入这个文件，这个服务就会在开机时自启动。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span>#vi /etc/rc.d/rc.local</span>
<span>#!/bin/sh</span>
<span>#</span>
<span>#This script will be executed *after* all the other init scripts.</span>
<span>#You can put your own initialization stuff in here if you don't want to do the full Sys V style init stuff.</span>
<span>touch</span> /var/lock/subsys/local
/etc/rc.d/init.d/httpd start
<span>#在文件中加入apache的启动命令</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>这样，只要重启之后，apache 服务就会开机自启动了。推荐大家使用这种方法管理服务的自启动，有两点好处：</p>
<ul>
<li>第一，如果大家都采用这种方法管理服务的自启动，当我们碰到一台陌生的服务器时，只要查看这个文件就知道这台服务器到底自启动了哪些服务，便于集中管理。</li>
<li>第二，chkconfig 命令只能识别 RPM 包默认安装的服务，而不能识别源码包安装的服务。 源码包安装的服务的自启动也是通过 <code>/etc/rc.d/rc.local</code> 文件实现的，所以不会出现同一台服务器自启动了两种安装方法的同一个服务。</li>
</ul>
<p>还要注意一下，修改 <code>/etc/rc.d/rc.local</code> 配置文件的自启动方法和 <code>chkconfig</code>  命令的自启动方法是两种不同的自启动方法。所以，就算通过修改 <code>/etc/rc.d/rc.local</code> 配置文件的方法让某个独立的服务自启动了，执行 <code>chkconfig --list</code> 命令并不到有什么变化。</p>
<p><strong>3) 使用 <code>ntsysv</code> 命令管理自启动</strong></p>
<p>第三种方法是使用 <code>ntsysv</code> 命令调用窗口模式来管理服务的自启动，非常简单。命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ntsysv [--level 运行级别]</span>
选项：
	--level 运行级别：可以指定设定自启动的运行级别；

例如：
<span>[</span>root@localhost ~<span>]</span><span># ntsysv --level 235</span>
<span>#只设定2、3、5级别的服务自启动</span>
<span>[</span>root@localhost ~<span>]</span><span># ntsysv</span>
<span>#按默认的运行级别设置服务自启动</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>执行命令后，会和 <code>setup</code> 命令类似，出现命令界面，如图3-2 所示。</p>
<div>
<p><img src="./assets/ntsysv.jpg" alt="ntsysv" loading="lazy"></p>
<p><strong>图3-2	<u>ntsysv 命令界面</u></strong></p>
</div>
<p>这个命令的操作是这样的：</p>
<ul>
<li>上下键：在不同服务之间移动；</li>
<li>空格键：选定或取消服务的自启动。也就是在服务之前是否输入“*”；</li>
<li>Tab键：在不同项目之间切换；</li>
<li>F1键：显示服务的说明；</li>
</ul>
<p>需要注意的是，<code>ntsysv</code> 命令不仅可以管理独立服务的自启动，也可以管理基于 xinetd 服务的自启动。也就是说，只要是 RPM 包默认安装的服务都能被 <code>ntsysv</code> 命令管理。但是源码包安装的服务不行。</p>
<p>这样管理服务的自启动多么方便，为什么还要学习其他的服务自启动管理命令呢？ <code>ntsysv</code> 命令虽然简单，但它是红帽系列 Linux 的专有命令，其他的 Linux 发行版本不一定拥有这条命令，而且条命令也不能管理源码包安装的服务，所以我们推荐大家使用 <code>/etc/rc.d/rc.local</code> 文件来管理服务的自启动。</p>
<h3 id="基于-xinetd-服务的管理"> 基于 xinetd 服务的管理</h3>
<p>本节学习基于 xinetd 服务的管理方法。基于 xinetd 的服务同样有启动管理和自启动管理之分，而且不管是启动管理还是自启动管理，都只有一种方法，相比独立的服务简单一些。</p>
<ol>
<li><strong>基于 xinetd 服务的启动</strong></li>
</ol>
<p>基于 xinetd 的服务没有自己独立的启动脚本程序，是需要依赖 xinetd 的启动脚本来启动的。xinetd 本身是独立的服务，所以 xinetd 服务自己的启动方法和独立服务的启动方法是一致的。</p>
<p>但是，所有基于 xinetd 这个超级守护进程的其他服务就不是这样的了，必须修改该服务的配置文件，才能启动基于 xinetd 的服务。所有基于 xinetd 服务的配置文件都保存在 <code>/etc/xinetd.d/</code> 目录中。</p>
<p>我们使用 Telnet 服务来举例。Telnet 服务是用来进行系统远程管理的，端口是 23。不过需要注意的是，Telnet 服务的远程管理数据在网络中是明文传输的，非常不安全，所以在生产服务器上是不建议启动 Telnet 服务的。在生产服务器上，远程管理使用的是 ssh 协议，ssh 协议是加密的，更加安全。</p>
<p>Telnet 服务也是分为“客户端/服务器端”的，其中服务器端是用来启动 Telnet 服务的，并不安全；客户端是用来连接服务器端或测试服务器的端口是否开启的，在实际工作中我们主要使用 Telnet 客户端来测试远程服务器开启了哪些端口。</p>
<p>客户端的命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># telnet 服务器IP</span>
<span>#连接并管理远程服务器，因为数据明文传输，所以不安全</span>
<span>[</span>root@localhost ~<span>]</span><span># telnet 服务器IP 端口</span>
<span>#测试远程服务器的端口是否开启。如果能够正常连接，则证明该端口是开启的</span>

例如：

<span>[</span>root@localhost ~<span>]</span><span># telnet 192.168.0.210 22</span>
<span>#测试一下192.168.0.210这台服务器上的22（ssh服务）端口是否打开</span>
<span>#连接成功后，退出时使用"Ctrl+]"快捷键回到telnet交互模式，再输入"quit"退出</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>虽然 Telnet 服务不安全，但 Telnet 服务是基于 xinetd 的服务，我们使用 Telnet 服务来学习一下基于 xinetd  服务的启动管理。在目前的 Linux 系统中，Telnet 的服务器端都是不安装的，如果进行测试，则需要手工安装。安装命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># rpm -ivh /mnt/cdroin/Packages/telnet-server-0.17-47.el6.i686.rpm</span>


Preparing<span>..</span>.			<span>#########################[100%]</span>
	<span>1</span>:telnet-server		<span>#########################[100%]</span>
<span>#安装</span>
<span>[</span>root@localhost ~<span>]</span><span># chkconfig -list</span>
<span>#安装之后查询一下</span>
<span>..</span>.…省略部分输出<span>..</span>.
基于xinetd的服务:
	chargen-dgram:	关闭
	chargen-stream:	关闭
	cvs:			关闭
	daytime-dgram:	关闭
	daytime-stream:	关闭
	discard-dgram:	关闭
	discard-stream:	关闭
	echo-dgram:		关闭
	echo-stream:	关闭
	rsync:			关闭
	tcpmux-server:	关闭
	telnet:			关闭
	time-dgram:		关闭
	time-stream:	关闭
<span>#Telnet服务已经安装，是基于xinetd的服务，自启动状态是关闭</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>接下来我们就要启动 Telnet 服务了。既然基于 xinetd 服务的配置文件都在 <code>/etc/xinetd.d/</code> 目录中，那么 Telnet 服务的配置文件就是 <code>/etc/xinetd.d/telnet</code>。我们打开这个文件看看，如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span>#vi /etc/xinetd.d/telnet</span>
<span>#default: on</span>
<span>#description: The telnet server serves telnet sessions; it uses \</span>
<span>#	unencrypted username/password pairs for authentication.</span>
<span>service</span> telnet							<span>&lt;</span>---服务的名称为telnet
<span>{</span>
	flags <span>=</span> REUSE						<span>&lt;</span>---标志为REUSE，设定TCP/IP socket可重用
	socketjtype <span>=</span> stream				<span>&lt;</span>---使用 TCP协议数据包
	<span>wait</span> <span>=</span> no							<span>&lt;</span>---允许多个连接同时连接
	user <span>=</span> root							<span>&lt;</span>---启动服务的用户为root
	server <span>=</span> /usr/sbin/in.telnetd		<span>&lt;</span>---服务的启动程序
	log_on_failure <span>+=</span> USERID			<span>&lt;</span>---登录失败后，记录用户的ID
	disable <span>=</span> <span>yes</span>						<span>&lt;</span>---服务不启动
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>如果想要启动 Telnet 服务，则只需要把 <code>/etc/xinetd.d/telnet</code> 文件中的&quot;disable=yes&quot;改为&quot;disable=no&quot;即可，&quot;disable&quot;代表取消，&quot;disable=yes&quot;代表取消是  yes，当然不启动服务；&quot;disable=no&quot;代表取消是 no，当然就是启动服务了。具体命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vi /etc/xinetd.d/telnet</span>
<span>#修改配置文件</span>
<span>service</span> telnet <span>{</span>
<span>..</span>.省略部分输出<span>..</span>.
disable <span>=</span> no
<span>#把 yes 改为 no</span>
<span>}</span>
<span>[</span>root@localhost ~<span>]</span><span># service xinetd restart</span>
<span>#重启xinetd服务</span>
停止 xinetd:										<span>[</span>确定<span>]</span>
正在启动 xinetd:									<span>[</span>确定<span>]</span>
<span>[</span>root@localhost ~<span>]</span><span># netstat -tlun | grep 23</span>
tcp		<span>0</span>		<span>0</span>		:::23		:::*		LISTEN
<span>#查看端口，23端口启动，表示Telne服务已经启动了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>基于 xinetd 服务的启动都是这样的，只需修改 <code>/etc/xinetd.d/</code> 目录中的配置文件，然后重启 xientd 服务即可。</p>
<ol start="2">
<li><strong>基于 xientd 服务的自启动</strong></li>
</ol>
<p>基于 xinetd 服务的自启动管理有两种方法，分别是通过 <code>chkconfig</code> 命令管理自启动和通过 <code>ntsysv</code> 命令管理自启动。但是不能通过修改 <code>/etc/rc.d/rc.local</code> 配置文件来管理自启动，因为基于 xinetd  的服务没有自己的启动脚本程序。我们分别来看看。</p>
<p><strong>1) 使用 <code>chkconfig</code> 命令管理自启动</strong></p>
<p><code>chkconfig</code> 自启动管理命令可以管理所有 RPM 包默认安装的服务，所以也可以用来管理基于 xinetd 服务的自启动。命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># chkconfig 服务名 on|off</span>
<span>#基于xinetd的服务没有自己的运行级别，而依靠xinetd服务的运行级别，所以不用指定--level选项</span>

例如：
<span>[</span>root@localhost ~<span>]</span><span># chkconfig telnet on</span>
<span>#启动Telnet服务的自启动</span>
<span>[</span>root@localhost ~<span>]</span><span># chkconfig --list | grep telnet</span>
telnet:启用
<span>#查看服务的自启动，Telnet服务变为了"启用"</span>
<span>[</span>root@localhost ~<span>]</span><span># chkconfig telnet off</span>
<span>#关闭Telnet服务的自启动</span>
<span>[</span>root@localhost ~<span>]</span><span># chkconfig --list|grep telnet</span>
telnet:关闭
<span>#查看服务的自启动，Telnet服务变为了 "关闭"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><strong>2) 使用 <code>ntsysv</code> 命令管理自启动</strong></p>
<p><code>ntsysv</code> 命令既然可以管理所有 RPM 包默认安装的服务，当然也能管理基于 xinetd 的服务。命令的使用方法和管理独立的服务是一样的，这里就不再重复介绍了。</p>
<p>其实，如果我们仔细来看，就会发现基于 xinetd 服务的启动和自启动区分得并不严格。启动命令也会把服务设置为自启动，自启动命令也会把服务设置为启动。我们做一个实验看看，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vi /etc/xinetd.d/telnet</span>
<span>service</span> telnet
<span>{</span>
	disable <span>=</span> <span>yes</span>
	<span>..</span>.省略部分输出<span>..</span>.
<span>}</span>
<span>[</span>root@localhost ~<span>]</span><span># service xinetd restart</span>
停止 xinetd:										<span>[</span>确定<span>]</span>
正在启动 xinetd:									<span>[</span>确定<span>]</span>
<span>[</span>root@localhost ~<span>]</span><span># chkconfig telnet off</span>
<span>#先关闭Telnet服务的启动和自启动，保证不会对后面的实验产生影响</span>

<span>[</span>root@localhost ~<span>]</span><span># vi /etc/xinetd.d/telnet</span>
<span>service</span> telnet
<span>{</span>
	disable <span>=</span> no
	<span>..</span>.省略部分输出<span>..</span>.
<span>}</span>
<span>[</span>root@localhost ~<span>]</span><span># service xinetd restart</span>
停止xinetd:											<span>[</span>确定<span>]</span>
正在启动xinetd:										<span>[</span>确定<span>]</span>
<span>#然后启动Telnet服务</span>
<span>[</span>root@localho.st ~<span>]</span> <span># chkconfig --list | grep telnet</span>
telnet：启用
<span>#看到了吗?我们一开始已经把Telnet服务的自启动关闭了。后面的实验虽然只启动了#Telnet服务，但是该服务自动变为了自启动状态</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>这个实验说明了基于 xinetd 服务的启动和自启动命令之间是通用的，在当前系统中启动了服务，服务的自启动也会开启；关闭了服务的自启动，当前系统中的服务也会关闭。</p>
<h2 id="源码包服务管理"> 源码包服务管理</h2>
<p>关于源码包服务管理，我们先学习源码包服务的启动管理，再来学习源码包服务的自启动管理，最后学习如何让源码包服务被系统服务管理命令识别。</p>
<h3 id="源码包服务的启动管理"> 源码包服务的启动管理</h3>
<p>源码包服务中所有的文件都会安装到指定目录当中，并且没有任何垃圾文件产生（Linux 的特性），所以服务的管理脚本程序也会安装到指定目录中。源码包服务的启动管理方式就是在服务的安装目录中找到管理脚本，然后执行这个脚本。</p>
<p>问题来了，每个服务的启动脚本都是不一样的，我们怎么确定每个服务的启动脚本呢？还记得在安装源码包服务时，我们强调需要査看每个服务的说明文档吗（一般是 INSTALL 或 READEM）？在这个说明文档中会明确地告诉大家服务的启动脚本是哪个文件。</p>
<p>我们用 apache 服务来举例。一般 apache 服务的安装位置是 <code>/usr/local/apache2/</code> 目录，那么 apache  服务的启动脚本就是 <code>/usr/local/apache2/bin/apachectl</code> 文件（查询 apache 说明文档得知）。启动命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># /usr/local/apache2/bin/apachectl start|stop|restart|...</span>
<span>#源码包服务的启动管理</span>

例如：
<span>[</span>root@localhost ~<span>]</span><span># /usr/local/apache2/bin/apachectl start</span>
<span>#会启动源码包安装的apache服务</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><p>注意</p>
<p>不管是源码包安装的 apache，还是 RPM 包默认安装的 apache，虽然在一台服务器中都可以安装，但是只能启动一个，因为它们都会占用 80 端口。</p>
</div>
<p>源码包服务的启动方法就这一种，比 RPM 包默认安装的服务要简单一些。</p>
<h3 id="源码包服务的自启动管理"> 源码包服务的自启动管理</h3>
<p>源码包服务的自启动管理也不能依靠系统的服务管理命令，而只能把标准启动命令写入 <code>/etc/rc.d/rc.local</code> 文件中。系统在启动过程中读取 <code>/etc/rc.d/rc.local</code> 文件时，就会调用源码包服务的启动脚本，从而让该服务开机自启动。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vi /etc/rc.d/rc.local</span>
<span>#修改自启动文件</span>
<span>#!/bin/sh</span>
<span>#This script will be executed *after* all the other init scripts.</span>
<span>#You can put your own initialization stuff in here if you don11</span>
<span>#want to do the full Sys V style init stuff.</span>
<span>touch</span> /var/lock/subsys/local
/usr/local/apache2/bin/apachectl start				<span>&lt;</span>---加入此行内容，apache的启动命令
<span>#加入源码包服务的标准启动命令，保存退出，源码包安装的apache服务就被设为自启动了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="源码包服务被服务管理命令识别"> 源码包服务被服务管理命令识别</h3>
<p>在默认情况下，源码包服务是不能被系统的服务管理命令所识别和管理的，但是如果我们做一些设定，则也是可以让源码包服务被系统的服务管理命令所识别和管理的。不过并不推荐大家这样做，因为这会让本来区别很明确的源码包服务和 RPM 包服务变得容易混淆，不利于系统维护和管理。</p>
<p>我们做一个实验，看看如何把源码包安装的 apache 服务变为和 RPM 包默认安装的 apache 服务一样，可以被 service、chkconfig、ntsysv 命令所识别。实验如下：</p>
<div><pre><code><span># 1) 卸载RPM包默认安装的apache服务</span>

<span>[</span>root@localhost ~<span>]</span><span># yum -y remove httpd</span>
<span>#卸载RPM包默认安装的apache服务,避免对实验产生影响（在生产服务器上慎用yum卸载，因为这有可能造成服务器崩溃)</span>
<span>[</span>root@localhost ~<span>]</span><span># service httpd start</span>
httpd:未被识别的服务
<span>#因为服务被卸载,所以service命令不能识别httpd服务</span>


<span># 2) 安装源码包的apache服务，并启动</span>

<span>#安装源码包的apache服务</span>
<span>[</span>root@localhost ~<span>]</span><span># /usr/local/apache2/bin/apachect1 start</span>
<span>[</span>root@localhost ~<span>]</span><span># netstat -tlun | grep 80</span>
tcp <span>0</span> <span>0</span> :::80 :::* LISTEN
<span>#启动源码包安装的apache服务，查看端口确定已经启动</span>

<span># 3) 让源码包安装的apache服务能被service命令管理启动</span>

<span>[</span>root@localhost ~<span>]</span><span># ln -s /usr/local/apache2/bin/apachectl /etc/±nit.d/apache</span>
<span>#service命令其实只是在/etc/init.d/目录中查找是否有服务的启动脚本，所以我们只需要做一个软链接,</span>
<span>#把源码包的启动脚本链接到/etc/init.d/目录中,就能被service命令所管理了。</span>
<span>#为了照顾大家的习惯，我把软链接文件命名为apache,注意这不是RPM包默认安装的apache服务</span>
<span>[</span>root@localhost ~<span>]</span><span># service apache restart</span>
<span>#虽然RPM包默认安装的apache服务被卸载了,但是service命令也能够生效</span>

<span># 4) 让源码包安装的apache服务能被chkconfig命令管理自启动</span>

<span>[</span>root@localhost ~<span>]</span><span># vi /etc/init.d/apache</span>
<span>#修改源码包安装的apache服务的启动脚本(注意此文件是软链接,所以修改的还是源码包启动脚本)</span>
<span>#!/bin/sh</span>
<span>#</span>
<span>#chkconfig: 35 86 76</span>
<span>#指定httpd脚本可以被chkconfig命令所管理</span>
<span>#格式是：chkconfig：运行级别 启动顺序 关闭顺序</span>
<span>#这里我们让apache服务在3和5级别中能被chkconfig命令所管理，启动顺序是S86，关闭顺序是K76</span>
<span>#(自定顺序，不要和系统中已有的启动顺序冲突)</span>
<span>#description: source package apache</span>
<span>#说明，内容随意</span>
<span>#以上两句话必须加入,才能被chkconfig命令所识别</span>
<span>..</span>.省略部分输出<span>..</span>.
<span>[</span>root@localhost ~<span>]</span><span># chkconfig --add apache</span>
<span>#让chkconfig命令能够管理源码包安装的apache服务</span>
<span>[</span>root01ocalhost ~<span>]</span><span># chkconfig --list | grep apache</span>
apache <span>0</span>:关闭 <span>1</span>:关闭 <span>2</span>:关闭 <span>3</span>:关闭 <span>4</span>:关闭 <span>5</span>:关闭 <span>6</span>:关闭
<span>#很神奇吧,虽然RPM包默认安装的apache服务被删除了,但是chkconfig命令可以管理源码包安装的tapache服务</span>

<span># 5) 让ntsysv命令可以管理源码包安装的apache服务</span>

<span>#ntsysv 命令其实和 chkconfig 命令使用同样的管理机制,也就是说,ntsysv 已经可以</span>
<span>#进行源码包安装 apache 服务的自启动管理了,如图3-3 所示</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div><div>
<p><img src="./assets/apache.jpg" alt="apache" loading="lazy"></p>
<p><strong>图3-3	<u>ntsysv 命令识别 apache</u></strong></p>
</div>
<p>总结一下，如果想让源码包服务被 <code>service</code> 命令所识别和管理，则只需做一个软链接把启动脚本链接到 <code>/etc/init.d/</code>  目录中即可。要想让源码包服务被 <code>chkconfig</code> 命令所识别，除了需要把服务的启动脚本链接到 <code>/etc/init.d/</code> 目录中，还要修改这个启动脚本，在启动脚本的开头加入如下内容：</p>
<div><pre><code><span>#chkconfig:运行级别 启动顺序 关闭</span>
<span>#description:说明</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>然后需要使用 <code>chkconfig--add 服务名</code> 的方式把服务加入 <code>chkconfig</code> 命令的管理中。命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># chkconfig [选项] [服务名]</span>
选项：
	-add：把服务加入 <span>chkconfig</span> 命令的管理中；
	-del：把服务从 <span>chkconfig</span> 命令的管理中删除；

<span># 例如：</span>
<span>[</span>root@localhost ~<span>]</span><span># chkconfig -del httpd</span>
<span>#把apache服务从chkconfig命令的管理中删除</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="服务管理总结"> 服务管理总结</h2>
<p>服务管理的分类较多，方法也比较多，容易混淆，我们来画一张图来总结一下 Linux 中服务管理的方法，如图3-4 所示。</p>
<div>
<p><img src="./assets/view.png" alt="view" loading="lazy"></p>
<p><strong>图3-4	<u>服务管理总结</u></strong></p>
</div>
<h2 id="常见服务类别及功能"> 常见服务类别及功能</h2>
<p>Linux 中的服务数量非常多，我们在学习时一直使用 apache 服务作为实例。很多人会产生困惑：其他的服务都是干什么的呢？它们有什么作用呢？是不是必须启动的呢？</p>
<p>那么，我们就来介绍 Linux 中常见服务及它们各自的作用。</p>
<p>在生产服务器上，安装完 Linux 之后有一步重要的工作，就是服务优化。也就是关闭不需要的服务，只开启需要的服务。因为服务启动得越多，占用的系统资源就越多，而且被攻击的可能性也増加了。如果要进行服务优化，就需要知道这些服务都有什么作用，如表3-1 所示。</p>
<p><strong>表3-1	<u>Linux 中常见服务的作用</u></strong></p>
<table>
<thead>
<tr>
<th>服务名称</th>
<th>功能简介</th>
<th>建议</th>
</tr>
</thead>
<tbody>
<tr>
<td>acpid</td>
<td>电源管理接口。如果是笔记本电脑用户，则建议开启，可以监听内核层的相关电源事件</td>
<td>开</td>
</tr>
<tr>
<td>anacron</td>
<td>系统的定时任务程序。是 cron 的一个子系统，如果定时任务错过了执行时间，则可以通过 anacron 继续唤醒执行</td>
<td>关</td>
</tr>
<tr>
<td>alsasound</td>
<td>alsa 声卡驱动。如果使用 alsa 声卡，则开启</td>
<td>关</td>
</tr>
<tr>
<td>apmd</td>
<td>电源管理模块。如果支持 acpid，就不需要 apmd，可以关闭</td>
<td>关</td>
</tr>
<tr>
<td>atd</td>
<td>指定系统在特定时间执行某个任务，只能执行一次。如果需要则开启，但我们一般使用 crond 来执行循环定时任务</td>
<td>关</td>
</tr>
<tr>
<td>auditd</td>
<td>审核子系统。如果开启了此服务，那么 SELinux 的审核信息会写入 <code>/var/log/audit/ audit.log</code> 文件；如果不开启，那么审核信息会记录在 syslog 中</td>
<td>开</td>
</tr>
<tr>
<td>autofs</td>
<td>让服务器可以自动挂载网络中其他服务器的共享数据,一般用来自动挂载 NFS 服务。如果没有 NFS 服务，则建议关闭</td>
<td>关</td>
</tr>
<tr>
<td>avahi-daemon</td>
<td>avahi 是 zeroconf 协议的实现，它可以在没有 DNS 服务的局域网里发现基于 zeroconf 协议的设备和服务。除非有兼容设备或使用 zeroconf 协议，否则关闭</td>
<td>关</td>
</tr>
<tr>
<td>bluetooth</td>
<td>蓝牙设备支持。一般不会在服务器上启用蓝牙设备，关闭它</td>
<td>关</td>
</tr>
<tr>
<td>capi</td>
<td>仅对使用 ISND 设备的用户有用</td>
<td>关</td>
</tr>
<tr>
<td>chargen-dgram</td>
<td>使用 UDP 协议的 chargen server。其主要提供类似远程打字的功能</td>
<td>关</td>
</tr>
<tr>
<td>chargen-stream</td>
<td>同上</td>
<td>关</td>
</tr>
<tr>
<td>cpuspeed</td>
<td>可以用来调整 CPU 的频率。当闲置时，可以自动降低 CPU 频率来节省电量</td>
<td>开</td>
</tr>
<tr>
<td>crond</td>
<td>系统的定时任务，一般的 Linux 服务器都需要定时任务来协助系统维护。建议开启</td>
<td>开</td>
</tr>
<tr>
<td>cvs</td>
<td>一个版本控制系统</td>
<td>关</td>
</tr>
<tr>
<td>daytime-dgram</td>
<td>使用 TCP 协议的 daytime 守护进程，该协议为客户机实现从远程服务器获取日期和时间的功能</td>
<td>关</td>
</tr>
<tr>
<td>daytime-slream</td>
<td>同上</td>
<td>关</td>
</tr>
<tr>
<td>dovecot</td>
<td>邮件服务中 POP3/IMAP 服务的守护进程，主要用来接收信件。如果启动了邮件服务则开启：否则关闭</td>
<td>关</td>
</tr>
<tr>
<td>echo-dgram</td>
<td>服务器回显客户服务的进程</td>
<td>关</td>
</tr>
<tr>
<td>echo-stream</td>
<td>同上</td>
<td>关</td>
</tr>
<tr>
<td>firstboot</td>
<td>系统安装完成后，有一个欢迎界面，需要对系统进行初始设定，这就是这个服务的作用。既然不是第一次启动了，则建议关闭</td>
<td>关</td>
</tr>
<tr>
<td>gpm</td>
<td>在字符终端（ttyl~tty6）中可以使用鼠标复制和粘贴，这就是这个服务的功能</td>
<td>开</td>
</tr>
<tr>
<td>haldaemon</td>
<td>检测和支持 USB 设备。如果是服务器则可以关闭，个人机则建议开启</td>
<td>关</td>
</tr>
<tr>
<td>hidd</td>
<td>蓝牙鼠标、键盘等蓝牙设备检测。必须启动 bluetooth 服务</td>
<td>关</td>
</tr>
<tr>
<td>hplip</td>
<td>HP 打印机支持，如果没有 HP 打印机则关闭</td>
<td>关</td>
</tr>
<tr>
<td>httpd</td>
<td>apache 服务的守护进程。如果需要启动 apache，就开启</td>
<td>开</td>
</tr>
<tr>
<td>ip6tables</td>
<td>IPv6 的防火墙。目前 IPv6 协议并没有使用，可以关闭</td>
<td>关</td>
</tr>
<tr>
<td>iptables</td>
<td>防火墙功能。Linux 中的防火墙是内核支持功能。这是服务器的主要防护手段，必须开启</td>
<td>开</td>
</tr>
<tr>
<td>irda</td>
<td>IrDA 提供红外线设备（笔记本电脑、PDA’s、手机、计算器等）间的通信支持。建议关闭</td>
<td>关</td>
</tr>
<tr>
<td>irqbalance</td>
<td>支持多核处理器，让 CPU 可以自动分配系统中断（IRQ)，提高系统性能。目前服务器多是多核 CPU，请开启</td>
<td>开</td>
</tr>
<tr>
<td>isdn</td>
<td>使用 ISDN 设备连接网络。目前主流的联网方式是光纤接入和 ADSL，ISDN 己经非常少见，请关闭</td>
<td>关</td>
</tr>
<tr>
<td>kudzu</td>
<td>该服务可以在开机时进行硬件检测，并会调用相关的设置软件。建议关闭，仅在需要时开启</td>
<td>关</td>
</tr>
<tr>
<td>lvm2-monitor</td>
<td>该服务可以让系统支持LVM逻辑卷组，如果分区采用的是LVM方式，那么应该开启。建议开启</td>
<td>开</td>
</tr>
<tr>
<td>mcstrans</td>
<td>SELinux 的支持服务。建议开启</td>
<td>开</td>
</tr>
<tr>
<td>mdmonitor</td>
<td>该服务用来监测 Software RAID 或 LVM 的信息。不是必需服务，建议关闭</td>
<td>关</td>
</tr>
<tr>
<td>mdmpd</td>
<td>该服务用来监测 Multi-Path 设备。不是必需服务，建议关闭</td>
<td>关</td>
</tr>
<tr>
<td>messagebus</td>
<td>这是 Linux 的 IPC（Interprocess Communication，进程间通信）服务，用来在各个软件中交换信息。建议关闭</td>
<td>关</td>
</tr>
<tr>
<td>microcode _ctl</td>
<td>Intel 系列的 CPU 可以通过这个服务支持额外的微指令集。建议关闭</td>
<td>关</td>
</tr>
<tr>
<td>mysqld</td>
<td>MySQL 数据库服务器。如果需要就开启；否则关闭</td>
<td>开</td>
</tr>
<tr>
<td>named</td>
<td>DNS 服务的守护进程，用来进行域名解析。如果是 DNS 服务器则开启；否则关闭</td>
<td>关</td>
</tr>
<tr>
<td>netfs</td>
<td>该服务用于在系统启动时自动挂载网络中的共享文件空间，比如 NFS、Samba 等。 需要就开启，否则关闭</td>
<td>关</td>
</tr>
<tr>
<td>network</td>
<td>提供网络设罝功能。通过这个服务来管理网络，建议开启</td>
<td>开</td>
</tr>
<tr>
<td>nfs</td>
<td>NFS（Network File System）服务，Linux 与 Linux 之间的文件共享服务。需要就开启，否则关闭</td>
<td>关</td>
</tr>
<tr>
<td>nfslock</td>
<td>在 Linux 中如果使用了 NFS 服务，那么，为了避免同一个文件被不同的用户同时编辑，所以有这个锁服务。有 NFS 时开启，否则关闭</td>
<td>关</td>
</tr>
<tr>
<td>ntpd</td>
<td>该服务可以通过互联网自动更新系统时间.使系统时间永远准确。需要则开启，但不是必需服务</td>
<td>关</td>
</tr>
<tr>
<td>pcscd</td>
<td>智能卡检测服务，可以关闭</td>
<td>关</td>
</tr>
<tr>
<td>portmap</td>
<td>用在远程过程调用（RPC）的服务，如果没有任何 RPC 服务，则可以关闭。主要是 NFS 和 NIS 服务需要</td>
<td>关</td>
</tr>
<tr>
<td>psacct</td>
<td>该守护进程支持几个监控进程活动的工具</td>
<td>关</td>
</tr>
<tr>
<td>rdisc</td>
<td>客户端 ICMP 路由协议</td>
<td>关</td>
</tr>
<tr>
<td>readahead_early</td>
<td>在系统开启的时候，先将某些进程加载入内存整理，可以加快启动速度</td>
<td>关</td>
</tr>
<tr>
<td>readahead_later</td>
<td>同上</td>
<td>关</td>
</tr>
<tr>
<td>restorecond</td>
<td>用于给 SELinux 监测和重新加载正确的文件上下文。如果开启 SELinux，则需要开启</td>
<td>关</td>
</tr>
<tr>
<td>rpcgssd</td>
<td>与 NFS 有关的客户端功能。如果没有 NFS 就关闭</td>
<td>关</td>
</tr>
<tr>
<td>rpcidmapd</td>
<td>同上</td>
<td>关</td>
</tr>
<tr>
<td>rsync</td>
<td>远程数据备份守护进程</td>
<td>关</td>
</tr>
<tr>
<td>sendmail</td>
<td>sendmail 邮件服务的守护进程。如果有邮件服务就开启；否则关闭</td>
<td>关</td>
</tr>
<tr>
<td>setroubleshoot</td>
<td>该服务用于将 SELinux 相关信息记录在日志 <code>/var/log/messages</code> 中。建议开启</td>
<td>开</td>
</tr>
<tr>
<td>smartd</td>
<td>该服务用于自动检测硬盘状态。建议开启</td>
<td>开</td>
</tr>
<tr>
<td>smb</td>
<td>网络服务 samba 的守护进程。可以让 Linux 和 Windows 之间共享数据。如果需要则开启</td>
<td>关</td>
</tr>
<tr>
<td>squid</td>
<td>代理服务的守护进程。如果需要则开启：否则关闭</td>
<td>关</td>
</tr>
<tr>
<td>sshd</td>
<td>ssh 加密远程登录管理的服务。服务器的远程管理必须使用此服务，不要关闭</td>
<td>开</td>
</tr>
<tr>
<td>syslog</td>
<td>日志的守护进程</td>
<td>开</td>
</tr>
<tr>
<td>vsftpd</td>
<td>vsftp 服务的守护进程。如果需要 FTP 服务则开启；否则关闭</td>
<td>关</td>
</tr>
<tr>
<td>xfs</td>
<td>这是 X Window 的字体守护进程，为图形界面提供字体服务。如果不启动图形界面，就不用开启</td>
<td>关</td>
</tr>
<tr>
<td>xinetd</td>
<td>超级守护进程。如果有依赖 xinetd 的服务，就必须开启</td>
<td>开</td>
</tr>
<tr>
<td>ypbind</td>
<td>为 NIS（网络信息系统）客户机激活 ypbind 服务进程</td>
<td>关</td>
</tr>
<tr>
<td>yum-updatesd</td>
<td>yum 的在线升级服务</td>
<td>关</td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2022-01-26T06:11:29.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">linux系统进程管理</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_manage/03.linux_process/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_manage/03.linux_process/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>很多人一看要学习系统管理了，策一感觉就是&quot;虽然不知道你在说什么，但是看起来很高端&quot;。</p>
<p>其实，系统管理只是一个统称，软件管理、文件系统管理、启动管理和服务管理都可以归入系统管理当中。</p>
<p>这次，我们主要学习进程管理、工作管理和系统定时任务。同时解决一些问题，如什么是进程、进程的管理方式是什么、工作管理的作用是什么、系统定时任务如何实现。</p>
<h2 id="进程的简介"> 进程的简介</h2>
<p>无论是 Linux 系统管理员还是普通用户，监视系统进程的运行情况并适时终止一些失控的进程，是每天的例行事务。和 Linux 系统相比，进程管理在 Windows 中更加直观，它主要是使用&quot;任务管理器&quot;来进行进程管理的。</p>
<p>通常，使用&quot;任务管理器&quot;主要有 3 个目的：</p>
<ol>
<li>利用“应用程序”和“进程”标签来査看系统中到底运行了哪些程序和进程；</li>
<li>利用“性能”和“用户”标签来判断服务器的健康状态；</li>
<li>在“应用程序”和“进程”标签中强制中止任务和进程；</li>
</ol>
<p>Linux 中虽然使用命令进行进程管理，但是进程管理的主要目的是一样的，即查看系统中运行的程序和进程、判断服务器的健康状态和强制中止不需要的进程。</p>
<p>那么，到底什么是进程呢？它和我们平时所说的“程序”又有什么联系呢？</p>
<h3 id="什么是进程和程序"> 什么是进程和程序</h3>
<p>进程是正在执行的一个程序或命令，每个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。程序是人使用计算机语言编写的可以实现特定目标或解决特定问题的代码集合。这么讲很难理解，那我们换一种说法。</p>
<ul>
<li>程序是人使用计算机语言编写的，可以实现一定功能，并且可以执行的代码集合。</li>
<li>进程是正在执行中的程序。当程序被执行时，执行人的权限和属性，以及程序的代码都会被加载入内存，操作系统给这个进程分配一个 ID，称为 PID（进程 ID）。</li>
</ul>
<p>也就是说，在操作系统中，所有可以执行的程序与命令都会产生进程。只是有些程序和命令非常简单，如 <code>ls</code> 命令、<code>touch</code> 命令等，它们在执行完后就会结束，相应的进程也就会终结，所以我们很难捕捉到这些进程。但是还有一些程和命令，比如 <code>httpd</code> 进程，启动之后就会一直驻留在系统当中，我们把这样的进程称作常驻内存进程。</p>
<p>某些进程会产生一些新的进程，我们把这些进程称作子进程，而把这个进程本身称作父进程。比如，我们必须正常登录到 Shell 环境中才能执行系统命令，而 Linux 的标准 Shell 是 bash。我们在 bash 当中执行了 <code>ls</code> 命令，那么 bash 就是父进程，而 <code>ls</code> 命令是在 bash 进程中产生的进程，所以 <code>ls</code> 进程是 bash 进程的子进程。也就是说，子进程是依赖父进程而产生的，如果父进程不存在，那么子进程也不存在了。</p>
<h3 id="进程管理的作用"> 进程管理的作用</h3>
<p>在使用 Windows 系统的过程中，使用任务管理器，很大程度上是为了强制关闭“未反应”的软件，也就是杀死进程。的确，这是很多使用进程管理工具或进程管理命令的人最常见的使用方法。不过，杀死进程（强制中止进程）只是进程管理工作中最不常用的手段，因为每个进程都有自己正确的结束方法，而杀死进程是在正常方法已经失效的情况下的后备手段。</p>
<p>那么，进程管理到底应该是做什么的呢？我以为，进程管理主要有以下 3 个作用。</p>
<h4 id="_1-判断服务器的健康状态"> 1) 判断服务器的健康状态</h4>
<p>运维工程师最主要的工作就是保证服务器安全、稳定地运行。理想的状态是，在服务器出现问题，但是还没有造成服务器宕机或停止服务时，就人为干预解决了问题。</p>
<p>进程管理最主要的工作就是判断服务器当前运行是否健康，是否需要人为干预。如果服务器的 CPU 占用率、内存占用率过高，就需要人为介入解决问题了。这又出现了一个问题，我们发现服务器的 CPU 或内存占用率很高，该如何介入呢？是直接终止高负载的进程吗？</p>
<p>当然不是，应该判断这个进程是否是正常进程，如果是正常进程，则说明你的服务器已经不能满足应用需求，你需要更好的硬件或搭建集群了；如果是非法进程占用了系统资源，则更不能直接中止进程，而要判断非法进程的来源、作用和所在位置，从而把它彻底清除。</p>
<p>当然，如果服务器数量很少，我们完全可以人为通过进程管理命令来进行监控与干预，但如果服务器数量较多，那么人为手工监控就变得非常困难了，这时我们就需要相应的监控服务，如 cacti 或 nagios。总之，进程管理工作中最重要的工作就是判断服务器的健康状态，最理想的状态是服务器宕机之前就解决问题，从而避免服务器的宕机。</p>
<h4 id="_2-查看系统中所有的进程"> 2) 查看系统中所有的进程</h4>
<p>我们需要查看看系统中所有正在运行的进程，通过这些进程可以判断系统中运行了哪些服务、是否有非法服务在运行。</p>
<h4 id="_3-杀死进程"> 3) 杀死进程</h4>
<p>这是进程管理中最不常用的手段。当需要停止服务时，会通过正确关闭命令来停止服务（如 apache 服务可以通过 <code>service httpd stop</code> 命令来关闭）。只有在正确终止进程的手段失效的情况下，才会考虑使用 <code>kill</code> 命令杀死进程。</p>
<p>其实，进程管理和 Windows 中任务管理器的作用非常类似，不过大家在使用任务管理器时是为了杀死进程，而不是为了判断服务器的健康状态。</p>
<h2 id="进程的启动"> 进程的启动</h2>
<p>在 Linux 系统中，每个进程都有一个唯一的进程号（PID），方便系统识别和调度进程。通过简单地输出运行程序的程序名，就可以运行该程序，其实也就是启动了一个进程。</p>
<p>总体来说，启动一个进程主要有 2 种途径，分别是通过手工启动和通过调度启动（事先进行设置，根据用户要求，进程可以自行启动），接下来就一一介绍这 2 中方式。</p>
<h3 id="手工启动"> 手工启动</h3>
<p>手工启动进程指的是由用户输入命令直接启动一个进程，根据所启动的进程类型和性质的不同，其又可以细分为前台启动和后台启动 2 种方式。</p>
<h4 id="前台启动进程"> <strong>前台启动进程</strong></h4>
<p>这是手工启动进程最常用的方式，因为当用户输入一个命令并运行，就已经启动了一个进程，而且是一个前台的进程，此时系统其实已经处于一个多进程的状态（一个是 Shell 进程，另一个是新启动的进程）。</p>
<blockquote>
<p>实际上，系统启动时就有许多进程悄悄地在后台运行，不过这里为了方便读者理解，并没有将这些进程包括在内。</p>
</blockquote>
<p>假如启动一个比较耗时的进程，然后再把该进程挂起，并使用 <code>ps</code> 命令查看，就会看到该进程在 <code>ps</code> 显示列表中，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># find / -name demo.jpg		&lt;--在根目录下查找 demo.jpg 文件，比较耗时</span>
<span>#此处省略了该命令的部分输出信息</span>
<span>#按“CTRL+Z”组合键，即可将该进程挂起</span>
<span>[</span>root@localhost ~<span>]</span><span># ps							&lt;--查看正在运行的进程</span>
PID		TTY		TIME		CMD
<span>2573</span>	pts/0	00:00:00	<span>bash</span>
<span>2587</span>	pts/0	00:00:01	<span>find</span>
<span>2588</span>	pts/0	00:00:00	<span>ps</span>
<span>#通过运行 `ps` 命令查看进程信息，可以看到，刚刚执行的 `find` 命令的进程号为 2587，同时 `ps` 进程的进程号为 2588。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><p>挂起</p>
<p>将进程挂起，指的是将前台运行的进程放到后台，并且暂停其运行，有关挂起进程和 <code>ps</code> 命令用法，后面会做详细介绍。</p>
</div>
<h4 id="后台启动进程"> <strong>后台启动进程</strong></h4>
<p>进程直接从后台运行，用的相对较少，除非该进程非常耗时，且用户也不急着需要其运行结果的时候，例如，用户需要启动一个需要长时间运行的格式化文本文件的进程，为了不使整个 Shell 在格式化过程中都处于“被占用”状态，从后台启动这个进程是比较明智的选择。</p>
<p>从后台启动进程，其实就是在命令结尾处添加一个 &quot; &amp;&quot; 符号（注意，&amp; 前面有空格）。输入命令并运行之后，Shell 会提供给我们一个数字，此数字就是该进程的进程号。然后直接就会出现提示符，用户就可以继续完成其他工作，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># find / -name install.log &amp;</span>
<span>[</span><span>1</span><span>]</span> <span>1920</span>
<span>#[1]是工作号，1920是进程号</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><p>提示</p>
<p>有关后台启动进程及相关的注意事项，后面也会做详细介绍。</p>
</div>
<p>以上介绍了手工启动的 2 种方式，实际上它们有个共同的特点，就是新进程都是由当前 Shell 这个进程产生的，换句话说，是 Shell 创建了新进程，于是称这种关系为进程间的父子关系，其中 Shell 是父进程，新进程是子进程。</p>
<p>值得一提的是，一个父进程可以有多个子进程，通常子进程结束后才能继续父进程；当然，如果是从后台启动，父进程就不用等待子进程了。</p>
<h3 id="调度启动进程"> 调度启动进程</h3>
<p>在 Linux 系统中，任务可以被配置在指定的时间、日期或者系统平均负载量低于指定值时自动启动。</p>
<p>例如，Linux 预配置了重要系统任务的运行，以便可以使系统能够实时被更新，系统管理员也可以使用自动化的任务来定期对重要数据进行备份。</p>
<p>实现调度启动进程的方法有很多，例如通过 <code>crontab</code>、<code>at</code> 等命令，有关这些命令的具体用法，后面会做详细介绍。</p>
<h2 id="进程的查看"> 进程的查看</h2>
<p>我们先来学习进程的查看命令，在 Linux 中运行的进程查看和服务器的健康状态判断都是依靠进程查看命令完成的，不过分别采用不同夫人命令，其中，<code>ps</code> 命令侧重静态地查看系统中正在运行的进程，<code>top</code> 命令侧重动态地查看进程和服务器的健康状态，<code>pstree</code> 命令主要用于查看进程树。下面分别来介绍。</p>
<h3 id="ps-命令-静态查看进程"> ps 命令：静态查看进程</h3>
<p><code>ps</code> 命令是最常用的监控进程的命令，通过此命令可以查看系统中所有运行进程的详细信息。</p>
<p>英文原意：report a snapshot of the current processes</p>
<p><code>ps</code> 命令的基本格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ps aux</span>
<span>#查看系统中所有的进程，使用 BS 操作系统格式</span>
<span>[</span>root@localhost ~<span>]</span><span># ps -le</span>
<span>#查看系统中所有的进程，使用 Linux 标准命令格式</span>

选项：
	a	：显示一个终端的所有进程，除会话引线外
	u	：显示进程的归属用户及内存的使用情况
	x	：显示没有控制终端的进程
	-l	：长格式显示更加详细的信息
	-e	：显示所有进程
	-f	：全格式
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>可以看到，<code>ps</code> 命令有些与众不同，它的部分选项不能加入“-”，比如命令 <code>ps aux</code>，其中“aux”是选项，但是前面不能带“-”。</p>
<p>大家如果执行 <code>man ps</code> 命令，则会发现 <code>ps</code> 命令的帮助为了适应不同的类 UNIX 系统，可用格式非常多，不方便记忆。所以，我建议大家记忆几个固定选项即可。比如：</p>
<ul>
<li><strong><code>ps aux</code></strong> 可以查看系统中所有的进程；</li>
<li><strong><code>ps -le</code></strong> 可以查看系统中所有的进程，而且还能看到进程的父进程的 PID 和进程优先级；</li>
<li><strong><code>ps -l</code></strong> 只能看到当前 Shell 产生的进程；</li>
</ul>
<p>有这三个命令就足够了，下面分别来查看。</p>
<p>例 1：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ps aux</span>
<span>#查看系统中所有的进程</span>
<span>USER</span>   PID   %CPU   %MEM    VSZ    RSS   TTY   STAT   START   TIME   COMMAND
root     <span>1</span>    <span>0.0</span>    <span>0.2</span>   <span>2872</span>   <span>1416</span>     ?     Ss   Jun04   <span>0</span>:02   /sbin/init
root     <span>2</span>    <span>0.0</span>    <span>0.0</span>      <span>0</span>      <span>0</span>     ?      S   Jun04   <span>0</span>:00   <span>[</span>kthreadd<span>]</span>
root     <span>3</span>    <span>0.0</span>    <span>0.0</span>      <span>0</span>      <span>0</span>     ?      S   Jun04   <span>0</span>:00   <span>[</span>migration/0<span>]</span>
root     <span>4</span>    <span>0.0</span>    <span>0.0</span>      <span>0</span>      <span>0</span>     ?      S   Jun04   <span>0</span>:00   <span>[</span>ksoftirqd/0<span>]</span>
<span>..</span>.省略部分输出<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>表4-1 中罗列出了以上输出信息中各列的具体含义。</p>
<p><strong>表4-1	<code>ps aux</code><u>表头的含义</u></strong></p>
<table>
<thead>
<tr>
<th>表头</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>USER</td>
<td>该进程是由哪个用户产生的。</td>
</tr>
<tr>
<td>PID</td>
<td>进程的 ID。</td>
</tr>
<tr>
<td>%CPU</td>
<td>该进程占用 CPU 资源的百分比，占用的百分比越高，进程越耗费资源。</td>
</tr>
<tr>
<td>%MEM</td>
<td>该进程占用物理内存的百分比，占用的百分比越高，进程越耗费资源。</td>
</tr>
<tr>
<td>VSZ</td>
<td>该进程占用虚拟内存的大小，单位为 KB。</td>
</tr>
<tr>
<td>RSS</td>
<td>该进程占用实际物理内存的大小，单位为 KB。</td>
</tr>
<tr>
<td>TTY</td>
<td>该进程是在哪个终端运行的。其中，tty1 ~ tty7 代表本地控制台终端（可以通过 Alt+F1 ~ F7  快捷键切换不同的终端），tty1~tty6 是本地的字符界面终端，tty7 是图形终端。pts/0 ~ 255  代表虚拟终端，一般是远程连接的终端，第一个远程连接占用 pts/0，第二个远程连接占用 pts/1，依次増长。</td>
</tr>
<tr>
<td>STAT</td>
<td>进程状态。常见的状态有以下几种：  <br />-D：不可被唤醒的睡眠状态，通常用于 I/O 情况。<br />-R：该进程正在运行。<br />-S：该进程处于睡眠状态，可被唤醒。 <br />-T：停止状态，可能是在后台暂停或进程处于除错状态。<br />-W：内存交互状态（从 2.6 内核开始无效）。<br />-X：死掉的进程（应该不会出现）。<br />-Z：僵尸进程。进程已经中止，但是部分程序还在内存当中。<br />-&lt;：高优先级（以下状态在 BSD 格式中出现）。<br />-N：低优先级。 <br />-L：被锁入内存。<br />-s：包含子进程。<br />-l：多线程（小写 L）。 <br />-+：位于后台。</td>
</tr>
<tr>
<td>START</td>
<td>该进程的启动时间。</td>
</tr>
<tr>
<td>TIME</td>
<td>该进程占用 CPU 的运算时间，注意不是系统时间。</td>
</tr>
<tr>
<td>COMMAND</td>
<td>产生此进程的命令名。</td>
</tr>
</tbody>
</table>
<p>例 2：</p>
<p><code>ps aux</code> 命令可以看到系统中所有的进程，<code>ps -le</code> 命令也能看到系统中所有的进程。由于“-l”选项的作用，所以 <code>ps -le</code> 命令能够看到更加详细的信息，比如父进程的 PID、优先级等。但是这两个命令的基本作用是一致的，掌握其中一个就足够了。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ps -le</span>
F   S   <span>UID</span>   PID   <span>PPID</span>   C   PRI   Nl   ADDR   SZ   WCHAN   TTY      TIME   CMD
<span>4</span>   S     <span>0</span>     <span>1</span>      <span>0</span>   <span>0</span>    <span>80</span>    <span>0</span>   -     <span>718</span>   -       ?    00:00:02   init
<span>1</span>   S     <span>0</span>     <span>2</span>      <span>0</span>   <span>0</span>    <span>80</span>    <span>0</span>   -       <span>0</span>   -       ?    00:00:00   kthreadd
<span>1</span>   S     <span>0</span>     <span>3</span>      <span>2</span>   <span>0</span>   -40    -   -       <span>0</span>   -       ?    00:00:00   migration/0
<span>1</span>   S     <span>0</span>     <span>4</span>      <span>2</span>   <span>0</span>    <span>80</span>    <span>0</span>   -       <span>0</span>   -       ?    00:00:00   ksoflirqd/0
<span>1</span>   S     <span>0</span>     <span>5</span>      <span>2</span>   <span>0</span>   -40    -   -       <span>0</span>   -       ?    00:00:00   migration/0
<span>..</span>.省略部分输出<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>表4-2 罗列出以上输出信息中各列的含义。</p>
<p><strong>表4-2	<code>ps -le</code> <u>表头的含义</u></strong></p>
<table>
<thead>
<tr>
<th>表头</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>F</td>
<td>进程标志，说明进程的权限，常见的标志有两个: <br />1：进程可以被复制，但是不能被执行； <br />4：进程使用超级用户权限；</td>
</tr>
<tr>
<td>S</td>
<td>进程状态。具体的状态和&quot;psaux&quot;命令中的 STAT 状态一致；</td>
</tr>
<tr>
<td>UID</td>
<td>运行此进程的用户的 ID；</td>
</tr>
<tr>
<td>PID</td>
<td>进程的 ID；</td>
</tr>
<tr>
<td>PPID</td>
<td>父进程的 ID；</td>
</tr>
<tr>
<td>C</td>
<td>该进程的 CPU 使用率，单位是百分比；</td>
</tr>
<tr>
<td>PRI</td>
<td>进程的优先级，数值越小，该进程的优先级越高，越早被 CPU 执行；</td>
</tr>
<tr>
<td>NI</td>
<td>进程的优先级，数值越小，该进程越早被执行；</td>
</tr>
<tr>
<td>ADDR</td>
<td>该进程在内存的哪个位置；</td>
</tr>
<tr>
<td>SZ</td>
<td>该进程占用多大内存；</td>
</tr>
<tr>
<td>WCHAN</td>
<td>该进程是否运行。&quot;-&quot;代表正在运行；</td>
</tr>
<tr>
<td>TTY</td>
<td>该进程由哪个终端产生；</td>
</tr>
<tr>
<td>TIME</td>
<td>该进程占用 CPU 的运算时间，注意不是系统时间；</td>
</tr>
<tr>
<td>CMD</td>
<td>产生此进程的命令名；</td>
</tr>
</tbody>
</table>
<p>例 3：</p>
<p>如果不想看到所有的进程，只想查看一下当前登录产生了哪些进程，那只需使用 <code>ps -l</code> 命令就足够了：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ps -l</span>
<span>#查看当前登录产生的进程</span>
F   S   <span>UID</span>   PID   <span>PPID</span>   C   PRI   NI   ADDR   SZ   WCHAN   TTY         TIME   CMD
<span>4</span>   S   <span>0</span>   <span>18618</span>  <span>18614</span>   <span>0</span>    <span>80</span>    <span>0</span>   -    <span>1681</span>   -       pts/1   00:00:00   <span>bash</span>
<span>4</span>   R   <span>0</span>   <span>18683</span>  <span>18618</span>   <span>4</span>    <span>80</span>    <span>0</span>   -    <span>1619</span>   -       pts/1   00:00:00   <span>ps</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>可以看到，这次从 pts/1 虚拟终端登录，只产生了两个进程：一个是登录之后生成的 Shell，也就是 bash；另一个是正在执行的 <code>ps</code> 命令。</p>
<p>我们再来说说僵尸进程。僵尸进程的产生一般是由于进程非正常停止或程序编写错误，导致子进程先于父进程结束，而父进程又没有正确地回收子进程，从而造成子进程一直存在于内存当中，这就是僵尸进程。</p>
<p>僵尸进程会对主机的稳定性产生影响，所以，在产生僵尸进程后，一定要对产生僵尸进程的软件进行优化，避免一直产生僵尸进程；对于已经产生的僵尸进程，可以在查找出来之后强制中止。</p>
<h3 id="top-命令-动态查看进程"> top 命令：动态查看进程</h3>
<p><code>ps</code> 命令可以一次性给出当前系统中进程状态，但使用此方式得到的信息缺乏时效性，并且，如果管理员需要实时监控进程运行情况，就必须不停地执行 <code>ps</code> 命令，这显然是缺乏效率的。</p>
<p>为此，Linux 提供了 <code>top</code> 命令。<code>top</code> 命令可以动态地持续监听进程地运行状态，与此同时，该命令还提供了一个交互界面，用户可以根据需要，人性化地定制自己的输出，进而更清楚地了进程的运行状态。</p>
<p>英文原意：display Linux processes</p>
<p><code>top</code> 命令的基本格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># top [选项]</span>
选项：
	-d 秒数		：指定 <span>top</span> 命令每隔几秒更新。默认是 <span>3</span> 秒；
	-b			：使用批处理模式输出。一般和<span>"-n"</span>选项合用，用于把 <span>top</span> 命令重定向到文件中；
	-n 次数		：指定 <span>top</span> 命令执行的次数。一般和<span>"-b"</span>选项合用；
	-p 进程PID	：仅查看指定 ID 的进程；
	-s			：使 <span>top</span> 命令在安全模式中运行，避免在交互模式中出现错误；
	-u 用户名	：只监听某个用户的进程；
	
在 <span>top</span> 命令的显示窗口中，还可以使用如下按键，进行一下交互操作：
	P	：按照 CPU 的使用率排序，默认就是此选项；
	M	：按照内存的使用率排序；
	N	：按照 PID 排序；
	T	：按照 CPU 的累积运算时间排序，也就是按照 TIME+ 项排序；
	k	：按照 PID 给予某个进程一个信号。一般用于中止某个进程，信号 <span>9</span> 是强制中止的信号；
	r	：按照 PID 给某个进程重设优先级（Nice）值；
	q	：退出 <span>top</span> 命令；
	? 或 h：显示交互模式的帮助；
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>我们看看 <code>top</code> 命令的执行结果，如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># top</span>
<span>top</span> - <span>12</span>:26:46 up <span>1</span> day, <span>13</span>:32, <span>2</span> users, load average: <span>0.00</span>, <span>0.00</span>, <span>0.00</span>
Tasks: <span>95</span> total, <span>1</span> running, <span>94</span> sleeping, <span>0</span> stopped, <span>0</span> zombie
Cpu<span>(</span>s<span>)</span>: <span>0.1</span>%us, <span>0.1</span>%sy, <span>0.0</span>%ni, <span>99.7</span>%id, <span>0.1</span>%wa, <span>0.0</span>%hi, <span>0.1</span>%si, <span>0.0</span>%st
Mem: 625344k total, 571504k used, 53840k free, 65800k buffers
Swap: 524280k total, 0k used, 524280k free, 409280k cached
PID   <span>USER</span> PR NI VIRT  RES  SHR S %CPU %MEM   TIME+ COMMAND
<span>19002</span> root <span>20</span>  <span>0</span> <span>2656</span> <span>1068</span>  <span>856</span> R  <span>0.3</span>  <span>0.2</span> <span>0</span>:01.87 <span>top</span>
<span>1</span>     root <span>20</span>  <span>0</span> <span>2872</span> <span>1416</span> <span>1200</span> S  <span>0.0</span>  <span>0.2</span> <span>0</span>:02.55 init
<span>2</span>     root <span>20</span>  <span>0</span>    <span>0</span>    <span>0</span>    <span>0</span> S  <span>0.0</span>  <span>0.0</span> <span>0</span>:00.03 kthreadd
<span>3</span>     root RT  <span>0</span>    <span>0</span>    <span>0</span>    <span>0</span> S  <span>0.0</span>  <span>0.0</span> <span>0</span>:00.00 migration/0
<span>4</span>     root <span>20</span>  <span>0</span>    <span>0</span>    <span>0</span>    <span>0</span> S  <span>0.0</span>  <span>0.0</span> <span>0</span>:00.15 ksoftirqd/0
<span>5</span>     root RT  <span>0</span>    <span>0</span>    <span>0</span>    <span>0</span> S  <span>0.0</span>  <span>0.0</span> <span>0</span>:00.00 migration/0
<span>6</span>     root RT  <span>0</span>    <span>0</span>    <span>0</span>    <span>0</span> S  <span>0.0</span>  <span>0.0</span> <span>0</span>:10.01 watchdog/0
<span>7</span>     root <span>20</span>  <span>0</span>    <span>0</span>    <span>0</span>    <span>0</span> S  <span>0.0</span>  <span>0.0</span> <span>0</span>:05.01 events/0
<span>8</span>     root <span>20</span>  <span>0</span>    <span>0</span>    <span>0</span>    <span>0</span> S  <span>0.0</span>  <span>0.0</span> <span>0</span>:00.00 cgroup
<span>9</span>     root <span>20</span>  <span>0</span>    <span>0</span>    <span>0</span>    <span>0</span> S  <span>0.0</span>  <span>0.0</span> <span>0</span>:00.00 khelper
<span>10</span>    root <span>20</span>  <span>0</span>    <span>0</span>    <span>0</span>    <span>0</span> S  <span>0.0</span>  <span>0.0</span> <span>0</span>:00.00 netns
<span>11</span>    root <span>20</span>  <span>0</span>    <span>0</span>    <span>0</span>    <span>0</span> S  <span>0.0</span>  <span>0.0</span> <span>0</span>:00.00 async/mgr
<span>12</span>    root <span>20</span>  <span>0</span>    <span>0</span>    <span>0</span>    <span>0</span> S  <span>0.0</span>  <span>0.0</span> <span>0</span>:00.00 pm
<span>13</span>    root <span>20</span>  <span>0</span>    <span>0</span>    <span>0</span>    <span>0</span> S  <span>0.0</span>  <span>0.0</span> <span>0</span>:01.70 sync_supers
<span>14</span>    root <span>20</span>  <span>0</span>    <span>0</span>    <span>0</span>    <span>0</span> S  <span>0.0</span>  <span>0.0</span> <span>0</span>:00.63 bdi-default
<span>15</span>    root <span>20</span>  <span>0</span>    <span>0</span>    <span>0</span>    <span>0</span> S  <span>0.0</span>  <span>0.0</span> <span>0</span>:00.00 kintegrityd/0
<span>16</span>    root <span>20</span>  <span>0</span>    <span>0</span>    <span>0</span>    <span>0</span> S  <span>0.0</span>  <span>0.0</span> <span>0</span>:02.52 kblockd/0
<span>17</span>    root <span>20</span>  <span>0</span>    <span>0</span>    <span>0</span>    <span>0</span> S  <span>0.0</span>  <span>0.0</span> <span>0</span>:00.00 kacpid
<span>18</span>    root <span>20</span>  <span>0</span>    <span>0</span>    <span>0</span>    <span>0</span> S  <span>0.0</span>  <span>0.0</span> <span>0</span>:00.00 kacpi_notify
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>我们解释一下命令的输出。<code>top</code> 命令的输出内容是动态的，默认每隔 3 秒刷新一次。命令的输出主要分为两部分：</p>
<ol>
<li>第一部分是前五行，显示的是整个系统的资源使用状况，我们就是通过这些输出来判断服务器的资源使用状态的；</li>
<li>第二部分从第六行开始，显示的是系统中进程的信息；</li>
</ol>
<p>我们先来说明第一部分的作用。</p>
<ul>
<li>第一行为任务队列信息，具体内容如表4-3 所示。</li>
</ul>
<p><strong>表4-3	<u>任务队列信息</u></strong></p>
<table>
<thead>
<tr>
<th>内 容</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td>12:26:46</td>
<td>系统当前时间</td>
</tr>
<tr>
<td>up 1 day, 13:32</td>
<td>系统的运行时间。本机己经运行 1 天 13 小时 32 分钟</td>
</tr>
<tr>
<td>2 users</td>
<td>当前登录了两个用户</td>
</tr>
<tr>
<td>load average: 0.00, 0.00, 0.00</td>
<td>系统在之前 1 分钟、5 分钟、15 分钟的平均负载。<br />如果 CPU 是单核的，则这个数值超过 1 就是高负载；<br />如果 CPU 是四核的，则这个数值超过 4 就是高负载 <br />（一般认为：平均负载不应该超过服务器 CPU 的核数）</td>
</tr>
</tbody>
</table>
<ul>
<li>第二行为进程信息，具体内容如表4-4 所示。</li>
</ul>
<p><strong>表4-4	<u>进程信息</u></strong></p>
<table>
<thead>
<tr>
<th>内 容</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tasks: 95 total</td>
<td>系统中的进程总数</td>
</tr>
<tr>
<td>1 running</td>
<td>正在运行的进程数</td>
</tr>
<tr>
<td>94 sleeping</td>
<td>睡眠的进程数</td>
</tr>
<tr>
<td>0 stopped</td>
<td>正在停止的进程数</td>
</tr>
<tr>
<td>0 zombie</td>
<td>僵尸进程数。如果不是 0，则需要手工检查僵尸进程</td>
</tr>
</tbody>
</table>
<ul>
<li>第三行为 CPU 信息，具体内容如表4-5 所示。</li>
</ul>
<p><strong>表4-5	<u>CPU 信息</u></strong></p>
<table>
<thead>
<tr>
<th>内 容</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cpu(s): 0.1 %us</td>
<td>用户模式占用的 CPU 百分比</td>
</tr>
<tr>
<td>0.1%sy</td>
<td>系统模式占用的 CPU 百分比</td>
</tr>
<tr>
<td>0.0%ni</td>
<td>改变过优先级的用户进程占用的 CPU 百分比</td>
</tr>
<tr>
<td>99.7%id</td>
<td>空闲 CPU 占用的 CPU 百分比</td>
</tr>
<tr>
<td>0.1%wa</td>
<td>等待输入/输出的进程占用的 CPU 百分比</td>
</tr>
<tr>
<td>0.0%hi</td>
<td>硬中断请求服务占用的 CPU 百分比</td>
</tr>
<tr>
<td>0.1%si</td>
<td>软中断请求服务占用的 CPU 百分比</td>
</tr>
<tr>
<td>0.0%st</td>
<td>st（steal time）意为虚拟时间百分比，就是当有虚拟机时，虚拟 CPU 等待实际 CPU 的时间百分比</td>
</tr>
</tbody>
</table>
<ul>
<li>第四行为物理内存信息，具体内容如表4-6 所示。</li>
</ul>
<p><strong>表4-6	<u>物理内存信息</u></strong></p>
<table>
<thead>
<tr>
<th>内 容</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mem: 625344k total</td>
<td>物理内存的总量，单位为 KB</td>
</tr>
<tr>
<td>571504k used</td>
<td>己经使用的物理内存数量</td>
</tr>
<tr>
<td>53840k&amp;ee</td>
<td>空闲的物理内存数量。<br />我们使用的是虚拟机，共分配了 628MB内存，所以只有53MB的空闲内存</td>
</tr>
<tr>
<td>65800k buffers</td>
<td>作为缓冲的内存数量</td>
</tr>
</tbody>
</table>
<ul>
<li>第五行为交换分区（swap）信息，如表4-7 所示。</li>
</ul>
<p><strong>表4-7	<u>交换分区信息</u></strong></p>
<table>
<thead>
<tr>
<th>内 容</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Swap: 524280k total</td>
<td>交换分区（虚拟内存）的总大小</td>
</tr>
<tr>
<td>0k used</td>
<td>已经使用的交换分区的大小</td>
</tr>
<tr>
<td>524280k free</td>
<td>空闲交换分区的大小</td>
</tr>
<tr>
<td>409280k cached</td>
<td>作为缓存的交换分区的大小</td>
</tr>
</tbody>
</table>
<p>我们通过 <code>top</code> 命令的第一部分就可以判断服务器的健康状态。如果 1 分钟、5 分钟、15 分钟的平均负载高于 1，则证明系统压力较大。如果 CPU 的使用率过高或空闲率过低，则证明系统压力较大。如果物理内存的空闲内存过小，则也证明系统压力较大。</p>
<p>这时，我们就应该判断是什么进程占用了系统资源。如果是不必要的进程，就应该结束这些进程；如果是必需进程，那么我们该増加服务器资源（比如増加虚拟机内存），或者建立集群服务器。</p>
<p>我们还要解释一下缓冲（buffer）和缓存（cache）的区别：</p>
<ul>
<li>缓存（cache）是在读取硬盘中的数据时，把最常用的数据保存在内存的缓存区中，再次读取该数据时，就不去硬盘中读取了，而在缓存中读取。</li>
<li>缓冲（buffer）是在向硬盘写入数据时，先把数据放入缓冲区，然后再一起向硬盘写入，把分散的写操作集中进行，减少磁盘碎片和硬盘的反复寻道，从而提高系统性能。</li>
</ul>
<p>简单来说，缓存（cache）是用来加速数据从硬盘中“读取”的，而缓冲（buffer）是用来加速数据“写入”硬盘的。</p>
<p>再来看 <code>top</code> 命令的第二部分输出，主要是系统进程信息，各个字段的含义如下：</p>
<ul>
<li>PID：进程的 ID。</li>
<li>USER：该进程所属的用户。</li>
<li>PR：优先级，数值越小优先级越高。</li>
<li>NI：优先级，数值越小、优先级越高。</li>
<li>VIRT：该进程使用的虚拟内存的大小，单位为 KB。</li>
<li>RES：该进程使用的物理内存的大小，单位为 KB。</li>
<li>SHR：共享内存大小，单位为 KB。</li>
<li>S：进程状态。</li>
<li>%CPU：该进程占用 CPU 的百分比。</li>
<li>%MEM：该进程占用内存的百分比。</li>
<li>TIME+：该进程共占用的 CPU 时间。</li>
<li>COMMAND：进程的命令名。</li>
</ul>
<p>这部分和 <code>ps</code> 命令的输出比较类似，只是如果在终端执行 <code>top</code> 命令，则不能看到所有的进程，而只能看到占比靠前的进程。接下来我们举几个 <code>top</code> 命令常用的实例。</p>
<p>如果只想让 <code>top</code> 命令查看某个进程，就可以使用 “-p”  选项。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># top -p 15273</span>
<span>#只查看 PID为 15273的apache进程</span>
<span>top</span> - <span>14</span>:28:47 up <span>1</span> day, <span>15</span>:34, <span>3</span> users, load average: <span>0.00</span>,0.00,0.00
Tasks: <span>1</span> total, <span>0</span> running, <span>1</span> sleeping, <span>0</span> stopped, <span>0</span> zombie
Cpu<span>(</span>s<span>)</span>: <span>0.0</span>%us, <span>0.0</span>%sy, <span>0.0</span>%ni,100.0%id, <span>0.0</span>%wa, <span>0.0</span>%hi, <span>0.0</span>%si, <span>0.0</span>%st
Mem: 625344k total, 574124k used, 51220k free, 67024k buffers
Swap: 524280k total, Ok used, 524280k free, 409344k cached
PID     <span>USER</span> PR NI VIRT  RES SHR S %CPU %MEM  TIME+  COMMAND
<span>15273</span> daemon <span>20</span> <span>0</span>  <span>4520</span> <span>1192</span> <span>580</span> S  <span>0.0</span>  <span>0.2</span> <span>0</span>:00.00   httpd
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><code>top</code> 命令如果不正确退出，则会持续运行。在 <code>top</code> 命令的交互界面中按 “q” 键会退出 <code>top</code> 命令；也可以按 “?” 或 “h” 键得到 <code>top</code> 命令交互界面的帮助信息；还可以按“k”键中止某个进程。比如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># top</span>
<span>top</span> - <span>14</span>:10:15 up <span>1</span> day, <span>15</span>:15， <span>3</span> users, load average: <span>0.00</span>，0.00, <span>0.00</span>
Tasks: <span>97</span> total, <span>1</span> running, <span>96</span> sleeping, <span>0</span> stopped, <span>0</span> zombie
Cpu<span>(</span>s<span>)</span>: <span>0.0</span>%us, <span>0.0</span>%sy, <span>0.0</span>%ni,100.0%id, <span>0.0</span>%wa, <span>0.0</span>%hi, <span>0.0</span>%si, <span>0.0</span>%st
Mem: 625344k total, 574248k used, 51096k free, 66840k buffers
Swap: 524280k total, Ok used, 524280k free, 409324k cached
PID to kill:15273
<span>#按"k"键，会提示输入要杀死进程的PID</span>
PID     <span>USER</span> PR NI VIRT  RES SHR S %CPU %MEM   TIME+ COMMAND
<span>15273</span> daemon <span>20</span>  <span>0</span> <span>4520</span> <span>1192</span> <span>580</span> S  <span>0.0</span> <span>0.2</span>  <span>0</span>:00.00 httpd
<span>..</span>.省略部分输出<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>输入要中止进程的 PID，比如要中止 15273 这个 apache 进程，命令如下：</p>
<div><pre><code><span>top</span> - <span>14</span>:11:42 up <span>1</span> day, <span>15</span>:17， <span>3</span> users, load average: <span>0.00</span>，0.00, <span>0.00</span>
Tasks: <span>97</span> total, <span>1</span> running, <span>96</span> sleeping, <span>0</span> stopped, <span>0</span> zombie
Cpu<span>(</span>s<span>)</span>: <span>0.0</span>%us, <span>0.3</span>%sy, <span>0.0</span>%ni, <span>99.7</span>%id, <span>0.0</span>%wa, <span>0.0</span>%hi, <span>0.0</span>%si, <span>0.0</span>%st
Mem: 625344k total, 574248k used, 51096k free, 66856k buffers
Swap: 524280k total, 0k used, 524280k free, 409324k cached
Kill PID <span>15273</span> with signal <span>[</span><span>15</span><span>]</span>:9
<span>#提示输入信号，信号9代表强制中止</span>
PID     <span>USER</span> PR NI VIRT  RES SHR S %CPU %MEM   TIME+ COMMAND
<span>15273</span> daemon <span>20</span>  <span>0</span> <span>4520</span> <span>1192</span> <span>580</span> S <span>0.0</span>   <span>0.2</span> <span>0</span>:00.00 httpd
…省略部分输出…
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>接下来 top 命令提示我们输入信号，信号 9 代表强制中止，这时就能够强制中止 15273 进程了。</p>
<p>如果要改变某个进程的优先级，就要利用“r”交互命令。需要注意的是，我们能够修改的只有 Nice 的优先级，而不能修改 Priority 的优先级。具体修改命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># top -p 18977</span>
<span>top</span> - <span>14</span>:17:09 up <span>1</span> day, <span>15</span>:22, <span>3</span> users, load average: <span>0.00</span>，0.00, <span>0.00</span>
Tasks: <span>97</span> total, <span>1</span> running, <span>96</span> sleeping, <span>0</span> stopped, <span>0</span> zombie
Cpu<span>(</span>s<span>)</span>: <span>0.3</span>%us, <span>0.0</span>%sy, <span>0.0</span>%ni, <span>99.7</span>%id, <span>0.0</span>%wa, <span>0.0</span>%hi, <span>0.0</span>%si, <span>0.0</span>%st
Mem: 625344k total, 574124k used, 51220k free, 66896k buffers
Swap: 524280k total, 0k used, 524280k free, 409324k cached
PID to renice:
<span>#输入"r"交互命令之后，提示输入要修改优先级的进程的PID</span>
PID   <span>USER</span> PR NI  VIRT  RES SHR  S %CPU %MEM   TIME+ COMMAND
<span>18977</span> root <span>20</span> <span>0</span>  <span>11592</span> <span>3304</span> <span>2572</span> S  <span>0.0</span> <span>0.5</span>  <span>0</span>:04.37 sshd
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>输入“r”交互命令，会提示输入需要修改优先级的进程的 PID。例如，我们想要修改 18977 这个 sshd 远程连接进程的优先级，就输入该进程的 PID。命令如下：</p>
<div><pre><code>Renice PID <span>18977</span> to value: <span>10</span>
<span>#输入PID后，需要输入Nice的优先级号</span>
<span>#我们把18977进程的优先级调整为10,回车后就能看到</span>
PID   <span>USER</span> PR NI  VIRT  RES SHR  S %CPU %MEM   TIME+ COMMAND
<span>18977</span> root <span>30</span> <span>10</span> <span>11592</span> <span>3304</span> <span>2572</span> R  <span>0.0</span> <span>0.5</span>  <span>0</span>:04.38 sshd
<span>#18977进程的优先级已经被修改了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>如果在操作终端执行 <code>top</code> 命令，则并不能看到系统中所有的进程，默认看到的只是 CPU 占比靠前的进程。如果我们想要看到所有的进程，则可以把 <code>top</code> 命令的执行结果重定向到文件中。不过 <code>top</code> 命令是持续运行的，这时就需要使用 “-b”和“-n”选项了。具体命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># top -b -n 1 > /root/top.log</span>
<span>#让top命令只执行一次，然后把执行结果保存到top.log文件中，这样就能看到所有的进程了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="pstree-命令-树形查看进程"> pstree 命令：树形查看进程</h3>
<p><code>pstree</code> 命令是以树形结构显示程序和进程之间的关系。</p>
<p>英文原意：display a tree of processes</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># pstree [选项] [PID或用户名]</span>
选项： 
	-a：显示启动每个进程对应的完整指令，包括启动进程的路径、参数等
	-c：不使用精简法显示进程信息，即显示的进程中包含子进程和父进程
	-n：根据进程 PID 号来排序输出，默认是以程序名排序输出的。
	-p：显示进程的 PID
	-u：显示进程对应的用户名称
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>需要注意的是，在使用 <code>pstree</code> 命令时，如果不指定进程的 PID 号，也不指定用户名称，则会以 <strong>init</strong> 进程为根进程，显示系统中所有程序和进程的信息；反之，若指定 PID 号或用户名，则将以 PID 或指定命令为根进程，显示 PID  或用户对应的所有程序和进程。</p>
<p><strong>init 进程是系统启动的第一个进程，进程的 PID 是 1，也是系统中所有进程的父进程。</strong></p>
<p>例 1：</p>
<div><pre><code><span>[</span>root@1ocalhost ~<span>]</span><span># pstree</span>
 init──┬──abrc-dump-oopa
 ├──abrtd
 ├──acpid
 <span>..</span>.省略部分输出<span>..</span>.
 ├──rayslogd───3*<span>[</span><span>{</span>rsyslogrd<span>}</span><span>]</span>
 <span>#有3个rsyslogd进程存在</span>
 ├──sshd───sshd───bash───pstree
 <span>#Pstree命令进程是在远程连接中被执行的</span>
 ├──udevd───2*<span>[</span>udevd<span>]</span>
 └──xinecd
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>例 2：</p>
<p>如果想知道某个用户都启动了哪些进程，使用 <code>pstree</code> 命令可以很容易实现，以 mysql 用户为例：</p>
<div><pre><code><span>[</span>root@1ocalhost ~<span>]</span><span># pstree mysql</span>
mysqid---6*<span>[</span><span>{</span>mysqid<span>}</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>此输出结果显示了 mysql 用户对应的进程为 mysqid，并且 mysqid 进程拥有 5 个子进程（外加 1 个父进程，共计 6 个进程）。</p>
<h3 id="lsof-命令-查看进程调用信息"> lsof 命令：查看进程调用信息</h3>
<p>我们知道，通过 <code>ps</code> 命令可以查询到系统中所有的进程，那么，是否可以进一步知道这个进程到底在调用哪些文件吗？当然可以，使用 <code>lsof</code> 命令即可。</p>
<p><code>lsof</code> 命令，列出系统中已经被打开的文件。通过 <code>lsof</code> 命令，我们就可以根据文件找到对应的进程信息，也可以根据进程信息找到进程打开的文件。</p>
<p>英文原意：list opened files</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># lsof [选项]</span>
选项：
-c 字符串	：只列出以字符串开头的进程打开的文件
+d 目录名	：列出某个目录中所有被进程调用的文件
-u 用户名	：只列出某个用户的进程打开的文件
-p PID		：列出某个 PID 进程打开的文件
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>例 1：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># lsof | more</span>
<span>#查询系统中所有进程调用的文件</span>
COMMAND	PID	<span>USER</span>	FD	TYPE	DEVICE	SIZE/OFF	NODE	NAME
init	<span>1</span>	root	cwd	DIR 	<span>8</span>，3	<span>4096</span>		<span>2</span>		/
init	<span>1</span>	root	rtd	DIR 	<span>8</span>，3	<span>4096</span>		<span>2</span>		/
init	<span>1</span>	root	txt	REG		<span>8</span>，3	<span>145180</span>		<span>130874</span>	/sbin/init
init	<span>1</span>	root	mem	REG 	<span>8</span>，3	<span>142472</span>		<span>665291</span>	/lib/ld-2.12.so
init	<span>1</span>	root	mem	REG 	<span>8</span>，3	<span>58704</span>		<span>655087</span>	/lib/libnss_files-2.12.so
<span>..</span>.省略部分输出<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>这个命令的输出非常多。它会按照 PID，从 1 号进程开始列出系统中所有的进程正在调用的文件名。</p>
<p>例 2：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># lsof /sbin/init</span>
<span>#查询某个文件被哪个进程调用</span>
COMMAND	PID	<span>USER</span>	FD	TYPE	DEVICE	SIZE/OFF	NODE	NAME
init	<span>1</span>	root	txt	REG		<span>8</span>，3	<span>145180</span>		<span>130874</span>	/sbin/init
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><code>lsof</code> 命令也可以反过来查询某个文件被哪个进程调用。这个例子就查询到 <code>/sbin/init</code> 文件是被 init 进程调用的。</p>
<p>例 3：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># lsof +d /usr/lib</span>
<span>#查询某个目录下所有的文件是被哪些进程调用的</span>
COMMAND		PID		<span>USER</span>	FD		TYPE	DEVICE	SIZE/OFF	NODE	NAME
rpc.idmap	<span>1196</span>	root	mem		REG		<span>8</span>，3	<span>26400</span>		<span>279930</span>	/usr/lib/libnfsidmap.so.0.3.0
rpc.idmap	<span>1196</span>	root	mem		REG		<span>8</span>，3	<span>108948</span>		<span>276696</span>	/usr/lib/libevent-1.4.so.2.1.3
avahi-dae	<span>1240</span>	avahi	mem		REG		<span>8</span>，3	<span>49124</span>		<span>271310</span>	/usr/lib/libavahi-common.so.3.5.1
avahi-dae	<span>1240</span>	avahi	mem		REG		<span>8</span>，3	<span>23904</span>		<span>283188</span>	/usr/lib/libdaemon.so.0.5.0
avahi-dae	<span>1240</span>	avahi	mem		REG		<span>8</span>，3	<span>227212</span>		<span>268396</span>	/usr/lib/libavahi-core.so.6.0.1
avahi-dae	<span>1241</span>	avahi	mem		REG		<span>8</span>，3	<span>49124</span>		<span>271310</span>	/usr/lib/libavahi-common.so.3.5.1
avahi-dae	<span>1241</span>	avahi	mem		REG		<span>8</span>，3	<span>23904</span>		<span>283188</span>	/usr/lib/libdaemon.so.0.5.0
avahi-dae	<span>1241</span>	avahi	mem		REG		<span>8</span>，3	<span>227212</span>		<span>268396</span>	/usr/lib/libavahi-core.so.6.0.1
cupsd		<span>1251</span>	root	mem		REG		<span>8</span>，3	<span>69564</span>		<span>270210</span>	/usr/lib/libtasn1.so.3.1.6
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>使用“+d”选项可以搜索某个目录下所有的文件，查看到底哪个文件被哪个进程调用了。</p>
<p>例 4：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># lsof -c httpd</span>
<span>#查看以httpd开头的进程调用了哪些文件</span>
COMMAND	PID		<span>USER</span>	FD	TYPE	DEVICE	SIZE/OFF	NODE	NAME
httpd	<span>4689</span>	root	cwd	DIR		<span>8</span>，3	<span>4096</span>		<span>2</span>		/
httpd	<span>4689</span>	root	rtd	DIR		<span>8</span>，3    <span>4096</span>		<span>2</span>		/
httpd	<span>4689</span>	root	txt	REG		<span>8</span>，3    <span>1797559</span>		<span>2855</span>	/usr/local/apache2/bin/httpd
httpd	<span>4689</span>	root	mem	REG		<span>8</span>，3    <span>302300</span>		<span>665303</span>	/lib/libfreebl3.so
httpd	<span>4689</span>	root	mem	REG		<span>8</span>，3    <span>58704</span>		<span>655087</span>	/lib/libnss_files-2.12.s
httpd	<span>4689</span>	root	mem	REG		<span>8</span>，3    <span>142472</span>		<span>665291</span>	/lib/ld-2.12.so
httpd	<span>4689</span>	root	mem	REG		<span>8</span>，3    <span>1889704</span>		<span>665292</span>	/lib/libc-2.12.so
<span>..</span>.省略部分输出<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>使用“-c”选项可以查询以某个字符串开头的进程调用的所有文件，比如执行 <code>lsof-c httpd</code> 命令就会查询出以 httpd 开头的进程调用的所有文件。</p>
<p>例 5：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># lsof -p 1</span>
<span>#查询PID是1的进程调用的文件</span>
COMMAND	PID	<span>USER</span>	FD	TYPE	DEVICE	SIZE/OFF	NODE	NAME
init	<span>1</span>	root	cwd	DIR		<span>8</span>，3	<span>4096</span>		<span>2</span>		/
init	<span>1</span>	root	rtd	DIR		<span>8</span>，3	<span>4096</span>		<span>2</span>		/
init	<span>1</span>	root	txt	REG		<span>8</span>，3	<span>145180</span>		<span>130874</span>	/sbin/init
init	<span>1</span>	root	mem	REG		<span>8</span>，3	<span>142472</span>		<span>665291</span>	/lib/ld-2.12.so
init	<span>1</span>	root	mem	REG		<span>8</span>，3	<span>58704</span>		<span>655087</span>	/lib/libnss_files-2.12.so
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>当然，我们也可以按照 PID 查询进程调用的文件，比如执行 <code>lsof -p 1</code> 命令就可以查看 PID 为 1 的进程调用的所有文件。</p>
<p>例 6：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># lsof -u root</span>
<span>#按照用户名查询某个用户的进程调用的文件</span>
COMMAND	PID	<span>USER</span>	FD	TYPE	DEVICE	SIZE/OFF	NODE	NAME
init	<span>1</span>	root	cwd	DIR		<span>8</span>，3	<span>4096</span>		<span>2</span>		/
init	<span>1</span>	root	rtd	DIR		<span>8</span>，3	<span>4096</span>		<span>2</span>		/
init	<span>1</span>	root	txt	REG		<span>8</span>，3	<span>145180</span>		<span>130874</span>	/sbin/init
init	<span>1</span>	root	mem	REG		<span>8</span>，3	<span>142472</span>		<span>665291</span>	/lib/ld-2.12.so
init	<span>1</span>	root	mem	REG		<span>8</span>，3	<span>58704</span>		<span>655087</span>	/lib/libnss_files-2.12.s
init	<span>1</span>	root	mem	REG		<span>8</span>，3	<span>38768</span>		<span>655310</span>	/lib/libnih-dbus.so.1.0.
<span>..</span>.省略部分输出<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>我们还可以查看某个用户的进程调用了哪些文件。</p>
<h2 id="进程的管理"> 进程的管理</h2>
<h3 id="进程优先级"> 进程优先级</h3>
<p>Linux 是一个多用户、多任务的操作系统，系统中通常运行着非常多的进程。但是 CPU 在一个时钟周期内只能运算一条指令（现在的 CPU 采用了多线程、多核心技术，所以在一个时钟周期内可以运算多条指令。  但是同时运算的指令数也远远小于系统中的进程总数），那问题来了：谁应该先运算，谁应该后运算呢？这就需要由进程的优先级来决定了。</p>
<p>另外，CPU 在运算数据时，不是把一个进程运算完成，再进行下一个进程的运算的，而是先运算进程1，再运算进程2，接下来运算进程3，然后再运算进程1，如此循环，直到进程任务结束。不仅如此，由于进程优先级的存在，进程并不是依次运算的，而是哪个进程的优先级高，哪个进程会在一次运算循环中被更多次地运算。</p>
<p>这样说很难理解，我们换一种说法。假设我现在有 4 个孩子（进程）需要喂饭（运算），我更喜欢孩子1（进程1 优先级更高），孩子2、孩子3  和孩子4 一视同仁（进程2、进程3 和进程4 的优先级一致）。现在我开始喂饭了，我不能先把孩子1  喂饱，再喂其他的孩子，而是需要循环喂饭（CPU 运算时所有进程循环运算）。那么，我在喂饭时（运算），会先喂孩子1  一口饭，然后再去喂其他孩子。而且在一次循环中，先喂孩子1 两口饭，因为我更喜欢孩子1（优先级高），而喂其他的孩子一口饭。这样，孩子1  会先吃饱（进程1 运算得更快），因为我更喜欢孩子1。</p>
<p>在 Linux 系统中，表示进程优先级的有两个参数：Priority 和 Nice。还记得 <code>ps -le</code> 命令吗？</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ps -le</span>
F	S	<span>UID</span>		PID		<span>PPID</span>	C	PRI		NI	ADDR	SZ		WCHAN	TTY		TIME		CMD
<span>4</span>	S	<span>0</span>		<span>1</span>		<span>0</span>		<span>0</span>	<span>80</span>		<span>0</span>	-		<span>718</span>		-		?		00:00:01	init
<span>1</span>	S	<span>0</span>		<span>2</span>		<span>0</span>		<span>0</span>	<span>80</span>		<span>0</span>	-		<span>0</span>		-		?		00:00:00	kthreadd
<span>..</span>.省略部分输出<span>..</span>. 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>其中，PRI 代表 Priority，NI 代表 Nice。这两个值都表示优先级，数值越小代表该进程越优先被 CPU 处理。不过，PRI 值是由内核动态调整的，用户不能直接修改。所以我们只能通过修改 NI 值来影响 PRI 值，间接地调整进程优先级。</p>
<blockquote>
<p><strong>PRI 和 NI 的关系如下：</strong></p>
<p><strong>PRI （最终值）= PRI （原始值）+ NI</strong></p>
</blockquote>
<p>其实，大家只需要记得，我们修改 NI 的值就可以改变进程的优先级即可。<u>NI 值越小，进程的 PRI 就会降低，该进程就越优先被 CPU 处理；反之，NI 值越大，进程的 PRI 值就会増加，该进程就越靠后被 CPU 处理。</u></p>
<p>修改 NI 值时有几个注意事项：</p>
<ul>
<li>NI 范围是 -20~19。</li>
<li>普通用户调整 NI 值的范围是 0~19，而且只能调整自己的进程。</li>
<li>普通用户只能调高 NI 值，而不能降低。如原本 NI 值为 0，则只能调整为大于 0。</li>
<li>只有 root 用户才能设定进程 NI 值为负值，而且可以调整任何用户的进程。</li>
</ul>
<p>当 Linux 内核尝试决定哪些运行中的进程可以访问 CPU 时，其中一个需要考虑的因素就是进程优先级的值（也称为 nice 值）。每个进程都有一个介于 -20 到 19 之间的 nice 值。默认情况下，进程的 nice 值为 0。</p>
<p>进程的 nice 值，可以通过 <code>nice</code> 命令和 <code>renice</code> 命令修改，进而调整进程的运行顺序。</p>
<h3 id="nice-命令"> nice 命令</h3>
<p><code>nice</code> 命令可以给要启动的进程赋予 NI 值，但是不能修改已运行进程的 NI 值。</p>
<p><code>nice</code> 命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span> <span># nice [选项] 命令</span>
选项：
	-n NI值	：给命令赋予 NI 值，该值的范围为 -20~19
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># service httpd start</span>
<span>[</span>root@localhost ~<span>]</span><span># ps -le 丨 grep "httd" | grep -v grep</span>
F	S	<span>UID</span>		PID		<span>PPID</span>	C	PRI		NI	ADDR	SZ		WCHAN	TTY		TIME		CMD
<span>1</span>	S	<span>0</span>		<span>2084</span>    <span>1</span>		<span>0</span>	<span>80</span>		<span>0</span>	-		<span>1130</span>	-		?		00:00:00	httpd
<span>5</span>	S	<span>2</span>		<span>2085</span>	<span>2084</span>	<span>0</span>	<span>80</span>		<span>0</span>	-		<span>1130</span>	-		?		00:00:00	httpd
<span>5</span>	S	<span>2</span>		<span>2086</span>	<span>2084</span>	<span>0</span>	<span>80</span>		<span>0</span>	-		<span>1130</span>	-		?		00:00:00	httpd
S	<span>2</span>	<span>2</span>		<span>2087</span>	<span>2084</span>	<span>0</span>	<span>80</span>		<span>0</span>	-		<span>1130</span>	-		?		00:00:00	httpd
<span>5</span>	S	<span>2</span>		<span>2088</span>	<span>2084</span>	<span>0</span>	<span>80</span>		<span>0</span>	-		<span>1130</span>	-		?		00:00:00	httpd
<span>5</span>	S	<span>2</span>		<span>2089</span>	<span>2084</span>	<span>0</span>	<span>80</span>		<span>0</span>	-		<span>1130</span>	-		?		00:00:00	httpd
<span>#用默认优先级自动apache服务，PRI值是80，而NI值是0</span>
<span>[</span>root@localhost ~<span>]</span><span># service httpd stop</span>
<span>#停止apache服务</span>
<span>[</span>root@localhost ~<span>]</span><span># nice -n -5 service httpd start</span>
<span>#启动apache服务，同时修改apache服务进程的NI值为-5</span>
<span>[</span>rooteiocdlhost ~<span>]</span><span># ps -le | grep "httpd" | grep -v grep</span>
F	S	<span>UID</span>		PID		<span>PPID</span>	C	PRI		NI	ADDR	SZ		WCHAN	TTY		TIME		CMD
<span>1</span>	S	<span>0</span>		<span>2122</span>    <span>1</span>		<span>0</span>	<span>75</span>		-5	-		<span>1130</span>	-		?		00:00:00	httpd
<span>5</span>	S	<span>2</span>		<span>2123</span>	<span>2122</span>	<span>0</span>	<span>75</span>		-5	-		<span>1130</span>	-		?		00:00:00	httpd
<span>5</span>	S	<span>2</span>		<span>2124</span>	<span>2122</span>	<span>0</span>	<span>75</span>		-5	-		<span>1130</span>	-		?		00:00:00	httpd
S	<span>2</span>	<span>2</span>		<span>2125</span>	<span>2122</span>	<span>0</span>	<span>75</span>		-5	-		<span>1130</span>	-		?		00:00:00	httpd
<span>5</span>	S	<span>2</span>		<span>2126</span>	<span>2122</span>	<span>0</span>	<span>75</span>		-5	-		<span>1130</span>	-		?		00:00:00	httpd
<span>5</span>	S	<span>2</span>		<span>2127</span>	<span>2122</span>	<span>0</span>	<span>75</span>		-5	-		<span>1130</span>	-		?		00:00:00	httpd
<span>#httpd进程的PRI值变为了75，而NI值为-5</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h3 id="renice-命令"> renice 命令</h3>
<p>同 <code>nice</code> 命令恰恰相反，<code>renice</code> 命令可以在进程运行时修改其 NI 值，从而调整优先级。</p>
<p><code>renice</code> 命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span> <span># renice [优先级] PID</span>
</code></pre>
<div><span>1</span><br></div></div><p>注意，此命令中使用的是进程的 PID 号，因此常与 <code>ps</code> 等命令配合使用。</p>
<p>例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># renice -10 2125</span>
<span>2125</span>: old priority -5, new priority -10

<span>[</span>root@localhost ~<span>]</span><span># ps -le | grep "httpd" | grep -v grep</span>
<span>1</span>	S	<span>0</span>		<span>2122</span>    <span>1</span>		<span>0</span>	<span>75</span>		-5	-		<span>1130</span>	-		?		00:00:00	httpd
<span>5</span>	S	<span>2</span>		<span>2123</span>	<span>2122</span>	<span>0</span>	<span>75</span>		-5	-		<span>1130</span>	-		?		00:00:00	httpd
<span>5</span>	S	<span>2</span>		<span>2124</span>	<span>2122</span>	<span>0</span>	<span>75</span>		-5	-		<span>1130</span>	-		?		00:00:00	httpd
S	<span>2</span>	<span>2</span>		<span>2125</span>	<span>2122</span>	<span>0</span>	<span>70</span>		-10	-		<span>1130</span>	-		?		00:00:00	httpd
<span>5</span>	S	<span>2</span>		<span>2126</span>	<span>2122</span>	<span>0</span>	<span>75</span>		-5	-		<span>1130</span>	-		?		00:00:00	httpd
<span>5</span>	S	<span>2</span>		<span>2127</span>	<span>2122</span>	<span>0</span>	<span>75</span>		-5	-		<span>1130</span>	-		?		00:00:00	httpd
<span>#PID为2125的进程的PRI值为70，而NI值为-10</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>如何合理地设置进程优先级，曾经是一件让系统管理员非常费神的事情。但现在已经不是了，如今的 CPU 足够强大，能够合理地对进程进行调整，输入输出设备也远远跟不上 CPU 地脚步，反而在更多的情况下，CPU 总是在等待哪些缓慢的  I/O（输入/输出）设备完成数据的读写和传输任务。</p>
<p>然而，手动设置进程的优先级并不能影响 I/O 设备对它的处理，这就意味着，哪些有着低优先级的进程常常不合理地占据着本就低效地 I/O 资源。</p>
<h3 id="进程间通信"> 进程间通信</h3>
<p>进程的管理主要是指进程的关闭与重启。我们一般关闭或重启软件，都是关闭或重启它的程序，而不是直接操作进程的。比如，要重启 apache 服务，一般使用命令 <code>service httpd restart</code> 重启 apache 的程序。</p>
<p>那么，可以通过直接管理进程来关闭或重启 apache 吗？答案是肯定的，这时就要依赖进程的信号（Signal）了。我们需要给予该进程号，告诉进程我们想要让它做什么。</p>
<p>系统中可以识别的信号较多，我们可以使用命令 <code>kill -l</code> 或 <code>man 7 signal</code> 来查询。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># kill -l</span>
<span>1</span><span>)</span> SIGHUP			<span>2</span><span>)</span> SIGINT			<span>3</span><span>)</span> SIGQUIT			<span>4</span><span>)</span> SIGILL			<span>5</span><span>)</span> SIGTRAP
<span>6</span><span>)</span> SIGABRT			<span>7</span><span>)</span> SIGBUS			<span>8</span><span>)</span> SIGFPE			<span>9</span><span>)</span> SIGKILL			<span>10</span><span>)</span> SIGUSR1
<span>11</span><span>)</span> SIGSEGV			<span>12</span><span>)</span> SIGUSR2			<span>13</span><span>)</span> SIGPIPE			<span>14</span><span>)</span> SIGALRM			<span>15</span><span>)</span> SIGTERM
<span>16</span><span>)</span> SIGSTKFLT		<span>17</span><span>)</span> SIGCHLD			<span>18</span><span>)</span> SIGCONT			<span>19</span><span>)</span> SIGSTOP			<span>20</span><span>)</span> SIGTSTP
<span>21</span><span>)</span> SIGTTIN			<span>22</span><span>)</span> SIGTTOU			<span>23</span><span>)</span> SIGURG			<span>24</span><span>)</span> SIGXCPU			<span>25</span><span>)</span> SIGXFSZ
<span>26</span><span>)</span> SIGVTALRM		<span>27</span><span>)</span> SIGPROF			<span>28</span><span>)</span> SIGWINCH		<span>29</span><span>)</span> SIGIO			<span>30</span><span>)</span> SIGPWR
<span>31</span><span>)</span> SIGSYS			<span>34</span><span>)</span> SIGRTMIN		<span>35</span><span>)</span> SIGRTMIN+1		<span>36</span><span>)</span> SIGRTMIN+2		<span>37</span><span>)</span> SIGRTMIN+3
<span>38</span><span>)</span> SIGRTMIN +4		<span>39</span><span>)</span> SIGRTMIN +5		<span>40</span><span>)</span> SIGRTMIN+6		<span>41</span><span>)</span>SIGRTMIN+7		<span>42</span><span>)</span> SIGRTMIN+8
<span>43</span><span>)</span> SIGRTMIN +9		<span>44</span><span>)</span> SIGRTMIN +10	<span>45</span><span>)</span> SIGRTMIN+11		<span>46</span><span>)</span> SIGRTMIN+12		<span>47</span><span>)</span> SIGRTMIN+13
<span>48</span><span>)</span> SIGRTMIN +14	<span>49</span><span>)</span> SIGRTMIN +15	<span>50</span><span>)</span> SIGRTMAX-14		<span>51</span><span>)</span> SIGRTMAX-13		<span>52</span><span>)</span> SIGRTMAX-12
<span>53</span><span>)</span> SIGRTMAX-11		<span>54</span><span>)</span> SIGRTMAX-10		<span>55</span><span>)</span> SIGRTMAX-9		<span>56</span><span>)</span> SIGRTMAX-8		<span>57</span><span>)</span> SIGRTMAX-7
<span>58</span><span>)</span> SIGRTMAX-6 		<span>59</span><span>)</span> SIGRTMAX-5		<span>60</span><span>)</span> SIGRTMAX-4		<span>61</span><span>)</span> SIGRTMAX-3		<span>62</span><span>)</span> SIGRTMAX-2
<span>63</span><span>)</span> SIGRTMAX-1		<span>64</span><span>)</span> SIGRTMAX
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>这里介绍一下常见的进程信号，如表4-8 所示。</p>
<p><strong>表4-8	<u>常见的进程信号</u></strong></p>
<table>
<thead>
<tr>
<th>信号代号</th>
<th>信号名称</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>SIGHUP</td>
<td><strong>该信号让进程立即关闭，然后重新读取配置文件之后重启</strong></td>
</tr>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>程序中止信号，用于中止前台进程。相当于输出 Ctrl+C 快捷键</td>
</tr>
<tr>
<td>8</td>
<td>SIGFPE</td>
<td>在发生致命的算术运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为 0 等其他所有的算术运算错误</td>
</tr>
<tr>
<td><strong>9</strong></td>
<td>SIGKILL</td>
<td><strong>用来立即结束程序的运行。本信号不能被阻塞、处理和忽略。般用于强制中止进程</strong></td>
</tr>
<tr>
<td>14</td>
<td>SIGALRM</td>
<td>时钟定时信号，计算的是实际的时间或时钟时间。alarm 函数使用该信号</td>
</tr>
<tr>
<td><strong>15</strong></td>
<td>SIGTERM</td>
<td><strong>正常结束进程的信号，<code>kill</code> 命令的默认信号</strong>。如果进程已经发生了问题，那么这 个信号是无法正常中止进程的，这时我们才会尝试 SIGKILL 信号，也就是信号 9</td>
</tr>
<tr>
<td>18</td>
<td>SIGCONT</td>
<td>该信号可以让暂停的进程恢复执行。本信号不能被阻断</td>
</tr>
<tr>
<td>19</td>
<td>SIGSTOP</td>
<td>该信号可以暂停前台进程，相当于输入 Ctrl+Z 快捷键。本信号不能被阻断</td>
</tr>
</tbody>
</table>
<p>我们只介绍了常见的进程信号，其中最重要的就是 &quot;1&quot;、&quot;9&quot;、&quot;15&quot;这三个信号，我们只需要记住这三个信号即可。</p>
<p>关于如何把这些信号传递给进程，从而控制这个进程，这就需要使用 <code>kill</code>、<code>killall</code> 以及 <code>pkill</code> 命令了，接下来介绍这 3 个命令。</p>
<h3 id="kill-命令-终止进程"> kill 命令：终止进程</h3>
<p><code>kill</code> 从字面来看，就是用来杀死进程的命令，但事实上，这个或多或少带有一定的误导性。从本质上讲，<code>kill</code> 命令只是用来向进程发送一个信号，至于这个信号是什么，是用户指定的。</p>
<p>也就是说，<code>kill</code> 命令的执行原理是这样的，<code>kill</code> 命令会向操作系统内核发送一个信号（多是终止信号）和目标进程的 PID，然后系统内核根据收到的信号类型，对指定进程进行相应的操作。</p>
<p><code>kill</code> 命令的基本格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># kill [信号] PID</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>kill</code> 命令是按照 PID 来确定进程的，所以 <code>kill</code> 命令只能识别 PID，而不能识别进程名。Linux 定义了几十种不同类型的信号，读者可以使用 <code>kill -l</code> 命令查看所有信号及其编号，这里仅列出几个常用的信号，如表4-9 所示。</p>
<p><strong>表4-9	<u>kill 命令的常用信号</u></strong></p>
<table>
<thead>
<tr>
<th>信号编号</th>
<th>信号名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>EXIT</td>
<td>程序退出时收到该信息。</td>
</tr>
<tr>
<td>1</td>
<td>HUP</td>
<td>挂掉电话线或终端连接的挂起信号，这个信号也会造成某些进程在没有终止的情况下重新初始化。</td>
</tr>
<tr>
<td>2</td>
<td>INT</td>
<td>表示结束进程，但并不是强制性的，常用的 &quot;Ctrl+C&quot; 组合键发出就是一个 kill -2 的信号。</td>
</tr>
<tr>
<td>3</td>
<td>QUIT</td>
<td>退出。</td>
</tr>
<tr>
<td>9</td>
<td>KILL</td>
<td>杀死进程，即强制结束进程。</td>
</tr>
<tr>
<td>11</td>
<td>SEGV</td>
<td>段错误。</td>
</tr>
<tr>
<td>15</td>
<td>TERM</td>
<td>正常结束进程，是 kill 命令的默认信号。</td>
</tr>
</tbody>
</table>
<p>需要注意的是，表中省略了各个信号名称的前缀 SIG，也就是说，SIGTERM 和 TERM 这两种写法都对，<code>kill</code> 命令都可以理解。</p>
<p>下面，我们举几个例子来说明一下 <code>kill</code> 命令。</p>
<div><pre><code><span>#例 1: 标准 kill 命令。</span>

<span>[</span>root@localhost ~<span>]</span><span># service httpd start</span>
<span>#启动RPM包默认安装的apache服务</span>
<span>[</span>root@localhost ~<span>]</span><span># pstree -p 丨 grep httpd | grep -v "grep"</span>
<span>#查看 httpd 的进程树及 PID。grep 命令査看 httpd 也会生成包含"httpd"关键字的进程，所以使用“-v”反向选择包含“grep”关键字的进程</span>
<span>#这里使用 pstree 命令来查询进程，当然也可以使用 ps 和 top 命令</span>
<span>|</span>-httpd<span>(</span><span>2246</span><span>)</span>-+-httpd<span>(</span><span>2247</span><span>)</span>
<span>|</span>  <span>|</span>-httpd<span>(</span><span>2248</span><span>)</span>
<span>|</span>  <span>|</span>-httpd<span>(</span><span>2249</span><span>)</span>
<span>|</span>  <span>|</span>-httpd<span>(</span><span>2250</span><span>)</span>
<span>|</span>  <span>|</span>-httpd<span>(</span><span>2251</span><span>)</span>
<span>[</span>root@localhost ~<span>]</span><span># kill 2248</span>
<span>#杀死PID是2248的httpd进程，默认信号是15，正常停止</span>
<span>#如果默认信号15不能杀死进程，则可以尝试-9信号，强制杀死进程</span>
<span>[</span>root@localhost ~<span>]</span><span># pstree -p | grep httpd | grep -v "grep"</span>
<span>|</span>-httpd<span>(</span><span>224</span><span><span>6</span>></span>-+-httpd<span>(</span><span>2247</span><span>)</span>
<span>|</span>  <span>|</span>-httpd<span>(</span><span>2249</span><span>)</span>
<span>|</span>  <span>|</span>-httpd<span>(</span><span>2250</span><span>)</span>
<span>|</span>  <span>|</span>-httpd<span>(</span><span>2251</span><span>)</span>
<span>#PID是2248的httpd进程消失了</span>


<span>#例 2: 使用“-1”信号，让进程重启。</span>

<span>[</span>root@localhost ~<span>]</span><span># kill -1 2246</span>
<span>#使用“-1 (数字1)”信号，让httpd的主进程重新启动</span>
<span>[</span>root@localhost ~<span>]</span><span># pstree -p | grep httpd | grep -v "grep"</span>
<span>|</span>-httpd<span>(</span><span>2246</span><span>)</span>-+-httpd<span>(</span><span>2270</span><span>)</span>
<span>|</span>  <span>|</span>-httpd<span>(</span><span>2271</span><span>)</span>
<span>|</span>  <span>|</span>-httpd<span>(</span><span>2272</span><span>)</span>
<span>|</span>  <span>|</span>-httpd<span>(</span><span>2273</span><span>)</span>
<span>|</span>  <span>|</span>-httpd<span>(</span><span>2274</span><span>)</span>
<span>#子httpd进程的PID都更换了，说明httpd进程已经重启了一次</span>


<span>#例 3: 使用“-19”信号，让进程暂停。</span>

<span>[</span>root@localhost ~<span>]</span><span># vi test.sh</span>
<span>#使用vi命令编辑一个文件，不要退出</span>
<span>[</span>root@localhost ~<span>]</span><span># ps aux | grep "vi" | grep -v "grep"</span>
root <span>2313</span> <span>0.0</span> <span>0.2</span> <span>7116</span> <span>1544</span> pts/1 S+ <span>19</span>:2.0 <span>0</span>:00 <span>vi</span> test.sh
<span>#换一个不同的终端，查看一下这个进程的状态。进程状态是S（休眠）和+（位于后台），因为是在另一个终端运行的命令</span>
<span>[</span>root@localhost ~<span>]</span><span># kill -19 2313</span>
<span>#使用-19信号，让PID为2313的进程暂停。相当于在vi界面按 Ctrl+Z 快捷键</span>
<span>[</span>root@localhost ~<span>]</span><span># ps aux | grep "vi" | grep -v "grep"</span>
root <span>2313</span> <span>0.0</span> <span>0.2</span> <span>7116</span> <span>1580</span> pts/1 T <span>19</span>:20 <span>0</span>:00 <span>vi</span> test.sh
<span>#注意2313进程的状态，变成了 T（暂停）状态。这时切换回vi的终端,发现vi命令已经暂停，又回到了命令提示符，不过2313进程就会卡在后台。</span>
<span>#如果想要恢复，可以使用"kill -9 2313”命令强制中止进程，也可以利用后面将要学习的工作管理来进行恢复</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><p>学会如何使用 <code>kill</code> 命令之后，再思考一个问题，使用 <code>kill</code> 命令一定可以终止一个进程吗？</p>
<p>答案是否定的。文章开头说过，<code>kill</code> 命令只是“发送”一个信号，因此，只有当信号被程序成功“捕获”，系统才会执行 <code>kill</code> 命令指定的操作；反之，如果信号被“封锁”或者“忽略”，则 <code>kill</code> 命令将会失效。</p>
<h3 id="killall-命令-终止特定的一类进程"> killall 命令：终止特定的一类进程</h3>
<p><code>killall</code> 也是用于关闭进程的一个命令，但和 <code>kill</code> 不同的是，<code>killall</code> 命令不再依靠 PID 来杀死单个进程，而是通过程序的进程名来杀死一类进程，也正是由于这一点，该命令常与 <code>ps</code>、<code>pstree</code> 等命令配合使用。</p>
<p><code>killall</code> 命令的基本格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># killall [选项] [信号] 进程名</span>
选项：
	-i：交互式，询问是否要杀死某个进程
	-I：忽略进程名的大小写
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>接下来，给大家举几个例子。</p>
<div><pre><code><span>#例 1： 杀死 httpd 进程。</span>

<span>[</span>root@localhost ~<span>]</span><span># service httpd start</span>
<span>#启动RPM包默认安装的apache服务</span>
<span>[</span>root@localhost ~<span>]</span><span># ps aux | grep "httpd" | grep -v "grep"</span>
root <span>1600</span> <span>0.0</span> <span>0.2</span> <span>4520</span> <span>1696</span>? Ss <span>19</span>:42 <span>0</span>:00 /usr/local/apache2/bin/httpd -k start
daemon <span>1601</span> <span>0.0</span> <span>0.1</span> <span>4520</span> <span>1188</span>? S <span>19</span>:42 <span>0</span>:00 /usr/local/apache2/bin/httpd -k start
daemon <span>1602</span> <span>0.0</span> <span>0.1</span> <span>4520</span> <span>1188</span>? S <span>19</span>:42 <span>0</span>:00 /usr/local/apache2/bin/httpd -k start
daemon <span>1603</span> <span>0.0</span> <span>0.1</span> <span>4520</span> <span>1188</span>? S <span>19</span>:42 <span>0</span>:00 /usr/local/apache2/bin/httpd -k start
daemon <span>1604</span> <span>0.0</span> <span>0.1</span> <span>4520</span> <span>1188</span>? S <span>19</span>:42 <span>0</span>:00 /usr/local/apache2/bin/httpd -k start
daemon <span>1605</span> <span>0.0</span> <span>0.1</span> <span>4520</span> <span>1188</span>? S <span>19</span>:42 <span>0</span>:00 /usr/local/apache2/bin/httpd -k start
<span>#查看httpd进程</span>
<span>[</span>root@localhost ~<span>]</span><span># killall httpd</span>
<span>#杀死所有进程名是httpd的进程</span>
<span>[</span>root@localhost ~<span>]</span><span># ps aux | grep "httpd" | grep -v "grep"</span>
<span>#查询发现所有的httpd进程都消失了</span>


<span>#例 2： 交互式杀死 sshd 进程。</span>

<span>[</span>root@localhost ~<span>]</span><span># ps aux | grep "sshd" | grep -v "grep"</span>
root <span>1733</span> <span>0.0</span> <span>0.1</span> <span>8508</span> <span>1008</span>? Ss <span>19</span>:47 <span>0</span>:00/usr/sbin/sshd
root <span>1735</span> <span>0.1</span> <span>0.5</span> <span>11452</span> <span>3296</span>? Ss <span>19</span>:47 <span>0</span>:00 sshd: root@pts/0
root <span>1758</span> <span>0.1</span> <span>0.5</span> <span>11452</span> <span>3296</span>? Ss <span>19</span>:47 <span>0</span>:00 sshd: root@pts/1
<span>#查询系统中有3个sshd进程。1733是sshd服务的进程，1735和1758是两个远程连接的进程</span>
<span>[</span>root@localhost ~<span>]</span><span># killall -i sshd</span>
<span>#交互式杀死sshd进程</span>
杀死 sshd<span>(</span><span>1733</span><span>)</span>?<span>(</span>y/N<span>)</span>n
<span>#这个进程是sshd的服务进程，如果杀死，那么所有的sshd连接都不能登陆</span>
杀死 sshd<span>(</span><span>1735</span><span>)</span>?<span>(</span>y/N<span>)</span>n
<span>#这是当前登录终端，不能杀死我自己吧</span>
杀死 sshd<span>(</span><span>1758</span><span>)</span>?<span>(</span>y/N<span>)</span>y
<span>#杀死另一个sshd登陆终端</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h3 id="pkill-命令-终止进程-踢出用户"> pkill 命令：终止进程，踢出用户</h3>
<p>当作于管理进程时，<code>pkill</code> 命令和 <code>killall</code> 命令的用法相同，都是通过进程名杀死一类进程，该命令的基本格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># pkill [信号] 进程名</span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>#例 1</span>

<span>[</span>root@localhost ~<span>]</span><span># pkill -9 httpd</span>
<span>#按名称强制杀死 httpd 进程</span>
<span>[</span>root@localhost ~<span>]</span><span># pstree -p | grep httpd</span>
<span>#查看 apache 进程，发现没有了</span>
<span>[</span>root@localhost ~<span>]</span><span># service httpd start</span>
<span>#重新启动 apache 进程</span>
Starting httpd: httpd: Could not reliably determine the server’s fully qualified domain me, using <span>127.0</span>.0.1 <span>for</span> ServerName
<span>[</span>OK<span>]</span>
<span>[</span>root@localhost ~<span>]</span><span># pstree -p | grep httpd</span>
<span>#再次查看，apache 进程重新启动</span>
    <span>\</span>- httpd <span>(</span><span>11157</span><span>)</span> -+-httpd<span>(</span><span>11159</span><span>)</span>
    <span>|</span>              <span>|</span>-httpd<span>(</span><span>11160</span><span>)</span>
    <span>|</span>              <span>|</span>-httpd<span>(</span><span>11161</span><span>)</span>
    <span>|</span>              <span>|</span>-httpd<span>(</span><span>11162</span><span>)</span>
    <span>|</span>              <span>|</span>-httpd<span>(</span><span>11163</span><span>)</span>
    <span>|</span>              <span>|</span>-httpd<span>(</span><span>11164</span><span>)</span>
    <span>|</span>              <span>|</span>-httpd<span>(</span><span>11165</span><span>)</span>
    <span>|</span>              <span>|</span>-httpd<span>(</span><span>11166</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><ul>
<li><strong><code>pkill</code>命令踢出登陆用户</strong></li>
</ul>
<p>除此之外，<code>pkill</code> 还有一个更重要的功能，即按照终端号来踢出用户登录，此时的 <code>pkill</code> 命令的基本格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># pkill [选项] [信号] 进程名</span>
选项：
	-t 终端号：按照终端号踢出用户
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>学习 <code>killall</code> 命令时，不知道大家发现没有，通过 <code>killall</code> 命令杀死 sshd 进程的方式来踢出用户，非常容易误杀死进程，要么会把 sshd 服务杀死，要么会把自己的登录终端杀死。</p>
<p>所以，不管是使用 <code>kill</code> 命令按照 PID 杀死登录进程，还是使用 <code>killall</code> 命令按照进程名杀死登录进程，都是非常容易误杀死进程的，而使用 <code>pkill</code> 命令则不会，举个例子：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># w</span>
<span>#使用w命令查询本机已经登录的用户</span>
<span>20</span>:06:34 up <span>28</span> min, <span>3</span> users, load average: <span>0.00</span>, <span>0.00</span>, <span>0.00</span>
<span>USER</span>	TTY		FROM			LOGIN@	IDLE	JCPU	PCPU	WHAT
root	ttyl	-				<span>19</span>:47	<span>18</span>:52	<span>0</span>.01s	<span>0</span>.01s	-bash
root	pts/0	<span>192.168</span>.0.100	<span>19</span>:47	<span>0</span>.00s	<span>0</span>.09s	<span>0</span>.04s	w
root	pts/1	<span>192.168</span>.0.100	<span>19</span>:51	<span>14</span>:56	<span>0</span>.02s	<span>0</span>.02s	-bash
<span>#当前主机已经登录了三个root用户，一个是本地终端ttyl登录，另外两个是从192.168.0.100登陆的远程登录</span>
<span>[</span>root@localhost ~<span>]</span><span># pkill -9 -t pts/1</span>
<span>#强制杀死从pts/1虚拟终端登陆的进程</span>
<span>[</span>root@localhost ~<span>]</span><span># w</span>
<span>20</span>:09:09 up <span>30</span> min, <span>2</span> users, load average: <span>0.00</span>, <span>0.00</span>,0.00
<span>USER</span>	TTY		FROM			LOGIN@	IDLE	JCPU	PCPU	WHAT
root	ttyl	-				<span>19</span>:47	<span>21</span>:27	<span>0</span>.01s	<span>0</span>.01s	-bash
root	pts/0	<span>192.168</span>.0.100	<span>19</span>:47	<span>0</span>.00s	<span>0</span>.06s	<span>0</span>.00s	w
<span>#虚拟终端pts/1的登录进程已经被杀死了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div>]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2022-01-26T06:11:29.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">linux系统工作管理</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_manage/04.linux_work/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_manage/04.linux_work/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="工作管理简介"> 工作管理简介</h2>
<p><strong>工作管理指的是在单个登录终端（也就是登录的 Shell 界面）同时管理多个工作的行为</strong>。也就是说，我们登陆了一个终端，已经在执行一个操作，那么是否可以在不关闭当前操作的情况下执行其他操作呢？</p>
<p>当然可以，我们可以再启动一个终端，然后执行其他的操作。不过，是否可以在一个终端执行不同的操作呢？这就需要通过工作管理来实现了。</p>
<p>例如，我在当前终端正在 <code>vi</code> 一个文件，在不停止 <code>vi</code> 的情况下，如果我想在同一个终端执行其他的命令，就应该把 <code>vi</code> 命令放入后台，然后再执行其他命令。把命令放入后台，然后把命令恢复到前台，或者让命令恢复到后台执行，这些管理操作就是工作管理。</p>
<p>后台管理有几个事项需要大家注意：</p>
<ol>
<li>前台是指当前可以操控和执行命令的这个操作环境；后台是指工作可以自行运行，但是不能直接用 <kbd>Ctrl</kbd>+<kbd>C</kbd> 快捷键来中止它，只能使用 fg/bg 来调用工作。</li>
<li>当前的登录终端只能管理当前终端的工作，而不能管理其他登录终端的工作。比如 tty1 登录的终端是不能管理 tty2 终端中的工作的。</li>
<li>放入后台的命令必须可以持续运行一段时间，这样我们才能捕捉和操作它。</li>
<li>放入后台执行的命令不能和前台用户有交互或需要前台输入，否则只能放入后台暂停，而不能执行。比如 <code>vi</code> 命令只能放入后台暂停，而不能执行，因为 <code>vi</code> 命令需要前台输入信息；<code>top</code> 命令也不能放入后台执行，而只能放入后台暂停，因为 <code>top</code> 命令需要和前台交互。</li>
</ol>
<h2 id="如何把命令放入后台"> 如何把命令放入后台</h2>
<p>Linux 命令放入后台的方法有两种，分别介绍如下。</p>
<h3 id="命令-把命令放入后台执行"> <code>命令 &amp;</code>，把命令放入后台执行</h3>
<p>第一种把命令放入后台的方法是在命令后面加入 <code>空格 &amp;</code>。使用这种方法放入后台的命令，在后台处于执行状态。</p>
<p>注意，放入后台执行的命令不能与前台有交互，否则这个命令是不能在后台执行的。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># find / -name install.log &amp;</span>
<span>[</span><span>1</span><span>]</span> <span>1920</span>
<span>#[工作号] 进程号</span>
<span>#把find命令放入后台执行，每个后台命令会被分配一个工作号。命令既然可以执行，就会有进程产生，所以也会有进程号</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这样，虽然 <code>find</code> 命令在执行，但在当前终端仍然可以执行其他操作。如果在终端上出现如下信息：</p>
<div><pre><code><span>[</span><span>1</span><span>]</span>+ Done <span>find</span> / -name install.log
</code></pre>
<div><span>1</span><br></div></div><p>则证明后台的这个命令已经完成了。当然，命令如果有执行结果，则也会显示到操作终端上。其中，[1] 是这个命令的工作号，&quot;+&quot;代表这个命令是最近一个被放入后台的。</p>
<h3 id="命令执行过程中按-ctrl-z-快捷键-命令在后台处于暂停状态"> 命令执行过程中按 Ctrl+z 快捷键，命令在后台处于暂停状态</h3>
<p>使用这种方法放入后台的命令，就算不和前台有交互，能在后台执行，也处于暂停状态，因为 <kbd>Ctrl</kbd>+<kbd>z</kbd> 快捷键就是暂停的快捷键。</p>
<div><pre><code><span>#例 1</span>

<span>[</span>root@localhost ~<span>]</span><span># top</span>
<span>#在top命令执行的过程中，按下Ctrl+z快捷键</span>
<span>[</span><span>1</span><span>]</span>+ Stopped <span>top</span>
<span>#top命令被放入后台，工作号是1，状态是暂停。而且，虽然top命令没有结束，但也能取得控制台权限</span>


<span>#例 2</span>

<span>[</span>root@localhost ~<span>]</span><span># tar -zcf etc.tar.gz /etc</span>
<span>#压缩一下/etc/目录</span>
tar:从成员名中删除开头的<span>"/"</span>
tar:从硬链接目标中删除开头的<span>"/"</span>
^Z
<span>#在执行过程中，按下Ctrl+z快捷键</span>
<span>[</span><span>2</span><span>]</span>+ Stopped tar-zcf etc.tar.gz/etc
<span>#tar命令被放入后台，工作号是2，状态是暂停</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>每个被放入后台的命令都会被分配一个工作号。第一个被放入后台的命令，工作号是 1；第二个被放入后台的命令，工作号是 2，以此类推。</p>
<h2 id="后台命令管理"> 后台命令管理</h2>
<h3 id="jobs-命令-查看后台的工作"> jobs 命令：查看后台的工作</h3>
<p><code>jobs</code> 命令可以用来查看当前终端放入后台的工作，工作管理的名字也来源于 <code>jobs</code> 命令。</p>
<p><code>jobs</code> 命令的基本格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># jobs [选项]</span>
选项：
	-l：列出进程的 PID 号
	-n：只列出上次发出通知后改变了状态的进程
	-p：只列出进程的 PID 号
	-r：只列出运行中的进程
	-s：只列出已停止的进程
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># jobs -l</span>
<span>[</span><span>1</span><span>]</span>- <span>2023</span> Stopped <span>top</span>
<span>[</span><span>2</span><span>]</span>+ <span>2034</span> Stopped <span>tar</span> -zcf etc.tar.gz /etc
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以看到，当前终端有两个后台工作：一个是 <code>top</code> 命令，工作号为 1，状态是暂停，标志是&quot;-&quot;；另一个是 <code>tar</code> 命令，工作号为  2，状态是暂停，标志是&quot;+&quot;。&quot;+&quot;号代表最近一个放入后台的工作，也是工作恢复时默认恢复的工作。&quot;-&quot;号代表倒数第二个放入后台的工作，而第三个以后的工作就没有&quot;+-&quot;标志了。</p>
<p>一旦当前的默认工作处理完成，则带减号的工作就会自动成为新的默认工作，换句话说，不管此时有多少正在运行的工作，任何时间都会有且仅有一个带加号的工作和一个带减号的工作。</p>
<h3 id="gf-命令-把后台命令恢复到前台执行"> gf 命令：把后台命令恢复到前台执行</h3>
<p>前面所讲，都是将工作丢到后台去运行，那么，有没有可以将后台工作拿到前台来执行的办法呢？答案是肯定的，使用 <code>fg</code> 命令即可。</p>
<p><code>fg</code> 命令用于把后台工作恢复到前台执行，该命令的基本格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># fg %工作号</span>
参数：
	%工作号：%可以省略，但若将 ”%工作号“ 全部省略，则此命令会将带有 + 号的工作恢复到前台。

<span>#例如：</span>

<span>[</span>root@localhost ~<span>]</span><span># jobs</span>
<span>[</span><span>1</span><span>]</span>- Stopped <span>top</span>
<span>[</span><span>2</span><span>]</span>+ Stopped tar-zcf etc.tar.gz/etc
<span>[</span>root@localhost ~<span>]</span><span># fg</span>
<span>#恢复“+”标志的工作，也就是tar命令</span>
<span>[</span>root@localhost ~<span>]</span><span># fg %1</span>
<span>#恢复1号工作，也就是top命令</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><code>top</code> 命令是不能在后台执行的，所以，如果要想中止 <code>top</code> 命令，要么把 <code>top</code> 命令恢复到前台，然后正常退出；要么找到 <code>top</code> 命令的 PID，使用 <code>kill</code> 命令杀死这个进程。</p>
<h3 id="bg-命令-把后台暂停的工作恢复到后台执行"> bg 命令：把后台暂停的工作恢复到后台执行</h3>
<p>前面讲过，使用 <kbd>Ctrl</kbd>+<kbd>z</kbd> 快捷键的方式，可以将前台工作放入后台，但是会处于暂停状态，那么，有没有办法可以让后台工作继续在后台执行呢？答案是肯定的，这就需要用到 <code>bg</code> 命令。</p>
<p><code>bg</code> 命令的基本格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># bg %工作号</span>

<span>#和 fg 命令类似，这里的 % 可以省略。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>举个例子，可以试着把上面的放入后台的两个工作恢复运行，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># bg %1</span>
<span>[</span>root@localhost ~<span>]</span><span># bg %2</span>
<span>#把两个命令恢复到后台执行</span>
<span>[</span>root@localhost ~<span>]</span><span># jobs</span>
<span>[</span><span>1</span><span>]</span>+ Stopped <span>top</span>
<span>[</span><span>2</span><span>]</span>- Running <span>tar</span> -zcf etc.tar.gz /etc <span>&amp;</span>
<span>#tar命令的状态变为了Running，但是top命令的状态还是Stopped</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>可以看到，<code>tar</code> 命令确实已经在后台执行了，但是 <code>top</code> 命令怎么还处于暂停状态呢？原因很简单，<code>top</code>  命令是需要和前台交互的，所以不能在后台执行。换句话说，<code>top</code> 命令就是给前台用户显示系统性能的命令，如果 <code>top</code> 命令在后台恢复运行了，那么给谁去看结果呢？</p>
<h3 id="nohup-命令-后台命令脱离终端运行"> nohup 命令：后台命令脱离终端运行</h3>
<p>我们知道，把命令放入后台，只能在当前登录终端执行。如果是远程管理的服务器，在远程终端执行了后台命令，这时退出登录，那么这个后台命令还能继续执行吗？当然时不行的，这个后台命令会被中止。但是我们确实需要在远程终端执行某些后台命令，该如何执行呢？</p>
<p>有以下 3 种方法：</p>
<ol>
<li>把需要在后台执行的命令加入 <code>/etc/rc.local</code> 文件，让系统在启动时执行这个后台程序。这种方法的问题是，服务器是不能随便重启的，如果有临时后台任务，就不能执行了。</li>
<li>使用系统定时任务，让系统在指定的时间执行某个后台命令。这样放入后台的命令与终端无关，是不依赖登录终端的。</li>
<li>使用 <code>nohup</code> 命令。</li>
</ol>
<p>这里重点讲解 <code>nohup</code> 命令的用法。</p>
<p><code>nohup</code> 命令的作用就是让后台工作在离开操作终端时，也能够正确地在后台执行。此命令的基本格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># nohup [命令] &amp;</span>

注意，这里的‘<span>&amp;</span>’表示此命令会在终端后台工作；反之，如果没有‘<span>&amp;</span>’，则表示此命令会在终端前台工作。

<span>#例如：</span>

<span>[</span>root@localhost ~<span>]</span><span># nohup find / -print > /root/file.log &amp;</span>
<span>[</span><span>3</span><span>]</span> <span>2349</span>
<span>#使用find命令，打印/下的所有文件。放入后台执行</span>
<span>[</span>root@localhost ~<span>]</span><span># nohup：忽略输入并把输出追加到"nohup.out"</span>
<span>#有提示信息</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>接下来的操作要迅速，否则 <code>find</code> 命令就会执行结束。然后我们可以退出登录，重新登录之后，执行 <code>ps aux</code> 命令，会发现 <code>find</code> 命令还在运行。</p>
<p>如果 <code>find</code> 命令执行太快，我们就可以写一个循环脚本，然后使用 <code>nohup</code> 命令执行。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vi for.sh</span>
<span>#！/bin/bash</span>
<span>for</span> <span><span>((</span>i<span>=</span><span>0</span><span>;</span>i<span>&lt;=</span><span>1000</span><span>;</span>i<span>=</span>i<span>+</span><span>1</span><span>))</span></span>
<span>#循环1000次</span>
<span>do</span>
<span>echo</span> <span>11</span> <span>>></span> /root/for.log
<span>#在for.log文件中写入11</span>
<span>sleep</span> 10s
<span>#每次循环睡眠10秒</span>
<span>done</span>
<span>[</span>root@localhost ~<span>]</span><span># chmod 755 for.sh</span>
<span>[</span>root@localhost ~<span>]</span><span># nohup /root/for.sh &amp;</span>
<span>[</span><span>1</span><span>]</span> <span>2478</span>
<span>[</span>root@localhost ~<span>]</span><span># nohup：忽略输入并把输出追加到"nohup.out"</span>
<span>#执行脚本</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>接下来退出登录，重新登录之后，这个脚本仍然可以通过 <code>ps aux</code> 命令看到。</p>
<h2 id="系统定时任务"> 系统定时任务</h2>
<p>在进行系统运行和维护时，有些工作可能不是马上就要执行的，而要在某个特定的时间执行一次或重复执行。为了不忘记这些工作，我们需要把它们记录在记事本中。如果计算机可以在指定的时间自动执行指定的任务，那么管理员不就可以轻松多了吗？Linux 的系统定时任务（也可以叫作计划任务）就可以帮助管理员在指定的时间执行指定的工作。比如，在每天的凌展 5:05 执行系统备份脚本，备份系统重要的文件；在每天中午 12:00 发送一封邮件，提醒我到快乐的午休时间了：在每周二的凌晨 5:25 执行系统重启动脚本，让服务器的状态归零。</p>
<p>系统定时任务主要有两种执行方式：第一种是使用 <code>at</code> 命令，<code>at</code> 命令定义的系统定时任务只能在指定时间执行一次，而不能循环执行；第二种是使用 <code>crontab</code> 命令，这个命令设定的系统定时任务比较灵活，可以按照分钟、小时、天、月或星期几循环执行任务。我们分别来介绍这两种系统定时任务的执行方式。</p>
<h3 id="at-命令-一次性执行定时任务"> at 命令：一次性执行定时任务</h3>
<h4 id="atd-服务管理与访问控制"> atd 服务管理与访问控制</h4>
<p>要想使用 <code>at</code> 命令，需提前安装好 <code>at</code> 软件包，并开启 atd 服务。因此，首先来看看如何安装 <code>at</code> 软件包。</p>
<p>在 Linux 系统中，查看 at 软件包是否已安装，可以使用 <code>rpm -q</code> 命令，如下所示：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># rpm -q at</span>
at-3.1.13-20.el7x86_64
<span>#可以看到，当前系统已经安装 at 软件包，若读者所用系统未安装，可使用如下命令进行安装：</span>
<span>[</span>root@localhost ~<span>]</span><span># yum -y install at</span>
<span>#省略输出信息，最终出现 Complete!，证明安装成功。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>除此之外，<code>at</code> 命令要想正确执行，还需要 atd 服务的支持。atd 服务是独立的服务，启动的命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># service atd start</span>
正在启动 atd： 								<span>[</span>确定<span>]</span>
<span>#如果想让 atd 服务开机时自启动，则可以使用如下命令：</span>
<span>[</span>root@localhost ~<span>]</span><span># chkconfig atd on</span>
<span>#当然，独立服务的自启动也可以修改 /etc/rc.local 配置文件，具体怎么做看个人习惯。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>安装好 <code>at</code> 软件包并开启 atd 服务之后，<code>at</code> 命令才可以正常使用，不过在此之前，我们还要学习一下 <code>at</code> 命令的访问控制。</p>
<p>访问控制指的是允许哪些用户使用 <code>at</code> 命令设定定时任务，或者不允许哪些用户使用 <code>at</code> 命令。大家可以将其想象成设定黑名单或白名单，这样更容易理解。</p>
<p><code>at</code> 命令的访问控制是依靠 <code>/etc/at.allow</code>（白名单）和 <code>/etc/at.deny</code>（黑名单）这两个文件来实现的，具体规则如下：</p>
<ul>
<li>如果系统中有 <code>/etc/at.allow</code> 文件，那么只有写入 <code>/etc/at.allow</code> 文件（白名单）中的用户可以使用 <code>at</code>  命令，其他用户不能使用 <code>at</code> 命令（注意，<code>/etc/at.allow</code> 文件的优先级更高，也就是说，如果同一个用户既写入 <code>/etc/at.allow</code> 文件，又写入 <code>/etc/at.deny</code> 文件，那么这个用户是可以使用 <code>at</code> 命令的）。</li>
<li>如果系统中没有 <code>/etc/at.allow</code> 文件，只有 <code>/etc/at.deny</code> 文件，那么写入 <code>/etc/at.deny</code> 文件（黑名单）中的用户不能使用 <code>at</code> 命令，其他用户可以使用 <code>at</code> 命令。不过这个文件对 root 用户不生效。</li>
<li>如果系统中这两个文件都不存在，那么只有 root 用户可以使用 <code>at</code> 命令。</li>
</ul>
<p>系统中默认只有 <code>/etc/at.deny</code> 文件，而且这个文件是空的，因此，系统中所有的用户都可以使用 <code>at</code> 命令。不过，如果我们打算控制用户的 <code>at</code> 命令权限，那么只需把用户写入 <code>/etc/at.deny</code> 文件即可。</p>
<p>对于 <code>/etc/at.allow</code> 和 <code>/etc/at.deny</code> 文件的优先级，我们做一个实验来验证一下，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls -l /etc/at*</span>
-rw-r--r--.1 root root <span>1</span> <span>1</span>月 <span>30</span> <span>2012</span> /etc/at.deny
<span>#系统中默认只有at.deny文件</span>
<span>[</span>root@localhost ~<span>]</span><span># echo user1 >> /etc/at.deny</span>
<span>[</span>root@localhost ~<span>]</span><span># cat /etc/at.deny</span>
user1
<span>#把user1用户写入/etc/at.deny文件</span>
<span>[</span>root@localhost ~<span>]</span><span># su - user1</span>
<span>[</span>user1@localhost ~<span>]</span>$ at 02:00
You <span>do</span> not have permission to use at.
<span>#没有权限使用at命令，切换成user1用户，这个用户已经不能执行at命令了</span>
<span>[</span>user1@localhost ~<span>]</span>$ <span>exit</span>
<span>logout</span>
<span>#返回root身份</span>
<span>[</span>root@localhost ~<span>]</span><span># echo user1 >> /etc/at.allow</span>
<span>[</span>root@localhost ~<span>]</span><span># cat /etc/at.allow</span>
user1
<span>#建立/etc/at.allow文件，并在文件中写入user1用户</span>
<span>[</span>root@localhost ~<span>]</span><span># su - user1</span>
<span>[</span>user1@localhost ~<span>]</span>$ at 02:00
at<span>></span>
<span>#切换成user1用户，user1用户可以执行at命令。这时user1用户既在/etc/at.deny文件中，又在/etc/at.allow文件中，但是/etc/at.allow文件的优先级更高</span>
<span>[</span>user1@localhost ~<span>]</span>$ <span>exit</span>
<span>logout</span>
<span>#返回root身份</span>
<span>[</span>root@localhost ~<span>]</span><span># at 02:00</span>
at<span>></span>
<span>#root用户虽然不在/etc/at.allow文件中，但是也能执行at命令，说明root用户不受这两个文件的控制</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>这个实验说明了 <code>/etc/at.allow</code> 文件的优先级更高，如果 <code>/etc/at.allow</code> 文件存在，则 <code>/etc/at.deny</code> 文件失效。<code>/etc/at.allow</code> 文件的管理更加严格，因为只有写入这个文件的用户才能使用 <code>at</code> 命令，如果需要禁用 <code>at</code> 命令的用户较多，则可以把少数用户写入这个文件。<code>/etc/at.deny</code> 文件的管理较为松散，如果允许使用 <code>at</code> 命令的用户较多，则可以把禁用的用户写入这个文件。不过这两个文件都不能对 root 用户生效。</p>
<h4 id="at-命令"> at 命令</h4>
<p>接下来正式介绍 <code>at</code> 命令。<code>at</code> 命令的格式非常简单，基本格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># at [选项] [时间]</span>
选项：
	-m			：当 at 工作完成后，无论命令是否输出，都用 E-mail 通知执行 at 命令的用户
	-c 工作号	：显示该 at 工作的实际内容
	-t 时间		：在指定时间提交工作并执行，时间格式为 <span>[</span><span>[</span>CC<span>]</span>YY<span>]</span>MMDDhhmm
	-d			：删除某个工作，需要提供相应的工作标识号（ID），同 atrm 命令的作用相同
	-l			：列出当前所有等待运行的工作，和 atq 命令具有相同的额作用
	-f 脚本文件	：指定所要提交的脚本文件

时间：
	HH:MM								-在指定的 “时：分” 执行命令，如 02:30 。如果时间已过，则它会在第二天的同一时间执行
	HH:MM YYYY-MM-DD					-在指定的 “时：分 年-月-日” 执行命令，如 02:30 <span>2013</span>-07-25
	HH:MM<span>[</span>am<span>|</span>pm<span>]</span> <span>[</span>month<span>]</span> <span>[</span>date<span>]</span>			-在指定的 “时：分<span>[</span>上午<span>|</span>下午<span>]</span> <span>[</span>月<span>]</span> <span>[</span>日<span>]</span>” 执行命令，如 <span>20</span>:30 July <span>25</span>
	HH:MM<span>[</span>am<span>|</span>pm<span>]</span> + <span>[</span>minutes<span>|</span>hours<span>|</span>days<span>|</span>weeks<span>]</span>	
										-在指定的 “时：分<span>[</span>上午<span>|</span>下午<span>]</span>” 的一段时间之后执行（时间单位 minutes、hours、days 或 weeks）
										 例如 now + <span>5</span> days 表示命令在 <span>5</span> 天之后的此时此刻执行
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p><code>at</code> 命令只要指定正确的时间，就可以输入需要在指定时间执行的命令。这个命令可以是系统命令，也可以是 Shell 脚本。举几个例子。</p>
<div><pre><code><span>#例 1</span>

<span>[</span>root@localhost ~<span>]</span><span># cat /root/hello.sh</span>
<span>#!/bin/bash</span>
<span>echo</span> <span>"hello world!!"</span>
<span>#该脚本会打印"hello world!!"</span>
<span>[</span>root@localhost ~<span>]</span><span># at now +2 minutes</span>
at<span>></span> /root/hello.sh <span>>></span> /root/hello.log
<span>#执行hello.sh脚本，并把输出写入/root/hello.log文件</span>
at<span>></span> <span>&lt;</span>EOT<span>></span>
<span>#使用Ctrl+D快捷键保存at任务</span>
job <span>8</span> at <span>2013</span>-07-25 <span>20</span>:54 <span>#这是第8个at任务,会在2013年7月25日20:54执行</span>
<span>[</span>root@localhost ~<span>]</span><span># at -c 8</span>
<span>#查询第8个at任务的内容</span>
<span>..</span>.省略部分内容<span>..</span>.
<span>#主要定义系统的环境变量</span>
/root/hello.sh <span>>></span> /root/hello.log
<span>#可以看到at执行的任务</span>


<span>#例 2</span>

<span>[</span>root@localhost ~J<span># at 02:00 2013-07-26</span>
at<span>></span> /bin/sync
at<span>></span> /sbin/shutdown -h now
at<span>></span> <span>&lt;</span>EOT<span>></span>
job <span>9</span> at <span>2013</span>-07-26 02:00
<span>#在指定的时间关机。在一个at任务中是可以执行多个系统命令的</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><div><p>说明</p>
<p>在使用系统定时任务时，不论执行的是系统命令还是 Shell 脚本，最好使用绝对路径来写命令，这样不容易报错。at 任务一旦使用 <kbd>Ctrl</kbd>+<kbd>D</kbd> 快捷键保存，实际上写入了 <code>/var/spool/at/</code> 这个目录，这个目录内的文件可以直接被 atd 服务调用和执行。</p>
</div>
<h4 id="其他-at-管理命令"> 其他 at 管理命令</h4>
<p>上面提到了 <code>atq</code> 命令和 <code>atrm</code> 命令。</p>
<p><code>atq</code> 命令，用于查看当前等待运行的工作</p>
<p><code>atrm</code> 命令，用于删除指定的工作</p>
<p>它们的使用方法也很简单，这里给大家举几个简单的例子。</p>
<div><pre><code><span>#例 3 ： atq 命令的用法</span>

<span>[</span>root@localhost ~<span>]</span><span># atq</span>
<span>9</span> <span>2013</span>-07-26 02：00 a root
<span>#说明root用户有一个at任务在2013年7月26日02：00执行，工作号是9</span>
<span>[</span>root@localhost ~<span>]</span><span># atrm [工作号]</span>
<span>#删除指定的at任务</span>


<span>#例 4： atrm 命令的用法</span>

<span>[</span>root@localhost ~<span>]</span><span># atrm 9</span>
<span>[</span>root@localhost ~<span>]</span><span># atq</span>
<span>#删除9号at任务，再查询就没有at任务存在了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="crontab-命令-循环执行定时任务"> crontab 命令：循环执行定时任务</h3>
<p>前面学习了 <code>at</code> 命令，此命令在指定的时间仅能执行一次任务，但在实际工作中，系统的定时任务一般是需要重复执行的。而 <code>at</code> 命令显然无法满足需求，这是就需要使用 <code>crontab</code> 命令来执行循环定时任务。</p>
<h4 id="crond-服务管理与访问控制"> crond 服务管理与访问控制</h4>
<p>在介绍 <code>crontab</code> 命令之前，我们首先要介绍一下 crond，因为 <code>crontab</code> 命令需要 crond 服务支持。crond 是 Linux 下用来周期地执行某种任务或等待处理某些事件的一个守护进程，和 Windows 中的计划任务有些类似。</p>
<p>crond 服务的启动和自启动方法如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># service crond restart</span>
停止 crond:									<span>[</span>确定<span>]</span>
正在启动 crond:								<span>[</span>确定<span>]</span>
<span>#重新启动crond服务</span>
<span>[</span>root@localhost ~<span>]</span><span># chkconfig crond on</span>
<span>#设定crond服务为开机自启动</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>其实，在安装完成操作系统后，默认会安装 crond 服务工具，且 crond 服务默认就是自启动的。crond 进程每分钟会定期检查是否有要执行的任务，如果有，则会自动执行该任务。</p>
<p>接下来，在介绍 <code>crontab</code> 命令。该命令和 <code>at</code> 命令类似，也是通过 <code>/etc/cron.allow</code> 和 <code>/etc/cron.deny</code> 文件来限制某些用户是否可以使用 <code>crontab</code> 命令的。而且原则也非常相似：</p>
<ul>
<li>当系统中有 <code>/etc/cron.allow</code> 文件时，只有写入此文件的用户可以使用 <code>crontab</code> 命令，没有写入的用户不能使用 <code>crontab</code>  命令。同样，如果有此文件，<code>/etc/cron.deny</code> 文件会被忽略，因为 <code>/etc/cron.allow</code> 文件的优先级更高。</li>
<li>当系统中只有 <code>/etc/cron.deny</code> 文件时，写入此文件的用户不能使用 <code>crontab</code> 命令，没有写入文件的用户可以使用 <code>crontab</code> 命令。</li>
<li>这个规则基本和 <code>at</code> 命令的规则一致，同样是 <code>/etc/cron.allow</code> 文件比 <code>/etc/cron.deny</code> 文件的优先级高，Linux 系统中默认只有 <code>/etc/cron.deny</code> 文件。</li>
</ul>
<h4 id="用户的-crontab-设置"> 用户的 crontab 设置</h4>
<p>每个用户都可以实现自己的 <code>crontab</code> 定时任务，只需使用这个用户身份执行 <code>crontab -e</code> 命令即可。当然，这个用户不能写入 <code>/etc/cron.deny</code> 文件。</p>
<p><code>crontab</code> 命令的基本格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># crontab [选项] [file]</span>
选项：
-u user	：用来设定某个用户的 <span>crontab</span> 服务，例如 <span>"-u demo"</span> 表示设备 demo  用户的 <span>crontab</span> 服务，此选项一般有 root 用户来运行
-e		：编辑某个用户的 <span>crontab</span> 文件内容。如果不指定用户，则表示编辑当前用户的 <span>crontab</span> 文件
-l		：显示某用户的 <span>crontab</span> 文件内容，如果不指定用户，则表示显示当前用户的 <span>crontab</span> 文件内容
-r		：从 /var/spool/cron 删除某用户的 <span>crontab</span> 文件，如果不指定用户，则默认删除当前用户的 <span>crontab</span> 文件
-i		：在删除用户的 <span>crontab</span> 文件时，给确认提示

注意：
这里的 <span>file</span> 指的是命令文件的名字，表示将 <span>file</span> 作为 <span>crontab</span> 的任务列表文件并载入 crontab，
若在命令行中未指定文件名，则此命令将接受标准输入（键盘）上键入的命令，并将它们键入 crontab。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>其实 <code>crontab</code> 定时任务非常简单，只需执行 <code>crontab -e</code> 命令，然后输入想要定时执行的任务即可。不过，当我们执行 <code>crontab -e</code> 命令时，打开的是一个空文件，而且操作方法和 <code>Vim</code> 是一致的。那么，个文件的格式才是我们真正需要学习的内容。文件格式如下：</p>
<div><pre><code><span>[</span>root@localhost ！<span>]</span><span># crontab -e</span>
<span>#进入 crontab 编辑界面。会打开Vim编辑你的任务，或者其他的编辑器工具，可以根据自己习惯选择编辑器</span>
* * * * * 执行的任务
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这个文件中是通过 5 个“<strong>*</strong>”来确定命令或任务的执行时间的，这 5 个“<strong>*</strong>”的具体含义如表5-1 所示。</p>
<p><strong>表5-1	<u>crontab 时间表示</u></strong></p>
<table>
<thead>
<tr>
<th>项目</th>
<th>含义</th>
<th>范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>第一个&quot;*&quot;</td>
<td>一小时当中的第几分钟（minute）</td>
<td>0~59</td>
</tr>
<tr>
<td>第二个&quot;*&quot;</td>
<td>一天当中的第几小时（hour）</td>
<td>0~23</td>
</tr>
<tr>
<td>第三个&quot;*&quot;</td>
<td>一个月当中的第几天（day）</td>
<td>1~31</td>
</tr>
<tr>
<td>第四个&quot;*&quot;</td>
<td>一年当中的第几个月（month）</td>
<td>1~12</td>
</tr>
<tr>
<td>第五个&quot;*&quot;</td>
<td>一周当中的星期几（week）</td>
<td>0~7（0和7都代表星期日）</td>
</tr>
</tbody>
</table>
<p>在时间表示中，还有一些特殊符号需要学习，如表5-2 所示。</p>
<p><strong>表5-2	<u>时间特殊符号</u></strong></p>
<table>
<thead>
<tr>
<th>特殊符号</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>*（星号）</td>
<td>代表任何时间。<br />比如第一个&quot;*&quot;就代表一小时种每分钟都执行一次的意思。</td>
</tr>
<tr>
<td>,（逗号）</td>
<td>代表不连续的时间。<br />比如&quot;0 8,12,16 * * * 命令&quot;就代表在每天的 8 点 0 分、12 点 0 分、16 点 0 分都执行一次命令。</td>
</tr>
<tr>
<td>-（中杠）</td>
<td>代表连续的时间范围。<br />比如&quot;0 5 * * 1-6 命令&quot;，代表在周一到周六的凌晨 5 点 0 分执行命令。</td>
</tr>
<tr>
<td>*/n（正斜线）</td>
<td>代表每隔多久执行一次。<br />比如&quot;*/10 * * * * 命令&quot;，代表每隔 10 分钟就执行一次命令。</td>
</tr>
</tbody>
</table>
<p>当 <code>crontab -e</code> 编辑完成之后，一旦保存退出，那么这个定时任务实际就会写入 <code>/var/spool/cron/</code> 目录中，每个用户的定时任务用自己的用户名进行区分。而且 <code>crontab</code> 命令只要保存就会生效，只要 crond 服务是启动的。</p>
<div><p>示例说明</p>
<p>知道了这 5 个时间字段的含义，我们多举几个时间的例子来熟悉一下时间字段，如下所示。</p>
<p>45 22 * * * 命令		：<u>在 22 点 45 分执行命令</u></p>
<p>0 17 * * 1 命令			：<u>在每周一的 17 点 0 分执行命令</u></p>
<p>0 5 1,15 * * 命令		：<u>在每月 1 日和 15 日的凌晨 5 点 0 分执行命令</u></p>
<p>40 4 * * 1-5命令		：<u>在每周一到周五的凌晨 4 点 40 分执行命令</u></p>
<p>*/10 4 * * * 命令		：<u>在每天的凌晨 4 点，每隔 10 分钟执行一次命令</u></p>
<p>0 0 1,15 * 1 命令		：<u>在每月 1 日和 15 日，每周一的 0 点 0 分都会执行命令</u></p>
<p><strong>注意：星期几和几日最好不要同时出现，因为它们定义的都是天，非常容易让管理员混淆</strong></p>
</div>
<p>现在我们已经对这 5 个时间字段非常熟悉了，可是在“执行的任务”字段中都可以写什么呢？既可以定时执行系统命令，也可以定时执行某个 Shell 脚本，这里举几个实际的例子。</p>
<div><pre><code><span>#例 1： 让系统每隔 5 分钟就向 /tmp/test 文件中写入一行“11”，验证一下系统定时任务是否会执行。</span>

<span>[</span>root@localhost ~<span>]</span><span># crontab -e</span>
<span>#进入编辑界面</span>
*/5 * * * * /bin/echo <span>"11"</span> <span>>></span> /tmp/test
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这个任务在时间工作中没有任何意义，但是可以很简单地验证我们的定时任务是否可以正常执行。如果觉得每隔 5 分钟太长，那就换成“*”，让它每分钟执行一次。而且和 <code>at</code> 命令一样，如果我们定时执行的是系统命令，那么最好使用绝对路径。</p>
<div><pre><code><span>#例 2： 让系统在每周二的凌晨 5 点 05 分重启一次。</span>

<span>[</span>root@localhost ~<span>]</span><span># crontab -e</span>
<span>5</span> <span>5</span> * * <span>2</span> /sbin/shutdown -r now
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果服务器的负载压力比较大，则建议每周重启一次，让系统状态归零。比如绝大多数游戏服务器每周维护一次，维护时最主要的工作就是重启，让系统状态归零。这时可以让我们的服务器自动来定时执行。</p>
<div><pre><code><span>#例 3： 在每月 1 日、10 日、15 日的凌晨 3 点 30 分都定时执行日志备份脚本 autobak.sh。</span>

<span>[</span>root@localhost ~<span>]</span><span># crontab -e</span>
<span>30</span> <span>3</span> <span>1,10</span>,15 * * /root/sh/autobak.sh
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这些定时任务保存之后，就可以在指定的时间执行了。我们可以使用命令来查看和删除定时任务，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># crontab -l</span>
<span>#查看root用户的crontab任务</span>
*/5 * * * * /bin/echo <span>"11"</span> <span>>></span> /tmp/test
<span>5</span> <span>5</span> * * <span>2</span> /sbin/shutdown -r now
<span>30</span> <span>3</span> <span>1,10</span>,15 * * /root/sh/autobak.sh
<span>[</span>root@localhost ~<span>]</span><span># crontab -r</span>
<span>#删除root用户所有的定时任务。如果只想删除某个定时任务，则可以执行“crontab -e”命令进入</span>
<span>#编辑模式手工删除</span>
<span>[</span>root@localhost ~<span>]</span><span># crontab -l</span>
no <span>crontab</span> <span>for</span> root
<span>#删除后，再查询就没有root用户的定时任务了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h4 id="crontab-的注意事项"> crontab 的注意事项</h4>
<p>在书写 <code>crontab</code> 定时任务时，需要注意以下几个事项：</p>
<ul>
<li>6 个选项都不能为空，必须填写。如果不确定，则使用“*”代表任意时间。</li>
<li><code>crontab</code> 定时任务的最小有效时间是分钟，最大有效时间是月。像 2018 年某时执行、3 点 30 分 30 秒这样的时间都不能被识别。</li>
<li>在定义时间时，日期和星期最好不要在一条定时任务中出现，因为它们都以天为单位，非常容易让管理员混淆。</li>
<li>在定时任务中，不管是直接写命令，还是在脚本中写命令，最好都使用绝对路径。有时使用相对路径的命令会报错。</li>
</ul>
<h4 id="系统的-crontab-设置"> 系统的 crontab 设置</h4>
<p><code>crontab -e</code> 是每个用户都可以执行的命令，也就是说，不同的用户身份可以执行自己的定时任务。但是有些定时任务需要系统执行，这时就需要编辑 <code>/etc/crontab</code> 这个配置文件了。</p>
<p>当然，并不是说写入 <code>/etc/crontab</code> 配置文件中的定时任务在执行时不需要用户身份，而是 <code>crontab -e</code> 命令在定义定时任务时，默认用户身份是当前登录用户。而在修改 <code>/etc/crontab</code> 配置文件时，定时任务的执行者身份是可以手工指定的。这样定时任务的执行会更加灵活，修改起来也更加方便。</p>
<p>那我们打开这个文件看看吧，如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vi /etc/crontab</span>
<span><span>SHELL</span></span><span>=</span>/bin/bash
<span>#标识使用哪种Shell</span>
<span><span>PATH</span></span><span>=</span>/sbin：/bin：/usr/sbin：/usr/bin
<span>#指定PATH环境变量。crontab使用自己的PATH，而不使用系统默认的PATH，所以在定时任务中出现的命令最好使用大写</span>
<span>MAILTO</span><span>=</span>root
<span>#如果有报错输出，或命令结果有输出，则会向root发送信息</span>
<span><span>HOME</span></span><span>=</span>/
<span>#标识主目录</span>
<span># For details see man 4 crontabs</span>
<span>#提示大家可以去“man 4 crontabs”查看帮助</span>
<span># Example of job definition：</span>
<span>#.——————————— minute (0 - 59)</span>
<span># |.———————— hour (0 - 23)</span>
<span># | |.——————— day of month (1 - 31)</span>
<span># | | |.———— month (1 - 12) OR jan，feb，mar，apr……</span>
<span># | | | | .———day of week(0-6)(Sunday=0 or 7)OR sun，mon，tue，wed，thu，fri，sat</span>
<span># | | | | |</span>
<span># * * * * * user-name command to be executed</span>
<span>#分 时 日 月 周 执行者身份 命令</span>
<span>#列出文件格式，并加入了注释</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>在 CentOS 6.x 中，<code>/etc/crontab</code> 文件也发生了变化。在 CentOS 5.x 中，这个文件的内容大概是这样子的：</p>
<div><pre><code><span>#以下输出在CentOS 5.5中</span>
<span>[</span>root@sc ~<span>]</span><span># vi /etc/crontab</span>
<span><span>SHELL</span></span><span>=</span>/bin/bash
<span><span>PATH</span></span><span>=</span>/sbin：/bin：/usr/sbin：/usr/bin
<span>MAILTO</span><span>=</span>root
<span><span>HOME</span></span><span>=</span>/
<span># run-parts</span>
01 * * * * root run-parts /etc/cron.hourly
02 <span>4</span> * * * root run-parts /etc/cron.daily
<span>22</span> <span>4</span> * * <span>0</span> root run-parts /etc/cron.weekly
<span>42</span> <span>4</span> <span>1</span> * * root run-parts /etc/cron.monthly
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>在 CentOS 5.x 中，<code>/etc/crontab</code> 文件会使用 run-parts 脚本执行  <code>/etc/cron.{daily，weekly，monthly}</code> 目录中的所有文件。这个 run-parts 其实是一个 Shell  脚本，保存在 <code>/usr/bin/run-parts</code>  中，它的作用就是把其后面跟随的目录中的所有可执行文件依次执行。也就是说，如果我们想让某个脚本在每天都执行一次，那么可以不用手工去写定时任务，而只需要给这个脚本赋予执行权限，并把它放入 <code>/etc/cron.daily/</code> 目录中，这样这个脚本就会在每天的凌晨 4 点 02 分执行了。</p>
<p>但是在 CentOS 6.x 中，<code>/etc/crontab</code> 文件中不再有相关的段落，那么 run-ptars 这种定时任务的执行方法是否不可用了呢？</p>
<p>我们看到 <code>/etc/crontab</code> 中有一句提示，让我们“man 4  crontabs”来查看帮助，那么我们就看看这个帮助吧！在这个帮助中，写明了“在旧版本的 crontab 配置文件中，通过 run-parts  脚本来调用 <code>cron.{daily，weekly，monthly}</code> 目录，定时执行这些目录中的脚本。在当前系统中，为了避免 cron 和  anacron 之间产生冲突，只要 anacron 已经安装，就使用 anacron 来执行这些目录中的脚本。具体可以查看 anacron(8) 的帮助”。对于 anacron 的用法，后面会介绍。</p>
<p>其实，对用户来讲，并不需要知道这个定时任务到底是由哪个程序调用的。我们需要知道的事情是如何使用系统的 <code>crontab</code> 设置。对此，新、老版本的 CentOS 没有区别，配置方法都有两种。</p>
<ul>
<li>
<p>第一种方法就是把需要定时执行的工作写成脚本程序，并赋予执行权限，然后直接把这个脚本复制到  <code>/etc/cron.{daily，weekly，monthly}</code> 目录中的任意一个。比如，我需要让某个脚本每周执行，就把这个脚本复制到  <code>/etc/cron.weekly/</code> 目录中。这样这个脚本就会每周执行一次，具体的执行时间要参考 anacron 的配置文件。</p>
</li>
<li>
<p>第二种方法就是修改 <code>/etc/crontab</code> 这个配置文件，加入自己的定时任务，不过需要注意指定脚本的执行者身份。例如：</p>
</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vi /etc/crontab</span>
<span>..</span>.省略部分输出<span>..</span>.
* * * * * root run-parts /root/cron/
<span>#让系统每分钟都执行一次/root/cron/目录中的脚本，脚本执行者是root用户</span>
<span>#虽然在CentOS 6.x中不直接通过此配置文件调用/etc/cron.{daily，weekly，monthly}这些目录，但是run-parts脚本还是可以使用的。所以我完全可以参照CentOS 5.x的方法来写定时任务</span>
<span>#使用run-parts脚本调用并执行/root/cron/目录中所有的可执行文件</span>
<span>[</span>root@localhost ~<span>]</span><span># mkdir cron</span>
<span>#建立/root/cron/目录</span>
<span>[</span>root@localhost cron<span>]</span><span># vi /root/cron/hello.sh</span>
<span>#/bin/bash</span>
<span>echo</span> <span>"hello"</span> <span>>></span> /root/cron/hello.log
<span>#在/root/cron/hello.log文件中写入“hello”</span>
<span>[</span>root@localhost cron<span>]</span><span># chmod 755 hello.sh</span>
<span>#赋予执行权限</span>
<span>#因为hello.sh脚本放入了/root/cron/目录中，所以每分钟执行一次。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>只要保存 <code>/etc/crontab</code> 文件，这个定时任务就可以执行了。当然要确定 crond 服务是运行的。</p>
<p>这两种方法都是可以使用的，具体看个人的习惯。不过，要想修改 <code>/etc/crontab</code> 文件，必须是 root 用户，普通用户不能修改，只能使用用户身份的 <code>crontab</code> 命令。</p>
<h3 id="anacron-命令-异步执行定时任务"> anacron 命令：异步执行定时任务</h3>
<h4 id="anacron-的作用"> anacron 的作用</h4>
<p>anacron 是用来做什么的呢？设想这样一个场景，Linux 服务器会在周末关机两天，但是设定的定时任务大多在周日早上进行，但在这个时间点，服务器又处于关机状态，导致系统很多定时任务无法运行。</p>
<p>又比如，我们需要在凌晨 5 点 05 分执行系统的日志备份，但 Linux 服务器不是 24  小时开机的，在晚上需要关机，白天上班之后才会再次开机，在这个定时任务的执行时间我们的服务器刚好没有开机，那么这个定时任务就不会执行了。anacron 就是用来解决这个问题的。</p>
<p>anacron 会以 天、周、月作为检测周期，判断是否有定时任务在关机之后没有执行。如果有这样的任务，那么 anacron 会在特定的时间重新执行这些定时任务。</p>
<p>那么，anacron 是如何判断这些定时任务已经超过执行时间的呢？这就需要借助 anacron 读取的时间记录文件。anacron  会分析现在的时间与时间记录文件所记载的上次执行 anacron 的时间，将两者进行比较，如果两个时间的差值超过 anacron  的指定时间差值（一般是 1 天、7 天和一个月），就说明有定时任务没有执行，这时 anacron  会介入并执行这个漏掉的定时任务，从而保证在关机时没有执行的定时任务不会被漏掉。</p>
<div><p>补充</p>
<p>在 CentOS 6.x 中，使用 cronie-anacron 软件包取代了 vixie-cron 软件包。而且在原先 CentOS 版本的  <code>/etc/cron.{daily，weekly，monthly}</code> 目录中的定时任务会同时被 cron 和 anacron  调用，这样非常容易出现重复执行同一个定时任务的错误。因此，在 CentOS 6.x  中，<code>/etc/cron.{daily，weekly，monthly}</code> 目录中的定时任务只会被 anacron 调用，从而保证这些定时任务只会在每天、每周或每月定时执行一次，而不会重复执行。</p>
<p>不仅如此，在 CentOS 6.x 中，anacron 还有一个变化，那就是 anacron 不再是单独的服务，而变成了系统命令。也就是说，我们不再使用 <code>service anacron restart</code> 命令来管理 anacron 服务了，而需要使用 <code>anacron</code> 命令来管理 anacron 工作。</p>
</div>
<h4 id="anacron-命令"> anacron 命令</h4>
<p><code>anacron</code> 命令的基本格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># anacron [选项] [工作名]</span>

选项：
	-f：强制执行相关工作，忽略时间戳
	-u：更新 /var/spool/anacron/cron.<span>{</span>daily，weekly，monthly<span>}</span> 文件中的时间戳为当前日期，但不执行任何工作	
	-s：依据 /etc/anacrontab 文件中设定的延迟时间顺序执行工作，在前一个工作未完成前，不会开始下一个工作
	-n：立即执行 /etc/anacrontab 中所有的工作，忽略所有的延迟时间
	-q：禁止将信息输出到标准错误，常和 -d 选项合用
	
工作名：	
	这里的工作名指的是依据 /etc/anacrontab 文件中定义的工作名
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>在当前的 Linux 中，其实不需要执行任何 <code>anacron</code> 命令，只需要配置好 <code>/etc/anacrontab</code> 文件，系统就会依赖这个文件中的设定来通过 anacron 执行定时任务了。那么，关键就是 <code>/etc/anacrontab</code> 文件的内容了。这个文件的内容如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vi /etc/anacrontab</span>
<span># /etc/anacrontab: configuration file for anacron</span>
<span># See anacron(8) and anacrontab(5) for details.</span>
<span><span>SHELL</span></span><span>=</span>/bin/sh
<span><span>PATH</span></span><span>=</span>/sbin:/bin:/usr/sbin:/usr/bin
<span>MAILTO</span><span>=</span>root
<span>#前面的内容和/etc/crontab类似</span>
<span>#the maximal random delay added to the base delay of the jobs</span>
<span>RANDOM_DELAY</span><span>=</span><span>45</span>
<span>#最大随机廷迟</span>
<span>#the jobs will be started during the following hours only</span>
<span>START_H0URS_RANGE</span><span>=</span><span>3</span>-22
<span>#anacron的执行时间范围是3:00~22:00</span>
<span>#period in days		delay in minutes	job-identifier		command</span>
<span>1</span>					<span>5</span>					cron.daily			<span>nice</span> run-parts /etc/cron.daily
<span>#每天开机 5 分钟后就检查 /etc/cron.daily 目录内的文件是否被执行，如果今天没有被执行，那就执行</span>
<span>7</span>					<span>25</span>					cron.weekly			<span>nice</span> run-parts /etc/cron.weekly
<span>#每隔 7 天开机后 25 分钟检查 /etc/cron.weekly 目录内的文件是否被执行，如果一周内没有被执行，就会执行</span>
@monthly			<span>45</span>					cron.monthly		<span>nice</span> run-parts /etc/cron.monthly
<span>#每隔一个月开机后 45 分钟检查 /etc/cron.monthly 目录内的文件是否被执行，如果一个月内没有被执行，那就执行 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>在这个文件中，“RANDOM_DELAY”定义的是最大随机延迟，也就是说，cron.daily 工作如果超过 1 天没有执行，则并不会马上执行，而是先延迟强制延迟时间，再延迟随机延迟时间，之后再执行命令；“START_HOURS_RANGE”的是定义  anacron 执行时间范围，anacron 只会在这个时间范围内执行。</p>
<p>我们用 cron.daily 工作来说明一下 <code>/etc/anacrontab</code> 的执行过程:</p>
<ol>
<li>读取 <code>/var/spool/anacron/cron.daily</code> 文件中 anacron 上一次执行的时间。</li>
<li>和当前时间比较，如果两个时间的差值超过 1 天，就执行 cron.daily 工作。</li>
<li>只能在 03:00-22:00 执行这个工作。</li>
<li>执行工作时强制延迟时间为 5 分钟，再随机延迟 0～45 分钟。</li>
<li>使用 <code>nice</code> 命令指定默认优先级，使用 run-parts 脚本执行 <code>/etc/cron.daily</code> 目录中所有的可执行文件。</li>
</ol>
<p>大家会发现，<code>/etc/cron.{daily，weekly，monthly}</code> 目录中的脚本在当前的 Linux 中是被 anacron 调用的，不再依靠 cron 服务。不过，anacron 不用设置多余的配置，我们只需要把需要定时执行的脚本放入 <code>/etc/cron.{daily，weekly，monthly}</code> 目录中，就会每天、每周或每月执行，而且也不再需要启动 anacron  服务了。如果需要进行修改，则只需修改 <code>/etc/anacrontab</code> 配置文件即可。</p>
<p>比如，我更加习惯让定时任务在凌晨 03:00-05:00 执行，就可以进行如下修改：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span> <span># vi /etc/anacrontab</span>
<span># /etc/anacrontab: configuration file for anacron</span>
<span># See anacron(8) and anacrontab(5) for details.</span>
<span><span>SHELL</span></span><span>=</span>/bin/sh
<span><span>PATH</span></span><span>=</span>/sbin:/bin:/usr/sbin:/usr/bin
<span>MAILTO</span><span>=</span>root
<span># the maximal random delay added to the base delay of the jobs</span>
<span>RANDOM_DELAY</span><span>=</span><span>0</span>
<span>#把最大随机廷迟改为0分钟,不再随机廷迟</span>
<span># the jobs will be started during the following hours only</span>
<span>START_HOORS_RANGE</span><span>=</span><span>3</span>-5
<span>#执行时间范围为03:00—05:00</span>
<span>#period in days		delay in minutes	job-identifier		command</span>
<span>1</span>					<span>0</span>					cron.daily			<span>nice</span> run-parts /etc/cron.daily
<span>7</span>					<span>0</span>					cron.weekly			<span>nice</span> run-parts /etc/cron.weekly
@monthly			<span>0</span>					cron.monthly		<span>nice</span> run-parts /etc/cron.monthly
<span>#把强制延迟也改为0分钟,不再强制廷迟</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>这样，所有放入 <code>/etc/cron.{daily，weekly，monthly}</code> 目录中的脚本都会在指定时间执行，而且也不怕服务器万一关机的情况了。</p>
<h2 id="系统资源查看"> 系统资源查看</h2>
<p>前面学习了 <code>ps</code>、<code>top</code>、<code>pstree</code> 命令，它们除了可以查看系统进程之外，还可以帮助我们判断系统的健康状态，尤其时 <code>top</code> 命令可以看到的信息非常多，也非常重要。Linux 系统除了这几个命令之外，还有一些重要的系统资源查看命令，下面我们详细学习一下。</p>
<h3 id="vmstat-命令-监控系统资源"> vmstat 命令：监控系统资源</h3>
<p><code>vmstat</code> 命令，可用来监控 CPU 使用、进程状态、内存使用、虚拟内存使用、硬盘输入/输出状态等信息。</p>
<p>英文原意： Report virtual memory statistics</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vmstat [选项]  [刷新延时 刷新次数]</span>
选项：
	-a		：显示活跃和非活跃内存
	-f		：显示从系统启动至今的fork数量 
	-d		：显示磁盘相关统计信息
	-S 单位	：使用指定单位显示。参数有 k 、K 、m 、M，默认 K
	-p 分区设备名：显示指定磁盘分区统计信息                          
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>例如：</p>
<div><pre><code><span>[</span>root@localhost proc<span>]</span><span># vmstat 1 3</span>
<span>#使用vmstat检测，每隔1秒刷新一次，共刷新3次</span>
procs-------------memory-------------swap-----io----system------cpu--------
r b		swpd <span>free</span>   buff  cache		si so	bi bo	<span>in</span> cs	us sy <span>id</span>  wa st
<span>0</span> <span>0</span>		 <span>0</span>	 <span>407376</span> <span>55772</span> <span>84644</span>		 <span>0</span>  <span>0</span> 	 <span>5</span>  <span>2</span>	 <span>9</span> <span>10</span>	 <span>0</span> 	<span>0</span> <span>100</span>  <span>0</span>  <span>0</span>
<span>0</span> <span>0</span>		 <span>0</span>	 <span>407368</span> <span>55772</span> <span>84644</span>		 <span>0</span>  <span>0</span> 	 <span>0</span>  <span>0</span>	<span>12</span> <span>10</span>	 <span>0</span> 	<span>0</span> <span>100</span>  <span>0</span>  <span>0</span>
<span>0</span> <span>0</span>		 <span>0</span>	 <span>407368</span> <span>55772</span> <span>84644</span>		 <span>0</span>  <span>0</span> 	 <span>0</span>  <span>0</span>	<span>15</span> <span>13</span>	 <span>0</span> 	<span>0</span> <span>100</span>  <span>0</span>  <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>该命令输出信息中，各个字段以及含义如表5-3 所示。</p>
<p><strong>表5-3	<u>vmstat 命令输出字段及含义</u></strong></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>procs</td>
<td>进程信息字段：<br />-r：等待运行的进程数，数量越大，系统越繁忙。<br />-b：不可被唤醒的进程数量，数量越大，系统越繁忙。</td>
</tr>
<tr>
<td>memory</td>
<td>内存信息字段：<br />-swpd：虚拟内存的使用情况，单位为 KB。<br />-free：空闲的内存容量，单位为 KB。<br />-buff：缓冲的内存容量，单位为 KB。<br />-cache：缓存的内存容量，单位为 KB。</td>
</tr>
<tr>
<td>swap</td>
<td>交换分区信息字段：<br /> -si：从磁盘中交换到内存中数据的数量，单位为 KB。<br />-so：从内存中交换到磁盘中数据的数量，单位为 KB。<br />这两个数越大，表明数据需要经常在磁盘和内存之间进行交换，系统性能越差。</td>
</tr>
<tr>
<td>io</td>
<td>磁盘读/写信息字段： <br />-bi：从块设备中读入的数据的总量，单位是块。<br />-bo：写到块设备的数据的总量，单位是块。<br />这两个数越大，代表系统的 I/O 越繁忙。</td>
</tr>
<tr>
<td>system</td>
<td>系统信息字段：<br /> -in：每秒被中断的进程次数。<br />-cs：每秒进行的事件切换次数。<br />这两个数越大，代表系统与接口设备的通信越繁忙。</td>
</tr>
<tr>
<td>cpu</td>
<td>CPU信息字段：<br />-us：非内核进程消耗 CPU 运算时间的百分比。<br />-sy：内核进程消耗 CPU 运算时间的百分比。<br />-id：空闲 CPU 的百分比。<br />-wa：等待 I/O 所消耗的 CPU 百分比。<br />-st：被虚拟机所盗用的 CPU 百分比。</td>
</tr>
</tbody>
</table>
<p>本机是一台测试用的虚拟机，并没有多少资源被占用，所以资源占比都比较低。如果服务器上的资源占用率比较高，那么使用 <code>vmstat</code> 命令查看到的参数值就会比较大，我们就需要手工进行干预。如果是非正常进程占用了系统资源，则需要判断这些进程是如何产生的，不能一杀了之；如果是正常进程占用了系统资源，则说明服务器需要升级了。</p>
<h3 id="dmesg-命令-显示开机信息"> dmesg 命令：显示开机信息</h3>
<p>在系统启动过程中，内核还会进行一次系统检测（第一次是 BIOS 进行检测），但是检测的过程不是没有显示在屏幕上，就是会快速的在屏幕上一闪而过那么，如果开机时来不及查看相关信息，我们是否可以在开机后查看呢？</p>
<p>答案是肯定的，使用 <code>dmesg</code> 命令就可以。无论是系统启动过程中，还是系统运行过程中，只要是内核产生的信息，都会被存储在系统缓冲区中，如果开机时来不及查看相关信息，可以使用 <code>dmesg</code> 命令将信息调出，此命令常用于查看系统的硬件信息。</p>
<p>除此之外，开机信息也可以通过 <code>/var/log/</code> 目录中的 <code>dmesg</code> 文件进行查看。</p>
<p><code>dmesg</code> 命令的用法很简单，基本格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># dmesg</span>
</code></pre>
<div><span>1</span><br></div></div><p>例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># dmesg | grep CPU</span>
<span>#查看CPU的信息</span>
Transmeta TransmetaCPU
SMP：Allowing <span>1</span> CPUs， <span>0</span> hotplug CPUs
NR_CPUS：32 nr_cpumask_bits：32 nr_cpu_ids：1 nr_node_ids：1
PERCPU：Embedded <span>14</span> pages/cpu @c1a00000 s35928 r0 d21416 u2097152
Initializing CPU<span>#0</span>
CPU：Physical Processor ID：0
mce：CPU supports <span>0</span> MCE banks
CPU0：Intel<span>(</span>R<span>)</span> Core<span>(</span>TM<span>)</span> i7-3630QM CPU @ <span>2</span>.40GHz stepping 09
Brought up <span>1</span> CPUs
microcode：CPU0 <span>sig</span><span>=</span>0x306a9， <span>pf</span><span>=</span>0x1， <span>revision</span><span>=</span>0x12

<span>[</span>root@localhost ~<span>]</span><span># dmesg | grep eth0</span>
<span>#查看第一块网卡的信息</span>
eth0：registered as PCnet/PCI II 79C970A
eth0：link up
eth0：no IPv6 routers present
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id="free-命令-查看内存使用状态"> free 命令：查看内存使用状态</h3>
<p><code>free</code> 命令用来显示系统内存状态，包括系统物理内存、虚拟内存（swap 交换分区）、共享内存和系统缓存的使用情况，其输出和 <code>top</code> 命令的内存部分非常相似。</p>
<p>free 命令的基本格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># free [选项]</span>
选项：
	-b			：以 Byte（字节）为单位，显示内存使用情况
	-k			：以 KB 为单位，显示内存使用情况，此选项是 <span>free</span> 命令的默认选项
	-m			：以 MB 为单位，显示内存使用情况
	-g			：以 GB 为单位，显示内存使用情况
	-t			：在输出的最终结果中，输出内存和 swap 分区的总量
	-o			：不显示系统缓冲区这一列
	-s 间隔秒数	：根据指定的间隔时间，持续显示内存使用情况
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>例如：</p>
<div><pre><code>[root@localhost ~]# free -m
 			total	used	free	shared	buffers	cached
 Mem:		725		666		59		0		132		287
 -/+ buffers/cache: 245		479
 Swap:		996		0		996
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><blockquote>
<p>第一行显示的是各个列的列表头信息，各自的含义如下所示：</p>
<blockquote>
<p>total 是总内存数；</p>
<p>used 是已经使用的内存数；</p>
<p>free 是空闲的内存数；</p>
<p>shared 是多个进程共享的内存总数；</p>
<p>buffers 是缓冲内存数；</p>
<p>cached 是缓存内存数。</p>
</blockquote>
</blockquote>
<blockquote>
<p>Mem 一行指的是内存的使用情况；</p>
</blockquote>
<blockquote>
<p>-/buffers/cache 的内存数，相当于第一行的  used-buffers-cached；</p>
<p>+/buffers/cache 的内存数，相当于第一行的  free+buffers+cached；</p>
</blockquote>
<blockquote>
<p>Swap 一行指的就是 swap 分区的使用情况。</p>
</blockquote>
<p>可以看到，系统的物理内存为 725 MB，已经使用了 666 MB，空闲 59 MB。而 swap 分区总大小为 996 MB，目前尚未使用。</p>
<h3 id="proc-cpuinfo-查看-cpu-信息"> /proc/cpuinfo：查看 CPU 信息</h3>
<p>CPU 的主要信息保存在 /proc/cpuinfo 这个文件中，我们只要查看这个文件，就可以知道 CPU 的相关信息。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cat /etc/cpuinfo</span>
processor		<span>:</span> <span>2</span>												<span>&lt;</span>---逻辑CPU编号
vendor_id		<span>:</span> GenuineIntel									<span>&lt;</span>---CPU制造厂商
cpu family		<span>:</span> <span>6</span>												<span>&lt;</span>---产品的系列代号
model			<span>:</span> <span>142</span>											<span>&lt;</span>---CPU的系列代号
model name		<span>:</span> Intel<span>(</span>R<span>)</span> Core<span>(</span>TM<span>)</span> i5-7300U CPU @ <span>2</span>.60GHz		<span>&lt;</span>---CPU系列的名字，编号，频率
stepping		<span>:</span> <span>9</span>												<span>&lt;</span>---更新版本
microcode		<span>:</span> 0xde
cpu MHz			<span>:</span> <span>897.143</span>										<span>&lt;</span>---实际主频
cache size		<span>:</span> <span>3072</span> KB										<span>&lt;</span>---二级缓存
physical <span>id</span>		<span>:</span> <span>0</span>
siblings		<span>:</span> <span>4</span>
core <span>id</span>			<span>:</span> <span>0</span>
cpu cores		<span>:</span> <span>2</span>
apicid			<span>:</span> <span>1</span>
initial apicid	<span>:</span> <span>1</span>
fpu				<span>:</span> <span>yes</span>
fpu_exception	<span>:</span> <span>yes</span>
cpuid level		<span>:</span> <span>22</span>
wp				<span>:</span> <span>yes</span>
flags			<span>:</span> fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc art arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc aperfmperf eagerfpu pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm 3dnowprefetch epb invpcid_single intel_pt ssbd ibrs ibpb stibp tpr_shadow vnmi flexpriority ept vpid fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm mpx rdseed adx smap clflushopt xsaveopt xsavec xgetbv1 dtherm ida arat pln pts hwp hwp_notify hwp_act_window hwp_epp md_clear spec_ctrl intel_stibp flush_l1d
<span>#CPU的功能标识</span>
bogomips		<span>:</span> <span>5424.00</span>
clflush size	<span>:</span> <span>64</span>
cache_alignment	<span>:</span> <span>64</span>
address sizes	<span>:</span> <span>39</span> bits physical, <span>48</span> bits virtual
power management:
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h3 id="w-和-who-命令-查看本机登录用户信息"> w 和 who 命令：查看本机登录用户信息</h3>
<p>Linux 中，使用 <code>w</code> 或 <code>who</code> 命令都可以查看服务器上目前已登录的用户信息，两者的区别在于，<code>w</code> 命令除了能知道目前已登陆的用户信息，还可以知道每个用户执行任务的情况。</p>
<h4 id="w-命令"> w 命令</h4>
<p>首先，介绍一下 <code>w</code> 命令的使用，<code>w</code> 命令的基本格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># w [选项] [用户名]</span>
选项：
	-h：不显示输出信息的标题
	-l：用长格式输出
	-s：用短格式输出，不显示登陆时间，JCPU 和 PCPU 时间
	-V：显示版本信息

如果 w 命令后跟 <span>[</span>用户名<span>]</span>，则表示只显示此用户的信息。

<span>#例 1： 显示当前用户登陆信息。</span>

<span>[</span>root@localhost ~<span>]</span><span># w</span>
<span>13</span>:13:56 up <span>13</span>:00, <span>1</span> user, load average: <span>0.08</span>, <span>0.02</span>, <span>0.01</span>
<span>USER</span>	TTY		FROM			LOGIN@	IDLE	JCPU	PCPU	WHAT
root	tty1	-				<span>11</span>:04	<span>0</span>.00s	<span>0</span>.36s	<span>0</span>.00s	-bash
root	pts/0	<span>192.168</span>.0.108	<span>13</span>:15	<span>0</span>.00s	<span>0</span>.06s	<span>0</span>.02s 	w
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>上面的输出信息中，第一行其实和 <code>top</code> 命令的第一行非常类似，主要显示了当前的系统时间、系统从启动至今已运行的时间、登陆到系统中的用户数和系统平均负载。</p>
<p>平均负载（load average）指的是在 1 分钟、5 分钟、15 分钟内系统的负载状况。</p>
<p>从第二行开始，显示的是当前所有登陆系统的用户信息，第二行是用户信息的各列标题，从第三行开始每行代表一个用户。这些标题的含义如表5-4 所示。</p>
<p><strong>表5-4	<u>w 命令输出信息各列标题及含义</u></strong></p>
<table>
<thead>
<tr>
<th>标题</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>USER</td>
<td>登录到系统的用户。</td>
</tr>
<tr>
<td>TTY</td>
<td>登录终端。</td>
</tr>
<tr>
<td>FROM</td>
<td>表示用户从哪里登陆进来，一般显示远程登陆主机的 IP 地址或者主机名。</td>
</tr>
<tr>
<td>LOGIN@</td>
<td>用户登陆的日期和时间。</td>
</tr>
<tr>
<td>IDLE</td>
<td>表示某个程序上次从终端开始执行到现在所持续的时间。</td>
</tr>
<tr>
<td>JCPU</td>
<td>和该终端连接的所有进程占用的 CPU 运算时间。这个时间里并不包括过去的后台作业时间，但是包括当前正在运行的后台作业所占用的时间。</td>
</tr>
<tr>
<td>PCPU</td>
<td>当前进程所占用的 CPU 运算时间。</td>
</tr>
<tr>
<td>WHAT</td>
<td>当前用户正在执行的进程名称和选项，换句话说，就是表示用户当前执行的是什么命令。</td>
</tr>
</tbody>
</table>
<p>从 <code>w</code> 命令的输出中已知，Linux 服务器上已经登录了两个 root 用户，一个是从本地终端1 登录的（tty1），另一个是从远程终端  登录的（pts/0），登录的来源 IP 是 192.168.0.108。</p>
<h4 id="who-命令"> who 命令</h4>
<p>相比较 <code>w</code> 命令，<code>who</code> 命令只能显示当前登陆的用户信心，但无法知晓每个用户正在执行的命令。 who 命令的基本格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># who [选项] [file]</span>
选项：
	-a		：列出所有信息，相当于所有选项
	-b		：列出系统最近启动的时间日期
	-l		：列出所有可登陆的终端信息
	-m		：仅列出关于当前终端的信息，“who -m” 命令等同于 “who am i”
	-q		：列出在本地系统上的用户和用户数的清单
	-r		：显示当前系统的运行级别
	-s		：仅显示名称、线路和时间字段信息，这是 <span>who</span> 命令的默认选项
	-u		：显示当前每个用户的用户名、登陆终端、登陆时间、线路活动和进程标识
	-T 或 -w：显示 <span>tty</span> 终端的状态，“+”表示对任何人可写，“-”表示仅对 root 用户或所有者可写，“？”表示遇到线路故障
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>需要说明的是，<code>who</code> 命令默认是通过 <code>/var/run/utmp</code> 文件来获取登陆用户信息，但如果通过 file 指定另一个文件，则 <code>who</code> 命令将不再默认读取 <code>/var/run/utmp</code> 文件，而是读取该指定文件来获取信息。</p>
<div><pre><code><span>#例 2： 显示系统最新启动日期，以及每个用户的登陆详情、终端状态。</span>

<span>[</span>root@localhost ~<span>]</span><span># who				&lt;--等同于 who -s</span>
root	tty1	<span>2013</span>-06-07 09：53
root	pts/0	<span>2013</span>-06-07 09：53 <span>(</span><span>192.168</span>.0.108<span>)</span>
<span>#用户名 登录终端  登录时间（登录来源IP）</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="last-和-lastlog-命令-查看过去登陆的用户信息"> last 和 lastlog 命令：查看过去登陆的用户信息</h3>
<p>前面，我们已经学了使用 <code>w</code> 或 <code>who</code> 命令查看当前登陆系统的用户信息，但如果原先登录的用户现在已经退出登录，那么是否还能查看呢？当然可以，这就需要使用 <code>last</code> 和 <code>lastlog</code> 命令。</p>
<p><code>last</code> 命令可以查看当前和过去登陆系统用户的相关信息；<code>lastlog</code> 命令可以查看到每个系统用户最近一次登陆系统的时间。</p>
<h4 id="last-命令"> last 命令</h4>
<p>我们先来看看 <code>last</code> 命令，此命令的基本格式如下所示：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># last [选项]</span>
选项：
	-a			：把从何处登陆系统的主机名或 IP 地址显示在最后一行
	-R			：不显示登陆系统的主机名或 IP 地址
	-x			：显示系统关机、重新开机以及执行等级的改变等信息
	-n 显示列数	：设置列出信息的显示行数
	-d			：将显示的 IP 地址转换成主机名称
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>在执行 last 命令时，它默认会读取 <code>/var/log/wtmp</code> 日志文件，这是一个二进制文件，不能直接用 vi 编辑，只能通过 <code>last</code> 命令调用。</p>
<div><pre><code><span>#例 1： 查询当前和过去登录的用户信息。</span>

<span>[</span>root@localhost ~<span>]</span><span># last</span>
root pts/0 <span>192.168</span>.0.108 Fri Jun <span>7</span> 09：53 still logged <span>in</span>
root tty1 Fri Jun <span>7</span> 09：53 still logged <span>in</span>
root pts/0 <span>192.168</span>.0.101 Fri Jun <span>7</span> 06：53 - 09：52 <span>(</span>02：59<span>)</span>
root pts/1 <span>192.168</span>.0.103 Fri Jun <span>7</span> 04：12 - 04：30 <span>(</span>00：18<span>)</span>
<span>#用户名 登录终端 登录IP 登录时间 - 退出时间（在线时间）</span>
<span>reboot</span> system boot <span>2.6</span>.32-279.el6.i Thu Jun <span>6</span> <span>23</span>：53 - 00：03 <span>(</span>00：09<span>)</span>
<span>#还能看到系统的重启时间</span>
<span>..</span>.省略部分输出<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h4 id="lastlog-命令"> lastlog 命令</h4>
<p>再来看看 <code>lastlog</code> 命令，此命令可以查看登陆过当前系统用户的最近一次登陆时间，比如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># lastlog</span>
<span>#用户名    端口  来自        最后登陆时间</span>
Username	Port	From			Latest
root		pts/1	<span>192.168</span>.1.100	Wed Mar <span>4</span> <span>11</span>:04:22 +0800 <span>2009</span>
bin									**Never logged in**
<span>..</span><span>..</span><span>(</span>中间省略<span>)</span><span>..</span><span>..</span>
vbird1		pts/2	<span>192.168</span>.1.100	Wed Mar <span>4</span> <span>13</span>:15:56 +0800 <span>2009</span>
<span>..</span><span>..</span><span>(</span>以下省略<span>)</span><span>..</span><span>..</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><code>lastlog</code> 命令默认是去读取 <code>/var/log/lastlog</code> 日志文件的，这个文件同样是二进制文件，不能直接用 vi 编辑，需要使用 <code>lastlog</code> 命令调用。</p>
<h3 id="uptime-命令-显示系统时间和平均负载"> uptime 命令：显示系统时间和平均负载</h3>
<p><code>uptime</code> 命令的作用就是显示系统的启动时间和平均负载，也就是 <code>top</code> 命令的第一行。其实 <code>w</code> 命令也能看到这行数据，具体愿意使用哪个命令看个人习惯。</p>
<p>命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># uptime</span>
<span>10</span>:56:30 up <span>10</span>:52, <span>2</span> users, load average: <span>0.00</span>, <span>0.00</span>, <span>0.00</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="uname命令-查看系统与内核的相关信息"> uname命令：查看系统与内核的相关信息</h3>
<p>可以使用 <code>uname</code> 命令查看系统与内核的相关信息，命令格式如下：</p>
<div><pre><code><span>[</span>root@locaihost ~<span>]</span><span># uname [选项]</span>
选项：
	-a：查看系統所有相关信息
	-r：查看内核版本
	-s：查看内核名称

<span>#例如：</span>
<span>[</span>root@localhost -<span>]</span><span># uname -a</span>
Linux localhost.localdomain <span>2.6</span>.32-279.e16.i686 <span>#1 SMP Fri Jun 22 10:59:55 UTC 2012 i686 i686 i386 GNU/Linux </span>

<span>[</span>root@localhost ~<span>]</span><span># uname -r</span>
<span>2.6</span>.32-279.e16.i686
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><p>系统详细信息</p>
<p>如果我们想要判断当前系统的位数，则可以通过 <code>file</code> 命令来判断系统文件（主要是系统命令）的位数，进而推断系统的位数。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># file /bin/ls</span>
/bin/ls: ELF <span>64</span>-bit LSB executable, x86-64, version <span>1</span> <span>(</span>SYSV<span>)</span>, dynamically linked <span>(</span>uses shared libs<span>)</span>, <span>for</span> GNU/Linux <span>2.6</span>.32, BuildID<span>[</span>sha1<span>]</span><span>=</span>aaf05615b6c91d3cbb076af81aeff531c5d7dfd9, stripped
<span>#很明显，当前系统是 64 位的</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果我们想要查询当前 Linux 系统的发行版本，则可以使用 <code>cat /etc/os-release</code> 命令。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cat /etc/os-release</span>
<span>NAME</span><span>=</span><span>"CentOS Linux"</span>
<span>VERSION</span><span>=</span><span>"7 (Core)"</span>
<span>ID</span><span>=</span><span>"centos"</span>
<span>ID_LIKE</span><span>=</span><span>"rhel fedora"</span>
<span>VERSION_ID</span><span>=</span><span>"7"</span>
<span>PRETTY_NAME</span><span>=</span><span>"CentOS Linux 7 (Core)"</span>
<span>ANSI_COLOR</span><span>=</span><span>"0;31"</span>
<span>CPE_NAME</span><span>=</span><span>"cpe:/o:centos:centos:7"</span>
<span>HOME_URL</span><span>=</span><span>"https://www.centos.org/"</span>
<span>BUG_REPORT_URL</span><span>=</span><span>"https://bugs.centos.org/"</span>

<span>CENTOS_MANTISBT_PROJECT</span><span>=</span><span>"CentOS-7"</span>
<span>CENTOS_MANTISBT_PROJECT_VERSION</span><span>=</span><span>"7"</span>
<span>REDHAT_SUPPORT_PRODUCT</span><span>=</span><span>"centos"</span>
<span>REDHAT_SUPPORT_PRODUCT_VERSION</span><span>=</span><span>"7"</span>

<span>#当前使用的 Linux 的发行版本是 CentOS 7</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div></div>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2022-01-26T06:11:29.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">linux系统日志管理</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_manage/05.linux_log/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_manage/05.linux_log/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>系统日志详细地记录了在什么时间，哪台服务器、哪个程序或服务出现了什么情况。不管是哪种操作系统，都详细地记录了重要程序和服务的日志，只是我们很少养成查看日志的习惯。</p>
<p>日志是系统信息最详细、最准确的记录者，如果大家能够善用日志，那么当系统出现问题时，我们就能在第一时间发现问题，也能够从日志中找到解决问题的方法。</p>
<p>很多人都觉得查看日志比较枯燥，甚至干脆看不懂，那么我们就来学习一下<strong>Linux系统的日志管理</strong>。</p>
<h2 id="日志简介"> 日志简介</h2>
<p>日志是操作系统用来记录在什么时间哪个进程做了什么样的工作、发生了什么事件。同时记录系统中硬件和软件产生的系统问题的。换句话说，目志就是系统的记账本，记账本中按照时间先后排序记录了系统中发生的所有事件。当然，如果把所有的信息放入一个日志文件中，那么这个文件的可读性会非常差，所以不同的日志应放入不同的日志文件中。</p>
<h3 id="日志相关服务"> 日志相关服务</h3>
<p>在 CentOS 6.x 中，日志服务已经由 rsyslogd 取代了原先的 syslogd。Red Hat 公司认为 syslogd 已经不能满足工作中的需求，rsyslogd 相比 syslogd 具有一些新的特点：</p>
<ul>
<li>基于 TCP 网络协议传输日志信息。</li>
<li>更安全的网络传输方式。</li>
<li>有日志信息的即时分析框架。</li>
<li>后台数据库。</li>
<li>在配置文件中可以写简单的逻辑判断。</li>
<li>与 syslog 配置文件相兼容。</li>
</ul>
<p>rsyslogd 日志服务更加先进，功能更多。但是，不论是该服务的使用，还是日志文件的格式，其实都是和 syslogd 服务相兼容的，所以学习起来基本和 syslogd 服务一致。</p>
<p>我们如何知道 Linux 中的 rsyslogd 服务是否启动了呢？如何查询 rsyslogd 服务的自启动状态呢？命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ps aux | grep "rsyslog" | grep -v "grep"</span>
root <span>1139</span> <span>0.0</span> <span>0.2</span> <span>35948</span> <span>1500</span> ? Sl 09：40 <span>0</span>：00 /sbin/rsyslogd -i/var/run/syslogd.pid -c <span>5</span>
<span>#有rsyslogd服务的进程，所以这个服务已经启动了</span>
<span>[</span>root@localhost ~<span>]</span><span># chkconfig --list | grep rsyslog</span>
rsyslog <span>0</span>：关闭 <span>1</span>：关闭 <span>2</span>：启用 <span>3</span>：启用 <span>4</span>：启用 <span>5</span>：启用 <span>6</span>：关闭
<span>#rsyslog服务在2、3、4、5运行级别上是开机自启动的</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>系统中的绝大多数日志文件是由 rsyslogd 服务来统一管理的，只要各个进程将信息给予这个服务，它就会自动地把日志按照特定的格式记录到不同的日志文件中。也就是说，采用 rsyslogd 服务管理的日志文件，它们的格式应该是统一的。</p>
<p>在 Linux 系统中有一部分日志不是由 rsyslogd 服务来管理的，比如 apache 服务，它的日志是由 Apache 软件自己产生并记录的，并没有调用 rsyslogd 服务。但是为了便于读取，apache 日志文件的格式和系统默认日志的格式是一致的。</p>
<h3 id="系统中常见的日志文件"> 系统中常见的日志文件</h3>
<p>日志文件是重要的系统信息文件，其中记录了许多重要的系统事件，包括用户的登录信息、系统的启动信息、系统的安全信息、邮件相关信息、各种服务相关信息等。这些信息有些非常敏感，所以在 Linux 中这些日志文件只有 root 用户可以读取。</p>
<p>那么，系统日志文件保存在什么地方呢？还记得 <code>/var/</code> 目录吗？它是用来保存系统动态数据的目录，那么 <code>/var/log/</code> 目录就是系统日志文件的保存位置。我们通过表6-1 来说明一下系统中的重要日志文件。</p>
<p><strong>表6-1	<u>系统中的重要日志文件</u></strong></p>
<table>
<thead>
<tr>
<th>日志文件</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td>/var/log/cron</td>
<td>记录与系统定时任务相关的曰志</td>
</tr>
<tr>
<td>/var/log/cups/</td>
<td>记录打印信息的曰志</td>
</tr>
<tr>
<td>/var/log/dmesg</td>
<td>记录了系统在开机时内核自检的信总。也可以使用 <code>dmesg</code> 命令直接查看内核自检信息</td>
</tr>
<tr>
<td>/var/log/btmp</td>
<td>记录错误登陆的日志。这个文件是二进制文件，不能直接用Vi查看，而要使用 <code>lastb</code> 命令查看。命令如下：<br /><code>[root@localhost log]# lastbroot</code><br /><code>tty1 Tue Jun 4 22:38 - 22:38 (00:00)</code><br /><code>#有人在6月4 日 22:38便用root用户在本地终端 1 登陆错误</code></td>
</tr>
<tr>
<td>/var/log/lasllog</td>
<td>记录系统中所有用户最后一次的登录时间的曰志。这个文件也是二进制文件，不能直接用 Vi 查看。而要使用 <code>lastlog</code> 命令查看</td>
</tr>
<tr>
<td>/var/Iog/mailog</td>
<td>记录邮件信息的曰志</td>
</tr>
<tr>
<td>/var/log/messages</td>
<td>它是核心系统日志文件，其中包含了系统启动时的引导信息，以及系统运行时的其他状态消息。I/O 错误、网络错误和其他系统错误都会记录到此文件中。其他信息，比如某个人的身份切换为 root，已经用户自定义安装软件的日志，也会在这里列出。</td>
</tr>
<tr>
<td>/var/log/secure</td>
<td>记录验证和授权方面的倍息，只要涉及账户和密码的程序都会记录，比如系统的登录、ssh 的登录、su 切换用户，sudo 授权，甚至添加用户和修改用户密码都会记录在这个日志文件中</td>
</tr>
<tr>
<td>/var/log/wtmp</td>
<td>永久记录所有用户的登陆、注销信息，同时记录系统的后动、重启、关机事件。同样，这个文件也是二进制文件，不能直接用Vi查看，而要使用 <code>last</code> 命令查看</td>
</tr>
<tr>
<td>/var/tun/ulmp</td>
<td>记录当前已经登录的用户的信息。这个文件会随着用户的登录和注销而不断变化，只记录当前登录用户的信息。同样，这个文件不能直接用Vi查看，而要使用 <code>w</code>、<code>who</code>、<code>users</code> 等命令查看</td>
</tr>
</tbody>
</table>
<p>除系统默认的日志之外，采用 RPM 包方式安装的系统服务也会默认把日志记录在 <code>/var/log/</code>  目录中（源码包安装的服务日志存放在源码包指定的目录中）。不过这些日志不是由 rsyslogd 服务来记录和管理的，而是各个服务使用自己的日志管理文档来记录自身的日志。以下介绍的日志目录在你的 Linux 上不一定存在，只有安装了相应的服务，日志才会出现。服务日志如表6-2 所示。</p>
<p><strong>表6-2	<u>服务日志</u></strong></p>
<table>
<thead>
<tr>
<th>日志文件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>/var/log/httpd/</td>
<td>RPM 包安装的 apache 服务的默认日志目录</td>
</tr>
<tr>
<td>/var/log/mail/</td>
<td>RPM 包安装的邮件服务的额外日志因录</td>
</tr>
<tr>
<td>/var/log/samba/</td>
<td>RPM 色安装的 Samba 服务的日志目录</td>
</tr>
<tr>
<td>/var/log/sssd/</td>
<td>守护进程安全服务目录</td>
</tr>
</tbody>
</table>
<h2 id="日志服务-rsyslogd"> 日志服务 rsyslogd</h2>
<p>我们已经知道 CentOS 6.x 使用 rsyslogd 服务取代了 syslogd 服务，其实在使用过程中这两个服务非常类似，包括由此服务产生的日志文件的格式、服务的配置文件等基本一样，所以我们不论学习了哪个服务，都会非常容易接受另外一个服务。下面，我们来学习 rsyslogd 服务，主要学习该服务产生的日志文件的格式和服务的配置文件。</p>
<h3 id="日志文件的格式"> 日志文件的格式</h3>
<p>只要是由日志服务 rsyslogd 记录的日志文件，它们的格式就都是一样的。所以我们只要了解了日志文件的格式，就可以很轻松地看懂日志文件。</p>
<p>日志文件的格式包含以下 4 列：</p>
<ul>
<li>事件产生的时间。</li>
<li>产生事件的服务器的主机名。</li>
<li>产生事件的服务名或程序名。</li>
<li>事件的具体信息。</li>
</ul>
<p>我们查看一下 <code>/var/log/secure</code> 日志，这个日志中主要记录的是用户验证和授权方面的信息，更加容易理解。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vi /var/log/secure</span>
Jun <span>5</span> 03：20：46 localhost sshd<span>[</span><span>1630</span><span>]</span>：Accepted password <span>for</span> root from <span>192.168</span>.0.104 port <span>4229</span> ssh2
<span># 6月5日 03：20：46 本地主机 sshd服务产生消息：接收从192.168.0.104主机的4229端口发起的ssh连接的密码</span>
Jun <span>5</span> 03：20：46 localhost sshd<span>[</span><span>1630</span><span>]</span>：pam_unix<span>(</span>sshd：session<span>)</span>：session opened <span>for</span> user root by <span>(</span>uid<span>=</span><span>0</span><span>)</span>
<span>#时间 本地主机 sshd服务中pam_unix模块产生消息：打开用户root的会话（UID为0）</span>
Jun <span>5</span> 03：25：04 localhost useradd<span>[</span><span>1661</span><span>]</span>：new group：name<span>=</span>bb， <span>GID</span><span>=</span><span>501</span>
<span>#时间 本地主机 useradd命令产生消息：新建立bb组，GID为501</span>
Jun <span>5</span> 03：25：04 localhost useradd<span>[</span><span>1661</span><span>]</span>：new user：name<span>=</span>bb， <span><span>UID</span></span><span>=</span><span>501</span>， <span>GID</span><span>=</span><span>501</span>， <span>home</span><span>=</span>/home/bb， <span>shell</span><span>=</span>/bin/bash
Jun <span>5</span> 03：25：09 localhost passwd：pam_unix<span>(</span>passwd：chauthtok<span>)</span>：password changed <span>for</span> bb
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>我截取了一段日志的内容，注释了其中的三句日志，剩余的两句日志大家可以看懂了吗？其实分析日志既是重要的系统维护工作，也是一项非常枯燥和烦琐的工作。如果我们的服务器出现了一些问题，比如系统不正常重启或关机、用户非正常登录、服务无法正常使用等，则都应该先查询日志。</p>
<p>实际上，只要感觉到服务器不是很正常就应该查看日志，甚至在服务器没有什么问题时也要养成定时查看系统日志的习惯。</p>
<h3 id="rsyslogd-服务的配置文件"> rsyslogd 服务的配置文件</h3>
<p>rsyslogd 服务是依赖其配置文件 <code>/etc/rsyslog.conf</code> 来确定哪个服务的什么等级的日志信息会被记录在哪个位置的。也就是说，日志服务的配置文件中主要定义了服务的名称、日志等级和日志记录位置。</p>
<h4 id="etc-rsyslog-conf-配置文件的格式"> /etc/rsyslog.conf 配置文件的格式</h4>
<p>该配置文件的基本格式如下所示：</p>
<div><pre><code>authpriv.*							/var/log/secure
<span>#服务名称[连接符号]日志等级			日志记录位置</span>
<span>#认证相关服务.所有日志等级			记录在/var/log/secure日志中</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ol>
<li><strong>服务名称</strong></li>
</ol>
<p>我们首先需要确定 rsyslogd 服务可以识别哪些服务的日志，也可以理解为以下这些服务委托 rsyslogd 服务来代为管理日志。这些服务如表6-3 所示。</p>
<p><strong>表6-3	<u>日志服务名称</u></strong></p>
<table>
<thead>
<tr>
<th>服务名称</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td>auth（LOG AUTH）</td>
<td>安全和认证相关消息 （不推荐使用 authpriv 替代）</td>
</tr>
<tr>
<td>authpriv（LOG_AUTHPRIV）</td>
<td>安全和认证相关消息（私有的）</td>
</tr>
<tr>
<td>cron（LOG_CRON）</td>
<td>系统定时任务 cront 和 at 产生的日志</td>
</tr>
<tr>
<td>daemon（LOG_DAEMON）</td>
<td>与各个守护进程相关的曰志</td>
</tr>
<tr>
<td>ftp（LOG_FTP）</td>
<td>ftp 守护进程产生的曰志</td>
</tr>
<tr>
<td>kern（LOG_KERN）</td>
<td>内核产生的曰志（不是用户进程产生的）</td>
</tr>
<tr>
<td>Iocal0-local7（LOG_LOCAL0-7）</td>
<td>为本地使用预留的服务</td>
</tr>
<tr>
<td>lpr（LOG_LPR）</td>
<td>打印产生的日志</td>
</tr>
<tr>
<td>mail（LOG_MAIL）</td>
<td>邮件收发信息</td>
</tr>
<tr>
<td>news（LOG_NEWS）</td>
<td>与新闻服务器相关的日志</td>
</tr>
<tr>
<td>syslog（LOG_SYSLOG）</td>
<td>存 syslogd 服务产生的曰志信息（虽然服务名称己经改为 reyslogd，但是很多配罝依然沿用了 syslogd 服务的，所以这里并没有修改服务名称）</td>
</tr>
<tr>
<td>user（LOG_USER）</td>
<td>用户等级类别的日志信息</td>
</tr>
<tr>
<td>uucp（LOG_UUCP）</td>
<td>uucp子系统的日志信息，uucp 是早期 Linux 系统进行数据传递的协议，后来 也常用在新闻组服务中</td>
</tr>
</tbody>
</table>
<p>这些日志服务名称是 rsyslogd 服务自己定义的，并不是实际的 Linux 的服务。当有服务需要由 rsyslogd 服务来帮助管理日志时，只需要调用这些服务名称就可以实现日志的委托管理。</p>
<p>这些日志服务名称大家可以使用命令 <code>man 3 syslog</code> 来查看。虽然我们的日志管理服务已经更新到 rsyslogd，但是很多配置依然沿用了 syslogd 服务，在帮助文档中仍然查看 syslog 服务的帮助信息。</p>
<ol start="2">
<li><strong>连接符号</strong></li>
</ol>
<p>日志服务连接日志等级的格式如下：</p>
<div><pre><code>日志服务<span>[</span>连接符号<span>]</span>日志等级				日志记录位置
</code></pre>
<div><span>1</span><br></div></div><p>在这里，连接符号可以被识别为以下三种。</p>
<blockquote>
<p>“<strong>.</strong>” 代表只要比后面的等级高的（包含该等级）日志都记录。比如，“cron.info”代表 cron 服务产生的日志，只要日志等级大于等于 info 级别，就记录。</p>
</blockquote>
<blockquote>
<p>“<strong>.=</strong>”代表只记录所需等级的日志，其他等级的日志都不记录。比如，“*.=emerg”代表人和日志服务产生的日志，只要等级是 emerg 等级，就记录。这种用法极少见，了解就好。</p>
</blockquote>
<blockquote>
<p>“<strong>.!</strong>”代表不等于，也就是除该等级的日志外，其他等级的日志都记录。</p>
</blockquote>
<ol start="3">
<li><strong>日志等级</strong></li>
</ol>
<p>每个日志的重要性都是有差别的，比如，有些日志只是系统的一个日常提醒，看不看根本不会对系统的运行产生影响；但是有些日志就是系统和服务的警告甚至报错信息，这些日志如果不处理，就会威胁系统的稳定或安全。如果把这些日志全部写入一个文件，那么很有可能因为管理员的大意而忽略重要信息。</p>
<p>比如，我们在工作中需要处理大量的邮件，每天可能会接收到 200 多封邮件。而这些邮件中的绝大多数是不需要处理的普通信息邮件，甚至是垃圾邮件。所以每天都要先把这些大量的非重要邮件删除之后，才能找到真正需要处理的邮件。但是每封邮件的标题都差不多，有时会误删除需要处理的邮件。这时就非常怀念 Linux 的日志等级，如果邮件也能标识重要等级，就不会误删除或漏处理重要邮件了。</p>
<p>邮件的等级信息也可以使用 <code>man 3 syslog</code> 命令来查看。日志等级如表6-4 所示，我们按照严重等级从低到高排列。</p>
<p><strong>表6-4	<u>日志等级</u></strong></p>
<table>
<thead>
<tr>
<th>等级名称</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td>debug（LOG_DEBUG）</td>
<td>一般的调试信息说明</td>
</tr>
<tr>
<td>info（LOG_INFO）</td>
<td>基本的通知信息</td>
</tr>
<tr>
<td>nolice（LOG_NOTICE）</td>
<td>普通信息，但是有一定的重要性</td>
</tr>
<tr>
<td>warning（LOG_WARNING）</td>
<td>警吿信息，但是还不会影响到服务或系统的运行</td>
</tr>
<tr>
<td>err（LOG_ERR）</td>
<td>错误信息, 一般达到 err 等级的信息已经可以影响到服务成系统的运行了</td>
</tr>
<tr>
<td>crit（LOG_CRIT）</td>
<td>临界状况信思，比 err 等级还要严重</td>
</tr>
<tr>
<td>alert（LOG_ALERT）</td>
<td>状态信息，比 crit 等级还要严重，必须立即采取行动</td>
</tr>
<tr>
<td>emerg（LOG_EMERG）</td>
<td>疼痛等级信息，系统已经无法使用了</td>
</tr>
<tr>
<td>*</td>
<td>代表所有日志等级。比如，“authpriv.*”代表 amhpriv 认证信息服务产生的日志，所有的日志等级都记录</td>
</tr>
</tbody>
</table>
<div><p>补充</p>
<p>日志等级还可以被识别为“none”。如果日志等级是 none，就说明忽略这个日志服务，该服务的所有日志都不再记录。</p>
</div>
<ol start="4">
<li><strong>日志记录位置</strong></li>
</ol>
<p>日志记录位置就是当前日志输出到哪个日志文件中保存，当然也可以把日志输出到打印机打印，或者输出到远程日志服务器上（当然，远程日志服务器要允许接收才行）。日志的记录位置也是固定的：</p>
<ul>
<li>日志文件的绝对路径。这是最常见的日志保存方法，如 <code>/var/log/secure</code> 就是用来保存系统验证和授权信息日志的。</li>
<li>系统设备文件。如 <code>/dev/lp0</code> 代表第一台打印机，如果日志保存位置是打印机设备，当有日志时就会在打印机上打印。</li>
<li>转发给远程主机。因为可以选择使用 TCP 和 UDP 协议传输日志信息，所以有两种发送格式：如果使用 <code>@192.168.0.210:514</code>，就会把日志内容使用 UDP 协议发送到192.168.0.210 的 UDP 514 端口上；如果使用 <code>@@192.168.0.210:514</code>，就会把日志内容使用 TCP 协议发送到 192.168.0.210 的 TCP 514 端口上，其中 <strong>514 是日志服务默认端口</strong>。当然，只要 192.168.0.210 同意接收此日志，就可以把日志内容保存在日志服务器上。</li>
<li>用户名。如果是“root”，就会把日志发送给 root 用户，当然 root 要在线，否则就收不到日志信息了。发送日志给用户时，可以使用“*”代表发送给所有在线用户，如 <code>mail.**</code>就会把 mail 服务产生的所有级别的日志发送给所有在线用户。如果需要把日志发送给多个在线用户，则用户名之间用“,”分隔。</li>
<li>忽略或丢弃日志。如果接收日志的对象是“~”，则代表这个日志不会被记录，而被直接丢弃。如“local3.* ~”代表忽略 local3 服务类型所有的日志都不记录。</li>
</ul>
<h4 id="etc-rsyslog-conf-配置文件的内容"> /etc/rsyslog.conf 配置文件的内容</h4>
<p>我们知道了 <code>/etc/rsyslog.conf</code> 配置文件中日志的格式，接下来就看看这个配置文件的具体内容。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vi /etc/rsyslog.conf</span>
<span>#查看配置文件的内容</span>
<span>#rsyslog v5 configuration file</span>

<span># For more information see /usr/share/doc/rsyslog-*/rsyslog_conf.html</span>
<span># If you experience problems, see http://www.rsyslog.com/doc/troubleshoot.html</span>

<span>#### MODULES ####</span>
<span>#加载棋块</span>

<span>$ModLoad</span> imuxsock <span># provides support for local system logging (e.g. via logger command)</span>
<span>#加载imixsock模块，为本地系统登录提供支持</span>
<span>$ModLoad</span> imklog <span># provides kernel logging support (previously done by rklogd)</span>
<span>#加载imklog模块，为内核登录提供支持</span>
<span>#$ModLoad immark # provides --MARK-- message capability</span>
<span>#加载immark模块，提供标记信息的能力</span>

<span># Provides UDP syslog reception</span>
<span>#$ModLoad imudp</span>
<span>#$UDPServerRun 514</span>
<span>#加载UPD模块，允许使用UDP的514端口接收采用UDP协议转发的日志</span>

<span># Provides TCP syslog reception</span>
<span>#$ModLoad imtcp</span>
<span>#$InputTCPServerRun 514</span>
<span>#加栽TCP摸块,允许使用TCP的514编口接收采用TCP协议转发的日志</span>

<span>#### GLOBAL DIRECTIVES ####</span>
<span>#定义全局设置</span>

<span># Use default timestamp format</span>
<span>$ActionFileDefaultTemplate</span> RSYSLOG_TraditionalFileFormat
<span>#定义曰志的时间使用默认的时间戳格式</span>

<span># File syncing capability is disabled by default. This feature is usually not required,</span>
<span># not useful and an extreme performance hit</span>
<span>#$ActionFileEnableSync on</span>
<span>#文件同步功能。默认没有开启,是注释的</span>

<span># Include all config files in /etc/rsyslog.d/</span>
<span>$IncludeConfig</span> /etc/rsyslog.d/*.conf
<span>#包含/etx/tsyslog.d/目录中所有的".conf"子配置文件。也就是说，这个目录中的所有子配置文件也同时生效</span>

<span>#### RULES ####</span>
<span>#日志文件保存规则</span>

<span># Log all kernel messages to the console.</span>
<span># Logging much else clutters up the screen.</span>
<span>#kern.*		/dev/console</span>
<span>#kern服务.所有曰志级别 保存在/dev/console</span>
<span>#这个日志默认没有开启,如果需要，则取消注释</span>

<span># Log anything (except mail) of level info or higher.</span>
<span># Don't log private authentication messages!</span>
*.info<span>;</span>mail.none<span>;</span>authpriv.none<span>;</span>cron.none		/var/log/messages
<span>#所有服务.info以上级到的日志保存在/var/log/messages日志文件中</span>
<span>#mail、authpriv、cron的志不记录在/var/log/messages曰志文件中，因为它们部有自己的曰志文件</span>
<span>#所以/var/log/messages日志是最重要的系统日志文件，需要经常查看</span>

<span># The authpriv file has restricted access.</span>
authpriv.*		/var/log/secure
<span>#用户认证服务所有级别的日志保存在/vai/1og/secure日志文件中</span>

<span># Log all the mail messages in one place.</span>
mail.*			-/var/log/maillog
<span>#mail服务的所有级别的日志保存在/var/log/maillog 日志文件中</span>
<span>#"-"的含义是日志先在内存中保存，当曰志足够多之后，再向文件中保存</span>

<span># Log cron stuff</span>
cron.*			/var/log/cron
<span>#计対任务的所有日志保存在/var/log/cron日志文件中</span>

<span># Everybody gets emergency messages</span>
*.emerg			*
<span>#所有日志服务的疼痛等级日志对所有在线用户广播</span>

<span># Save news errors of level crit and higher in a special file.</span>
uucp,news.crit	/var/log/spooler
<span>#uucp和news曰志服务的crit以上级别的日志保存在/var/log/sppoler曰志文件中</span>

<span># Save boot messages also to boot.log</span>
local7.*		/var/log/boot.log
<span>#loacl7 日志服务的所有日志写入/var/log/boot.log 日志文件中</span>
<span>#会把开机时的检测信息在显示到屏幕的同时写入/var/log/boot.log 日志文件中</span>

<span># ### begin forwarding rule ###</span>
<span>#定义转发规到</span>
<span># The statement between the begin ... end define a SINGLE forwarding</span>
<span># rule. They belong together, do NOT split them. If you create multiple</span>
<span># forwarding rules, duplicate the whole block!</span>
<span># Remote Logging (we use TCP for reliable delivery)</span>
<span>#</span>
<span># An on-disk queue is created for this action. If the remote host is</span>
<span># down, messages are spooled to disk and sent when it is up again.</span>
<span>#SWorkDirectory /var/lib/rsyslog # where to place spool files</span>
<span>#$ActionQueueFileName fwdRulel # unique name prefix for spool files</span>
<span>#$ActionQueueMaxDiskSpace 1g # 1gb space limit (use as much as possible)</span>
<span>#$ActionQueueSaveOnShutdown on # save messages to disk on shutdown</span>
<span>#$ActionQueueType LinkedList t run asynchronously</span>
<span>#$ActionResumeRetryCount -1 # infinite retries if host is down</span>
<span># remote host is: name/ip:port, e.g. 192.168.0.1:514, port optional</span>
<span>#*•* @6remote-host:514</span>
<span># ### end of the forwarding rule ##</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br></div></div><p>其实系统已经非常完善地定义了这个配置文件的内容，系统中重要的日志也已经记录得非常完备。如果是外来的服务，如 apache、Samba  等服务，那么这些服务的配置文件中也详细定义了日志的记录格式和记录方法。所以，日志的配置文件基本上不需要我们修改，我们要做的仅仅是查看和分析系统记录好的日志而已。</p>
<h4 id="定义自己的日志"> 定义自己的日志</h4>
<p>如果想要定义自己的日志可以吗？当然可以，只需在 <code>/etc/rsyslog.conf</code> 配置文件中按照格式写入即可。当然 rsyslogd 服务可以识别的日志服务只有前表中列出的这么多。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vi /etc/rsyslog.conf</span>
<span>#写入以下这句话</span>
*.crit			/var/log/alert.log
<span>#把所有服务的“临界点”以上的错误都保存在/var/log/alert.log 日志中</span>

<span>[</span>root@localhost ~<span>]</span><span># service rsyslog restart</span>
关闭系统日志记录器:						<span>[</span>确定<span>]</span>
启动系统日志记录器：						<span>[</span>确定<span>]</span>
<span>#重启rsyslog 服务</span>
<span>[</span>root@localhost ~<span>]</span><span># ll /var/log/alert.log</span>
-rw-------. <span>1</span> root root <span>0</span>  <span>6</span> 月 <span>5</span> <span>10</span>:33 /var/log/alert.log
<span>#alert.log 日志就生成了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>这样 <code>/var/log/alert.log</code> 日志就生成了。如果这个日志中出现任何信息，则应该是比较危险的错误信息，应该引起警惕。</p>
<h4 id="日志服务器设置"> 日志服务器设置</h4>
<p>我们知道，使用 <code>@IP:端口</code> 或 <code>@@IP:端口</code> 的格式可以把日志发送到远程主机上，那么这么做有什么意义吗？</p>
<p>假设我需要管理几十台服务器，那么我每天的重要工作就是查看这些服务器的日志，可是每台服务器单独登录，并且查看日志非常烦琐，我可以把几十台服务器的日志集中到一台日志服务器上吗？这样我每天只要登录这台日志服务器，就可以查看所有服务器的日志，要方便得多。</p>
<p>如何实现日志服务器的功能呢？其实并不难，不过我们首先需要分清服务器端和客户端。假设服务器端的服务器 IP 地址是 192.168.0.210，主机名是 localhost.localdomain；客户端的服务器 IP 地址是 192.168.0.211，主机名是 www1。我们现在要做的是把 192.168.0.211 的日志保存在 192.168.0.210 这台服务器上。实验过程如下：</p>
<div><pre><code><span>#服务器端设定（192.168.0.210）：</span>
<span>[</span>root@localhost ~<span>]</span><span># vi /etc/rsyslog.conf</span>
<span>..</span>.省略部分输出<span>..</span>.
<span># Provides TCP syslog reception</span>
<span>$ModLoad</span> imtcp
<span>$InputTCPServerRun</span> <span>514</span>
<span>#取消这两句话的注释，允许服务器使用TCP 514端口接收日志</span>
<span>..</span>.省略部分输出<span>..</span>.

<span>[</span>root@localhost ~<span>]</span><span># service rsyslog restart</span>
<span>#重启rsyslog日志服务</span>
<span>[</span>root@localhost ~<span>]</span><span># netstat -tlun | grep 514</span>
tcp <span>0</span> <span>0</span> <span>0.0</span>.0.0：514 <span>0.0</span>.0.0：* LISTEN
<span>#查看514端口已经打开</span>
<span>#==================================================</span>
<span>#客户端设置（192.168.0.211）：</span>
<span>[</span>root@www1 ~<span>]</span><span># vi /etc/rsyslog.conf</span>
<span>#修改日志服务配置文件</span>
*.* @@192.168.0.210:514
<span>#把所有日志采用TCP协议发送到192.168.0.210的514端口上</span>
<span>[</span>root@www1 ~<span>]</span><span># service rsyslog restart</span>
<span>#重启日志服务</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>这样日志服务器和客户端就搭建完成了，以后 192.168.0.211 这台客户机上所产生的所有日志都会记录到 192.168.0.210 上。比如：</p>
<div><pre><code><span>#在客户机上(192.168.0.211)</span>
<span>[</span>root@wwwl ~<span>]</span><span># useradd zhangsan</span>
<span>#添加zhansan用户提示符的主机名是www1</span>
<span>#==================================================</span>
<span>#在限务器(192.168.0.210)上</span>
<span>[</span>root@localhost ~<span>]</span><span># vi /var/log/secure</span>
<span>#査看服务器的secure日志(注意:主机名是localhost)</span>
Aug <span>8</span> <span>23</span>:00:57 wwwl sshd<span>[</span><span>1408</span><span>]</span>: Server listening on <span>0.0</span>.0.0 port <span>22</span>.
Aug <span>8</span> <span>23</span>:00:57 wwwl sshd<span>[</span><span>1408</span><span>]</span>: Server listening on :: port <span>22</span>.
Aug <span>8</span> <span>23</span>:01:58 wwwl sshd<span>[</span><span>1630</span><span>]</span>: Accepted password <span>for</span> root from <span>192.168</span>.0.101 port <span>7036</span> ssh2
Aug <span>8</span> <span>23</span>:01:58 wwwl sshd<span>[</span><span>1630</span><span>]</span>: pam_unix<span>(</span>sshd:session<span>)</span>: session opened <span>for</span> user root by <span>(</span>uid<span>=</span><span>0</span><span>)</span>
Aug <span>8</span> <span>23</span>:03:03 wwwl useradd<span>[</span><span>1654</span><span>]</span>: new group: <span>name</span><span>=</span>zhangsan, GID-505
Aug <span>8</span> <span>23</span>:03:03 wwwl useradd<span>[</span><span>1654</span><span>]</span>: new user: <span>name</span><span>=</span>zhangsan, <span>UXD</span><span>=</span><span>505</span>, <span>GID</span><span>=</span><span>505</span>,home<span>=</span>/home/zhangsan, <span>shell</span><span>=</span>/bin/bash
Aug <span>8</span> <span>23</span>:03:09 wwwl passwd: pam_unix<span>(</span>passwd:chauthtok<span>)</span>: password changed <span>for</span> zhangsan
<span>#注意：查看到的日志内容的主机名是www1，说明我们虽然查看的是服务器的日志文件，但是在其中可以看到客户机的日志内容</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>需要注意的是，日志服务是通过主机名来区别不同的服务器的。所以，如果我们配置了日志服务，则需要给所有的服务器分配不同的主机名。</p>
<h2 id="日志轮替"> 日志轮替</h2>
<p>日志是重要的系统文件，记录和保存了系统中所有的重要事件。但是日志文件也需要进行定期的维护，因为日志文件是不断增长的，如果完全不进行日志维护，而任由其随意递增，那么用不了多久，我们的硬盘就会被写满。</p>
<p>**日志维护的最主要的工作就是把旧的日志文件删除，从而腾出空间保存新的日志文件。**这项工作如果靠管理员手工来完成，那其实是非常烦琐的，而且也容易忘记。那么 Linux 系统是否可以自动完成日志的轮替工作呢？</p>
<p>logrotate 就是用来进行日志轮替（也叫日志转储）的，也就是把旧的日志文件移动并改名，同时创建一个新的空日志文件用来记录新日志，当旧日志文件超出保存的范围时就删除。</p>
<h3 id="日志文件的命名规则"> 日志文件的命名规则</h3>
<p>日志轮替最主要的作用就是把旧的日志文件移动并改名，同时建立新的空日志文件，当旧日志文件超出保存的范围时就删除。那么，旧的日志文件改名之后，如何命名呢？主要依靠 <code>/etc/logrotate.conf</code> 配置文件中的“dateext”参数。</p>
<p>如果配置文件中有“dateext”参数，那么日志会用日期来作为日志文件的后缀，如“secure-20130605”。这样日志文件名不会重叠，也就不需要对日志文件进行改名，只需要保存指定的日志个数，删除多余的日志文件即可。</p>
<p>如果配置文件中没有“dateext”参数，那么日志文件就需要进行改名了。当第一次进行日志轮替时，当前的“secure”日志会自动改名为“secure.1”，然后新建“secure”日志，用来保存新的日志；当第二次进行日志轮替时，“secure.1”会自动改名为“secure.2”，当前的“secure”日志会自动改名为“secure.1”，然后也会新建“secure”日志，用来保存新的日志；以此类推。</p>
<h3 id="logrotate-配置文件"> logrotate 配置文件</h3>
<p>我们来查看一下 logrotate 的配置文件 <code>/etc/logrotate.conf</code> 的默认内容。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vi /etc/logrotate.conf</span>
<span># see "man logrotate" for details</span>
<span># rotate log files weekly</span>
weekly
<span>#每周对日志文件进行一次轮替</span>

<span># keep 4 weeks worth of backlogs</span>
rotate <span>4</span>
<span>#保存4个日志文件,也就是说,如果进行了5次日志轮替，就会删除第一个备份曰志</span>

<span># create new (empty) log files after rotating old ones</span>
create
<span>#在日志轮替时,自动创建新的日志文件</span>

<span># use date as a suffix of the rotated file</span>
dateext
<span>#使用日期作为日志轮替文件的后缀</span>

<span># uncomment this if you want your log files compressed</span>
<span>#compress</span>
<span>#日志文件是否压缩。如果取消注释,则日志会在转储的同时进行压缩</span>
<span>#以上日志配置为默认配置,如果需要轮替的日志没有设定独立的参数,那么都会遵循以上参数</span>
<span>#如果轮替曰志配置了独立参数,那么独立参数的优先级更高</span>

<span># RPM packages drop log rotation information into this directory</span>
include /etc/logrotate.d
<span>#包含/etc/logrotate.d/目录中所有的子配置文件。也就是说,会把这个目录中所有的子配置文件读取进来，进行日志轮替</span>

<span># no packages own wtmp and btmp -- we'11 rotate them here</span>
<span>#以下两个轮替曰志有自己的独立参数，如果和默认的参数冲突，则独立参数生效</span>
/var/log/wtmp <span>{</span>
<span>#以下参数仅对此目录有效</span>
monthly
<span>#每月对日志文件进行一次轮替</span>
create 0664 root utmp
<span>#建立的新日志文件,权限是0664,所有者是root,所属组是utmp组</span>
	minsize 1M
	<span>#日志文件最小轮替大小是1MB。也就是日志一定要超过1MB才会轮替，否则就算时间达到一个月，也不进行曰志轮替</span>
rotate <span>1</span>
<span>#仅保留一个曰志备份。也就是只保留wtmp和wtmp.1曰志)</span>
<span>}</span>

/var/log/btmp <span>{</span>
<span>#以下参数只对/var/log/btmp生效</span>
missingok
<span>#如果日志不存在,则忽略该日志的警告信患</span>
	monthly
	create 0600 root utmp
	rotate <span>1</span>
<span>}</span>
<span># system-specific logs may be also be configured here.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div><p>在这个配置文件中，主要分为三部分：</p>
<ul>
<li>第一部分是默认设置，如果需要转储的日志文件没有特殊配置，则遵循默认设置的参数；</li>
<li>第二部分是读取 <code>/etc/logrotate.d/</code> 目录中的日志轮替的子配置文件，也就是说，在 <code>/etc/logrotate.d/</code> 目录中的所有符合语法规则的子配置文件也会进行日志轮替；</li>
<li>第三部分是对 wtmp 和 btmp 日志文件的轮替进行设定，如果此设定和默认参数冲突，则当前设定生效（如 wtmp 的当前参数设定的轮替时间是每月，而默认参数的轮替时间是每周，则对 wtmp 这个日志文件来说，轮替时间是每月，当前的设定参数生效）。</li>
</ul>
<p>logrotate 配置文件的主要参数如表6-5 所示。</p>
<p><strong>表6-5	<u>logrotate 配置文件的主要参数</u></strong></p>
<table>
<thead>
<tr>
<th>参 致</th>
<th>参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>daily</td>
<td>日志的轮替周期是毎天</td>
</tr>
<tr>
<td>weekly</td>
<td>日志的轮替周期是每周</td>
</tr>
<tr>
<td>monthly</td>
<td>日志的轮控周期是每月</td>
</tr>
<tr>
<td>rotate 数宇</td>
<td>保留的日志文件的个数。0 指没有备份</td>
</tr>
<tr>
<td>compress</td>
<td>当进行日志轮替时，对旧的日志进行压缩</td>
</tr>
<tr>
<td>create mode owner group</td>
<td>建立新日志，同时指定新日志的权限与所有者和所属组。如 create 0600 root utmp。</td>
</tr>
<tr>
<td>mail address</td>
<td>当进行日志轮替时.输出内存通过邮件发送到指定的邮件地址</td>
</tr>
<tr>
<td>missingok</td>
<td>如果日志不存在，则忽略该日志的警告信息</td>
</tr>
<tr>
<td>nolifempty</td>
<td>如果曰志为空文件，則不进行日志轮替</td>
</tr>
<tr>
<td>minsize 大小</td>
<td>日志轮替的最小值。也就是日志一定要达到这个最小值才会进行轮持，否则就算时间达到也不进行轮替</td>
</tr>
<tr>
<td>size 大小</td>
<td>日志只有大于指定大小才进行日志轮替，而不是按照时间轮替，如 size 100k</td>
</tr>
<tr>
<td>dateext</td>
<td>使用日期作为日志轮替文件的后缀，如 secure-20130605</td>
</tr>
<tr>
<td>sharedscripts</td>
<td>在此关键宇之后的脚本只执行一次</td>
</tr>
<tr>
<td>prerotate/endscript</td>
<td>在曰志轮替之前执行脚本命令。endscript 标识 prerotate 脚本结束</td>
</tr>
<tr>
<td>postrolaie/endscript</td>
<td>在日志轮替之后执行脚本命令。endscript 标识 postrotate 脚本结束</td>
</tr>
</tbody>
</table>
<p>这些参数中较为难理解的应该是 prerotate/endscript 和 postrotate/endscript，我们利用 <code>man logrotate</code> 中的例子来解释一下这两个参数。例如：</p>
<div><pre><code><span>"/var/log/httpd/access.log"</span> /var/log/httpd/error.log <span>{</span>
<span>#日志轮替的是/var/log/httpd/中RPM包默认安装的apache正确访问日志和错误日志</span>
	rotate <span>5</span>
	<span>#轮替5次</span>
	mail www@my.org
	<span>#把信息发送到指定邮箱</span>
	size 100k
	<span>#日志大于100KB时才进行日志轮替,不再按照时间轮替</span>
	sharedscripts
	<span>#以下脚本只执行一次</span>
	postrotate
	<span>#在日志轮替结束之后,执行以下脚本</span>
		/usr/bin/killall -HUP httpd
		<span>#重启apache 服务</span>
endscript
<span>#脚本结束</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p><u>prerotate 和 postrotate  主要用于在日志轮替的同时执行指定的脚本，一般用于日志轮替之后重启服务</u>。这里强调一下，如果你的日志是写入 rsyslog  服务的配置文件的，那么把新日志加入 logrotate 后，一定要重启 rsyslog  服务，否则你会发现，虽然新日志建立了，但数据还是写入了旧的日志当中。那是因为虽然 logrotate 知道日志轮替了，但是 rsyslog  服务并不知道。</p>
<p>同理，如果采用源码包安装了 apache、Nginx 等服务，则需要重启 apache 或 Nginx 服务，同时还要重启 rsyslog 服务，否则日志也不能正常轮替。</p>
<p>不过，这里有一个典型应用就是给予特定的日志加入 chattr 的 a 属性。如果系统文件加入了 a 属性，那么这个文件就只能增加数据，而不能删除和修改已有的数据，root 用户也不例外。</p>
<p>因此，我们会给重要的日志文件加入 a 属性，这样就可以保护日志文件不被恶意修改。不过，一旦加入了 a  属性，那么在进行日志轮替时，这个日志文件是不能被改名的，当然也就不能进行日志轮替了。我们可以利用 prerotate 和 postrotate 参数来修改日志文件的 chattr 的 a 属性。</p>
<h3 id="把自己的日志加入日志轮替"> 把自己的日志加入日志轮替</h3>
<p>如果有些日志默认没有加入日志轮替（比如源码包安装的服务的日志，或者自己添加的日志），那么这些日志默认是不会进行日志轮替的，这样当然不符合我们对日志的管理要求。如果需要把这些日志也加入日志轮替，那该如何操作呢？</p>
<p>这里有两种方法：</p>
<ul>
<li>第一种方法是直接在 <code>/etc/logrotate.conf</code> 配置文件中写入该日志的轮替策略，从而把日志加入轮替；</li>
<li>第二种方法是在 <code>/etc/logrotate.d/</code> 目录中新建立该日志的轮替文件，在该轮替文件中写入正确的轮替策略，因为该目录中的文件都会被包含到主配置文件中，所以也可以把日志加入轮替。</li>
</ul>
<p>我们推荐第二种方法，因为系统中需要轮替的日志非常多，如果全部直接写入 <code>/etc/logrotate.conf</code> 配置文件，那么这个文件的可管理性就会非常差，不利于此文件的维护。</p>
<p>说起来很复杂，我们举个例子。还记得我们自己生成的 <code>/var/log/alert.log</code> 日志吗？这个日志不是系统默认日志，而是我们通过 <code>/etc/rsyslog.conf</code> 配置文件自己生成的日志，所以默认这个日志是不会进行轮替的。如果我们需要把这个日志加入日志轮替策略，那该怎么实现呢？我们采用第二种方法，也就是在  <code>/etc/logrotate.d/</code> 目录中建立此日志的轮替文件。</p>
<p>具体步骤如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># chattr +a /var/log/alert.log</span>
<span>#先给日志文件赋予chattr的a属性，保证日志的安全</span>
<span>[</span>root@localhost ~<span>]</span><span># vi /etc/logrotate.d/alter</span>
<span>#创建alter轮替文件,把/var/log/alert.log加入轮替</span>
/var/log/alert.log <span>{</span>
	weekly
	<span>#每周轮替一次</span>
	rotate <span>6</span>
	<span>#保留6个轮替曰志</span>
	sharedscripts
	<span>#以下命令只执行一次</span>
	prerotate
	<span>#在日志轮替之前执行</span>
		/usr/bin/chattr -a /var/log/alert.log
		<span>#在日志轮替之前取消a属性,以便让日志可以轮替</span>
	endscript
	<span>#脚本结朿</span>

	sharedscripts
	postrotate
	<span>#在日志轮替之后执行</span>
		/usr/bin/chattr +a /var/log/alert.log
		<span>#在日志轮替之后,重新加入a属性</span>
	endscript

	sharedscripts
	postrotate
	/bin/kill -HUP <span><span>$(</span>/bin/cat /var/run/syslogd.pid <span><span>2</span>></span>/dev/null<span>)</span></span> <span>&amp;></span>/dev/null
	endscript
	<span>#重启rsyslog服务，保证日志轮替正常进行</span>
 <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>这样我们自己生成的日志 <code>/var/log/alert.log</code> 也就可以进行日志轮替了，当然这些配置信息也是可以直接写入 <code>/etc/logrotate.conf</code> 这个配置文件的。</p>
<p>再举一个例子，我们如果需要把 Nginx 服务的日志加入日志轮替，则需要注意重启 Nginx 服务，当然还要重启 rsyslog 服务。例如:</p>
<div><pre><code>/date/logs/nginx/access/access.log /date/logs/nginx/access/default.log<span>{</span>
<span>#假设 Nginx 服务的日志放在/date/目录下</span>
	daily
	rotate <span>30</span>
	create
	compress
	sharedscripts
    postrotate
		/bin/kill -HUP <span><span>$(</span>/bin/cat /var/run/syslogd.pid<span>)</span></span> <span>&amp;></span>/dev/null
		<span>#重启 rsyslog 服务</span>
		/bin/k111 -HUP <span><span>$(</span>/bin/cat /var/local/nginx/logs/nginx.pid<span>)</span></span> <span>&amp;></span>/dev/null
		<span>#重启 Nginx 服务</span>
	endscript
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="logrotate-命令"> logrotate 命令</h3>
<p>日志轮替之所以可以在指定的时间备份日志，是因为其依赖系统定时任务。如果大家还记得 <code>/etc/cron.daily/</code> 目录，就会发现这个目录中是有 <code>logrotate</code> 文件的，查看一下这个文件，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vi /etc/cron.daily/logrotate</span>
<span>#!/bin/sh</span>
/usr/sbin/logrotate /etc/logrotate.conf <span>></span>/dev/null <span><span>2</span>></span><span>&amp;1</span>
<span>#最主要的就是执行了logrotate命令</span>
<span>EXITVALUE</span><span>=</span><span>$?</span>
<span>if</span> <span>[</span> <span>$EXITVALUE</span> <span>!=</span> <span>0</span> <span>]</span><span>;</span> <span>then</span>
	/usr/bin/logger -t <span>logrotate</span> <span>"ALERT exited abnormally with [<span>$EXITVALUE</span>]"</span>
<span>fi</span>
<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>也就是说，系统每天都会执行 <code>/etc/cron.daily/logrotate</code> 文件，运行这个文件中的 <code>/usr/sbin/logrotate /etc/logrotate.conf &gt;/dev/null 2&gt;&amp;1</code> 命令。<code>logrotate</code> 命令会依据 <code>/etc/logrotate.conf</code> 配置文件的配置，来判断配置文件中的日志是否符合日志轮替的条件（比如，日志备份时间已经满一周），如果符合，日志就会进行轮替。所以说，日志轮替还是由 crond 服务发起的。</p>
<p><code>logrotate</code> 命令的格式是什么样的呢？我们来学习一下。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># logrotate [选项] 配置文件名</span>
选项：
		如果此命令没有选项，则会按照配置文件中的条件进行日志轮替
	-v：显示日志轮替过程。加入了-v 选项，会显示日志的轮替过程
	-f：强制进行日志轮替。不管日志轮替的条件是否符合，强制配置文件中所有的日志进行轮替
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>我们执行 <code>logrotate</code> 命令，并查看一下执行过程。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># logrotate -v /etc/logrotate.conf</span>
<span>#查看日志轮替的流程</span>
<span>..</span>.省略部分输出<span>..</span>.
rotating pattern: /var/log/alert.log weekly <span>(</span><span>6</span> rotations<span>)</span>
<span>#这就是我们自己加入轮替的alert.log日志</span>
empty log files are rotated， old logs are removed
considering log /var/log/alert.log
log does not need rotating
<span>#时间不够一周，所以不进行日志轮替</span>
<span>..</span>.省略部分输出<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>我们发现，<code>/var/log/alert.log</code> 加入了日志轮替，已经被 <code>logrotate</code> 识别并调用了，只是时间没有达到轮替的标准，所以没有进行轮替。那我们强制进行一次日志轮替，看看会有什么结果。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># logrotate -vf /etc/logrotate.conf</span>
<span>#强制进行日志轮替，不管是否符合轮替条件</span>
<span>..</span>.省略部分输出<span>..</span>.
rotating pattern: /var/log/alert.log forced from <span>command</span> line <span>(</span><span>6</span> rotations<span>)</span>
empty log files are rotated， old logs are removed
considering log /var/log/alert.log
log needs rotating
<span>#日志需要轮替</span>
rotating log /var/log/alert.log, log-<span>></span>rotateCount is <span>6</span>
dateext suffix <span>'-20130607'</span>
<span>#提取日期参数</span>
glob pattern <span>'-[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]'</span>
glob finding old rotated logs failed
running prerotate script
fscreate context <span>set</span> to unconfined_u：object_r：var_log_t：s0
renaming /var/log/alert.log to /var/log/alert.log-20130607
<span>#旧的日志被重命名</span>
creating new /var/log/alert.log mode <span>=</span> 0600 uid <span>=</span> <span>0</span> gid <span>=</span> <span>0</span>
<span>#创建新日志文件，同时指定权限、所有者和属组</span>
running postrotate script
<span>..</span>.省略部分输出<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>我们发现，<code>alert.log</code> 日志已经完成了日志轮替。查看一下新生成的日志和旧日志，如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ll /var/log/alert.log*</span>
-rw-------.1 root root   <span>0</span> <span>6</span>月 <span>7</span> <span>10</span>：07 /var/log/alert.log
-rw-------.1 root root <span>237</span> <span>6</span>月 <span>7</span> 09：58 /var/log/alert.log-20130607
<span>#旧的日志文件已经轮替</span>
<span>[</span>root@localhost ~<span>]</span><span># lsattr /var/log/alert.log</span>
-----a-------e- /var/log/alert.log
<span>#查看文件属性，新的日志文件被自动加入了chattr的a属性</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>logrotate 命令在使用“-f”选项之后，就会不管日志是否符合轮替条件，而强制把所有的日志都进行轮替。</p>
<h2 id="日志分析工具"> 日志分析工具</h2>
<p>日志是非常重要的系统文件，管理员每天的重要工作就是分析和查看服务器的日志，判断服务器的健康状态。但是日志管理又是一项非常枯燥的工作，如果需要管理员手工查看服务器上所有的日志，那实在是一项非常痛苦的工作。有些管理员就会偷懒，省略日志的检测工作，但是这样做非常容易导致服务器出现问题。</p>
<p>那么我们有取代的方案吗？有，那就是日志分析工具。这些日志分析工具会详细地查看日志，同时分析这些日志，并且把分析的结果通过邮件的方式发送给 root 用户。这样，我们每天只要查看日志分析工具的邮件，就可以知道服务器的基本情况，而不用挨个检查日志了。这样系统管理员就可以从繁重的日常工作中解脱出来，去处理更加重要的工作。</p>
<p>在 CentOS 中自带了一个日志分析工具，就是 <code>logwatch</code>。不过这个工具默认没有安装（因为我们选择的是“Basic Server”），所以需要手工安装。安装命令如下：</p>
<div><pre><code><span>[</span>root@localhost Packages<span>]</span><span># yum -y install logwatch</span>
</code></pre>
<div><span>1</span><br></div></div><p>安装完成之后，需要手工生成 <code>logwatch</code> 的配置文件。默认配置文件是 <code>/etc/logwatch/conf/logwatch.conf</code>，不过这个配置文件是空的，需要把模板配置文件复制过来。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cp /usr/share/logwatch/default.conf/logwatch.conf /etc/logwatch/conf/logwatch.conf</span>
<span>#复制配置文件</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这个配置文件的内容中绝大多数是注释，我们把注释去掉，那么这个配置文件的内容如下所示：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vi /etc/logwatch/conf/logwatch.conf</span>
<span>#查看配置文件</span>
LogDir <span>=</span> /var/log
<span>#logwatch会分析和统计/var/log/中的日志</span>
TmpDir <span>=</span> /var/cache/logwatch
<span>#指定logwatch的临时目录</span>
MailTo <span>=</span> root
<span>#日志的分析结果，给root用户发送邮件</span>
MailFrom <span>=</span> Logwatch
<span>#邮件的发送者是Logwatch，在接收邮件时显示</span>
Print <span>=</span>
<span>#是否打印。如果选择“yes”，那么日志分析会被打印到标准输出，而且不会发送邮件。我们在这里不打印，而是给root用户发送邮件</span>
<span>#Save = /tmp/logwatch</span>
<span>#如果开启这一项，日志分析就不会发送邮件，而是保存在/tmp/logwatch文件中</span>
Range <span>=</span> yesterday
<span>#分析哪天的日志。可以识别“All”“Today”“Yesterday”，用来分析“所有日志”“今天日志”“昨天日志”</span>
Detail <span>=</span> Low
<span>#日志的详细程度。可以识别“Low”“Med”“High”。也可以用数字表示，范围为0～10，“0”代表最不详细，“10”代表最详细</span>
Service <span>=</span> All
<span>#分析和监控所有日志</span>
Service <span>=</span> <span>"-zz-network"</span>
<span>#但是不监控“-zz-network”服务的日志。“-服务名”表示不分析和监控此服务的日志</span>
Service <span>=</span> <span>"-zz-sys"</span>
Service <span>=</span> <span>"-eximstats"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>这个配置文件基本不需要修改（我在实验时把 Range 项改为了 All，否则一会儿的实验可以分析的日志过少），它就会默认每天执行。它为什么会每天执行呢？聪明的你已经想到了，一定是 <code>crond</code> 服务的作用。没错，logwatch 一旦安装，就会在 <code>/etc/cron.daily/</code> 目录中建立 <code>0logwatch</code> 文件，用于在每天定时执行 <code>logwatch</code> 命令，分析和监控相关日志。</p>
<p>如果想要让这个日志分析马上执行，则只需执行 <code>logrotate</code> 命令即可。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># logwatch</span>
<span>#马上执行logwatch日志分析工具</span>
<span>[</span>root01ocalhost ~<span>]</span><span># mail</span>
<span>#查看邮件</span>
Heirloom Mail version <span>12.4</span> <span>7</span>/29/08. Type ? <span>for</span> help, <span>"/var/spool/mail/root"</span><span>:</span> <span>5</span> messages <span>1</span> new <span>2</span> unread
   <span>1</span> logwatch@localhost.1 Fri Jun <span>7</span> <span>11</span>:17 <span>42</span>/1482 <span>"Logwatch for localhost.localdomain (Linux)"</span>
 U <span>2</span> logwatch@localhost.1 Fri Jun <span>7</span> <span>11</span>:19 <span>42</span>/1481 <span>"Logwatch for localhost.localdomain (Linux)"</span>
   <span>3</span> logwatch@localhost.1 Fri Jun <span>7</span> <span>11</span>:23 <span>1234</span>/70928 <span>"Logwatch for localhost.localdomain (Linux)"</span>
   <span>4</span> logwatch@localhost.1 Fri Jun <span>7</span> <span>11</span>:24 <span>190</span>/5070 <span>"Logwatch for localhost.localdomain (Linux)"</span>
   <span>5</span> logwatch@localhost.1 Fri Jun <span>7</span> <span>11</span>:55 <span>41</span>/1471 <span>"Logwatch for localhost.localdomain (Linux)"</span>
<span>></span>N <span>6</span> logwatch@localhost.1 Fri Jun <span>7</span> <span>11</span>:57 <span>189</span>/5059 <span>"Logwatch for localhost.localdomain (Linux)"</span>
<span>#第6封邮件就是刚刚生成的曰志分析邮件，"N"代表没有查看</span>
<span>&amp;</span> <span>6</span>
Message <span>6</span>:
From root@localhost.localdomain Fri Jun <span>7</span> <span>11</span>:57:35 <span>2013</span>
Return-Path: <span>&lt;</span>root@localhost.localdomain<span>></span>
X-Original-To: root
Delivered-To: root@localhost.localdomain
To: root@localhost.localdomain
From: logwatch@localhost.localdomain
Subject: Logwatch <span>for</span> localhost.localdomain <span>(</span>Linux<span>)</span>
Content-Type: text/plain<span>;</span> <span>charset</span><span>=</span><span>"iso-8859-1"</span>
Date: Fri, <span>7</span> Jun <span>2013</span> <span>11</span>:57:33 +0800 <span>(</span>CST<span>)</span>
Status: R
<span>######## Logwatch 7.3.6 (05/19/07) ################</span>
	Processing Initiated: Fri Jun <span>7</span> <span>11</span>:57:33 <span>2013</span>
	Date Range Processed: all
  Detail Level of Output: <span>0</span>
	      Type of Output: unformatted
	   Logfiles <span>for</span> Host: localhost.localdomain
<span>###################################################</span>
<span>#上面是曰志分析的时间和日期</span>
<span>..</span>.省略部分输出<span>..</span>.
--------- Connections <span>(</span>secure-log<span>)</span> Begin-----------
<span>#分析secure.log日志的内容。统计新建立了哪些用户和组，以及错误登录信息 New Users：</span>
  bb <span>(</span><span>501</span><span>)</span>
  def <span>(</span><span>503</span><span>)</span>
  hjk <span>(</span><span>504</span><span>)</span>
  zhangsan <span>(</span><span>505</span><span>)</span>
  dovecot <span>(</span><span>97</span><span>)</span>
  dovenull <span>(</span><span>498</span><span>)</span>
  aa <span>(</span><span>500</span><span>)</span>
 
New Groups:
  bb <span>(</span><span>501</span><span>)</span>
  def <span>(</span><span>503</span><span>)</span>
  hjk <span>(</span><span>504</span><span>)</span>
  zhangsan <span>(</span><span>505</span><span>)</span>
  dovecot <span>(</span><span>97</span><span>)</span>
  dovenull <span>(</span><span>498</span><span>)</span>
  aa <span>(</span><span>500</span><span>)</span>
 
Failed logins:
  User root:
  	<span>(</span>null<span>)</span>: <span>3</span> Time<span>(</span>s<span>)</span>
 
Root logins on tty's: <span>7</span> Time<span>(</span>s<span>)</span>.
**Unmatched Entries**
	groupadd: group added to /etc/group: <span>name</span><span>=</span>dovecot, <span>GID</span><span>=</span><span>97</span>: <span>1</span> Time<span>(</span>s<span>)</span>
	groupadd: group added to /etc/group: <span>name</span><span>=</span>dovenull, <span>GID</span><span>=</span><span>498</span>: <span>1</span> Time<span>(</span>s<span>)</span>
	groupadd: group added to /etc/gshadow: <span>name</span><span>=</span>dovecot: <span>1</span> Time<span>(</span>s<span>)</span>
	groupadd: group added to /etc/gshadow: <span>name</span><span>=</span>dovenull: <span>1</span> Time<span>(</span>s<span>)</span>
--------Connections <span>(</span>secure-log<span>)</span>End-------

-------------SSHD Begin-------------------
<span>#分析SSHD的日志。可以知道哪些IP地址连接过服务器</span>

SSHD Killed: <span>7</span> Time<span>(</span>s<span>)</span>

SSHD Started: <span>24</span> Time<span>(</span>s<span>)</span>

Users logging <span>in</span> through sshd:
	root:
		<span>192.168</span>.0.104: <span>10</span> <span>times</span>
		<span>192.168</span>.0.108: <span>8</span> <span>times</span>
		<span>192.168</span>.0.101: <span>6</span> <span>times</span>
		<span>192.168</span>.0.126: <span>4</span> <span>times</span>
		<span>192.168</span>.0.100: <span>3</span> <span>times</span>
		<span>192.168</span>.0.105: <span>3</span> <span>times</span>
		<span>192.168</span>.0.106: <span>2</span> <span>times</span>
		<span>192.168</span>.0.102: <span>1</span> <span>time</span>
		<span>192.168</span>.0.103: <span>1</span> <span>time</span>
		
SFTP subsystem requests: <span>3</span>. Time<span>(</span>s<span>)</span>

**Unmatched Entries**
Exiting on signal <span>15</span> <span>:</span> <span>6</span> time<span>(</span>s<span>)</span>

----------------SSHD End-----------

--------------- yum Begin ---------
<span>#统计yum安装的软件。可以知道我们安装了哪些软件</span>
 
Packages Installed:
  perl-YAML-Syck-1.07-4.el6.i686
  perl-Date-Manip-6.24-1.el6.noarch
  logwatch-7.3.6-49.el6.noarch

-----------yum End-------------

--------Disk Space Begin-------
<span>#统计磁盘空间情况</span>
Filesystem	Size	Used	Avail	Use%	Mounted on
/dev/sda3	20G		<span>1</span>.9G	17G		<span>11</span>%		/
/dev/sda1	194M	26M		158M	<span>15</span>%		/boot
/dev/sr0	<span>3</span>.5G	<span>3</span>.5G	<span>0</span>		<span>100</span>%	/mnt/cdrom

---------Disk Space End-----------------

<span>#########Logwatch End ##################</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br></div></div><p>有了这个日志分析工具，日志管理工作就会轻松很多。当然，在 Linux 中可以支持很多日志分析工具，我们在这里只介绍了 CentOS 自带的 <code>logwatch</code>，大家可以根据自己的习惯选择相应的日志分析工具。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2022-01-26T06:11:29.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">LAMP和LNMP环境搭建</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_manage/06.LAMP_LNMP_evn/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_manage/06.LAMP_LNMP_evn/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p><strong>LAMP 环境搭建</strong>指的是在 Linux 操作系统中分别安装 Apache 网页服务器、MySQL 数据库服务器和 PHP 开发服务器，以及一些对应的扩展软件。</p>
<p>LAMP 环境是当前极为流行的搭建动态网站的开源软件系统，拥有良好的稳定性及兼容性。而且随着开源软件的蓬勃发展，越来越多的企业和个人选择在 LAMP 开发平台上搭建自己的网站。</p>
<p><strong>LNMP 环境搭建</strong>指的是在 Linux 操作系统中分别安装 Nginx 网页服务器、MySQL 数据库服务器和 PHP 开发服务器，以及一些对应的扩展软件。</p>
<p>在 LNMP 环境中，使用 Nginx 网页服务器取代了 Apache 网页服务器。Nginx 是一款高性能的 HTTP 网页服务器和反向代理服务器，它的执行效率极高，配置相比 Apache 也较为简单，所以在短时间内被国内外很多大型公司所采用，大有取代 Apache 的势头（目前还是以 Apache 为主流的）。</p>
<div><p>占比</p>
<p><a href="http://www.netcraft.com" target="_blank" rel="noopener noreferrer">www.netcraft.com</a> 网站的统计数据表明，采用 LAMP 环境搭建的网站数量占全球网站总数的 52.19％（2013 年 7 月数据），而其余的网站平台（如 Microsoft IIS 开发平台、Linux Nginx 开发平台、Google 开发平台等）占用了剩余的份额。</p>
</div>
<h2 id="lamp-环境搭建"> LAMP 环境搭建</h2>
<p>我们知道，如果我们安装的是应用服务软件，这个软件是给外网用户访问和使用的，那么应该使用源码包安装，因为源码包安装的软件经过了本机编译，性能更好。所以我们的 LAMP 环境搭建，在生产服务器上一般采用源码包进行安装，而不会使用 RPM 包进行安装，接下来我们要讲的也是采用源码包方式搭建 LAMP 环境。</p>
<p>LAMP 环境搭建是较为复杂的 Linux 实验，在进行真正的环境安装之前，需要做一些细致的准备工作，以避免在安装过程中出现不必要的错误。我们需要进行的准备工作有以下几步。</p>
<h3 id="安装前的准备"> 安装前的准备</h3>
<h4 id="获取源码包"> 获取源码包</h4>
<p>我们已经知道 RPM 包是在 CentOS 的安装光盘中保存的，但是源码包需要去互联网下载。我们此次完成 LAMP 环境搭建需要 19 个软件包，这是目前较为完善和常用的 LAMP 环境搭建方式。这些软件包的下载地址如表7-1 所示。这些下载地址只是参考，如果有失效的，则请自行搜索。</p>
<p><strong>表7-1	<u>LAMP 环境搭建所需的软件包</u></strong></p>
<table>
<thead>
<tr>
<th>软件包</th>
<th>说 明</th>
<th>下载地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>httpd-2.4.7.tar.gz</td>
<td>Apache 包</td>
<td>http://www.apache.org/</td>
</tr>
<tr>
<td>mysql-5.5.23.tar.gz</td>
<td>MySQL 数据库</td>
<td>http://dev.mysql.com/downloads/</td>
</tr>
<tr>
<td>php-5.4.25.tar.gz</td>
<td>PHP 语言</td>
<td>http://www.php.net/downloads.php</td>
</tr>
<tr>
<td>phpMyAdmin-4.1.4-all-languages.iar.gz</td>
<td>Web方式的 MySQL 管理工具</td>
<td>http://www.phpmyadmin.com/</td>
</tr>
<tr>
<td>libxml2_2.9.1.tar.gz</td>
<td>用来解析 XML文档的函数库</td>
<td>http://www.linuxfromscratch.org/blfs/view/svn/general/libxml2.html</td>
</tr>
<tr>
<td>libmerypt-2.5.8.tar.gz</td>
<td>加密算法扩展库</td>
<td>http://prdownloads.sourceforge.net/mcrypt/libmcrypt-2.5.8.tar.gz?use_mirror=peterhost</td>
</tr>
<tr>
<td>mhash-0.9.9.9.tar.gz</td>
<td>加密算法扩展库</td>
<td>http://sourceforge.net/projects/mhash/files/mhash/0.9.9.9/</td>
</tr>
<tr>
<td>mcrypt-2-6.8-tar.gz</td>
<td>加密算法扩展库</td>
<td>http://sourceforge.net/projects/mcrypt/files/MCrypt/2.6.8/</td>
</tr>
<tr>
<td>zlib-1.2.3.tar.gz</td>
<td>数据压缩函数库</td>
<td>http://www.zlib.net/</td>
</tr>
<tr>
<td>gd-2.0.35.tar.gz</td>
<td>PHP 处理用形的扩展库</td>
<td>https://bitbucket.org/libgd/gd-libgd/downloads</td>
</tr>
<tr>
<td>freetype-2.3.5-tar-gz</td>
<td>字体引擎库</td>
<td>http://download.savannah.gnu.org/releases/freetype/</td>
</tr>
<tr>
<td>libpng-1.2.31.tar.gz</td>
<td>用于解码 .png 格式的图片</td>
<td>ftp://ftp.simplesystems.org/pub/libpng/png/src/</td>
</tr>
<tr>
<td>jpegsrc.v6b.tar.gz</td>
<td>用于解码.jpg和.jpeg格式的图片</td>
<td>http://www.ijg.org/files/jpegsrc.v6b.tar.gz</td>
</tr>
<tr>
<td>apr-1.4.6.tar.gz</td>
<td>Apache支持镆块</td>
<td>http://archive.apache.org/dist/apr/</td>
</tr>
<tr>
<td>apr-util-1.4.1.tar.gz</td>
<td>Apache支持模块</td>
<td>http://archive.apache.org/dist/apr/</td>
</tr>
<tr>
<td>pcre-8.34.tar.gz</td>
<td>Apache支持模块，使 Apache支持 pcre 正则表达式规则</td>
<td>http://sourceforge.net/projects/pcre/files/pcre/8.34/pcre-8.34.tar.gz/stats/map</td>
</tr>
<tr>
<td>ncurses-5.9.tar.gz</td>
<td>使应用程序直接控制终端屏幕显示的函数库</td>
<td>http://ftp.gnu.org/pub/gnu/ncurses/</td>
</tr>
<tr>
<td>memcache-3.0.8.tgz</td>
<td>memcache 函数库（客户端）</td>
<td>http://pecl.php.net/package/memcache</td>
</tr>
<tr>
<td>memcached-1.4.17.tar.gz</td>
<td>memcached 服务器端</td>
<td>http://memcached.org/</td>
</tr>
</tbody>
</table>
<p>大家可能已经发现，我们下载的软件包不全是最新的版本，这主要是为了和 php-5.4.25.tar.gz 这个软件包进行匹配。当然，php-5.4.25.tar.gz 也已经不是最新版本的 PHP 了，不过在计算机领域永远不是最新版本的软件就是最好的，新软件虽然有了更多的功能，但是这个软件并没有经过实际工作的检验，它不一定稳定，也有可能会有 Bug；反而版本较低的、但是经过足够的实践检验的软件会更受开发者的欢迎。</p>
<p>Linux 就是这样的，CentOS 6.x 自 2011 年发布以来，经过多年的补充和完善，目前才逐渐得到个人使用者和企业使用者的认可。PHP 同样如此，目前 php-5.4.25.tar.gz 依然是使用最多的 PHP 版本，所以我们依然使用 php-5.4.25.tar.gz  来介绍 LAMP 环境的搭建。</p>
<h4 id="把软件包传送到-linux-服务器上"> 把软件包传送到 Linux 服务器上</h4>
<p>我们可以直接把软件包下载到 Linux 服务器上，也可以先下载到本地 Windows 中，再上传到 Linux 服务器中。如果是先下载到本地 Windows 中，再上传到 Linux 服务器中，那么需要利用网络文件服务器来进行数据的传输。但是我们现在还没有学习 Linux 中的文件服务器（如 FTP、Samba 或 NFS），所以我们在这里介绍一款名为 WinSCP 的软件。</p>
<p>WinSCP 是在 Windows 中安装，使用 SFTP 协议向 Linux 服务器传递文件的工具。它的特点是使用简单、图形化操作，而且数据传递过程是加密的，较为安全，是 Windows 和 Linux 之间进行数据传递的常用软件。WinSCP 第一次启动的界面如图7-1 所示。</p>
<div>
<p><img src="./assets/winscp.jpg" alt="scp" loading="lazy"></p>
<p><strong>图7-1	<u>WinSCP 启动界面</u></strong></p>
</div>
<p>在启动界面的“主机名”文本框中输入 Linux 服务器的 IP 地址，如 192.168.0.210，在“用户名”文本框中输入 Linux 的用户名，在“密码”文本框中输入正确的密码，单击“登录”按钮，就会见到如图7-2 所示的界面。</p>
<div>
<p><img src="./assets/scp1.jpg" alt="scp1" loading="lazy"></p>
<p><strong>图7-2	<u>WinSCP传输界面</u></strong></p>
</div>
<p>在这个工具中，左半部分是 Windows 系统中的文件，右半部分是 Linux 服务器上的文件。如果需要从 Windows 向 Linux  传递什么文件，则只需找到这个文件或目录，从左半部分拖拽到右半部分即可；反过来就是从 Linux 传递文件到 Windows 中，非常简单。</p>
<p>那么，我们应该把软件放置在 Linux 服务器的什么位置呢？Linux 中的 <code>/usr/local/src/</code> 目录是系统默认的放置下载软件源代码的位置，所以我们就把搭建  LAMP 环境所需的所有软件包都传递到这个位置，传递完成后查看一下，如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls /usr/local/src/</span>
apr-1.4.6.tar.gz jpegsrc.v6b.tar.gz memcache-3.0.8.tgz
pcre-8.34.tar.gz apr-util-1.4.1.tar.gz libmcrypt-2.5.8.tar.gz
memcached-1.4.17.tar.gz php-5.4.25.tar.gz freetype-2.3.5.tar.gz
libpng-1.2.31.tar.gz mhash-0.9.9.9.tar.gz phpMyAdmin-4.1.4-all-languages.tar.gz
gd-2.0.35.tar.gz libxml2-2.9.1.tar.gz mysql-5.5.23.tar.gz
zlib-1.2.3.tar.gz httpd-2.4.7.tar.gz mcrypt-2.6.8.tar.gz ncurses-5.9.tar.gz
<span>[</span>root@localhost ~<span>]</span><span># ls /usr/local/src/ | wc -l</span>
<span>19</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>我们发现，19 个软件包全部传递到 Linux 服务器中。</p>
<h4 id="安装编译工具"> 安装编译工具</h4>
<p>源码包都是用 C 或 C++ 语言编写的，而且需要在本机编译之后才能正确安装。在 Linux 中，C 语言的编译器是 gcc，C++ 语言的编译器是 gcc-c++。</p>
<p>在安装源码包之前，需要确认这两个编译器是否存在。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># rpm -qa | grep gcc</span>
libgcc-4.4.6-4.el6.i686
gcc-4.4.6-4.el6.i686
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以看到，我们已经安装了 gcc 编译器，但是还没有安装 gcc-c++ 编译器。使用 yum 安装 gcc-c++ 编译器，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># yum -y install gcc-c++</span>
</code></pre>
<div><span>1</span><br></div></div><p>如果 Linux 服务器可以正常连接互联网，那么这条 yum 命令是可以直接使用的，不用进行任何配置与修改。只是 yum 会去连接 CentOS 的官方服务器，这台服务器在国外，速度可能较慢。如果 Linux 服务器不能正常连接互联网，则也可以使用本地光盘作为 yum 源。</p>
<p>安装完成后再查询一下，如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># rpm -qa | grep gcc</span>
gcc-4.4.7-3.el6.i686
libgcc-4.4.7-3.el6.i686
gcc-c++-4.4.7-3.el6.i686
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>gcc 和 gcc-c++ 编译器都已经安装了。大家可能发现这次查询的 gcc 是 4.4.7 版本，而上次查询的 gcc 是 4.4.6 版本，那是因为我们使用网络 yum 源去 CentOS 的官方服务器上安装 gcc-c++，但是在安装 gcc-c++ 的时候，是需要 gcc 已经安装完成的。在 CentOS 的官方服务器上，gcc 和 gcc-c++ 的版本更高，所以在安装 gcc-c++ 的时候，自动更新了 gcc 的版本。不管怎么说，编译工具已经安装完成，我们可以进行下一步的准备工作了。</p>
<h4 id="关闭-rpm-包安装的-apache-和-mysql"> 关闭 RPM 包安装的 apache 和 mysql</h4>
<p>我们在生产服务器上是不会既安装 RPM 包的 apache，又安装源码包的 apache 的。但是为了教学需要，有时需要安装这两种包的 apache。我们现在需要停用 RPM包安装的 apache 和 mysql，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># service httpd stop</span>
<span>[</span>root@localhost ~<span>]</span><span># service mysqld stop</span>
<span>#停止apache和mysql服务</span>
<span>[</span>root@localhost ~<span>]</span><span># chkconfig httpd off</span>
<span>[</span>root@localhost ~<span>]</span><span># chkconfig mysqld off</span>
<span>#关闭apache和mysql的自启动</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id="关闭防火墙和-selinux"> 关闭防火墙和 SELinux</h4>
<p>在生产服务器上，防火墙是不能直接关闭的，而是需要设置防火墙允许 80 端口（apache）、3306 端口（mysql）和 11211（memcache）端口访问的。但是目前我们还没有学习防火墙，所以只能暂时关闭它了。关闭命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># setup</span>
</code></pre>
<div><span>1</span><br></div></div><p>在图7-3 所示的界面中选择“防火墙配置”，进入防火墙配置界面。</p>
<div>
<p><img src="./assets/setup.jpg" alt="setup" loading="lazy"></p>
<p><strong>图7-3	<u>setup界面</u></strong></p>
</div>
<p>在图7-4 所示的界面中，把“启用”前面的“*”去掉，选择“确定”保存，默认防火墙规则就会被关闭。</p>
<div>
<p><img src="./assets/fhq.jpg" alt="fhq" loading="lazy"></p>
<p><strong>图7-4	<u>关闭防火墙</u></strong></p>
</div>
<p>再查询一下防火墙规则：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># iptables -L</span>
Chain INPUT <span>(</span>policy ACCEPT<span>)</span>
target prot opt <span>source</span> destination
Chain FORWARD <span>(</span>policy ACCEPT<span>)</span>
target prot opt <span>source</span> destination
Chain OUTPUT <span>(</span>policy ACCEPT<span>)</span>
target prot opt <span>source</span> destination
<span>#默认filter表中的三条链中的规则都是空。防火墙已经被关闭了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>除关闭防火墙之外，我们还需要关闭 SELinux 安全子系统。因为这个子系统会对我们的安装过程产生影响，所以先关闭它。关闭命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vi /etc/selinux/config</span>
<span>#把 SELINUX=enforcing改为 SELINUX=disabled</span>
<span>[</span>root@localhost ~<span>]</span><span># shutdown -r now</span>
<span>#重启Linux系统</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>关闭 SELinux 之后，必须重启 Linux 系统，修改才会生效。</p>
<h4 id="关闭不必要的服务"> 关闭不必要的服务</h4>
<p>接下来需要关闭我们不需要的服务，这既是服务器的必须优化步骤，也会使我们在 LAMP 环境搭建过程中的报错可能性大大降低，所以建议大家进行这一步服务优化。具体方法就是使用 <code>ntsysv</code> 命令把不需要的服务前面的“*”去掉，然后重启 Linux 服务器。具体哪些服务是必须启动的，哪些服务是不必要的，大家可以参考<a href="http://localhost:8080/blog/project/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/02.linux%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/#%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E5%88%AB%E5%8F%8A%E5%8A%9F%E8%83%BD" target="_blank" rel="noopener noreferrer">《Linux常见服务类别及功能》</a>。</p>
<h4 id="批量解压源码包"> 批量解压源码包</h4>
<p>我们需要安装 17 个源码包，如果一个一个地解压缩实在太麻烦了，那么我们写一个小的 Shell 脚本，批量进行解压缩。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vi tar.sh</span>
<span>#建立解压缩脚本</span>
<span>#! /bin/bash</span>
<span>#标称是 Shell脚本</span>
<span>cd</span> /usr/local/src/
<span>#进入保存源妈包的目录</span>
<span>ls</span> *.tar.gz <span>></span> /usr/local/src/ls.log
<span>#把所有以.tar.gz结尾的文件名覆盖写入ls.log文件</span>
<span>ls</span> *.tgz <span>>></span> /usr/local/src/ls.log
<span>#把所有以.tgz结尾的文件名追加写入ls.log文件</span>
<span>file</span><span>=</span><span><span>$(</span><span>cat</span> /usr/local/src/ls.log<span>)</span></span>
<span>#读取 ls.log 文件中的内容,赋子变量file</span>
<span>for</span> <span>i</span> <span>in</span> <span>$file</span>
<span>#for循环,每次德环把变量file中的一个文件名</span>
	<span>do</span>
	<span>tar</span> -zxf <span>$i</span>
	<span>#解压缩毎个压缩文件</span>
	<span>done</span>
<span>rm</span> -rf /usr/local/src/ls.log
<span>#删除临时文件ls.log</span>
<span>#以上是脚本的内容</span>
<span>[</span>rootBlocalhost ~<span>]</span><span># chmod 755 tar.sh</span>
<span>#赋予tar.sh文件执行权限</span>
<span>[</span>root@localhost ~<span>]</span><span># ./tar.sh</span>
<span>#执行这个脚本</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>这样，所有的压缩包就已经完成了解压缩过程。</p>
<h4 id="检查硬盘的剩余空间"> 检查硬盘的剩余空间</h4>
<p>LAMP 环境搭建大概需要 3GB 的空闲空间，所以确认一下硬盘的剩余空间，命令如下：</p>
<div><pre><code><span>[</span>root@localhost src<span>]</span><span># df -h</span>
文件系统	容量	已用	可用	已用%%	挂载点
/dev/sda3	20G		<span>2</span>.5G	16G		<span>14</span>%		/
tmpfs		306M	<span>0</span>		306M	<span>0</span>%		/dev/shm
/dev/sda1	194M	26M		158M	<span>15</span>%		/boot
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>/</code>分区还有 16GB 的可用空间，足够使用了。</p>
<h3 id="安装过程"> 安装过程</h3>
<h4 id="_1-安装-libxml2-源码包"> 1.安装 libxml2 源码包</h4>
<p><strong>libxml2 是一个用来解析 XML 文档的函数库</strong>。它用 C 语言写成，并且能被多种语言所调用，如 C、C++、XSH、C#、Python、Kylix、Delphi、Ruby、PHP 等。它最初是为 GNOME 开发的项目，但是现在可以用在各种各样的项目中。</p>
<p>libxml2 的代码可移植性非常好，因为它基于标准的 ANSI C 库，并采用了 MIT 许可证。安装步骤如下。</p>
<ol>
<li>安装python-devel</li>
</ol>
<p>这个软件包是 libxml2 的依赖包，如果不安装，libxml2 安装就会报错。这个软件包只是一个底层依赖包，所以安装 RPM 包即可。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># yum -y install python-devel </span>
</code></pre>
<div><span>1</span><br></div></div><ol start="2">
<li>进入解压缩之后的源码目录</li>
</ol>
<p>这一步不能省略，因为 <code>./configure</code>、<code>make</code> 和 <code>make install</code> 操作的都是当前所在目录，所以一定要进入解压缩之后的源码目录。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cd /usr/local/src/libxml2-2.9.1</span>
</code></pre>
<div><span>1</span><br></div></div><ol start="3">
<li>编译前的准备和配置</li>
</ol>
<p>这一步主要检查安装需要的系统环境、配置软件需要的功能选项，并生成配置安装文件 <code>Makefile</code>，以后的编译与编译安装过程需要依赖 <code>Makefile</code> 文件。命令如下：</p>
<div><pre><code><span>[</span>root@localhost libxml2-2.9.1<span>]</span><span># ./configure --prefix=/usr/local/libxml2/</span>
<span># “--prefix=/usr/local/libxml2/”用于指定安装位置</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>有些人可能会有疑问：这个软件的安装位置和安装目录名称是可以随意指定的吗？我们一般会将源码包安装到 <code>/usr/local/</code> 目录中，这个目录是 Linux 的默认源码包安装目录，并不推荐大家随意更改。至于安装目录名称，如果只是单独安装这个软件，则目录名称可以随意指定，不一定非要叫“libxml2”。但是我们在搭建 LAMP 环境时，这个软件会被后面的软件所调用，如果修改了安装目录名称，那么后面一系列的安装命令都要进行修改，非常容易报错，所以不建议大家随意修改。</p>
<ol start="4">
<li>编译</li>
</ol>
<p>也就是依靠 gcc 把源码包翻译为二进制的机器语言包。命令如下：</p>
<div><pre><code><span>[</span>root@localhost libxml2-2.9.1<span>]</span><span># make</span>
</code></pre>
<div><span>1</span><br></div></div><p>以上的编译前配置和编译都不会在 <code>/usr/local/</code> 目录中写入任何数据，只会在源码目录中生成 <code>Makefile</code> 等临时文件。所以，如果报错了，则只需执行 <code>make clean</code> 命令清除缓存和临时文件，再进行安装即可。</p>
<ol start="5">
<li>编译安装</li>
</ol>
<p>这一步才会真正向 <code>/usr/local/</code> 目录中写入数据。命令如下：</p>
<div><pre><code><span>[</span>root@localhost libxml2-2.9.1<span>]</span><span># make install</span>
</code></pre>
<div><span>1</span><br></div></div><p>这条命令执行之后，就会建立 <code>/usr/local/libxml2/</code> 目录，并在目录下生成相应的文件。</p>
<h4 id="_2-安装-libmcrypt-源码包"> 2.安装 libmcrypt 源码包</h4>
<p><strong>libmcrypt 是加密算法扩展库</strong>。支持 DES、3DES、RIJNDAEL、Twofish、IDEA、GOST、CAST-256、ARCFOUR、SERPENT、SAFER+ 等算法。安装步骤如下。</p>
<ol>
<li>进入解压缩目录</li>
</ol>
<div><pre><code><span>[</span>root@localhost libxml2-2.9.1<span>]</span><span># cd /usr/local/src/libmcrypt-2.5.8</span>
</code></pre>
<div><span>1</span><br></div></div><ol start="2">
<li>编译前配置，并指定安装位置</li>
</ol>
<div><pre><code><span>[</span>root@localhost libmcrypt-2.5.8<span>]</span><span># ./configure --prefix=/usr/local/libmcrypt</span>
</code></pre>
<div><span>1</span><br></div></div><ol start="3">
<li>编译</li>
</ol>
<div><pre><code><span>[</span>root@localhost libmcrypt-2.5.8<span>]</span><span># make</span>
</code></pre>
<div><span>1</span><br></div></div><ol start="4">
<li>编译安装</li>
</ol>
<div><pre><code><span>[</span>root@localhost libmcrypt-2.5.8<span>]</span><span># make install</span>
</code></pre>
<div><span>1</span><br></div></div><ol start="5">
<li>安装 libltdl 库</li>
</ol>
<p>在安装完 libmcrypt 之后，有些 Linux 还需要安装 libltdl 库，这个库是 libmcrypt 的子软件，就在 libmcrypt 的源码包之中，所以要进入 <code>/usr/local/libmcrypt</code> 目录才能看到。命令如下：</p>
<div><pre><code><span>[</span>root@localhost root<span>]</span><span># cd /usr/local/src/libmcrypt-2.5.8/libltdl</span>
<span>#进入软件源码目录</span>
<span>[</span>root@localhost libltdl<span>]</span><span># ./configure --enable-ltdl-install</span>
<span>#配置libltdl库的安装</span>
<span>[</span>root@localhost libltdl<span>]</span><span># make</span>
<span>#编译</span>
<span>[</span>root@localhost libltdl<span>]</span><span># make install</span>
<span>#编译安装</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>安装完成之后，记得确认安装目录是否生成。</p>
<h4 id="_3-安装-mhash-源码包"> 3.安装 mhash 源码包</h4>
<p><strong>mhash 是基于离散数学原理的不可逆向的 PHP 加密方式扩展库</strong>。mhash 可以用于创建校验数值，消息摘要，消息认证码，以及无须原文的关键信息保存（如密码）等。</p>
<p>安装步骤如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cd /usr/local/src/mhash-0.9.9.9</span>
<span>#进入解压缩目录</span>
<span>[</span>root@localhost mhash-0.9.9.9<span>]</span><span># ./configure</span>
<span>#没有指定安装位置。因为在mcrypt包安装时，会在默认位置查找mhash包，如果指定了安装位置，那么mcrypt包在安装时会报错</span>
<span>[</span>root@localhost mhash-0.9.9.9<span>]</span><span># make</span>
<span>#编译</span>
<span>[</span>root@localhost mhash-0.9.9.9<span>]</span><span># make install >> /root/mhash_install.log</span>
<span>#编译安装。把安装过程保存在mhash_install.log文件中，便于删除</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h4 id="_4-安装-mcrypt-源码包"> 4.安装 mcrypt 源码包</h4>
<p><strong>mcrypt 是 PHP  里面重要的加密支持扩展库</strong>。mcrypt 库支持 20 多种加密算法和 8 种加密模式。mcrypt 要比 libmcrypt  更加先进，在很多项目中必须使用 mcrypt 加密方式。<u>请大家注意，在安装 mcrypt 之前，必须先正确安装 libmcrypt 和 mhash。</u></p>
<p>安装步骤如下：</p>
<div><pre><code><span>[</span>root@localhost mhash-0.9.9.9<span>]</span><span># cd /usr/local/src/mcrypt-2.6.8</span>
<span>#进入源码目录</span>
<span>[</span>root@localhost mcrypt-2.6.8<span>]</span><span># LD_LIBRARY_PATH=/usr/local/libmcrypt/lib:/usr/local/lib ./configure --with-libmcrypt-prefix=/usr/local/libmcrypt</span>
<span>#LD_LIBRARY_PATH用于指定libmcrypt和mhash库的位置</span>
<span>#./configure为编译前准备命令，--with-libmcrypt-prefix用于指定libmcrypt软件位置</span>
<span>[</span>root@localhost mcrypt-2.6.8<span>]</span><span># make</span>
<span>#编译</span>
<span>[</span>root@localhost mcrypt-2.6.8<span>]</span><span># make install</span>
<span>#编译安装</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>请大家注意，在这里 mcrypt 并没有安装完成。因为 mcrypt 是 PHP 的模块，所以需要等到 PHP 安装完成之后，再继续安装。</p>
<p>PHP 模块安装成功后，才能按照以下步骤继续安装 mcrypt。</p>
<div><p>提示</p>
<p>这里要先暂停一下，等 <u><strong>14.安装 PHP 源码包</strong></u> 安装完成后再继续安装。</p>
</div>
<div><pre><code><span># 1)编译安装</span>

<span>[</span>root@localhost memcache-3.0.8<span>]</span><span># cd /lamp/php-5.4.25/ext/mcrypt/</span>
<span>#进入PDO模块的解压缩目录</span>
<span>[</span>root@localhost mcrypt<span>]</span><span># /usr/local/php/bin/phpize</span>
<span>#使用phpize加载PDO模块</span>
<span>[</span>root@localhost mcrypt<span>]</span><span># ./configure \ #编译前配置</span>
--with-php-config<span>=</span>/usr/local/php/bin/php-config <span>\</span>#指定php-config文件的位置
--with-mcrypt<span>=</span>/usr/local/libmcrypt/ <span>#调用libmcrypt</span>
<span>[</span>root@localhost mcrypt<span>]</span><span># make</span>
<span>#编译</span>
<span>[</span>root@localhost mcrypt<span>]</span><span># make install</span>
<span>#编译安装</span>

<span># 2) 修改PHP配置文件</span>

要让 PHP 可以识别和使用 memcache 和 mcrypt 模块，还需要修改一下 PHP 的配置文件，命令如下：

<span>[</span>root@localhost mcrypt<span>]</span><span># vi /usr/local/php/etc/php.ini</span>
<span>#修改PHP配置文件</span>
extension_dir <span>=</span> <span>"./"</span>
<span>#在这个文件中找到这句话，把它改为以下这句话</span>
<span>extension_dir</span><span>=</span><span>"/usr/local/php//lib/php/extensions/no-debug-non-zts-20060613/"</span>
<span>#新加入以下两句话</span>
<span>extension</span><span>=</span><span>"memcache.so"</span><span>;</span>
<span>extension</span><span>=</span><span>"mcrypt.so"</span><span>;</span>

安装完成之后，重启 apache，就可以在 phpinfo 页面中看到这两个模块了。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h4 id="_5-安装-zlib-源码包"> 5.安装 zlib 源码包</h4>
<p><strong>zlib 是提供数据压缩用的函数库</strong>。使用 DEFLATE 算法，最初是为 libpng 函数库所写的，后来普遍被许多软件所使用。此函数库为自由软件，使用 zlib 授权。</p>
<p>安装步骤如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cd /usr/local/src/zlib-1.2.3</span>
<span>#进入zlib解压缩目录</span>
<span>[</span>root@localhost zlib-1.2.3<span>]</span><span># ./configure</span>
<span>#编译前配置，没有指定安装位置，zlib会安装到系统的默认位置。</span>
<span>#这是为了让libpng可以在默认位置中找到zlib。如果指定了zlib的安装位置，那么libpng在安装时可能会报错</span>
<span>[</span>root@localhost zlib-1.2.3<span>]</span><span># make</span>
<span>#编译</span>
<span>[</span>root@localhost zlib-1.2.3<span>]</span><span># make install >> /root/zlib_install.log</span>
<span>#编译安装。把编译安装过程保存到zlib_install.log文件中，以方便删除</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h4 id="_6-安装-libpng-源码包"> 6.安装 libpng 源码包</h4>
<p><strong>libpng 软件中包含 libpng 函数库</strong>。这些库是用来解码 .png 格式的图片的。安装步骤如下：</p>
<div><pre><code><span>[</span>root@localhost zlib-1.2.3<span>]</span><span># cd /usr/local/src/libpng-1.2.31</span>
<span>#进入libpng解压缩目录</span>
<span>[</span>root@localhost libpng-1.2.31<span>]</span><span># ./configure --prefix=/usr/local/libpng</span>
<span>#编译前配置，指定安装位置</span>
<span>[</span>root@localhost libpng-1.2.31<span>]</span><span># make</span>
<span>#编译</span>
<span>[</span>root@localhost libpng-1.2.31<span>]</span><span># makeinstall</span>
<span>#编译安装</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h4 id="_7-安装-jpeg6-源码包"> 7.安装 jpeg6 源码包</h4>
<p><strong>jpeg6 软件是用来解码 .jpg 和 .jpeg 格式的图片的</strong>。安装步骤如下。</p>
<ol>
<li>手工建立必需的目录</li>
</ol>
<div><pre><code><span>[</span>root@localhost root<span>]</span><span># mkdir /usr/local/jpeg6</span>
<span>#建立jpeg6软件安装目录</span>
<span>[</span>root@localhost root<span>]</span><span># mkdir /usr/local/jpeg6/bin</span>
<span>#建立存放命令的目录</span>
<span>[</span>root@localhost root<span>]</span><span># mkdir /usr/local/jpeg6/lib</span>
<span>#创建jpeg6函数库文件所在目录</span>
<span>[</span>root@localhost root<span>]</span><span># mkdir /usr/local/jpeg6/include</span>
<span>#建立存放头文件的目录</span>
<span>[</span>root@localhost root<span>]</span><span># mkdir -p /usr/local/jpeg6/man/man1</span>
<span>#建立存放帮助手册的目录</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>请大家注意，这些目录必须手工建立，否则安装过程会报错</p>
<ol start="2">
<li>编译与安装</li>
</ol>
<div><pre><code><span>[</span>root@localhost libpng-1.2.31<span>]</span><span># cd /usr/local/src/jpeg-6b/</span>
<span>#进入jpeg6解压缩目录</span>
<span>[</span>root@localhost jpeg-6b<span>]</span><span># ./configure \</span>
--prefix<span>=</span>/usr/local/jpeg6/ <span>\</span>		<span>#指定安装位置</span>
--enable-shared <span>\</span>					<span>#建立共享库使用的GNU的libtool</span>
enable---static						<span>#建立静态库使用的GNU的libtool</span>
<span>#编译前配置。</span>
<span>#“\”代表一条命令没有写完，换行继续输入</span>
<span>[</span>root@localhost jpeg-6b<span>]</span><span># make</span>
<span>#编译</span>
<span>[</span>root@localhost jpeg-6b<span>]</span><span># make install</span>
<span>#编译安装</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h4 id="_8-安装-freetype-源码包"> 8.安装 FreeType 源码包</h4>
<p><strong>FreeType 库是一个完全免费（开源）的、高质量的、可移植的字体引擎</strong>。它提供统一的接口来访问多种字体格式文件，包括 TrueType、OpenType、Type1、CID、CFF、Windows FON/FNT、X11 PCF 等，支持单色位图、反走样位图的渲染。</p>
<p>FreeType 库是高度模块化的程序库，虽然它是使用 ANSI C 开发的，但是采用面向对象的思想，因此，FreeType 的用户可以灵活地对它进行裁剪。</p>
<p>FreeType 安装步骤如下：</p>
<div><pre><code><span>[</span>root@localhost jpeg-6b<span>]</span><span># cd /usr/local/src/freetype-2.3.5</span>
<span>#进入freetype解压缩目录</span>
<span>[</span>root@localhost freetype-2.3.5<span>]</span><span># ./configure --prefix=/usr/local/freetype</span>
<span>#编译前配置，指定安装位置</span>
<span>[</span>root@localhost freetype-2.3.5<span>]</span><span># make</span>
<span>#编译</span>
<span>[</span>root@localhost freetype-2.3.5<span>]</span><span># make install</span>
<span>#编译安装</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h4 id="_9-安装-gd-库源码包"> 9.安装 gd 库源码包</h4>
<p><strong>gd 库是 PHP 处理图形的扩展库</strong>。它提供了一系列用来处理图片的 API（应用程序编程接口），使用 gd 库可以处理图片或者生成图片。在网站上，gd 库通常用来生成缩略图，或者对图片加水印，或者生成汉字验证码，或者对网站数据生成报表等。</p>
<p>gd 库安装步骤如下。</p>
<ol>
<li>建立 gd 库安装目录，进入 gd 库解压缩目录</li>
</ol>
<div><pre><code><span>[</span>root@localhost autoconf-2.61<span>]</span><span># cd /usr/local/src/gd-2.0.35</span>
</code></pre>
<div><span>1</span><br></div></div><ol start="2">
<li>修改 gd_png.c 文件</li>
</ol>
<div><pre><code><span>[</span>root@localhost gd-2.0.35<span>]</span><span># vi gd_png.c</span>
<span>#把文件中 include "png.h" 改为 include "/usr/local/libpng/include/png.h"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果不修改 gd_png.c 文件，则默认会在当前目录下搜索 png.h 文件。我们已知 libpng 安装在 <code>/usr/local/libpng/</code> 目录中，所以当然不能找到，就会报错。把 png.h 的正确路径 <code>/usr/local/libpng/include/png.h</code> 写入，报错就能解决。</p>
<ol start="3">
<li>编译安装</li>
</ol>
<div><pre><code><span>[</span>root@localhost gd-2.0.35<span>]</span><span># ./configure \</span>
--prefix<span>=</span>/usr/local/gd2/ <span>\</span> 				<span>#指定安装位置</span>
--with-jpeg<span>=</span>/usr/local/jpeg6/ <span>\</span> 		<span>#指定jpeg6的位置</span>
--with-freetype<span>=</span>/usr/local/freetype/ <span>\</span>	<span>#指定freetype的位置</span>
--with-png<span>=</span>/usr/local/libpng/			<span>#指定libpng的位置</span>
<span>#编译前配置</span>
<span>#因为gd库需要调用前面安装的zlib、jpeg、freetype和libpng，所以需要指定它们的安装位置，才能正确调用这些软件。</span>
<span>#不过因为前面安装zlib时没有指定安装位置，所以不用指定--with-zlib=/usr/local/zlib/选项，gd会自动到默认安装位置中寻找zlib</span>
<span>#“\”代表一条命令没有写完，换行继续输入</span>
<span>[</span>root@localhost gd-2.0.35<span>]</span><span># make</span>
<span>#编译</span>
<span>[</span>root@localhost gd-2.0.35<span>]</span><span># make install</span>
<span>#编译安装</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h4 id="_10-安装-apache-源码包"> 10.安装 apache 源码包</h4>
<p>Apache 其实是一个软件基金会组织的名字，早期他们开发的 Web Server 软件非常流行，当时的名称就叫做 Apache，不过后来改名字叫做 httpd 了，所以，现在大家常说的 Apache ，通常指的就是 httpd。</p>
<p>另外，Apache 就是 LAMP 环境中的“A”。前面做了这么多准备工作，就是为了正确安装 Apache+MySQL+PHP，现在可以安装 Apache 了。安装步骤如下。</p>
<ol>
<li>复制 apr 和 apr-util 库</li>
</ol>
<p>这里是 Apache 2.4 自己的 Bug，我们必须手工复制 apr、apr-util 和 pcre 这三个库，才可以正确安装 Apache 2.4。</p>
<div><pre><code><span>cp</span> -r /usr/local/src/apr-1.4.6 /usr/local/src/httpd-2.4.7/srclib/apr
<span>cp</span> -r /usr/local/src/apr-util-1.4.1 /usr/local/src/httpd-2.4.7/srclib/apr-util
<span>#这两个包先要解压缩，然后改名复制到指定位置</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ol start="2">
<li>安装 pcre 源码包</li>
</ol>
<p>pcre 是一个用 C 语言编写的正则表达式函数库，Apache 和 PHP 默认使用的就是 pcre 正则表达式规则。</p>
<div><pre><code><span>[</span>root@localhost gd-2.0.35<span>]</span><span># cd /usr/local/src/pcre-8.34</span>
<span>#进入解压缩目录</span>
<span>[</span>root@localhost pcre-8.34<span>]</span><span># ./configure</span>
<span>#编译前配置</span>
<span>[</span>root@localhost pcre-8.34<span>]</span><span># make</span>
<span>#编译</span>
<span>[</span>root@localhost pcre-8.34<span>]</span><span># make install</span>
<span>#编译安装</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ol start="3">
<li>进入 Apache 解压缩目录</li>
</ol>
<div><pre><code><span>[</span>root@localhost pcre-8.34<span>]</span><span># cd /usr/local/src/httpd-2.4.7</span>
</code></pre>
<div><span>1</span><br></div></div><ol start="4">
<li>编译前配置</li>
</ol>
<div><pre><code><span>[</span>root@localhost httpd-2.4.7<span>]</span><span># ./configure \	#编译前配置</span>
--prefix<span>=</span>/usr/local/apache2/ <span>\</span>				<span>#指定Apache安装目录</span>
--sysconfdir<span>=</span>/usr/local/apache2/etc/ <span>\</span>		<span>#指定Apache配置文件保存目录</span>
--with-included-apr <span>\</span>						<span>#使用捆绑APR/APR-Util 的副本</span>
--enable-so <span>\</span>								<span>#以动态共享对象(DSO)方式编译</span>
--enable-deflate<span>=</span>shared <span>\</span>					<span>#启用编小传输编玛支持的模块</span>
--enable-expires<span>=</span>shared <span>\</span>					<span>#根据用户的特别设定来生成失效和隐藏控制的HTTP头信息</span>
--enable-rewrite-shared						<span>#启动重写功能的模块</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>这里的 Apache 是使用动态方式编译的，那么是否有静态方式编译呢？当然有，静态方式编译就是直接将 Apache 的模块放入 Apache 中，如果 Apache 需要调用这个模块，则直接调用即可。这种方法安装的 Apache 性能更好、速度更快，但是如果需要加载新的模块，则是需要重新编译和安装 Apache 的。</p>
<p>如果采用动态的方式编译，则并没有直接把模块放入 Apache，而是把模块的所在位置放入了 Apache。如果 Apache 需要调用模块，则需要到指定位置自己查找，性能比静态方式稍差。但是如果需要加载新的模块，则不用重新安装 Apache，可以动态地加载新模块。更常用的编译方式是动态方式编译，所以在安装过程中我们采用动态方式编译。</p>
<ol start="5">
<li>编译和编译安装</li>
</ol>
<div><pre><code><span>[</span>root@localhost httpd-2.4.7<span>]</span><span># make</span>
<span>[</span>root@localhost httpd-2.4.7<span>]</span><span># make install</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ol start="6">
<li>启动 Apache，并进行测试</li>
</ol>
<div><pre><code><span>[</span>root@localhost httpd-2.4.7<span>]</span><span># /usr/local/apache2/bin/apachectl start</span>
<span>#启动Apache</span>
<span>[</span>root@localhost httpd-2.4.7<span>]</span><span># netstat -tlun | grep 80</span>
tcp <span>0</span> <span>0</span>::80 ::* LISTEN
<span>#80端口已经启动，说明Apache已经启动了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>接下来我们需要使用浏览器测试一下 Apache 服务器是否可以访问，只需在 URL（统一资源定位，就是地址栏）中输入“http://IP”即可，如图7-5 所示。</p>
<div>
<p><img src="./assets/apachework.jpg" alt="apache" loading="lazy"></p>
<p><strong>图7-5	<u>Apache测试页</u></strong></p>
</div>
<p>如果看到了“It works！”，则说明 Apache 服务器正常工作了。</p>
<ol start="7">
<li>设置 Apache 开机自启动</li>
</ol>
<p>我们需要保证 Apache 每次开机都能正常启动，所以还要设置自启动，命令如下：</p>
<div><pre><code><span>[</span>root@localhost httpd-2.4.7<span>]</span><span># vi /etc/rc.local</span>
/usr/local/apache2/bin/apachectl start
<span>#在rc.local文件中加入Apache启动命令</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id="_11-安装-ncurses-源码包"> 11.安装 ncurses 源码包</h4>
<p><strong>ncurses 提供字符终端处理库</strong>，包括面板和菜单。它提供了一套控制光标、建立窗口、改变前景/背景颜色及处理鼠标操作的函数，使用户在字符终端编写应用程序时绕过了那些恼人的底层机制。简而言之，它是一个可以使应用程序直接控制终端屏幕显示的函数库。</p>
<p>这个软件既可以采用 RPM 包方式安装，也可以采用源码包方式安装。但是不用两种包都安装，只要安装一种即可。</p>
<ol>
<li>方法一：安装 RPM 的 ncurses 包</li>
</ol>
<p>这里既可以使用手工 RPM 包命令安装，也可以使用 yum 命令安装，我们使用 RPM 包命令安装。安装命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># rpm -ivh /mnt/cdrom/Packages/ncurses-5.7-3.20090208.el6.i686.rpm</span>
<span>[</span>root@localhost ~<span>]</span><span># rpm -ivh /mnt/cdrom/Packages/ncurses-devel-5.7-3.20090208.el6.i686.rpm</span>
<span>[</span>root@localhost ~<span>]</span><span># rpm -ivh /mnt/cdrom/Packages/ncurses-libs-5.7-3.20090208.el6.i686.rpm</span>
<span>[</span>root@localhost ~<span>]</span><span># rpm -ivh /mnt/cdrom/Packages/ncurses-base-5.7-3.20090208.el6.i686.rpm</span>
<span>[</span>root@localhost ~<span>]</span><span># rpm -ivh /mnt/cdrom/Packages/ncurses-term-5.7-3.20090208.el6.i686.rpm</span>
<span>[</span>root@localhost ~<span>]</span><span># rpm-ivh/mnt/cdrom/Packages/ncurses-static-5.7-3.20090208.el6.i686.rpm</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ol start="2">
<li>方法二：安装 ncurses 的源码包</li>
</ol>
<p>安装步骤如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cd /usr/locai/src/ncurses-5.9</span>
<span>#进入ncurses解压缩目录</span>
<span>[</span>root@localhost ncurses-5.9<span>]</span> <span># ./configure \	#编译前配置</span>
--with-shared <span>\</span>									<span>#生成共享库</span>
--without-debug <span>\</span>								<span>#不生成 debug 库</span>
--without-ada <span>\</span>									<span>#不编译为ada绑定，因为进入chroot环境不能便用ada</span>
--enable-overwrite								<span>#参数为定义把头文件安装到/tools/include目录下，而不是/tools/include/ncurses 目录下</span>
<span>[</span>root@localhost ncurses-5.9<span>]</span><span># make</span>
<span>#编译</span>
<span>[</span>root@localhost ncurses-5.9<span>)</span><span># make install</span>
<span>#编译安装</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h4 id="_12-安装-cmake-和-bison-源码包"> 12.安装 cmake 和 bison 源码包</h4>
<p>MySQL 在 5.5 版本以后，不再使用 <code>./configure</code> 工具进行编译安装，而使用 cmake 工具替代了 <code>./configure</code> 工具。</p>
<p>bison 是一个自由软件，用于自动生成语法分析器程序，可用于所有常见的操作系统。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># yum -y install cmake</span>
<span>[</span>root@localhost ~<span>]</span><span># yum -y install bison</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="_13-安装-mysql-源码包"> 13.安装 MySQL 源码包</h4>
<p>接下来，我们学习安装 MySQL 数据库，其安装步骤稍微复杂，我们逐步来进行解析。</p>
<ol>
<li>添加 mysql 用户和 mysql 用户组</li>
</ol>
<p>命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># groupadd mysql</span>
<span>#添加mysql用户组</span>
<span>[</span>root@localhost ～<span>]</span><span># useradd -g mysql mysql</span>
<span>#添加mysql用户，同时指定mysql用户的初始组是mysql组</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这里添加的 mysql 用户和用户组是稍后用来给 MySQL 安装目录分配权限用的，所以并不需要设定密码，因为这个用户是不能直接登录 Linux 系统的。</p>
<ol start="2">
<li>进入 MySQL 解压缩目录</li>
</ol>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cd /usr/local/src/mysql-5.5.23</span>
</code></pre>
<div><span>1</span><br></div></div><ol start="3">
<li>编译前配置</li>
</ol>
<div><pre><code><span>[</span>root@localhost mysql-5.5.23<span>]</span><span># cmake \		#命令</span>
-DCMAKE_INSTALL_PREFIX<span>=</span>/usr/local/mysql <span>\</span>	<span>#指定安装位置</span>
-DMYSQL_UNIX_ADDR<span>=</span>/tmp/mysql.sock <span>\</span>			<span>#指定[socket](http://c.biancheng.net/socket/)（套接字）文件位置</span>
-DEXTRA_CHARSETS<span>=</span>all <span>\</span>						<span>#支持所有的扩展字符集</span>
-DDEFAULT_CHARSET<span>=</span>utf8 <span>\</span>					<span>#指定默认字符集</span>
-DDEFAULT_COLLATION<span>=</span>utf8_general_ci <span>\</span>		<span>#指定默认字符校对</span>
-DWITH_MYISAM_STORAGE_ENGINE<span>=</span><span>1</span> <span>\</span>			<span>#安装myisam存储引擎</span>
-DWITH_INNOBASE_STORAGE_ENGINE<span>=</span><span>1</span> <span>\</span>			<span>#安装innodb存储引擎</span>
-DWITH_MEMORY_STORAGE_ENGINE<span>=</span><span>1</span> <span>\</span>			<span>#安装memory存储引擎</span>
-DWITH_READLINE<span>=</span><span>1</span> <span>\</span>							<span>#支持readline库</span>
-DENABLED_LOCAL_INFILE<span>=</span><span>1</span> <span>\</span>					<span>#启用加载本地数据</span>
-DMYSQL_USER<span>=</span>mysql <span>\</span>						<span>#指定MySQL运行用户</span>
-DMYSQL_TCP_PORT<span>=</span><span>3306</span>						<span>#指定MySQL端口</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><ol start="4">
<li>编译</li>
</ol>
<div><pre><code><span>[</span>root@localhost mysql-5.5.23<span>]</span><span># make</span>
</code></pre>
<div><span>1</span><br></div></div><p>使用 cmake 进行编译。如果编译过程中出现了报错，则不再使用 <code>make clean</code> 命令清除缓存及临时文件，而是直接删除 <code>rm-rf CMakeCache.txt</code> 文件。</p>
<ol start="5">
<li>编译安装</li>
</ol>
<div><pre><code><span>[</span>root@localhost mysql-5.5.23<span>]</span><span># make install</span>
</code></pre>
<div><span>1</span><br></div></div><ol start="6">
<li>生成 MySQL 的配置文件，并修改配置文件</li>
</ol>
<p>这个配置文件不用手工建立，在 MySQL 安装目录中给我们准备了模板文件，只需把模板文件复制到指定位置并改名即可。命令如下：</p>
<div><pre><code><span>[</span>root@localhost mysql-5.5.23<span>]</span><span># cp/usr/local/mysql/share/mysql/my-medium.cnf /etc/my.cnf</span>
</code></pre>
<div><span>1</span><br></div></div><ol start="7">
<li>修改 MySQL 安装目录的权限</li>
</ol>
<div><pre><code><span>[</span>root@localhost mysql-5.5.23<span>]</span><span># cd /usr/local/mysql/</span>
<span>#进入MySQL安装目录</span>
<span>[</span>root@localhost mysql<span>]</span><span># chown -R mysql .</span>
<span>#把当前目录下所有文件的所有者改为root用户</span>
<span>[</span>root@localhost mysql<span>]</span><span># chgrp -R mysql .</span>
<span>#把当前目录下所有文件的所属组改为mysql组</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ol start="8">
<li>初始化数据库</li>
</ol>
<p>源码包安装的 MySQL 中所有的数据库默认都保存在 <code>/usr/local/mysql/data/</code> 目录中，MySQL 的初始数据库 mysql 库和 test 库也会保存在这个目录中。</p>
<p>但是，如果我们仔细查看 <code>/usr/local/mysql/data/</code> 目录，就会发现这个目录中只有两个空目录，并没有任何数据。也就是说，MySQL 中的所有数据库是不存在的，那么这个 MySQL 是不能使用的，因为 MySQL 的所有用户是要保存在 user 表中的，而 user 表保存在 mysql 库中，而 mysql 库是保存在  <code>/usr/local/mysql/data/</code> 目录中的。</p>
<p>那么，我们现在需要在 data 目录中建立 MySQL 的初始数据库。命令如下：</p>
<div><pre><code><span>[</span>root@localhost mysql<span>]</span><span># /usr/local/mysql/bin/mysql_install_db --user=mysql</span>
<span>#初始化数据库</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这条命令的 --user 选项表示使用 mysql 用户来初始化数据库，这个用户要和我们在步骤一中建立的用户一致。命令执行完成之后，<code>/usr/local/mysal/data/</code> 目录中应该会出现很多相应的数据，证明数据库初始化成功。</p>
<ol start="9">
<li>继续修改 MySQL 安装目录的权限</li>
</ol>
<div><pre><code><span>[</span>root@localhost mysql<span>]</span><span># chown -R root .</span>
<span>#把当前目录下所有文件的所有者改为root用户</span>
<span>#注意：修改的目录依然是/usr/local/mysql/目录下的文件</span>
<span>[</span>root@localhost mysql<span>]</span><span># chown -R mysql data</span>
<span>#把data目录的所有者改为mysql用户</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ol start="10">
<li>启动 MySQL 服务器，并保证 mysql 服务开机自启动</li>
</ol>
<p>MySQL 服务器的安装已经完成，我们可以尝试启动 MySQL 服务器，命令如下：</p>
<div><pre><code><span>[</span>root@localhost mysql<span>]</span><span># /usr/local/mysql/bin/mysqld_safe --user=mysql &amp;</span>
<span>#使用mysql用户启动MySQL服务器，并在后台持续运行</span>
<span>[</span>root@localhost mysql<span>]</span><span># netstat -tlun | grep 3306</span>
tcp <span>0</span> <span>0</span> <span>0.0</span>.0.0：3306 <span>0.0</span>.0.0：* LISTEN
<span>#3306端口已经开启了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>当然，我们还要保证 mysql 服务开机自启动，命令如下：</p>
<div><pre><code><span>[</span>root@localhost mysql<span>]</span><span># vi /etc/rc.local</span>
<span>#修改自启动配置文件，加入如下的mysql服务标准启动命令</span>
/usr/local/mysql/bin/mysqld_safe --user<span>=</span>mysql <span>&amp;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ol start="11">
<li>设定 MySQL 中 root 用户的密码，并登录</li>
</ol>
<p>MySQL 的管理员也是 root，不过这只是数据库的管理员，不要和 Linux 的 root 用户混淆了。我们需要给 MySQL 的本地用户设定一个密码。设定密码的方式有很多种，我们使用 Linux 的命令 <code>mysqladmin</code> 设定 MySQL 的 root 用户的密码。命令如下：</p>
<div><pre><code><span>[</span>root@localhost mysql<span>]</span><span># /usr/local/mysql/bin/mysqladmin -u root password 123</span>
<span>#给MySQL的root用户设定密码为123</span>
<span>[</span>root@localhost mysql<span>]</span><span># /usr/local/mysql/bin/mysql -u root -p</span>
<span>#使用root用户登录mysql</span>
Enter password：				<span>#输入正确的密码</span>
Welcome to the MySQL monitor． Commands end with <span>;</span> or <span>\</span>g.
Your MySQL connection <span>id</span> is <span>2</span>
Server version：5.1.59-community-log Source distribution
Copyright <span>(</span>c<span>)</span> <span>2000</span>， <span>2011</span>， Oracle and/or its affiliates．All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates．Other names may be trademarks of their respective owners.
Type <span>'help;'</span> or <span>'\h'</span> <span>for</span> help．Type <span>'\c'</span> to <span>clear</span> the current input statement.

mysql<span>></span>
<span>#看到了MySQL的交互界面</span>
mysql<span>></span> <span>\</span>s					<span>#查询服务器状态信息</span>
<span>..</span>.省略部分输出<span>..</span>.
Server	characterset： utf8
Db		characterset： utf8
Client	characterset： utf8
Conn．	characterset： utf8
<span>#编码格式已经修改为UTF-8</span>
<span>..</span>.省略部分输出<span>..</span>.
mysql<span>></span> <span>exit</span>
<span>#退出MySQL</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h4 id="_14-安装-php-源码包"> 14.安装 PHP 源码包</h4>
<p>关于 PHP 的版本，目前大多数企业都会使用 5.4 及更高版本，甚至越来越多的企业使用 PHP 7 版本，要知道，这两个版本还是有很大差异的，PHP 7 有很大的性能提升。</p>
<p>虽然“新事物取代旧事物”是必然趋势，但就目前来说，PHP 7 版本还是太新了，很多企业的网站不一定兼容。因此，这里安装的 PHP 版本为 5.4。接下来，就一起来学习如何在 Linux 系统中安装 PHP 源码包，具体步骤如下。</p>
<ol>
<li>安装 libtool 和 libtool-ltdl</li>
</ol>
<div><pre><code><span>[</span>root@localhost mysql<span>]</span><span># yum -y install "libtool*"</span>
<span>[</span>root@localhost mysql<span>]</span><span># yum -y install "libtool-ltdl*"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ol start="2">
<li>手工修改 gd 库文件</li>
</ol>
<p>PHP 5.4 也有一些 Bug，在检测 gd 库时会报错，需要我们手工修改。命令如下：</p>
<div><pre><code><span>[</span>root@localhost mysql<span>]</span><span># vi /usr/local/gd2/include/gd_io.h</span>
<span>#修改gd_io.h头文件</span>
typedef struct gdIOCtx
<span>{</span>
	<span>..</span>.
	void <span>(</span>*data<span>)</span><span>;</span>
	<span>#在此程序段中加入此句</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ol start="3">
<li>编译安装 PHP 源码包</li>
</ol>
<p>命令如下：</p>
<div><pre><code><span>[</span>root@localhost mysql<span>]</span><span># cd /usr/local/src/ php-5.4.25</span>
<span>[</span>root@localhost php-5.4.25<span>]</span><span># ./configure \			#编译前配置</span>
--prefix<span>=</span>/usr/local/php/ <span>\</span>							<span>#指定安装位置</span>
--with-config-file-path<span>=</span>/usr/local/php/etc/ <span>\</span>		<span>#指定PHP配置文件位置</span>
--with-apxs2<span>=</span>/usr/local/apache2/bin/apxs <span>\</span>			<span>#调用apache2</span>
--with-mysql<span>=</span>/usr/local/mysql/ <span>\</span>					<span>#调用mysql</span>
--with-libxml-dir<span>=</span>/usr/local/libxml2/ <span>\</span>				<span>#调用libxml2库</span>
--with-jpeg-dir<span>=</span>/usr/local/jpeg6/ <span>\</span>					<span>#调用jpeg库</span>
--with-png-dir<span>=</span>/usr/local/libpng/ <span>\</span>					<span>#调用libpng库</span>
--with-freetype-dir<span>=</span>/usr/local/freetype/ <span>\</span>			<span>#调用freetype库</span>
--with-gd<span>=</span>/usr/local/gd2/ <span>\</span>							<span>#调用gd库</span>
--with-mcrypt<span>=</span>/usr/local/libmcrypt/ <span>\</span>				<span>#调用libmcrypt库</span>
--with-mysqli<span>=</span>/usr/local/mysql/bin/mysql_config <span>\</span>	<span>#增加MysqlLi功能</span>
--enable-soap <span>\</span>										<span>#支持SOAP和Web Services</span>
--enable-mbstring<span>=</span>all <span>\</span>								<span>#支持多字节字符串</span>
--enable-sockets									<span>#支持socket（套接字）通信</span>
--with-pdo-mysql<span>=</span>/usr/local/mysql					<span>#启用mysql的pdo模块支持</span>
<span>[</span>root@localhost php-5.4.25<span>]</span><span># make</span>
<span>#编译</span>
<span>[</span>root@localhost php-5.4.25<span>]</span><span># make install</span>
<span>#编译安装</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><ol start="4">
<li>建立PHP配置文件</li>
</ol>
<p>和 MySQL 一样，这个配置文件不用手工建立，也是有模板文件的，我们只需复制即可。命令如下：</p>
<div><pre><code><span>[</span>root@localhost php-5.4.25<span>]</span><span># cp /usr/local/src/ php-5.4.25/php.ini-production</span>
/usr/local/php/etc/php.ini
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ol start="5">
<li>让 apache 可以识别“.php”扩展名</li>
</ol>
<p>在安装 PHP 时，在 <code>./configure</code> 命令中使用 --with-apxs2=/usr/local/apache2/bin/apxs 选项，已经把 PHP 作为模块被 apache 识别了。不过，apache 并不知道哪些扩展名的文件要调用 PHP 模块来解析（如果是 apache 不认识的扩展名，那么客户端在访问时，apache 不会尝试解析，而是提示客户端下载），所以我们需要修改 apache 的配置文件，让 apache 可以认识 PHP 脚本的扩展名。</p>
<p>比如，我们想让 apache 在遇到“.php”和“.phps”扩展名时，调用 PHP 模块来解析这些文件的内容，那么我们只需要执行如下命令：</p>
<div><pre><code><span>[</span>root@localhost php-5.4.25<span>]</span><span># vi /usr/local/apache2/etc/httpd.conf</span>
<span>#修改apache配置文件，加入如下内容</span>
AddType application/x-httpd-php.php.phps
<span>#这句话的意思是：如果遇到.php和.phps扩展名，则调用PHP模块来解析这个文件的内容</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这句话加载在 apache 配置文件中的任何位置都是可以的，不过系统中有类似的语句 AddType application/x-gzip.gz.tgz，那么我们一般将其加载到这句话后面。命令如下：</p>
<div><pre><code><span>[</span>root@localhost php-5.4.25<span>]</span><span># vi /usr/local/apache2/etc/httpd.conf</span>
<span>..</span>.省略部分输出<span>..</span>.
<span># If the AddEncoding directives above are commented-out， then you probably should define those extensions to indicate media types：</span>
<span>#</span>
	AddType application/x-compress .Z
	AddType application/x-gzip .gz .tgz
	AddType application/x-httpd-php .php .phps
    <span>#加载到此位置</span>
<span>..</span>.省略部分输出<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>至于 PHP 文件的扩展名，可以自由定义。</p>
<ol start="6">
<li>重启Apache服务器</li>
</ol>
<p>我们修改了 apache 的配置文件，如果想让这个修改生效，那么必须重启 Apache 服务器。重启命令如下：</p>
<div><pre><code><span>[</span>root@localhost php-5.4.25<span>]</span><span># /usr/local/apache2/bin/apachectl stop</span>
<span>[</span>root@localhost php-5.4.25<span>]</span><span># /usr/local/apache2/bin/apachectl start</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这里最好不要使用 restart 参数，因为对于源码包的 apache 启动命令，restart 参数有时会不起作用。</p>
<ol start="7">
<li>测试 PHP 环境是否正常</li>
</ol>
<p>对源码包安装的 apache 来讲，网页的默认保存位置是 <code>/usr/local/apache2/htdocs/</code> 目录。为了测试 PHP 环境是否正常，我们需要在这个目录中建立一个 PHP 文件，看看这个文件是否可以正常显示。命令如下：</p>
<div><pre><code><span>[</span>root@localhost php-5.4.25<span>]</span><span># vi /usr/local/apache2/htdocs/index.php</span>
<span>&lt;</span>?php
	phpinfo<span>(</span><span>)</span><span>;</span>
?<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这里我们使用了 phpinfo() 函数，这个函数的主要作用是显示 PHP 的相关信息，这些信息包括 PHP 的编译信息、PHP 的版本、服务器信息和环境、PHP 的环境、操作系统信息、路径、主要的配置选项、HTTP 头信息和 PHP 的许可等。我们一般使用这个函数来测试 PHP 是否安装成功，接下来在浏览器中输入“http://服务器IP/index.php”来执行该文件，如图7-6 所示。</p>
<div>
<p><img src="./assets/php.jpg" alt="php" loading="lazy"></p>
<p><strong>图7-6	<u>phpinfo测试页</u></strong></p>
</div>
<p>如果能看到图6，那么恭喜你，PHP 安装成功。</p>
<div><p>提示</p>
<p>PHP 安装完成了，但是别忘了上面 <u><strong>4.安装 mcrypt 源码包</strong></u> 部分还没有结束，回去继续安装后半部分。</p>
</div>
<h4 id="_15-安装-memcache-模块"> 15.安装 memcache 模块</h4>
<p>memcache 是一个高性能的分布式的内存对象缓存系统，通过在内存中维护一张统一的、巨大的 Hash 表，它能够用来存储各种格式的数据，包括图像、视频、文件及数据库检索的结果等。简单地说就是将数据调用到内存中，然后从内存中读取，从而大大提高读取速度。</p>
<p>大家需要注意，memcache 有两个软件：</p>
<ul>
<li>
<p>memcache-3.0.8 是 memcache 模块，也就是客户端；</p>
</li>
<li>
<p>memcached-1.4.17 是 memcache 服务器端。</p>
</li>
</ul>
<ol>
<li>memcache客户端安装</li>
</ol>
<div><pre><code><span>[</span>root@localhost src<span>]</span><span># yum -y install zlib-devel</span>
<span>#安装底层依赖包zlib-devel</span>
<span>[</span>root@localhost src<span>]</span><span># cd /usr/local/src/memcache-3.0.8</span>
<span>#进入memcache-3.0.8解压缩目录</span>
<span>[</span>root@localhost memcache-3.0.8<span>]</span><span># /usr/local/php/bin/phpize</span>
<span>#用phpize加载memcache模块。这条命令一定要进入memcache目录才能正确执行</span>
<span>[</span>root@localhost memcache-3.0.8<span>]</span><span># ./configure --with-php-config=/usr/local/php/bin/php-config</span>
<span>#编译前配置。指定php-config文件的位置</span>
<span>[</span>root@localhost memcache-3.0.8<span>]</span><span># make</span>
<span>#编译</span>
<span>[</span>root@localhost memcache-3.0.8<span>]</span><span># make install</span>
<span>#编译安装</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><ol start="2">
<li>memcache服务器端安装</li>
</ol>
<p>接下来该安装 memcached-1.4.17 这个服务器端程序了，命令如下：</p>
<div><pre><code><span>[</span>root@localhost memcached-1.4.17<span>]</span><span># yum -y install libevent-devel</span>
<span>#安装memcache，需要先安装libevent-devel包，yum安装它</span>
<span>#注意libevent-devel包在CentOS 6.x的第二张光盘中</span>
<span>[</span>root@localhost memcached-1.4.17<span>]</span><span># ./configure --prefix=/usr/local/memcache</span>
<span>#编译前配置</span>
<span>[</span>root@localhost memcached-1.4.17<span>]</span><span># make</span>
<span>#编译</span>
<span>[</span>root@localhost memcached-1.4.17<span>]</span><span># make install</span>
<span>#编译安装</span>
<span>[</span>root@localhost memcached-1.4.17<span>]</span><span># useradd memcache</span>
<span>#添加memcache用户，这个用户只是用来启动服务的，不用设置密码</span>
<span>[</span>root@localhost memcached-1.4.17<span>]</span><span># /usr/local/memcache/bin/memcached-u memcache &amp;</span>
<span>#在后台启动memcache服务器</span>
<span>[</span>root@localhost memcached-1.4.17<span>]</span><span># netstat -tlun | grep 11211</span>
tcp <span>0</span> <span>0</span> <span>0.0</span>.0.0:11211 <span>0.0</span>.0.0:* LISTEN
tcp <span>0</span> <span>0</span>::11211 ::* LISTEN
udp <span>0</span> <span>0</span> <span>0.0</span>.0.0:11211 <span>0.0</span>.0.0：*
udp <span>0</span> <span>0</span>::11211 ::*
<span>#memcache的端口是11211，已经启动了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>还要保证 memcache 开机自启动，命令如下：</p>
<div><pre><code><span>[</span>root@localhost memcached-1.4.17<span>]</span><span># vi /etc/rc.local</span>
<span>#修改自启动文件</span>
<span>touch</span> /var/lock/subsys/local
/usr/local/apache2/bin/apachectl start
/usr/local/mysql/bin/mysqld_safe --user<span>=</span>mysql <span>&amp;</span>
/usr/local/memcache/bin/memcached -u memcache <span>&amp;</span>
<span>#加入memcache启动命令</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>最终，LAMP 环境需要自启动的服务是 apache、mysql 和 memcache。</p>
<h4 id="_16-安装-phpmyadmin"> 16.安装 phpMyAdmin</h4>
<p>安装 phpMyAdmin，它是用 PHP 脚本写的 MySQL 数据库的管理软件，是使用 Web 图形模式直接管理 MySQL 数据库的工具。phpMyAdmin 可以用来创建、修改、删除数据库和数据表；可以用来创建、修改、删除数据记录；可以用来导入和导出整个数据库；还可以完成许多其他的 MySQL 系统管理任务。</p>
<p>对于不熟悉使用命令来进行数据库管理的管理者来说，phpMyAdmin 更加简单和方便。其实大家可以把 phpMyAdmin 当作使用 PHP 脚本写的一个项目，我们安装 phpMyAdmin 的方法可以套用到绝大多数 PHP 开源项目的安装上（其他 PHP 的开源项目在安装到 LAMP 环境中时，可能需要手工建立后台数据库结构和数据库表结构）。安装步骤如下。</p>
<ol>
<li>复制 phpMyAdmin 脚本文件</li>
</ol>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cp -r /usr/local/src/phpMyAdmin-4.1.4-all-languages /usr/local/apache2/htdocs/phpmyadmin</span>
<span>#改名复制phpMyAdmin到apache的默认网页目录中</span>
<span>[</span>root@localhost ~<span>]</span><span># cd /usr/local/apache2/htdocs/phpmyadmin/</span>
<span>#进入phpmyadmin目录</span>
<span>[</span>root@localhost phpmyadmin<span>]</span><span># cp config.sample.inc.php config.inc.php</span>
<span>#复制配置模板文件为真正的配置文件</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>phpMyAdmin 和前面章节中介绍安装的源码包都不太一样，不再是使用 C 语言编写的源码包程序，而是一个使用 PHP  脚本编写的、通过浏览器解释执行的网站项目。所以在安装时，只需把 phpMyAdmin 复制到 apache 的默认网页目录中，并通过浏览器来解释执行这个脚本即可。</p>
<ol start="2">
<li>修改 phpMyAdmin 的验证方式</li>
</ol>
<p>phpMyAdmin 默认识别 3 种验证方式：</p>
<ul>
<li>
<p><u>HTTP 身份验证</u>：调用apache的加密目录模块，在用户登录时，弹出登录窗口，需要输入正确的用户名和密码才能正常登录；</p>
</li>
<li>
<p><u>cookie 身份验证</u>：是HTTP身份验证模式的补充，不能使用 HTTP 身份验证模式的场合都可以使用它，它要求用户必须允许来自 phpMyAdmin 的 cookie 进入自己的计算机，即用户需要在浏览器中开启客户端的 cookie 功能；</p>
</li>
<li>
<p><u>config 身份验证</u>：客户端在登录时不再需要输入用户名和密码，就可以直接登录，因为用户名和密码是用明文方式写入 config.inc.php 配置文件的，所以这种验证方式并不安全，不推荐使用；</p>
</li>
</ul>
<p>1）HTTP身份验证配置</p>
<p>要想使用 HTTP 身份验证，只需要修改 PHP 的配置文件 config.inc.php，把验证方式改为“http”即可。命令如下：</p>
<div><pre><code><span>[</span>root@localhost phpmyadmin<span>]</span><span># vi config.inc.php</span>
把   <span>$cfg</span><span>[</span><span>'Servers'</span><span>]</span><span>[</span><span>$i</span><span>]</span><span>[</span><span>'auth_type'</span><span>]</span> <span>=</span> <span>'cookie'</span><span>;</span>
改为 <span>$cfg</span><span>[</span><span>'Servers'</span><span>]</span><span>[</span><span>$i</span><span>]</span><span>[</span><span>'auth_type'</span><span>]</span> <span>=</span> <span>'http'</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>保存退出后，就可以在浏览器中输入“http://192.168.0.210/phpmyadmin/index.php”进行访问了，如图7-7 所示。</p>
<div>
<p><img src="./assets/http.jpg" alt="http" loading="lazy"></p>
<p><strong>图7-7	<u>phpMyAdmin 的 HTTP 身份验证</u></strong></p>
</div>
<p>在登录对话框中输入 MySQL 的管理员“root”和我们刚刚安装 MySQL 时设定的密码“123”就能登录 phpMyAdmin了。</p>
<p>2）cookie身份验证</p>
<p>如果想让 phpMyAdmin 使用 cookie 身份验证模式，除必须修改 config.inc.php 文件里的 auth_type  语句外，还必须向 blowfish_secret 参数提供一个字符串。这个字符串可以是任意的，目的是在把登录时使用的用户名和密码存储在客户端的  cookie 中之前，系统将使用这个字符串对它们进行加密。</p>
<p>在 config.inc.php 中修改的内容如下：</p>
<div><pre><code><span>[</span>root@localhost phpmyadmin<span>]</span><span># vi config.inc.php</span>
<span>$cfg</span><span>[</span><span>'blowfish_secret'</span><span>]</span> <span>=</span> <span>'c.baincheng.net'</span><span>;</span> /* YOU MUST FILL IN THIS FOR COOKIE AUTH！*/
<span>#这里可以写任意字符串</span>
<span>#在PHP中，/* */代表注释一段话</span>
<span>$cfg</span><span>[</span><span>'Servers'</span><span>]</span><span>[</span><span>$i</span><span>]</span><span>[</span><span>'auth_type'</span><span>]</span> <span>=</span> <span>'cookie'</span><span>;</span>
<span>#把验证方式改为cookie</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>保存退出后，就可以使用浏览器访问了，访问方式和 HTTP 身份验证是一样的，如图7-8 所示。同样，在登录对话框中输入 MySQL 的用户名和密码即可登录。</p>
<div>
<p><img src="http://c.biancheng.net/uploads/allimg/181029/2-1Q0291453163I.jpg" alt="img" loading="lazy"></p>
<p><strong>图7-8	<u>phpMyAdmin的cookie身份验证</u></strong></p>
</div>
<p>至此，LAMP 环境搭建完成。这个实验正确完成的关键点在于细心，不要漏敲命令，不要敲错命令。而且源码包的编译时间也较长，比如 mysql 的编译安装时间大概需要 30 分钟，所以还要有足够的耐心。这个实验也是我们目前碰到的较为复杂的实验，所以在完成实验之后，会有巨大的满足感和成就感。当然。在出现报错时也不要沮丧，认真检查自己的安装过程，仔细排除错误，实验是一定可以成功的（多利用 <code>history</code> 命令）。</p>
<h2 id="lnmp-环境搭建"> LNMP 环境搭建</h2>
<p>目前 Nginx 服务器较为流行，很多公司都采用了效率更高、配置更加简单、支持的并发连接数量更多的 Nginx 服务器作为网页服务器。虽然目前 Apache 服务器还是主流网页服务器，但是 Nginx 服务器的优势已经逐渐显现出来。那么，和 Apache 服务器相比，Nginx 服务器到底有哪些优势呢？</p>
<ol>
<li>支持更多的并发连接数量</li>
</ol>
<p>官方测试的 Nginx 可以支持多达 5 万个并发连接数量，在实际的生产环境中可以轻松地支持 2 万~-4 万个并发连接数量，这远远多于 Apache 支持的并发连接数量。而且 Nginx 虽然支持的并发连接数量更多，但是占用的系统资源要比 Apache 小得多。</p>
<ol start="2">
<li>内存资源消耗更少</li>
</ol>
<p>经过实际测试，Nginx 服务器在支持 3 万个左右并发连接的情况下，服务器的总体内存消耗不超过 2GB，而且还可以通过减少 php-cgi 进程数量，进一步缩减 Nginx 占用的内存数量（当然会影响一部分性能）。</p>
<ol start="3">
<li>Nginx 可以方便地实现反向代理</li>
</ol>
<p>Nginx 服务器自带反向代理功能，可以非常方便和简单地实现反向代理配置，这样可以节省购买昂贵的硬件负载均衡交互机的费用，非常经济（当然性能不如硬件负载均衡交换机)。</p>
<ol start="4">
<li>Nginx 配置简单</li>
</ol>
<p>Nginx 的配置较为简单，配置文件要远小于 Apache 配置文件，而且语法简单，易于学习和掌握。</p>
<ol start="5">
<li>其他优势</li>
</ol>
<p>Nginx 服务器还支持 Rewrite 功能，更加节省带宽，稳定性更高。</p>
<h3 id="安装前的准备-2"> 安装前的准备</h3>
<p>如果我们手工安装 LNMP 环境，那么同样需要安装大概 14 个源码包（根据版本和功能不同而不同）。不过，现在网上非常流行的 LNMP 环境的搭建过程是采用 LNMP 一键安装包直接安装。这个一键安装包实际上就是一个事先写好的安装脚本，按照这个安装脚本，只要指定一些基本的选项，就可以完全自动安装，所以安装过程会大大简化。</p>
<p>下面，我们就使用一键安装包来搭建 LNMP 环境。不过在安装之前还是要做一些准备工作的。</p>
<h4 id="是否可以和lamp环境共存"> 是否可以和LAMP环境共存</h4>
<p>在 Linux 中其实是可以搭建 LNMPA 环境的，也就是在 Linux 中安装 Nginx、MySQL、PHP 和 Apache 这样的网站服务器架构，这是结合了 LAMP 环境和 LNMP 环境各自的优点而产生的新的网站服务器架构。</p>
<p>不过，我们今天只是搭建 LNMP 架构，建议不要在 LAMP 环境中覆盖安装 LNMP 环境，而应该使用一个完全干净的环境重新搭建 LNMP 环境，避免出现不必要的麻烦。我的服务器因为使用的是虚拟机，所以我直接恢复了初始安装的快照，一切从头来过。</p>
<h4 id="下载-lnmp-一键安装包"> 下载 LNMP 一键安装包</h4>
<p>既然是一键安装包，所以我们就不用去下载单个的源码包了，只要下载 LNMP 一键安装包即可。</p>
<p>http://soft.vpser.net/lnmp/lnmp1.0-full.tar.gz</p>
<h4 id="其他准备工作"> 其他准备工作</h4>
<p>我们还需要做以下一些准备工作：</p>
<ul>
<li>保证 yum 源可以使用。</li>
<li>上传 LNMP 一键安装包到 Linux 服务器。</li>
<li>安装 gcc 编译工具。如果没有安装 gcc 编译工具，那么 LNMP 一键安装包会尝试自动 yum 安装，但是要保证 yum 源是可用的。</li>
<li>停用 RPM 包安装的 apache 和 MySQL。</li>
<li>禁用防火墙和 SELinux。</li>
<li>关闭 Linux 中不必要的服务。</li>
</ul>
<p>这些准备工作基本和 LAMP 环境一致，在此不再一一列举。</p>
<h3 id="安装过程-2"> 安装过程</h3>
<p>利用下载好的 LNMP 一键安装包在 Linux 系统上安装 LNMP 环境。</p>
<h4 id="_1-解压缩一键安装包"> 1.解压缩一键安装包</h4>
<p>我们把 LNMP 一键安装包保存在 <code>/usr/local/src/</code> 目录下，第一步仍然是解压缩一键安装包。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cd /usr/local/src/</span>
<span>[</span>root@localhost src<span>]</span><span># tar -zxvf lnmp1.0-full.tar.gz</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="_2-执行安装脚本安装-lnmp-一键安装包"> 2.执行安装脚本安装 LNMP 一键安装包</h4>
<p>既然是脚本安装包，那就不需要我们一个一个手工安装了，只要执行安装脚本 centos.sh 即可自动安装（Debian 中执行脚本为 debian.sh，Ubuntu 中执行脚本为 ubuntu.sh）。命令如下：</p>
<div><pre><code><span>[</span>root@localhost src<span>]</span><span># cd lnmp1.0-full</span>
<span>[</span>root@localhost lnmp1.0-full<span>]</span><span># ./centos.sh</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>回车之后安装就会继续，会看到如下界面：</p>
<div><pre><code><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span>
LUMP V1.0 <span>for</span> CentOS/RadHat Linux VPS Written by Licess
<span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span>
A tool to auto-compile <span>&amp;</span> <span>install</span> Nginx+MySQL+PHP on Linux
For <span>more</span> information please visit http://www.lnmp.org/
<span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span>
Please input the root password of mysql:
<span>(</span>Default password: root<span>)</span> <span>:</span> <span>123</span> 							<span>&lt;</span>---设定MySQL 的密码，这里设为 <span>123</span>
<span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span>
Do you want to <span>install</span> the InnoDB Storage Engine?
<span>(</span>Default no,if you want please input: y , <span>if</span> not please press the enter button<span>)</span>:y
														<span>&lt;</span>---是否需要安装MySQL InnoDB，如果需要安装则输入y

Install PHP <span>5.3</span>.17,Please input y
Install PHP <span>5.2</span>.17,Please input n or press Enter
<span>(</span>Please input y or n<span>)</span> :y								<span>&lt;</span>---选择安装PHP的版本,输入y安装的是5.3.17
Install MySQL <span>5.5</span>.27,Please input y
Install MySQL <span>5.1</span>.60,Please input n or press Enter
<span>(</span>Please input y or n<span>)</span> :y								<span>&lt;</span>---选择安装MySQL的版本，输入y安装的是5.5.27

Press any key to start. <span>.</span> .or Press Ctrl+c to cancel	<span>&lt;</span>---按任意鍵开始安装
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>如果在安装过程中输入错误，则可以按 <kbd>Ctrl</kbd>+<kbd>Backspace</kbd> 组合键来进行删除。这个安装过程完全是依赖 centos.sh 脚本自动执行的，所以比 LAMP 的手工安装过程简单得多，我们只要指定一些基本的选项，就可以完成安装了。</p>
<p>具体的安装时间要视 Linux 服务器的性能而定，可能会等待几十分钟。如果大家有兴趣，则可以查看一下 centos.sh 这个安装脚本，看看它是如何实现自动安装的。如果看到以下界面，则证明安装成功。</p>
<div><pre><code><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>=</span>
Manager <span>for</span> LNMP VI.0 , Written by Licess
<span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>=</span>
LNMP is a tool to auto-compile <span>&amp;</span> <span>install</span> Nginx+MySQL+PHP on Linux
This script is a tool to Manage status of lnmp
For <span>more</span> information please visit http://www.lnmp.org
Usage: /root/lnmp <span>{</span>start<span>|</span>stop<span>|</span>reload<span>|</span>restart<span>|</span><span>kill</span><span>|</span>status<span>}</span>
<span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>=</span>
Nginx is runing<span>!</span>
php-fpm is runing<span>!</span>
MySQL running <span>(</span><span>12489</span><span>)</span>								<span>[</span>确定<span>]</span>
Active Internet connections <span>(</span>only servers<span>)</span>
Proto	Recv-Q	Send-Q	Local Address	Foreign	Address		State
tcp		<span>0</span>		<span>0</span>		<span>0.0</span>.0.0:53575	<span>0.0</span>.0.0:*			LISTEN
tcp		<span>0</span>		<span>0</span>		<span>0.0</span>.0.0:3306	<span>0.0</span>.0.0:*			LISTEN
tcp		<span>0</span>		<span>0</span>		<span>0.0</span>.0.0:111		<span>0.0</span>.0.0:*			LISTEN
tcp		<span>0</span>		<span>0</span>		<span>0.0</span>.0.0:80		<span>0.0</span>.0.0:*			LISTEN
tcp		<span>0</span>		<span>0</span>		<span>0.0</span>.0.0:22		<span>0.0</span>.0.0:*			LISTEN
tcp		<span>0</span>		<span>0</span>		<span>127.0</span>.0.1:631	<span>0.0</span>.0.0:*			LISTEN
tcp		<span>0</span>		<span>0</span>		<span>127.0</span>.0.1:25	<span>0.0</span>.0.0:*			LISTEN
tcp		<span>0</span>		<span>0</span>		:::57454		:::*				LISTEN
tcp		<span>0</span>		<span>0</span>		:::111			:::*				LISTEN
tcp		<span>0</span>		<span>0</span>		:::22			:::*				LISTEN
tcp		<span>0</span>		<span>0</span>		::1:631			:::*				LISTEN
tcp		<span>0</span>		<span>0</span>		::1:25			:::*				LISTEN
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h4 id="_3-lnmp-一键安装包安装的软件及具体位置"> 3.LNMP 一键安装包安装的软件及具体位置</h4>
<p>既然是一键安装，那么默认安装的软件和软件的安装位置都是事先设定好的，在安装过程中不能更改。具体安装了哪些软件及其位置如表7-2 所示。</p>
<p><strong>表7-2	<u>LNMP 一键安装包安装的软件及其位置</u></strong></p>
<table>
	<tr>
	    <th>默认安装软件</th>
	    <th>安装位置</th>
	    <th>相关配置文件名</th>  
	    <th>配置文件位置</th>
	</tr >
	<tr >
	    <td rowspan="3">Nginx</td>
	    <td rowspan="3">/usr/local/nginx/</td>
	    <td>Nginx配置文件</td>
	    <td>/usr/local/nginx/conf/nginx.conf</td>
	</tr>
	<tr>
	    <td>默认网站目录</td>
	    <td>/home/wwwroot/delault</td>
	</tr>
	<tr>
	    <td>日志文件</td>
	    <td>/home/wwwlogs/</td>
	</tr>
    <tr >
	    <td rowspan="2">MySQL</td>
	    <td rowspan="2">/usr/local/mysql/</td>
	    <td>MySQL配置文件</td>
	    <td>/etc/my.cnf</td>
	</tr>
	<tr>
	    <td>数据所在位置</td>
	    <td>/usr/local/mysql/var/</td>
	</tr>
    <tr >
	    <td rowspan="2">PHP</td>
	    <td rowspan="2">/usr/local/php/</td>
	    <td>PHP配置文件</td>
	    <td>/usr/local/php/etc/php.ini</td>
	</tr>
	<tr>
	    <td>php-fpm配置文件</td>
	    <td>/usr/local/php/etc/php-fpm.conf</td>
	</tr>
    <tr >
	    <td>phpMyAdmin</td>
	    <td>/home/wwwroot/dcfault/phpmyadmin/</td>
	    <td>无</td>
	    <td>无</td>
	</tr>
    <tr >
	    <td>Zend Optimizer</td>
	    <td>/usr/local/zend/</td>
	    <td>无</td>
	    <td>无</td>
	</tr>
</table>
也就是说，LNMP 一键安装只安装了基本的 Nginx、MySQL、PHP、phpMyAdmin 和 Zend Optimizer。
<h4 id="_3-安装-php-模块"> 3.安装 PHP 模块</h4>
<p>我们已经知道 LNMP 一键安装包默认只安装了最基本的 Nginx+MySQL+PHP 环境，并没有安装扩展功能模块，如果需要安装扩展模块该怎么办？</p>
<p>不用担心，也有相应的安装脚本，我们一个一个来看。需要注意的是，以下 5 个模块并不是必须安装的，而是用到哪个模块才安装哪个模块。</p>
<p>1）安装 eAccelerator</p>
<p>eAccelerator 是一个开放源码的 PHP 加速器，提高了 PHP 脚本的缓存性能，使得 PHP 脚本在编译状态下对服务器的开销几乎完全消除。它还对脚本起到了优化作用，以加快其执行效率。安装过程如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cd /usr/local/src/lnmp1.0-full</span>
<span>#进入lnmp解压缩目录</span>
<span>[</span>root@localhost lnmp1.0-full<span>]</span><span># ./eaccelerator.sh</span>
<span>#执行ccelerator.sh 安装脚本</span>
<span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span>
Install eAcesselerator <span>for</span> LNMP VI.0 , Written by Licess
<span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span>
LNMP is a tool to auto-compile S <span>install</span> Nginx+MySQL+PHP on Linux This script is a tool to <span>install</span> eAccelerator <span>for</span> lnmp

For <span>more</span> information please visit http://www.lnmp.org
<span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span>
Which version <span>do</span> you want to install:
Install eaccelerator <span>0.9</span>.5.3 please type: old
<span>#0.9.5.3版本支持PHP 5.2,如需此版本请输入old</span>
Install eaccelerator <span>0.9</span>.6.1 please type: new
<span>#0.9.6.1版本支持PHP 5.2和5.3,如需此版本请输入new</span>
Install eaccelerator <span>1.0</span>-dev please type： dev
<span>#1.0版本支持PHP 5.2, 5.3和5.4，如需此版本请输入dev</span>
Type old, new or dev <span>(</span>Default version old<span>)</span>:dev
<span>#输入 dev</span>
Press any key to start. <span>.</span> .or Press Ctrl+c to
<span>#按任意键开始安装</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>这里按回车键，eAccelerator 就会自动安装，也很方便。</p>
<p>2）安装 xCache</p>
<p>xCache 是一个又快又稳定的 PHP opcode 缓存器，经过良好的测试并可在大流量/高负载的生产机器上稳定运行，经过（在 Linux 上）测试并支持所有现行 PHP 分支的最新发布版本。安装过程如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cd /usr/local/src/lnmp1.0-full</span>
<span>#进入lnmp解压缩目录</span>
<span>[</span>root@localhost lnmp1.0-full<span>]</span><span># ./xcache.sh</span>
<span>#执行xcache.sh安装脚本</span>
<span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>=</span>
Install XCache <span>for</span> LNMP V1.0 ， Written by Licess
<span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>=</span>
LNMP is a tool to auto-compile <span>&amp;</span> <span>install</span> Nginx+MySQL+PHP on Linux
This script is a tool to <span>install</span> XCache <span>for</span> lnmp
<span>more</span> information please visit http://www.lnmp.org
<span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>=</span>
Which version <span>do</span> you want to install：
Install XCache <span>2.0</span>.0 please type：old
Install XCache <span>3.0</span>.1 please type：new
Type old or new <span>(</span>Default <span>install</span> XCache <span>3.0</span>.1<span>)</span>：new
<span>#安装较新的版本</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>同样，回车之后会让你确认，再次回车就可以安装了。</p>
<p>3）安装 memcached</p>
<p>memcached 的安装过程如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cd /usr/local/src/lnmp1.0-full</span>
<span>#进入lnmp解压缩目录</span>
<span>[</span>root@localhost lnmp1.0-full<span>]</span><span>#./memcached.sh</span>
<span>#执行memcached.sh安装脚本</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这个软件的安装不再有安装选项需要选择，回车就会自动安装 memcache php 扩展和 memcached。</p>
<p>4）安装 imageMagick</p>
<p>imageMagick 是一个用于查看、编辑位图文件以及进行图像格式转换的开放源码软件套装，它可以读取、编辑超过 100 种图像格式，可用来代替 gd 库。安装过程如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cd /usr/local/src/lnmp1.0-full</span>
<span>#进入lnmp解压缩目录</span>
<span>[</span>root@localhost lnmp1.0-full<span>]</span><span># ./imageMagick.sh</span>
<span>#执行imageMagick.sh安装脚本</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这个软件也没有安装选项需要选择，回车就会自动安装 imageMagick。</p>
<p>5）安装 ionCube</p>
<p>ionCube loader 是用来解密 ionCube 加密的 PHP 脚本的，如 whmcs 就采用 ionCube 加密。安装过程如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cd /usr/local/src/lnmp1.0-full</span>
<span>#进入lnmp解压缩目录</span>
<span>[</span>root@localhost lnmp1.0-full<span>]</span><span># ./ionCube.sh</span>
<span>#执行ionCube.sh安装脚本</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>回车就会自动安装。</p>
<p>至此，LNMP 一键安装包就安装完成了，使用脚本安装的方法是不是比手工安装要简单的多呢？</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2022-01-26T06:11:29.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">linux数据备份与恢复</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_manage/07.linux_backup_recover/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_manage/07.linux_backup_recover/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>不知道大家有没有丢失过重要的数据呢？</p>
<p>丢失数据的理由是多种多样的，有人是因为重装系统时，没有把加密文件的密钥导出，重装系统后密钥丢失，导致所有的加密数据不能解密；也有人是因为在火车上笔记本电脑被别人调包，从而导致硬盘中的重要数据丢失；还有人是因为在系统中误执行了 <code>rm -rf</code> 命令，导致整个根目录被人为清空。但由此带来的后果是一样严重的。</p>
<p>保护重要数据的最有效的方法就是“不要把鸡蛋都放在一只篮子里”，这就是数据备份最主要的作用。</p>
<h2 id="备份的重要性"> 备份的重要性</h2>
<p>前面我们已经学习了很多有关 Linux  系统的安全防范策略（例如用户管理、权限管理等），但安全永远是相对的，而不是绝对的。系统硬件的损坏，黑客的无孔不入，都是系统安全的大敌。在这种情况下，如果我们要保证系统安全和应用安全，备份是必不可少的一个步骤。</p>
<p>虽然 Linux 系统难免会因内部环境、底层硬件、外来黑客等因素的影响出现问题，但作为一名系统管理人员，自身的职责并不是要保证系统永远不出问题（事实上也是不可能做到的），而是要在系统出现故障或者崩溃时，能以最快的速度，用最短时间恢复系统的运行，保证数据的安全，从而将故障带来的损失降到最低。</p>
<p>要实现这样的目标，就要求系统管理人员对系统和业务应用有一个合理的备份恢复策略，完美的备份策略可以保证业务的 0 宕机时间和数据的完全恢复。有人说，既然数据备份非常重要，那我把重要数据在硬盘中保存一份，在移动硬盘中也保存一份，再刻录一张光盘，这样数据应该非常安全了吧？</p>
<p>对个人用户来讲，这样保存数据已经足够了；但是对企业用户来讲，还是有安全隐患的，因为这些数据还是放在同一个地方的。还记得美国的“9·11”事件吗？像美国纽约世贸中心那样的庞然大物也轰然倒塌。当然，相比这样的灾难来讲，数据的损失已经是微不足道的了，不过这仍然说明异地备份的重要性。所以，我们在备份数据的时候，不仅要把数据保存在多个存储介质中，还要考虑把重要数据异地保存。</p>
<p>至于在 Linux 系统中，有哪些数据应该被视为重要数据，又该如何备份？</p>
<h2 id="linux-中的哪些数据需要备份"> Linux 中的哪些数据需要备份</h2>
<p>既然备份这么重要，那么对 Linux 服务器来讲，我们到底需要备份哪些数据呢？当然最理想的就是把整块硬盘中的数据都备份，甚至连分区和文件系统都备份，这样如果硬盘损坏，那么我们可以直接把备份硬盘中的数据导入损坏的硬盘，甚至可以直接用备份硬盘代替损坏的硬盘。从数据恢复角度来说，这样的整盘备份是最方便的（<code>dd</code> 命令就可以实现整盘备份，类似于 Windows 中的 GHOST 软件)。不过这种备份的备份时间比较长，占用的硬盘空间较大，不太适合经常进行。我们最常进行的备份还是把系统中的重要数据进行备份。那么，哪些数据是 Linux 服务器中较为重要的、需要定时备份的数据呢？</p>
<h3 id="linux-服务器中的重要数据"> Linux 服务器中的重要数据</h3>
<p>Linux 服务器中的哪些数据需要备份，可能不同的管理员有不同的理解，不过有这样一些数据是大家公认的需要备份的数据。</p>
<ul>
<li>
<p><code>/root/</code> 目录：<code>/toot/</code> 目录是管理员的家目录，很多管理员会习惯在这个目录中保存一些相关数据，那么，当进行数据备份时，需要备份此目录。</p>
</li>
<li>
<p><code>/home/</code> 目录：<code>/home/</code> 目录是普通用户的家目录。如果是生产服务器，那么这个目录中也会保存大量的重要数据，应该备份。</p>
</li>
<li>
<p><code>/var/spool/mail/</code> 目录：在默认情况下，所有的用户未读的邮件会保存在 <code>/var/spool/mail/</code> 目录下和用户名相同的邮箱文件中，已读的邮件会保存在用户家目录下的 <code>mbox</code> 文件中（<code>mail</code> 命令默认如此保存，不过如果使用了 <code>hold</code> 命令，那么不管邮件是否已读，都保存在 <code>/var/spool/mail/</code> 目录中。可以使用 <code>mbox</code> 命令恢复已读邮件保存在 <code>~/mbox</code> 文件中）。一般情况下，用户的邮件也是需要备份的重要数据。</p>
</li>
<li>
<p><code>/etc/</code> 目录：系统重要的配置文件保存目录，当然需要备份。</p>
</li>
<li>
<p>其他目录：根据系统的具体情况，备份你认为重要的目录。比如，我们的系统中有重要的日志，或者安装了 RPM 包的 MySQL 服务器（RPM 包安装的 mysql 服务，数据库保存在 <code>/var/lib/mysql/</code>目录中)，那么 <code>/var/</code> 目录就需要备份；如果我们的服务器中安装了多个操作系统，或编译过新的内核，那么 <code>/boot</code> 目录就需要备份。</p>
</li>
</ul>
<h3 id="安装服务的数据"> 安装服务的数据</h3>
<p>我们的 Linux 服务器中会安装各种各样的应用程序，这些程序当然也有重要数据需要备份。不过应用程序是多种多样的，每种应用程序到底应该备份什么数据也不尽相同，要具体情况具体对待。这里拿最常见的 apache 服务和 mysql 服务来举例。</p>
<ul>
<li>apache 服务需要备份如下内容：
<ul>
<li>配置文件。RPM 包安装的 apache 需要备份 <code>/etc/httpd/con/hpptd.conf</code>；源码包安装的 apache 则需要备份 <code>/usr/local/apache2/conf/httpd.conf</code>。</li>
<li>网页主目录。RPM 包安装的 apache 需要备份 <code>/var/www/html/</code> 目录中所有的数据；源码包安装的 apache 需要备份 <code>/usr/local/apache2/htdocs/</code> 目录中所有的数据。</li>
<li>日志文件。RPM 包安装的 apache 需要备份 <code>/var/log/httpd/</code> 目录中所有的日志；源码包安装的 apache 需要备份 <code>/usr/local/apache2/logs/</code> 目录中所有的日志。</li>
</ul>
</li>
</ul>
<p>其实，对源码包安装的 apache 来讲，只要备份 <code>/usr/ocal/apache2/</code> 目录中所有的数据即可，因为源码包安装的服务的所有数据都会保存到指定目录中。但如果是 RPM 包安装的服务，就需要单独记忆和指定了。</p>
<ul>
<li>mysql 服务需要备份如下内容：
<ul>
<li>对于源码包安装的 mysql 服务，数据库默认安装到 <code>/usr/local/mysql/data/</code> 目录中，只需备份此目录即可。</li>
<li>对于 RPM 包安装的 mysql 服务，数据库默认安装到 <code>/var/lib/mysql/</code> 目录中，只需备份此目录即可。</li>
</ul>
</li>
</ul>
<p>如果是源码包安装的服务，则可以直接备份 <code>/usr/local/</code> 目录，因为一般源码包服务都会安装到 <code>/usr/local/</code> 目录中。如果是 RPM 包安装的服务，则需要具体服务具体对待，备份正确的数据。</p>
<h2 id="备份策略"> 备份策略</h2>
<p>常用的备份策略有<strong>完全备份</strong>和<strong>增量备份</strong>，而增量备份有可细分为累计增量备份和差异增量备份。下面来分别讲述不同备份策略以及之间的区别。</p>
<h3 id="完全备份"> 完全备份</h3>
<p>完全备份是指把所有需要备份的数据全部备份。当然，完全备份可以备份整块硬盘、整个分区或某个具体的目录。对于 Linux 操作系统来说，完全备份指的就是将根目录下的所有文件进行备份。</p>
<p>完全备份的好处是，所有数据都进行了备份，系统中任何数据丢失都能恢复，且恢复效率较高。如果完全备份备份的是整块硬盘，那么甚至不需要数据恢复，只要把备份硬盘安装上，服务器就会恢复正常。</p>
<p>完全备份的缺点也很明显，那就是需要备份的数据量较大，备份时间较长，备份了很多无用数据，占用的空间较大，所以完全备份不可能每天执行。</p>
<p>我们一般会对关键服务器进行整盘完全备份，如果出现问题，则可以很快地使用备份硬盘进行替换，从而减少损失。我们甚至会对关键服务器搭设一台一模一样的服务器，这样只要远程几个命令（或使用 Shell 脚本自动检测，自动进行服务器替换），备份服务器就会接替原本的服务器，使故障响应时间大大缩短。</p>
<h3 id="累计增量备份"> 累计增量备份</h3>
<p>在一个数据量很大的业务应用中，每天对 Linux 系统进行完全备份是不现实的，这就需要用到增量备份策略。</p>
<p>累计增量备份是指先进行一次完全备份，服务器运行一段时间之后，比较当前系统和完全备份的备份数据之间的差异，只备份有差异的数据。服务器继续运行，再经过一段时间，进行第二次增量备份。在进行第二次增量备份时，当前系统和第一次增量备份的数据进行比较，也是只备份有差异的数据。第三次增量备份是和第二次增量备份的数据进行比较，以此类推。</p>
<p>因此，累计增量备份就是只备份每天增加或者变化的数据，而不备份系统中没有变动的数据。我们画一张示意图，如图8-1 所示。</p>
<div>
<p><img src="./assets/bk1.jpg" alt="累计增量备份" loading="lazy"></p>
<p><strong>图8-1 <u>累计增量备份</u></strong></p>
</div>
<p>假设我们在第一天进行一次完全备份。第二天增量备份时，只会备份第二天和第一天之间的差异数据，但是第二天的总备份数据是完全备份加第一次增量备份的数据。第三天增量备份时，只会备份第三天和第二天之间的差异数据，但是第三天的总备份数据是完全备份加第一次增量备份的数据，再加第二次增量备份的数据。当然，第四天增量备份时，只会备份第四天和第三天的差异数据，但是第四天的总备份数据是完全备份加第一次增量备份的数据，加第二次增量备份的数据，再加第三次增量备份的数据。</p>
<p>采用累计增量备份的好处是，每次备份需要备份的数据较少，耗时较短，占用的空间较小；坏处是数据恢复比较麻烦，如果是图1  的例子，那么当进行数据恢复时，就要先恢复完全备份的数据，再依次恢复第一次增量备份的数据、第二次增量备份的数据和第三次增量备份的数据，最终才能恢复所有的数据。</p>
<h3 id="差异增量备份"> 差异增量备份</h3>
<p>差异增量备份（后续简称差异备份）也要先进行一次完全备份，但是和累计增量备份不同的是，每次差异备份都备份和原始的完全备份不同的数据。也就是说，差异备份每次备份的参照物都是原始的完全备份，而不是上一次的差异备份。我们也画一张示意图，如图8-2 所示。</p>
<div>
<p><img src="./assets/bk2.jpg" alt="差异增量备份" loading="lazy"></p>
<p><strong>图8-2	<u>差异增量备份</u></strong></p>
</div>
<p>假设我们在第一天也进行一次完全备份。第二天差异备份时，会备份第二天和第一天之间的差异数据，而第二天的备份数据是完全备份加第一次差异备份的数据。第三天进行差异备份时，仍和第一天的原始数据进行对比，把第二天和第三天所有的数据都备份在第二次差异备份中，第三天的备份数据是完全备份加第二次差异备份的数据。第四天进行差异备份时，仍和第一天的原始数据进行对比，把第二天、第三天和第四天所有的不同数据都备份到第三次差异备份中，第四天的备份数据是完全备份加第三次差异备份的数据。</p>
<p>相比较而言，差异备份既不像完全备份一样把所有数据都进行备份，也不像增量备份在进行数据恢复时那么麻烦，只要先恢复完全备份的数据，再恢复差异备份的数据即可。不过，随着时间的增加，和完全备份相比，变动的数据越来越多，那么差异备份也可能会变得数据量庞大、备份速度缓慢、占用空间较大。</p>
<p>一个比较的备份策略是，对于数据量不大，并且每天数据量增加不多的系统，优先选择完全备份；对于数据量巨大，每天新增数据也很多的系统，视情况选择差异备份或者增量备份。</p>
<h2 id="备份和恢复"> 备份和恢复</h2>
<p>其实数据备份就是把数据复制一份保存在其他位置，如果能够压缩一下，当然就更好了。那我们使用 <code>tar</code> 或 <code>cp</code> 命令可以实现数据的备份吗？当然可以，不过它们只能实现完全备份，如果要实现增量备份和差异备份，就必须写 Shell 脚本来实现了。</p>
<p>作为 Linux 系统管理员，最经常使用的备份工具就是 <code>tar</code> 和 <code>cpio</code> 命令。前面已经学过，此处不做说明。</p>
<div><p>tar 备份脚本示例</p>
<p>下面通过 <code>tar</code> 命令做的一个 Web 服务器的备份脚本，详细了解 <code>tar</code> 命令作为备份工具时的具体用法。</p>
<p>以下是一个有关 Web 服务器的备份脚本：</p>
<div><pre><code><span>#!/bin/sh</span>
<span>BAKDATE</span><span>=</span><span><span>`</span><span>date</span> +%y%m%d<span>`</span></span>
<span>DATA3</span><span>=</span><span><span>`</span><span>date</span> -d <span>"3 days ago"</span> +%y%m%d<span>`</span></span>
<span>osdata</span><span>=</span>/disk1
<span>userdata</span><span>=</span>/disk2
<span>echo</span> <span>"backup OS data starting"</span>
<span>tar</span> -zcvf /<span>$osdata</span>/etc.data/etc_<span>$BAKDATE</span>.tar.gz /etc
<span>tar</span> -zcvf /<span>$osdata</span>/boot.data/boot_<span>$BAKDATE</span>.tar.gz /boot
<span>tar</span> -zcvf /<span>$osdata</span>/home.data/home_<span>$BAKDATE</span>.tar.gz /home
<span>tar</span> -zcvf /<span>$osdata</span>/root.data/root_<span>$BAKDATE</span>.tar.gz /root
<span>tar</span> -zcvf /<span>$userdata</span>/usr_data/usrlocal_<span>$BAKDATE</span>.tar.gz /usr/local
<span>tar</span> -zcvf /<span>$userdata</span>/var_www/www_<span>$BAKDATE</span>.tar.gz /var/www
<span>cp</span> -r /<span>$osdata</span>/* /<span>$userdata</span>
<span>cp</span> -r /<span>$userdata</span>/* /<span>$osdata</span>
<span>echo</span> <span>"Backup OS data complete!"</span>

<span>echo</span> <span>"delete OS data 3 days ago"</span>
<span>rm</span> -rf /<span>$osdata</span>/etc.data/etc_<span>$DATA3</span>.tar.gz
<span>rm</span> -rf /<span>$osdata</span>/boot.data/boot_<span>$DATA3</span>.tar.gz
<span>rm</span> -rf /<span>$osdata</span>/home.data/home_<span>$DATA3</span>.tar.gz
<span>rm</span> -rf /<span>$osdata</span>/root.data/root_<span>$DATA3</span>.tar.gz
<span>rm</span> -rf /<span>$osdata</span>/usr_data/usrlocal_<span>$DATA3</span>.tar.gz
<span>rm</span> -rf /<span>$osdata</span>/var_www/www_<span>$DATA3</span>.tar.gz

<span>rm</span> -rf /<span>$userdata</span>/etc.data/etc_<span>$DATA3</span>.tar.gz
<span>rm</span> -rf /<span>$userdata</span>/boot.data/boot_<span>$DATA3</span>.tar.gz
<span>rm</span> -rf /<span>$userdata</span>/home.data/home_<span>$DATA3</span>.tar.gz
<span>rm</span> -rf /<span>$userdata</span>/root.data/root_<span>$DATA3</span>.tar.gz
<span>rm</span> -rf /<span>$userdata</span>/usr_data/usrlocal_<span>$DATA3</span>.tar.gz
<span>rm</span> -rf /<span>$userdata</span>/var_www/www_<span>$DATA3</span>.tar.gz
<span>echo</span> <span>"delete cws ok!"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>上面这段脚本完成的工作是，将系统和用户的备份数据分别保存在两个不同的本地磁盘 disk1 和 disk2 中，并且保留最近 3 天的数据，3 天前的数据自动删除。主要备份的数据有 <code>/etc</code> 目录、<code>/boot</code> 目录、<code>/home</code> 目录、<code>/root</code> 目录、<code>/usr/local</code> 目录和 <code>/var/www</code> 目录。当然这里只是举个例子，凡是存放数据的重要目录，都需要进行备份。</p>
<p>将此脚本放到系统守护进程（类似于 Windows 下的计划任务）crontab 下，设定备份时间，即可实现定时数据备份。有关 crontab 的详细介绍，请看前面的 Linux 工作管理。</p>
</div>
<h3 id="dump-命令"> dump 命令</h3>
<p>在 Linux 中给我们准备了专用的备份和恢复命令，那就是 <code>dump</code> 和 <code>restore</code>，它们可以轻松地实现数据备份和数据恢复，而且它们是可以直接实现增量备份和差异备份的。</p>
<p>在系统学习 <code>dump</code> 命令之前，由于 CentOS 6.x 系统默认是没有安装此命令的，因此需要我们手动安装 <code>dump</code> 命令，安装命令如下：</p>
<div><pre><code><span>[</span>root@localhost ～<span>]</span><span># yum -y install dump</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>dump</code> 命令使用“备份级别”来实现增量备份，它支持 0～9 共 10 个备份级别。其中，0 级别指的就是完全备份，1～9 级别都是增量备份级别。</p>
<p>举个列子，当我们备份一份数据时，第一次备份应该使用 0 级别，会把所有数据完全备份一次；第二次备份就可以使用 1 级别了，它会和 0 级别进行比较，把 0 级别备份之后变化的数据进行备份；第三次备份使用 2 级别，2 级别会和 1 级别进行比较，把 1 级别备份之后变化的数据进行备份，以此类推。</p>
<p><u>需要注意的是，只有在备份整个分区或整块硬盘时，才能支持 1～9 的增量备份级别；如果只是备份某个文件或不是分区的目录，则只能使用 0 级别进行完全备份。</u></p>
<p><code>dump</code> 命令的基本格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># dump [选项] 备份之后的文件名 原文件或目录</span>
选项：
	-level		：就是我们说的 <span>0</span>～9 共 <span>10</span> 个备份级别
	-f 文件名	：指定备份之后的文件名
	-u			：备份成功之后，把备份时间、备份级别以及实施备份的文件系统等信息，都记录在 /etc/dumpdates 文件中
	-v			：显示备份过程中更多的输出信息
	-j			：调用 bzlib 库压缩备份文件，其实就是把备份文件压缩为 .bz2 格式，默认压缩等级是 <span>2</span>
	-W			：显示允许被 dump 的分区的备份等级及备份时间
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><code>dump</code> 命令是一个较为复杂的命令，如果我们只是想要实现数据的备份与恢复，那么掌握以上几个选项就足够了。</p>
<h4 id="备份分区"> 备份分区</h4>
<p>​</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># df -h</span>
文件系统	容量	已用	可用	已用%	挂载点
/dev/sda3	20G		<span>3</span>.0G	16G		<span>17</span>%		/
tmpfs		306M	<span>0</span>		306M	<span>0</span>%		/dev/shm
/dev/sda1	194M	26M		158M	<span>15</span>%		/boot
/dev/sr0	<span>3</span>.5G	<span>3</span>.5G	<span>0</span>		<span>100</span>%	/mnt/cdrom
<span>#系统中我们就分了/分区和/boot分区。根分区太大,备份速度太慢,我们还是备份/boot分区吧</span>
<span>[</span>rootSlocalhost ~<span>]</span><span># dump -0uj -f /root/boot.bak.bz2 /boot/</span>
<span>#备份命令。先执行一次完全备份,并压缩和更新备份时间</span>
DUMP: Date of this level <span>0</span> dump: Wed Jun <span>5</span> 03:08:22 <span>2013</span>
<span>#备份的级别和时间</span>
DUMP: Dumping /dev/sdal <span>(</span>/boot<span>)</span> to /root/boot.bak.bz2
<span>#备份源和目标</span>
DUMP: Label: none
<span>#分区没有卷标</span>
DUMP: Writing <span>10</span> Kilobyte records
DUMP: Compressing output at compression level <span>2</span> <span>(</span>bzlib<span>)</span>
<span>#备份时压缩</span>
DUMP: mapping <span>(</span>Pass I<span>)</span> <span>[</span>regular files<span>]</span>
DUMP: mapping <span>(</span>Pass II<span>)</span> <span>[</span>directories<span>]</span>
DUMP: estimated <span>21846</span> blocks.
DUMP: Volume <span>1</span> started with block <span>1</span> at： Wed Jun <span>5</span> 03:08:22 <span>2013</span>
DUMP: dumping <span>(</span>Pass III<span>)</span> <span>[</span>directories<span>]</span>
<span>#开始dump 备份</span>
DUMP: dumping <span>(</span>Pass XV<span>)</span> <span>[</span>regular files<span>]</span>
DUMP: Closing /root/boot.bak.bz2
<span>#备份结朿，生成备份文件</span>
DUMP: Volume <span>1</span> completed at: Wed Jun <span>5</span> 03:08:30 <span>2013</span>
DUMP: Volume <span>1</span> took <span>0</span>:00:08
DUMP: Volume <span>1</span> transfer rate: <span>2370</span> kB/s
DUMP: Volume <span>1</span> 21930kB uncompressed, 18962kB compressed, <span>1.157</span>:1
<span>#数据容量</span>
DUMP: 2X930 blocks <span>(</span><span>21</span>.42MB<span>)</span> on <span>1</span> volume<span>(</span>s<span>)</span>
DUMP: finished <span>in</span> <span>7</span> seconds, throughput <span>3132</span> kBytes/sec
DUMP: Date of this level <span>0</span> dump: Wed Jun <span>5</span> 03:08:22 <span>2013</span>
DUMP: Date this dump completed: Wed Jun <span>5</span> 03:08:30 <span>2013</span>
DUMP: Average transfer rate: <span>2370</span> kB/s
DUMP: Wrote 21930kB uncompressed, 18962kB compressed, <span>1.157</span>:1
<span>[</span>root@localhost ~<span>]</span><span># cat /etc/dumpdates</span>
<span>#查看备份时间文件</span>
/dev/sdal	<span>0</span>	Wed Jun <span>5</span> 03:08:22 <span>2013</span> +0800
<span>#备份的分区	备份级别	备份曰期</span>
<span>[</span>root@localhost @<span>]</span><span># ll -h /root/boot.bak.bz2</span>
-rw-r--r--. <span>1</span> root root 19M <span>6</span> 月 <span>5</span> 03:08 /root/boot.bak.bz2
<span>#备份文件生成了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><p>如果 <code>/boot</code> 分区的内容发生了变化，则可以使用 1 级别进行增量备份。当然，如果数据会继续发生变化，则可以继续使用 2～9 级别增量备份。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ll -h /root/install.log</span>
-rw-r--r--.1 root root 25K <span>4</span>月 <span>10</span> <span>21</span>：49 /root/install.log
<span>#查看安装软件包日志的大小为25KB</span>
<span>[</span>root@localhost ~<span>]</span><span># cp install.log /boot/</span>
<span>#复制日志文件到/boot分区</span>
<span>[</span>root@localhost ~<span>]</span><span># dump -1uj -f /root/boot.bak1.bz2 /boot/</span>
<span>#增量备份/boot分区，并压缩</span>
<span>[</span>root@localhost ~<span>]</span><span># ll -h boot.bak*</span>
-rw-r--r--.1 root root 18K <span>6</span>月 <span>5</span> 03：16 boot.bak1.bz2
-rw-r--r--.1 root root 19M <span>6</span>月 <span>5</span> 03：08 boot.bak.bz2
<span>#boot.bak1.bz2压缩文件只有18KB，证明增量备份只备份了0级别以后变化的数据</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>如果备份的是整个分区，那么是可以使用 <code>dump -W</code> 命令来查询分区的备份时间及备份级别的。不过要注意，如果备份时没有使用“-u”选项，那么 <code>dump -W</code> 命令是不会记录备份的时间和级别的。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># dump -W</span>
Last dump<span>(</span>s<span>)</span> <span>done</span> <span>(</span>Dump <span>'>'</span> <span>file</span> systems<span>)</span>：
/dev/sda3 <span>(</span>		/<span>)</span> Last dump：Level <span>1</span>， Date Wed Jun <span>5</span> 02：31：50 <span>2013</span>
/dev/sda1 <span>(</span>	/boot<span>)</span> Last dump：Level <span>1</span>， Date Wed Jun <span>5</span> 03：16：27 <span>2013</span>
<span>#/分区和/boot分区都进行过dump备份，/boot分区的最新备份级别是1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>dump</code> 命令可以非常方便地实现增量备份，但是如何实现差异备份呢？其实也很简单，先使用 0 级别完全备份一次，以后的每次备份都使用 1 级别进行备份。</p>
<h4 id="备份文件或目录"> 备份文件或目录</h4>
<p><code>dump</code> 命令也可以文件或目录，不过，只要不是备份分区，就只能使用 0 级别进行完全备份，而不再支持增量备份。同时，不能使用“-u”选项更新分区的备份时间，当然也不能使用 <code>dump -W</code> 命令查询到文件或目录的备份。</p>
<p>我们说 <code>/etc/</code> 目录是重要的配置文件目录，那么我们就备份这个目录来看看吧。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># dump -0j -f /root/etc.dump.bz2 /etc/</span>
<span>#完全备份/etc/目录</span>
<span>[</span>root@localhost ~<span>]</span><span># ll -h /root/etc.dump.bz2</span>
-rw-r--r--.1 root root <span>8</span>.6M <span>6</span>月 <span>5</span> 03：26 /root/etc.dump.bz2
<span>#查看备份文件</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>不过，如果使用增量备份会怎么样呢？命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># dump -1j -f /root/etc.dump1.bz2 /etc/</span>
DUMP：Only level <span>0</span> dumps are allowed on a subdirectory
DUMP：The ENTIRE dump is aborted.
<span>#备份失败了，目录备份只能使用0级别</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="restore-命令"> restore 命令</h3>
<p><code>restore</code> 命令是 <code>dump</code> 命令的配套命令，<code>dump</code> 命令是用来备份分区和数据的，而 <code>restore</code> 命令是用来恢复数据的。</p>
<p><code>restore</code> 命令的基本格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># restore [模式选项] [-f]</span>
模式选项：
	restore 命令常用的模式有以下 <span>4</span> 种，这 <span>4</span> 种模式不能混用：
	-C：比较备份数据和实际数据的变化。如果实际数据中的现有数据发生了变化，那么这个选项能够检测到这个变化。
		但是如果实际数据中新增了数据，那么这个选项是不能检测到变化的
	-i：进入交互模式，手工选择需要恢复的文件
	-t：查看模式，用于查看备份文件中拥有哪些数据
	-r：还原模式，用于数据还原
	
选项：	
	-f：选项用于指定备份文件的文件名
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h4 id="比较备份数据和实际数据的变化"> 比较备份数据和实际数据的变化</h4>
<p>这里大家需要注意，数据比较只有在原有数据减少或发生变化时才能检测到变化，而新增的数据是不会被检测到的。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># touch /boot/abc</span>
<span>#在/boot/目录中新建abc文件</span>
<span>[</span>root@localhost ~<span>]</span><span># restore -C -f /root/boot.bak.bz2</span>
Dump tape is compressed.
Dump date：Wed Jun <span>5</span> 08：20：02 <span>2013</span>
Dumped from：the epoch
Level <span>0</span> dump of /boot on localhost：/dev/sda1
Label：none
filesys <span>=</span> /boot
<span>#restore检测，没有发现任何变化（当然，因为备份数据在备份时没有abc文件，所以restore命令是不能识别新建文件的）</span>
<span>[</span>root@localhost ~<span>]</span><span># mv /boot/vmlinuz-2.6.32-279.el6.i686 /boot/vmlinuz-2.6.32-279.el6.i686.bak</span>
<span>#把/boot/目录中的内核镜像文件改一个名字</span>
<span>[</span>root@localhost ~<span>]</span><span># restore -C -f /root/boot.bak.bz2</span>
Dump tape is compressed.
Dump date：Wed Jun <span>5</span> 08：20：02 <span>2013</span>
Dumped from：the epoch
Level <span>0</span> dump of /boot on localhost：/dev/sda1
Label：none
filesys <span>=</span> /boot
restore：unable to <span>stat</span> ./vmlinuz-2.6.32-279.el6.i686：No such <span>file</span> or directory Some files were modified！ <span>1</span> compare errors
<span>#restore发现内核镜像文件丢失</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>这个实验比较危险，一定要记得把内核镜像文件的名字改回来，否则一旦重启，系统就会无法正常启动。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mv /boot/vmlinuz-2.6.32-279.el6.i686.bak /boot/vmlinuz2.6.32-279.el6.i686</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="查看模式"> 查看模式</h4>
<p>这种模式比较简单，就是查看备份文件中到底包含什么内容。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># restore -t -f boot.bak.bz2</span>
Dump tape is compressed．
<span>#备份数据是压缩的</span>
Dump date：Wed Jun <span>5</span> 08：20：02 <span>2013</span>
<span>#数据备份时间</span>
Dumped from：the epoch
Level <span>0</span> dump of /boot on localhost：/dev/sda1
<span>#备份等级</span>
Label：none
<span>#分区的卷标，没有设定卷标</span>
<span>2</span>.
<span>11</span> ./lost+found
<span>12</span> ./grub
<span>24</span> ./grub/grub.conf
<span>13</span> ./grub/splash.xpm.gz
<span>..</span>.省略部分输出<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h4 id="还原模式"> 还原模式</h4>
<p><code>restore</code> 命令的还原模式既可以用于还原整个分区，也可以用于还原文件或目录。命令格式是一样的，不过要注意，如果要还原增量备份的数据，则一定要先还原完全备份的数据。命令如下：</p>
<div><pre><code><span>#还原boot.bak.bz2分区备份</span>
<span>#先还原完全备份的数据</span>
<span>[</span>root@localhost ~<span>]</span><span># mkdir boot.test</span>
<span>#建立准备解压缩的目录。当然，如果这个目录是我新建的分区，就可以直接把数据恢复到分区中</span>
<span>[</span>root@localhost ~<span>]</span><span># cd boot.test/</span>
<span>#进入解压缩目录</span>
<span>[</span>root@localhost boot.test<span>]</span><span># restore -r -f /root/boot.bak.bz2</span>
Dump tape is compressed.
<span>#备份数据是压缩数据</span>
<span>#解压缩</span>
<span>[</span>root@localhost boot.test<span>]</span><span># ll</span>
<span>#查看一下解压缩的文件</span>
总用量21300
-rw-r--r--. <span>1</span> root root <span>106611</span> <span>6</span>月 <span>22</span> <span>20</span>:12 config-2.6.32-279.el6.i686
drwxr-xr-x. <span>3</span> root root <span>4096</span> <span>4</span> 月 <span>10</span> <span>21</span>:47 efi
drwxr-xr-x. <span>2</span> root root <span>4096</span> <span>4</span> 月 <span>10</span> <span>21</span>:49 grub
-rw-r--r--. <span>1</span> root root <span>14708399</span> <span>4</span> 月 <span>10</span> <span>21</span>:49 initrara£s-2.6.32-279.el6.i686.img
drwx------. <span>2</span> root root <span>4096</span> <span>4</span> 月 <span>10</span> <span>21</span>:44 lost+found
-rw-------. <span>1</span> root root <span>47504</span> <span>6</span> 月 <span>5</span> 09:44 restoresymtable
-rw-r--r--. <span>1</span> root root <span>175903</span> <span>6</span> 月 <span>22</span> <span>20</span>:12 symvers-2.6.32-279.el6.i686.gz
-rw-r--r--. <span>1</span> root root <span>1846041</span> <span>6</span> 月 <span>22</span> <span>20</span>:12 System.map-2.6.32-279.el6.i686
-rw-r--r--. <span>1</span> root root <span>1048576</span> <span>6</span> 月 <span>5</span> 02:38 <span>test</span>
-rwxr-xr-x. <span>1</span> root root <span>3856608</span> <span>6</span> 月 <span>22</span> <span>20</span>:12 vmlinuz-2.6.32-279.el6.i686
<span>#再还原增量备份的数据</span>
<span>[</span>root@localhost boot.test<span>]</span><span># restore -r -f /root/boot.bakl.bz2</span>
Dump tape is compressed.
<span>#恢复增量备份的数据</span>
<span>[</span>root@localhost boot.test<span>]</span><span># ll</span>
总用量21328
-rw-r--r--. <span>1</span> root root <span>106611</span> <span>6</span> 月 <span>22</span> <span>20</span>:12 config-2.6.32-279.el6.i686
drwxr-xr-x. <span>3</span> root root <span>4096</span> <span>4</span> 月 <span>10</span> <span>21</span>:47 efi
drwxr-xr-x. <span>2</span> root root <span>4096</span> <span>4</span> 月 <span>10</span> <span>21</span>:49 grub
-rw-r--r--. <span>1</span> root root <span>14708399</span> <span>4</span> 月 <span>10</span> <span>21</span>:49 initramfs-2.6.32-279.eX6.i686.img
-rw-r--r--. <span>1</span> root root <span>24772</span> <span>6</span> 月 <span>5</span> 08:20 install. log
<span>#增量备份的install.log文件被恢复了</span>
drwx------. <span>2</span> root root <span>4096</span> <span>4</span> 月 <span>10</span> <span>21</span>:44 lost+found
-rw-------. <span>1</span> root root <span>47552</span> <span>6</span> 月 <span>5</span> 09:57 restoresymtable
-rw-r--r--. <span>1</span> root root <span>175903</span> <span>6</span> 月 <span>22</span> <span>20</span>:12 symvers-2.6.32-279.el6.i686.gz
-rw-r--r--. <span>1</span> root root <span>1846041</span> <span>6</span> 月 <span>22</span> <span>20</span>:12 System.map-2.6.32-279.el6.i686
-rw-r--r--. <span>1</span> root root <span>1048576</span> <span>6</span> 月 <span>5</span> 02:38 <span>test</span>
-rwxr-xr-x. <span>1</span> root root <span>3856608</span> <span>6</span>月 <span>22</span> <span>20</span>:12 vmlinuz-2.6.32-279.el6.i686
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><p>我们再来还原 <code>/etc/</code> 目录的备份 <code>etc.dump.bz2</code>，其实还原的方法是完全一样的。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># restore -r -f etc.dump.bz2</span>
Dump tape is compressed.
<span>#还原etc.dump.bz2备份</span>
<span>[</span>root@localhost ~<span>]</span><span># ll -d /root/etc</span>
drwxr-xr-x.103 root root <span>12288</span> <span>6</span>月 <span>5</span> 07:45 /root/etc
<span>#在root下生成了etc目录，里面的数据和/etc/目录中的数据完全一致</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="dd命令"> dd命令</h3>
<p><code>dd</code> 命令主要用来进行数据备份，并且可以在备份的过程中进行格式转换。其实 <code>dd</code> 命令可以把源数据复制成目标数据，而且不管源数据是文件、分区、磁盘还是光盘，都可以进行数据备份。</p>
<p><code>dd</code> 命令的基本格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># dd if="输入文件" of="输出文件" bs="数据块" count="数量"</span>
参数：
	<span>if</span>			：定义输入数据的文件，也可以是输入设备；
	of			：定义输出数据的文件，也可以是输出设备；
	bs			：指定数据块的大小，也就是定义一次性读取或写入多少字节。模式数据块大小是 <span>512</span> 字节；
	count		：指定 bs 的数量；
	<span>conv</span><span>=</span>标志	：依据标志转换文件。
	
		标志有以下这些：
		ascii	：由 EBCDIC 码转换至 ASCII 码；
		ebcdic	：由 ASCII 码转换至 EBCDIC 码；
		ibm		：由 ASCII 码转换至替换的 EBCDIC 码；
		block	：将结束字符块里的换行替换成等长的空格；
		unblock	：将 cbs 大小的块中尾部的空格替换为一个换行符；
		lcase	：将大写字符转换为小写；
		notrunc	：不截断输出文件；
		ucase	：将小写字符转换为大写；
		swab	：交换每一对输入数据字节；
		noerror	：读取数据发生错误后仍然继续；
		<span>sync</span>	：将每个输入数据块以 NUL 字符填满至 ibs 的大小；当配合 block 或 unblock 时，会以空格代替 NUL 字符填充；
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h4 id="备份文件"> 备份文件</h4>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># dd if=/etc/httpd/conf/httpd.conf of=/tmp/httpd.bak</span>
记录了67+1 的读入
<span>#数据占了写满的67个数据块，以及1个没有写满的数据块</span>
记录了67+1 的写出
<span>#默认数据块大小是512字节</span>
<span>34439</span>字节<span>(</span><span>34</span> kB<span>)</span>已复制，0.0524897 秒，656 kB/秒
<span>#如果要备份文件，那么dd命令和cp命令非常类似</span>
<span>[</span>root@localhost ~<span>]</span><span># ll -h /tmp/httpd.bak</span>
-rw-r--r--.1 root root 34K <span>6</span>月 <span>5</span> <span>18</span>：04 /tmp/httpd.bak
<span>#查看一下生成的备份文件的大小</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h4 id="备份分区为一个备份文件"> 备份分区为一个备份文件</h4>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># df -h</span>
文件系统	容量	已用	可用	已用%%	挂载点
/dev/sda3	20G		<span>2</span>.0G	17G		<span>11</span>%		/
tmpfs		306M	<span>0</span>		306M	<span>0</span>%		/dev/shm
/dev/sda1	194M	27M		157M	<span>15</span>%		/boot
/dev/sr0	<span>3</span>.5G	<span>3</span>.5G	<span>0</span>		<span>100</span>%	/mnt/cdrom
<span>#查看一下分区容量，我们备份/boot分区</span>
<span>[</span>root@localhost ~<span>]</span><span># dd if=/dev/sda1 of=/tmp/boot.bak</span>
<span>#备份完成</span>
<span>[</span>root@localhost ~<span>]</span><span># ll -h /tmp/boot.bak</span>
-rw-r--r--.1 root root 200M <span>6</span>月 <span>5</span> <span>18</span>：14 /tmp/boot.bak
<span>#查看生成的备份文件</span>

<span>#如果需要恢复，则执行以下命令</span>
<span>[</span>root@localhost ~<span>]</span><span># dd if=/tmp/boot.bak of=/dev/sda1</span>

<span>#如果想要把分区直接备份成另一个分区，就需要生成一个新的分区，</span>
<span>#这个分区的大小不能比源分区小，只能和源分区大小一致或比它大。命令如下：</span>
<span>[</span>root@localhost ~<span>]</span><span># dd if=/dev/sda1 of=/dev/sdb1</span>
<span>#如果需要恢复，则只需把输入项和输出项反过来即可，命令如下：</span>
<span>[</span>root@localhost ~<span>]</span><span># dd if=/dev/sdb1 of=/dev/sda1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h4 id="整盘备份"> 整盘备份</h4>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># dd if=/dev/sda of=/dev/sdb</span>
<span>#把磁盘a备份到磁盘b</span>
<span>[</span>root@localhost ~<span>]</span><span># dd if=/dev/sda of=/tmp/disk.bak</span>
<span>#把磁盘a备份成文件disk.bak</span>
<span>#备份恢复</span>
<span>#如果要备份到另一块硬盘上，那么，当源硬盘数据损坏时，只需用备份硬盘替换源硬盘即可</span>
<span>#如果要备份成文件，那么在恢复时需要把备份数据复制到其他Linux中，然后把新硬盘安装到这台Linux</span>
<span>#服务器上，再把磁盘备份数据复制到新硬盘中。命令如下</span>
<span>[</span>root@localhost ~<span>]</span><span># dd if=/tmp/disk.bak of=/dev/sdb</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h4 id="复制软盘"> 复制软盘</h4>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># dd if=/dev/fd0 of=/tmp/fd.bak</span>
<span>#在Linux中软盘的设备文件名是/dev/fd0</span>
<span>#这条命令先把软盘中的数据保存为临时数据文件</span>
<span>[</span>root@localhost ~<span>]</span><span># dd if=/tmp/fd.bak of=/dev/fd0</span>
<span>#然后更换新的软盘，把数据备份复制到新软盘中，就实现了软盘的复制</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="复制光盘"> 复制光盘</h4>
<p>如果需要备份的是光盘，那么在 Linux 中就是使用 <code>dd</code> 命令制作光盘的 ISO 镜像的。命令如下：</p>
<div><pre><code><span>#制作光盘ISO镜像</span>
<span>[</span>root@localhost ~<span>]</span><span># dd if=/dev/cdrom of=/tmp/cd.iso</span>
<span>#把光盘中所有的数据制作成ISO镜像</span>
<span>[</span>root@localhost ~J <span># mkdir /mnt/cd</span>
<span>#建立一个新的挂载点</span>
<span>[</span>root@localhost ~<span>]</span><span># mount -o loop /tmp/cd.iso /mnt/cd</span>
<span>#挂栽ISO文件到挂载点</span>
<span>[</span>root@localhost ~<span>]</span><span># cd /mnt/cd</span>
<span>#进入挂栽点</span>
<span>[</span>root@localhost cd<span>]</span><span># ls</span>
CentOS_BuildTag images RELEASE-NOTES-en-tJS.html RPM-GPG-KEY-CentOS-Debug-6 TRANS.TBL
EULA    isolinux repodata   RPM-GPG-KEY-CentOS-Security-6
GPL Packages RPM-GPG-KEY-CentOS-6 RPM-GPG-KEY-CentOS-Testing-6
<span>#数据是光盘当中的数据,这个ISO镜像是可以被当作真正的光盘使用的</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h4 id="其他"> 其他</h4>
<p>我们有时需要制作指定大小的文件，比如，在增加 swap 分区时，就需要建立指定大小的文件，这时也使用 <code>dd</code> 命令。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># dd if=/dev/zero of=/tmp/testfile bs=1M count=10</span>
<span>#数据输入项是/dev/zero会向目标文件中不停地写入二进制的0</span>
<span>#指定数据块大小是1MB</span>
<span>#指定生成10个数据块。也就是定义输出的文件大小为10MB</span>
记录了10+0 的读入
<span>#显示数据占满了10个数据块</span>
记录了10+0 的写出
<span>#不过这里数据块的大小已经是1MB了</span>
<span>10485760</span>字节<span>(</span><span>10</span> MB<span>)</span>已复制，0.00709902 秒，1.5 GB/秒
<span>[</span>root@localhost ~<span>]</span><span># ll -h /tmp/testfile</span>
-rw-r--r--.1 root root 10M <span>6</span>月 <span>5</span> <span>18</span>：46 /tmp/testfile
<span>#生成的testfile文件的大小刚好是10MB</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><code>dd</code> 命令在进行整盘复制时，类似于 GHOST 工具的功能，不过通过 <code>dd</code> 命令复制出来的硬盘数据要比 GHOST 复制出来的硬盘数据稳定得多。虽然 <code>dd</code> 命令功能强大，不过也有一个明显的缺点，就是复制的时间较长，复制 100GB 的数据需要 15～25 分钟（根据服务器的性能不同而不同）。</p>
<p>实现数据备份还有非常多的方法和工具，比如 <code>tar</code> 和 <code>cpio</code> 命令。至于网络复制工具，如 rsync 和 scp 等，需要较完善的网络知识才能够学习，这里不再介绍。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2022-01-26T06:11:29.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">SELinux管理</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_manage/08.SELinux/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_manage/08.SELinux/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>root 用户实在是一个超人，它在 Linux 系统当中就是无所不能的，而且读、写和执行权限对 root 用户完全没有作用。root 用户的存在极大地方便了 Linux 的管理，但是也造成了一定的安全隐患。</p>
<p>大家想象一下，如果 root 用户被盗用了，或者 root 用户本身对 Linux 并不熟悉，在管理 Linux 的过程中产生了误操作，则会造成什么样的后果？</p>
<p>其实绝大多数系统的严重错误都是由于 root 用户的误操作引起的，来自外部的攻击产生的影响反而不是那么严重。root 用户的权限过高了，一些看似简单、微小的操作，都很有可能对系统产生重大的影响。最常见的错误就是 root 用户为了管理方便，给重要的系统文件或系统目录设置了 777 权限，这会造成严重的安全隐患。</p>
<p>SELinux 是由美国国家安全局（NSA）开发的，整合在 Linux 内核当中，针对特定的进程与指定的文件资源进行权限控制的系统。即使你是 root 用户，也必须遵守 SELinux 的规则，才能正确访问正确的资源，这样可以有效地防止 root 用户的误操作（当然，root 用户可以修改 SELinux 的规则）。</p>
<p>需要注意的是，系统的默认权限还是会生效的，也就是说，用户既要符合系统的读、写、执行权限，又要符合 SELinux 的规则，才能正确地访问系统资源。</p>
<h2 id="selinux-是什么"> SELinux 是什么</h2>
<p>SELinux，Security Enhanced Linux 的缩写，也就是安全强化的 Linux，是由美国国家安全局（NSA）联合其他安全机构（比如 SCC 公司）共同开发的，旨在增强传统 Linux 操作系统的安全性，解决传统 Linux 系统中自主访问控制（DAC）系统中的各种权限问题（如 root 权限过高等）。</p>
<p>SELinux 项目在 2000 年以 GPL 协议的形式开源，当 Red Hat 在其 Linux 发行版本中包括了 SELinux 之后，SELinux 才逐步变得流行起来。现在，SELinux 已经被许多组织广泛使用，几乎所有的 Linux  内核 2.6 以上版本，都集成了 SELinux 功能。</p>
<p><strong>对于 SELinux，初学者可以这么理解，它是部署在 Linux 上用于增强系统安全的功能模块。</strong></p>
<p>我们知道，传统的 Linux 系统中，默认权限是对文件或目录的所有者、所属组和其他人的读、写和执行权限进行控制，这种控制方式称为自主访问控制（DAC）方式；而在 SELinux 中，采用的是强制访问控制（MAC）系统，也就是控制一个进程对具体文件系统上面的文件或目录是否拥有访问权限，而判断进程是否可以访问文件或目录的依据，取决于 SELinux 中设定的很多策略规则。</p>
<p>说到这里，就有必要详细地了解一下这两个访问控制系统的特点：</p>
<ul>
<li>自主访问控制系统（Discretionary Access Control，DAC）是 Linux 的默认访问控制方式，也就是依据用户的身份和该身份对文件及目录的 rwx 权限来判断是否可以访问。不过，在 DAC 访问控制的实际使用中我们也发现了一些问题：
<ul>
<li>root 权限过高，rwx 权限对 root 用户并不生效，一旦 root 用户被窃取或者 root 用户本身的误操作，都是对 Linux 系统的致命威胁。</li>
<li>Linux 默认权限过于简单，只有所有者、所属组和其他人的身份，权限也只有读、写和执行权限，并不利于权限细分与设定。</li>
<li>不合理权限的分配会导致严重后果，比如给系统敏感文件或目录设定 777 权限，或给敏感文件设定特殊权限——SetUID 权限等。</li>
</ul>
</li>
<li>强制访问控制（Mandatory Access Control，MAC）是通过 SELinux 的默认策略规则来控制特定的进程对系统的文件资源的访问。也就是说，即使你是 root 用户，但是当你访问文件资源时，如果使用了不正确的进程，那么也是不能访问这个文件资源的。这样一来，SELinux 控制的就不单单只是用户及权限，还有进程。每个进程能够访问哪个文件资源，以及每个文件资源可以被哪些进程访问，都靠 SELinux 的规则策略来确定。注意，在 SELinux 中，Linux 的默认权限还是有作用的，也就是说，一个用户要能访问一个文件，既要求这个用户的权限符合 rwx 权限，也要求这个用户的进程符合 SELinux 的规定。
不过，系统中有这么多的进程，也有这么多的文件，如果手工来进行分配和指定，那么工作量过大。所以 SELinux 提供了很多的默认策略规则，这些策略规则已经设定得比较完善，我们稍后再来学习如何查看和管理这些策略规则。</li>
</ul>
<p>为了使读者清楚地了解 SELinux 所扮演的角色，这里举一个例子，假设 apache 上发现了一个漏洞，使得某个远程用户可以访问系统的敏感文件（如 <code>/etc/shadow</code>）。如果我们的 Linux 中启用了 SELinux，那么，因为 apache 服务的进程并不具备访问 <code>/etc/shadow</code> 的权限，所以这个远程用户通过 apache 访问 <code>/etc/shadow</code> 文件就会被 SELinux 所阻挡，起到保护 Linux 系统的作用。</p>
<p>通过以上的介绍，应该对 SELinux 有了初步的认识，下面我们再通过了解 SELinux 的工作模式，细致了解 SELinux。</p>
<h2 id="selinux的主要作用"> SELinux的主要作用</h2>
<p>我们知道，传统的 Linux 系统安全，采用的是 DAC（自主访问控制方式），而 SELinux 是部署在 Linux 系统中的安全增强功能模块，它通过对进程和文件资源采用 MAC（强制访问控制方式）为 Linux 系统提供了改进的安全性。</p>
<p>需要注意的是，SELinux 的 MAC 并不会完全取代 DAC，恰恰相反，对于 Linux  系统安全来说，它是一个额外的安全层，换句话说，当使用 SELinux 时，DAC 仍然被使用，且会首先被使用，如果允许访问，再使用 SELinux 策略；反之，如果 DAC 规则拒绝访问，则根本无需使用 SELinux 策略。</p>
<p>例如，若用户尝试对没有执行权限（rw-）的文件进行执行操作，那么传统的 DAC 规则就会拒绝用户访问，因此，也就无需再使用 SELinux 策略。</p>
<p>相比传统的 Linux DAC 安全控制方式，SELinux 具有诸多好处，比如说：</p>
<ul>
<li>它使用的是 MAC 控制方式，这被认为是最强的访问控制方式；</li>
<li>它赋予了主体（用户或进程）最小的访问特权，这也就意味着，每个主体仅被赋予了完成相关任务所必须的一组有限的权限。通过赋予最小访问特权，可以防止主体对其他用户或进程产生不利的影响；</li>
<li>SELinux 管理过程中，每个进程都有自己的运行区域（称为域），各进程仅运行在自己的域内，无法访问其他进程和文件，除非被授予了特殊权限。</li>
<li>SELinux 可以调整到 Permissive 模式，此模式允许查看在系统上执行 SELinux 后所产生的影响。在 Permissive 模式中，SELinux 仍然会记录它所认为的安全漏洞，但并不会阻止它们。</li>
</ul>
<p>有关 SELinux 模式设置等内容，后面会详细介绍。</p>
<p>其实，想要了解 SELinux 的优点，最直接的办法就是查看当 Linux 系统上没有运行 SELinux 时会发生什么事情。</p>
<p>例如，Web 服务器守护进程（httpd）正在监听某一端口上所发生的事情，而后进来了一个请求查看主页的来自 Web 浏览器的简单请求。由于不会受到 SELinux 的约束，httpd 守护进程听到请求后，可以完成以下事情：</p>
<ol>
<li>根据相关的所有者和所属组的 rwx 权限，可以访问任何文件或目录；</li>
<li>完成存在安全隐患的活动，比如允许上传文件或更改系统显示；</li>
<li>可以监听任何端口的传入请求。</li>
</ol>
<p>但在一个受 SELinux 约束的系统上，httpd 守护进程受到了更加严格的控制。仍然使用上面的示例，httpd仅能监听 SELinux  允许其监听的端口。SELinux 还可以防止 httpd 访问任何没有正确设置安全上下文的文件，并拒绝没有再 SELinux 中显式启用的不安全活动。</p>
<p>因此，从本质上讲，SELinux 最大程序上限制了 Linux 系统中的恶意代码活动。</p>
<h2 id="selinux-的运行模式"> SELinux 的运行模式</h2>
<p>通过对 SELinux 的介绍，初学者可以这样认为，在传统 Linux 系统使用访问控制方式的基础上，附加使用 SELinux 可增强系统安全。 那么，SELinux 是如何运行的呢？</p>
<p>在解释 SELinux 的工作模式之前，先解释几个概念。</p>
<ol>
<li>主体（Subject）：就是想要访问文件或目录资源的进程。想要得到资源，基本流程是这样的：由用户调用命令，由命令产生进程，由进程去访问文件或目录资源。在自主访问控制系统中（Linux 默认权限中），靠权限控制的主体是用户；而在强制访问控制系统中（SELinux 中），靠策略规则控制的主体则是进程。</li>
<li>目标（Object）：这个概念比较明确，就是需要访问的文件或目录资源。</li>
<li>策略（Policy）：Linux 系统中进程与文件的数量庞大，那么限制进程是否可以访问文件的 SELinux 规则数量就更加烦琐，如果每个规则都需要管理员手工设定，那么 SELinux 的可用性就会极低。还好我们不用手工定义规则，SELinux 默认定义了两个策略，规则都已经在这两个策略中写好了，默认只要调用策略就可以正常使用了。这两个默认策略如下：
<ul>
<li>-targeted：这是 SELinux 的默认策略，这个策略主要是限制网络服务的，对本机系统的限制极少。我们使用这个策略已经足够了。</li>
<li>-mls：多级安全保护策略，这个策略限制得更为严格。</li>
</ul>
</li>
<li>安全上下文（Security Context）：每个进程、文件和目录都有自己的安全上下文，进程具体是否能够访问文件或目录，就要看这个安全上下文是否匹配。如果进程的安全上下文和文件或目录的安全上下文能够匹配，则该进程可以访问这个文件或目录。当然，判断进程的安全上下文和文件或目录的安全上下文是否匹配，则需要依靠策略中的规则。举个例子，我们需要找对象，男人可以看作主体，女人就是目标了。而男人是否可以追到女人（主体是否可以访问目标），主要看两个人的性格是否合适（主体和目标的安全上下文是否匹配）。不过，两个人的性格是否合适，是需要靠生活习惯、为人处世、家庭环境等具体的条件来进行判断的（安全上下文是否匹配是需要通过策略中的规则来确定的）。</li>
</ol>
<p>我们画一张示意图，来表示一下这几个概念之间的关系，如图9-1 所示。</p>
<div>
<p><img src="./assets/selinux.jpg" alt="selinux" loading="lazy"></p>
<p><strong>图9-1	<u>SELinux 运行模式的相关概念</u></strong></p>
</div>
<p>解释一下这张示意图：当主体想要访问目标时，如果系统中启动了 SELinux，则主体的访问请求首先需要和 SELinux  中定义好的策略进行匹配。如果进程符合策略中定义好的规则，则允许访问，这时进程的安全上下文就可以和目标的安全上下文进行匹配；如果比较失败，则拒绝访问，并通过 AVC（Access Vector Cache，访问向量缓存，主要用于记录所有和 SELinux  相关的访问统计信息）生成拒绝访问信息。如果安全上下文匹配，则可以正常访问目标文件。当然，最终是否可以真正地访问到目标文件，还要匹配产生进程（主体）的用户是否对目标文件拥有合理的读、写、执行权限。</p>
<p>我们在进行 SELinux  管理的时候，一般只会修改文件或目录的安全上下文，使其和访问进程的安全上下文匹配或不匹配，用来控制进程是否可以访问文件或目录资源；而很少会去修改策略中的具体规则，因为规则实在太多了，修改起来过于复杂。不过，我们是可以人为定义规则是否生效，用以控制规则的启用与关闭的。</p>
<h2 id="selinux-的工作模式"> SELinux 的工作模式</h2>
<p>SELinux 提供了 3 种工作模式：Disabled、Permissive 和 Enforcing，而每种模式都为 Linux 系统安全提供了不同的好处。</p>
<h3 id="disable-工作模式-关闭模式"> Disable 工作模式（关闭模式）</h3>
<p>在 Disable 模式中，SELinux 被关闭，默认的 DAC 访问控制方式被使用。对于那些不需要增强安全性的环境来说，该模式是非常有用的。</p>
<p>例如，若从你的角度看正在运行的应用程序工作正常，但是却产生了大量的 SELinux AVC  拒绝消息，最终可能会填满日志文件，从而导致系统无法使用。在这种情况下，最直接的解决方法就是禁用 SELinux，当然，你也可以在应用程序所访问的文件上设置正确的安全上下文。</p>
<p>需要注意的是，在禁用 SELinux 之前，需要考虑一下是否可能会在系统上再次使用 SELinux，如果决定以后将其设置为 Enforcing 或 Permissive，那么当下次重启系统时，系统将会通过一个自动 SELinux 文件重新进程标记。</p>
<p>关闭 SELinux 的方式也很简单，只需编辑配置文件 <code>/etc/selinux/config</code>，并将文本中 SELINUX= 更改为 SELINUX=disabled 即可，重启系统后，SELinux 就被禁用了。</p>
<h3 id="permissive-工作模式-宽容模式"> Permissive 工作模式（宽容模式）</h3>
<p>在 Permissive 模式中，SELinux 被启用，但安全策略规则并没有被强制执行。当安全策略规则应该拒绝访问时，访问仍然被允许。然而，此时会向日志文件发送一条消息，表示该访问应该被拒绝。</p>
<p>SELinux Permissive 模式主要用于以下几种情况：</p>
<ul>
<li>审核当前的 SELinux 策略规则；</li>
<li>测试新应用程序，看看将 SELinux 策略规则应用到这些程序时会有什么效果；</li>
<li>解决某一特定服务或应用程序在 SELinux 下不再正常工作的故障。</li>
</ul>
<p>某些情况下，可使用 <code>audit2allow</code> 命令来读取 SELinux 审核日志并生成新的 SELinux 规则，从而有选择性地允许被拒绝的行为，而这也是一种在不禁用 SELinux 的情况下，让应用程序在 Linux 系统上工作的快速方法。</p>
<h3 id="enforcing-工作模式-强制模式"> Enforcing 工作模式（强制模式）</h3>
<p>从此模式的名称就可以看出，在 Enforcing 模式中， SELinux 被启动，并强制执行所有的安全策略规则。</p>
<h2 id="selinux-配置文件"> SELinux 配置文件</h2>
<p>我们知道，SELinux 是预先配置的，可以在不进行任何手动配置的情况下使用 SELinux 功能。然而，一般来说，预先配置的 SELinux 设置很难满足所有的 Linux 系统安全需求。</p>
<p>SELinux 配置只能有 root 用户进行设置和修改。配置和策略文件位于 <code>/etc/selinux</code> 目录中，主配置文件位 <code>/etc/selinux/config</code> 文件，该文件中的内容如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vim /etc/selinux/config</span>
<span># This file controls the state of SELinux on the system.</span>
<span># SELINUX= can take one of these three values：</span>
<span>#	enforcing - SELinux security policy is enforced.</span>
<span>#	permissive - SELinux prints warnings instead of enforcing.</span>
<span>#	disabled - No SELinux policy is loaded.</span>

<span>SELINUX</span><span>=</span>enforcing
<span>#指定SELinux的运行模式。有enforcing（强制模式）、permissive（宽容模式）、disabled（不生效）三种模式</span>

<span># SELINUXTYPE= can take one of these two values：</span>
<span>#	targeted - Targeted processes are protected，</span>
<span>#	mls - Multi Level Security protection.</span>
<span>SELINUXTYPE</span><span>=</span>targeted
<span>#指定SELinux的默认策略。有 targeted（针对性保护策略，是默认策略）和 mls（多级安全保护策略）两种策略</span>
<span>#主配置文件中，除去以‘#’符号开头的注释行，有效配置参数仅有 2 行。</span>
其中，SELinux<span>=</span>enforcing 为 SELinux 默认的工作模式，有效值还可以是 permissive 和 disabled；
<span>SELINUXTYPE</span><span>=</span>targeted 用于指定 SELinux 的默认策略。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>这里需要注意，如果从强制模式（enforcing）、宽容模式（permissive）切换到关闭模式（disabled），或者从关闭模式切换到其他两种模式，则必须重启 Linux 系统才能生效，但是强制模式和宽容模式这两种模式互相切换不用重启 Linux 系统就可以生效。这是因为 SELinux 是整合到 Linux 内核中的，所以必须重启才能正确关闭和启动。而且，如果从关闭模式切换到启动模式，那么重启 Linux 系统的速度会比较慢，那是因为需要重新写入安全上下文信息。</p>
<h2 id="selinux-工作模式设置"> SELinux 工作模式设置</h2>
<p>除了通过配置文件可以对 SELinux 进行工作模式的修改之外，还可以使用命令查看和修改 SELinux 工作模式。</p>
<p>首先，查看系统当前 SELinux 的工作模式，可以使用 <code>getenforce</code> 命令；而如果想要查看配置文件中的当前模式和模式设置，可以使用 <code>sestatus</code> 命令，下面的代码显示了这两个命令：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># getenforce</span>
<span>#查询SELinux的运行模式</span>
Enforcing
<span>#当前的SELinux是强制模式</span>
<span>[</span>root@localhost ~<span>]</span><span># sestatus</span>
SELinux status:				enabled
SELinuxfs mount:			/selinux
Current mode:				enforcing
Mode from config file:		enforcing
Policy version:				<span>24</span>
Policy from config file:	targeted
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>除可以查询 SELinux 的运行模式之外，也可以修改 SELinux 的运行模式，即使用 <code>setenforce</code> 命令。不过需要注意，<code>setenforce</code> 命令只能让 SELinux 在 enforcing 和 permissive  两种模式之间进行切换。如果从启动切换到关闭，或从关闭切换到启动，则只能修改配置文件，<code>setenforce</code> 命令就无能为力了。</p>
<p><code>setenforce</code> 命令的基本格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># setenforce 选项</span>
选项：
	<span>0</span>： 切换成 permissive（宽容模式）；
	<span>1</span>： 切换成 enforcing（强制模式）；
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># setenforce 0</span>
<span>#切换成宽容模式</span>
<span>[</span>root@localhost ~<span>]</span><span># getenforce</span>
Permissive
<span>[</span>root@localhost ~<span>]</span><span># setenforce 1</span>
<span>#切换成强制模式</span>
<span>[</span>root@localhost ~<span>]</span><span># getenforce</span>
Enforcing
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="selinux-安全上下文管理"> SELinux 安全上下文管理</h2>
<p>SELinux 管理过程中，进程是否可以正确地访问文件资源，取决于它们的安全上下文。进程和文件都有自己的安全上下文，SELinux  会为进程和文件添加安全信息标签，比如 SELinux 用户、角色、类型、类别等，当运行 SELinux 后，所有这些信息都将作为访问控制的依据。</p>
<p>首先，通过一个实例看看如何查看文件和目录的安全上下文，执行命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls -Z</span>
<span>#使用选项-Z查看文件和目录的安全上下文</span>
-rw-------．root root system_u:object_r:admin_home_t:s0 anaconda-ks.cfg
-rw-r--r--．root root system_u:object_r:admin_home_t:s0 install.log
-rw-r--r--．root root system_u:object_r:admin_home_t:s0 install.log.syslog
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>可以看到，查看文件的安全上下文非常简单，就是使用 <code>ls -Z</code> 命令。而在此基础上，如果想要查看目录的安全上下文，需要添加“-d”选项，代表查看目录本身，而非目录下的子文件。举个例子：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls -Zd /var/www/html/</span>
drwxr-xr-x．root root system_u:object_r:httpd_sys_content_t:s0 /var/www/html/
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>那么，该如何查看进程的安全上下文呢？只需使用 <code>ps</code> 命令即可。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># service httpd start</span>
<span>#启动apache服务</span>
<span>[</span>root@localhost ~<span>]</span><span># ps auxZ | grep httpd</span>
unconfined_u:system_r:httpd_t:s0 root <span>25620</span> <span>0.0</span> <span>0.5</span> <span>11188</span> <span>3304</span> ? Ss 03:44 <span>0</span>:02 /usr/sbin/httpd
<span>..</span>.省略部分输出<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>也就是说，只要进程和文件的安全上下文匹配，该进程就可以访问该文件资源。在上面的命令输出中，我们加粗的就是安全上下文。</p>
<p>安全上下文看起来比较复杂，它使用“:”分隔为 4 个字段，其实共有 5 个字段，只是最后一个“类别”字段是可选的，例如：</p>
<div><pre><code>system_u:object_r:httpd_sys_content_t:s0:<span>[</span>类别<span>]</span>
<span>#身份字段:角色:类型:灵敏度:[类别]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>下面对这 5 个字段的作用进行说明。</p>
<h3 id="_1-身份字段-user"> 1) 身份字段（user)</h3>
<p>用于标识该数据被哪个身份所拥有，相当于权限中的用户身份。这个字段并没有特别的作用，知道就好。常见的身份类型有以下 3 种：</p>
<ol>
<li>- root：表示安全上下文的身份是 root。</li>
<li>- system_u：表示系统用户身份，其中“_u”代表 user。</li>
<li>- user_u：表示与一般用户账号相关的身份，其中“_u”代表 user。</li>
</ol>
<p>user 字段只用于标识数据或进程被哪个身份所拥有，一般系统数据的 user 字段就是 system_u，而用户数据的 user 字段就是 user_u。</p>
<p>那么，SELinux 中到底可以识别多少用户身份字段呢？我们可以使用 <code>seinfo</code> 命令来进行查询。SELinux 的相关命令一般都是以“se”开头的，所以也较为好记。</p>
<p><code>seinfo</code> 命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># seinfo [选项]</span>
 选项：
 	-u： 列出SELinux中所有的身份（user）；
 	-r： 列出SELinux中所有的角色（role）；
 	-t： 列出SELinux中所有的类型（type）；
 	-b： 列出所有的布尔值（也就是策略中的具体规则名称）；
 	-x： 显示更多的信息；
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><code>seinfo</code> 命令的功能较多，我们在这里只想查询 SELinux 中的身份，那么只需执行如下命令：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># seinfo -u</span>
Users：9
	sysadm_u
	system_u
	xguest_u
	root
	guest_u
	staff_u
	user_u
	unconfined_u
	git_shell_u
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>就可以看到 SELinux 中能够识别的 user 身份共有 9 种。不过这个字段在实际使用中并没有太多的作用，了解一下即可。</p>
<h3 id="_2-角色-role"> 2) 角色（role）</h3>
<p>主要用来表示此数据是进程还是文件或目录。这个字段在实际使用中也不需要修改，所以了解就好。</p>
<p>常见的角色有以下两种：</p>
<ul>
<li>- object_r：代表该数据是文件或目录，这里的“_r”代表 role。</li>
<li>- system_r：代表该数据是进程，这里的“_r”代表 role。</li>
</ul>
<p>那么，SELinux 中到底有多少种角色呢？使用 <code>seinfo</code> 命令也可以查询，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># seinfo -r</span>
Roles：12
	guest_r
	staff_r
	user_r
	git_shell_r
	logadm_r
	object_r
	sysadm_r
	system_r
	webadm_r
	xguest_r
	nx_server_r
	unconfined_r
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="_3-类型-type"> 3) 类型（type）</h3>
<p>类型字段是安全上下文中最重要的字段，进程是否可以访问文件，主要就是看进程的安全上下文类型字段是否和文件的安全上下文类型字段相匹配，如果匹配则可以访问。</p>
<p>注意，类型字段在文件或目录的安全上下文中被称作类型（type），但是在进程的安全上下文中被称作域（domain）。也就是说，在主体（Subject）的安全上下文中，这个字段被称为域；在目标（Object）的安全上下文中，这个字段被称为类型。域和类型需要匹配（进程的类型要和文件的类型相匹配），才能正确访问。</p>
<p>SELinux 中到底有多少类型也是通过 <code>seinfo</code> 命令查询的，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># seinfo -t | more</span>
Types：3488
<span>#共有3488个类型</span>
	bluetooth_conf_t
	cmirrord_exec_t
	foghorn_exec_t
	jacorb_port_t
	sosreport_t
	etc_runtime_t
	<span>..</span>.省略部分输出<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>我们知道了类型的作用，可是我们怎么知道进程的域和文件的类型是否匹配呢？这就要查询具体的策略规则了，我们在后面再进行介绍。</p>
<p>不过，我们已知 apache 进程可以访问 <code>/var/www/html/</code>（此目录为 RPM 包安装的 apache 的默认网页主目录）目录中的网页文件，所以 apache 进程的域和 <code>/var/www/html/</code> 目录的类型应该是匹配的，我们查询一下，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ps auxZ | grep httpd</span>
unconfined_u：system_r：httpd_t：s0 root <span>25620</span> <span>0.0</span> <span>0.5</span> <span>11188</span> <span>3304</span> ? Ss
03：44 <span>0</span>：02 /usr/sbin/httpd
<span>#apache进程的域是httpd_t</span>
<span>[</span>root@localhost ~<span>]</span><span># ls -dZ /var/www/html/</span>
drwxr-xr-x．root root system_u：object_r：httpd_sys_content_t：s0 /var/www/html/
<span>#/var/www/html/目录的类型是httpd_sys_content_t</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>apache 进程的域是 httpd_t，<code>/var/www/html/</code> 目录的类型是  httpd_sys_content_t，这个主体的安全上下文类型经过策略规则的比对，是和目标的安全上下文类型匹配的，所以 apache  进程可以访问 <code>/var/www/html/</code> 目录。</p>
<p>我们在 SELinux 中最常遇到的问题就是进程的域和文件的类型不匹配，所以我们一定要掌握如何修改类型字段。</p>
<h3 id="_4-灵敏度"> 4) 灵敏度</h3>
<p>灵敏度一般是用 s0、s1、s2 来命名的，数字代表灵敏度的分级。数值越大，代表灵敏度越高。</p>
<h3 id="_5-类别"> 5) 类别</h3>
<p>类别字段不是必须有的，所以我们使用 <code>ls</code> 和 <code>ps</code> 命令查询的时候并没有看到类别字段。但是我们可以通过 <code>seinfo</code> 命令来查询，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># seinfo -u -x</span>
<span>#查询所有的user字段，并查看详细信息</span>
system_u							<span>#user字段名</span>
	default level：s0				<span>#默认灵敏度</span>
	range：s0 - s0：c0.c1023		<span>#灵敏度可以识别的类别</span>
	roles：							<span>#该user能够匹配的role（角色）</span>
		object_r
		system_r
		unconfined_r
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="修改和设置安全上下文的"> 修改和设置安全上下文的</h2>
<p>安全上下文的修改是我们必须掌握的，其实也并不难，主要是通过两个命令来实现的。</p>
<p><code>chcon</code> 命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># chcon [选项] 文件或目录</span>
选项：
	-R： 递归，当前目录和目录下的所有子文件同时设置；
	-t： 修改安全上下文的类型字段，最常用；
	-u： 修改安全上下文的身份字段；
	-r： 修改安全上下文的角色字段；
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>举个例子：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># echo'test page！！！' >> /var/www/html/index.html</span>
<span>#建立一个网页文件，并写入“test page！！！”</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>我们可以通过浏览器查看这个网页，只需在浏览器的 URL 中输入“http://ip”即可，如图9-2 所示。</p>
<div>
<p><img src="./assets/seapache.jpg" alt="seapache" loading="lazy"></p>
<p><strong>图9-2 <u>访问 apache 测试页</u></strong></p>
</div>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls -Z /var/www/html/index.html</span>
-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 /var/www/html/index.html
<span>#这个网页文件的模式类别是httpd_sys_content_t</span>
<span>[</span>root@localhost ~<span>]</span><span># seinfo -t I grep var_t</span>
<span>#查询SELinun中所有的类型、发现有一个类型叫var_t</span>
<span>[</span>root@localhost ~<span>]</span><span># chcon -t var_t /var/www/html/index.html</span>
<span>#把网页文件的类型修改为var_t类型</span>
<span>[</span>root@localhost ~<span>]</span><span># ls -Z /var/www/html/index.html</span>
-rw-r--r--. toot root unconfined_u:object_r:var_t:s0 /var/www/html/index.html
<span>#这个网页的类型已经被修改了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>我们把网页文件的类型修改了，这样 apache 进程的安全上下文一定不能匹配网页的安全上下文，就会出现如图9-3 所示的情况。</p>
<div>
<p><img src="./assets/seapache2.jpg" alt="seapache2" loading="lazy"></p>
<p><strong>图9-3	<u>拒绝访问</u></strong></p>
</div>
<p>这时网页就会提示权限拒绝，这里我们已经知道是安全上下文不匹配惹的祸！当然，我们可以通过 <code>chcon</code> 命令修改回来就可以修复。不过，我们还有一个命令 <code>restorecon</code>，这个命令的作用就是把文件的安全上下文恢复成默认的安全上下文。SELinux 的安全上下文设定非常完善，所以使用 <code>restorecon</code> 命令就可以修复安全上下文不匹配所引起的问题。</p>
<p><code>restorecon</code> 命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span> <span># restorecon [选项】 文件或目录</span>
选项：
	-R：递归.当前目录和目录下所有的子文件同时恢复；
	-V：把恢复过程显示到屏幕上；
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>例如：</p>
<div><pre><code><span>[</span>root@1ocalhost ~<span>]</span><span># restorecon -Rv /var/www/html/index.html</span>
restorecon reset  /var/www/html/index.html  context
unconfined_u:object_r:var_t:s0-<span>></span>unconfined_u:object_r:httpd_sys_content_t:s0
<span>#这里已经提示了安全上下文从var_t恢复成了httpd_sys_content_t</span>
<span>[</span>root@1ocalhost ~<span>]</span><span># ls -Z /var/www/html/index.html</span>
-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 /var/www/html/index.html
<span>#查看一下，安全上下文已经恢复正常了.网页的访问也已经恢复正常了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="查询和修改默认安全上下文"> 查询和修改默认安全上下文</h2>
<p>前面讲到，<code>restorecon</code> 命令可以将文件或目录恢复成默认的安全上下文，这就说明每个文件和目录都有自己的默认安全上下文，事实也是如此，为了管理的便捷，系统给所有的系统默认文件和目录都定义了默认的安全上下文。</p>
<p>那么，默认安全上下文该如何查询和修改呢？这就要使用 <code>semanage</code> 命令了。该命令的基本格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># semanage fcontext -l</span>
<span>#其中，fcontext 主要用于安全上下文方面，-l 是查询的意思。</span>

<span>[</span>root@localhost ~<span>]</span><span># semanage fcontext [选项] [-first] file_spec</span>
选项：
	-a：添加默认安全上下文配置
	-d：删除指定的默认安全上下文
	-m：修改指定的默认安全上下文
	-t：设定默认安全上下文的类型
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="查询默认安全上下文"> 查询默认安全上下文</h3>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># semanage fcontext -l</span>
<span>#查询所有的默认安全上下文</span>
<span>..</span>.省略部分输出<span>..</span>.
/var/www<span>(</span>/.*<span>)</span>? all files
system_u：object_r：httpd_sys_content_t：s0
<span>..</span>.省略部分输出<span>..</span>.
<span>#能够看到/var/www/目录下所有内容的默认安全上下文都是httpd_sys_content_t</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>所以，一旦对 <code>/var/www/</code> 目录下文件的安全上下文进行了修改，就可以使用 <code>restorecon</code> 命令进行恢复，因为默认安全上下文已经明确定义了。</p>
<h3 id="修改默认安全上下文"> 修改默认安全上下文</h3>
<p>那么，可以修改目录的默认安全上下文吗？当然可以，举个例子：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mkdir /www</span>
<span>#新建/www/目录，打算用这个目录作为apache的网页主目录，而不再使用/var/www/html/目录</span>
<span>[</span>root@localhost ~<span>]</span><span># ls -Zd /www/</span>
drwxr-xr-x．root root unconfined_u：object_r：default_t：s0 /www/
<span>#而这个目录的安全上下文类型是default_t，那么apache进程当然就不能访问和使用/www/目录了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这时我们可以直接设置 <code>/www/</code> 目录的安全上下文类型为 httpd_sys_content_t，但是为了以后管理方便，我打算修改 <code>/www/</code> 目录的默认安全上下文类型。先查询一下 <code>/www/</code> 目录的默认安全上下文类型，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># semanage fcontext -l | grep "/www"</span>
<span>#查询/www/目录的默认安全上下文</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>查询出了一堆结果，但是并没有 <code>/www/</code> 目录的默认安全上下文，因为这个目录是手工建立的，并不是系统默认目录，所以并没有默认安全上下文，需要我们手工设定。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># semanage fcontext -a -t httpd_sys_content_t "/www(/.*)?"</span>
<span>#这条命令会给/www/目录及目录下的所有内容设定默认安全上下文类型是httpd_sys_content_t</span>
<span>[</span>root@localhost ~<span># semanage fcontext -l | grep "/www"</span>
<span>..</span>.省略部分输出<span>..</span>.
/www<span>(</span>/.*<span>)</span>? all files system_u：object_r：httpd_sys_content_t：s0
<span>#/www/目录的默认安全上下文出现了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>这时已经设定好了 <code>/www/</code> 目录的默认安全上下文。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls -Zd /www/</span>
drwxr-xr-x．root root unconfined_u：object_r：default_t：s0 /www/
<span>#但是查询发现/www/目录的安全上下文并没有进行修改，那是因为我们只修改了默认安全上下文，而没有修改目录的当前安全上下文</span>
<span>[</span>root@localhost ~<span>]</span><span># restorecon -Rv /www/</span>
restorecon reset /www context
unconfined_u：object_r：default_t：s0-<span>></span>unconfined_u：object_r：httpd_sys_content_t：s0
<span>#恢复一下/www/目录的默认安全上下文，发现类型已经被修改为httpd_sys_content_t</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>默认安全上下文的设定就这么简单。</p>
<h2 id="selinux-日志查看"> SELinux 日志查看</h2>
<p>在实际的生产服务器上，一旦 SELinux 出现了问题，我们该如何判断问题出现在哪里？又该如何修改呢？这时我们就要求助 SELinux 的日志系统了，在日志系统中详细地记录了 SELinux 中出现的问题，并提供了解决建议。</p>
<h3 id="auditd-的安装与启动"> auditd 的安装与启动</h3>
<p>我们当前可以使用的日志系统只有 auditd，当然这个服务是需要安装的，在我们的系统中 auditd 服务是已经安装的。如果没有安装，则使用 yum 安装即可。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># yum -y install auditd</span>
</code></pre>
<div><span>1</span><br></div></div><p>安装完成之后，只需启动 auditd 服务即可。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># service auditd start</span>
</code></pre>
<div><span>1</span><br></div></div><p>当然，还要使 auditd 服务是开机自启动的。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># chkconfig auditd on</span>
<span>[</span>root@localhost ~<span>]</span><span># chkconfig --list | grep auditd</span>
auditd <span>0</span>:关闭 <span>1</span>:关闭 <span>2</span>:启用 <span>3</span>:启用 <span>4</span>:启用 <span>5</span>:启用 <span>6</span>:关闭
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>其实这些工作，系统都已经帮我们完成了，不过为了保险起见，最好还是检查一下。</p>
<h3 id="auditd-日志使用"> auditd 日志使用</h3>
<p>auditd 会把 SELinux 的信息都记录在 <code>/var/log/auditd/auditd.log</code> 中。这个文件中记录的信息会非常多，如果手工查看，则效率将非常低下。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ll -h /var/log/audit/audit.log</span>
-rw-------.1 root root 386K <span>6</span>月 <span>5</span> <span>15</span>：53 /var/log/audit/audit.log
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>而且我们这里的 Linux 只是实验用的虚拟机，如果是真正的生产服务器，那么这个日志的大小将更加恐怖（注意：audit.log 并没有自动加入  logrotate 日志轮替当中，需要手工让这个日志进行轮替）。所以，如果我们手工查看这个日志，那么效率会非常低下。</p>
<p>还好，Linux 较为人性化，给我们准备了几个工具，来帮助我们分析这个日志，下面分别来学习一下。</p>
<h3 id="audit2why-命令"> audit2why 命令</h3>
<p><code>audit2why</code> 命令用来分析 audit.log 日志文件，并分析 SELinux 为什么会拒绝进程的访问。也就是说，这个命令显示的都是 SELinux 的拒绝访问信息，而正确的信息会被忽略。命令的格式也非常简单，如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># audit2why &lt; 日志文件名</span>

例如：
<span>[</span>root@localhost ~<span>]</span><span># audit2why &lt; /var/log/audit/audit.log</span>
<span>type</span><span>=</span>AVC <span>msg</span><span>=</span>audit<span>(</span><span>1370412789.400</span>:858<span>)</span>: avc: denied <span>{</span> getattr <span>)</span> <span>for</span>  <span>pid</span><span>=</span><span>25624</span>
<span>comm</span><span>=</span><span>"httpd"</span> <span>path</span><span>=</span><span>"/var/www/htirl/index.html"</span>  <span>dev</span><span>=</span>sda3   <span>ino</span><span>=</span><span>918426</span>
<span>scontext</span><span>=</span>unconfined_u:system_r:httpd_t:s0
<span>tcontext</span><span>=</span>unconfined_u:object_r:var_t:s0 <span>tclass</span><span>=</span>file
<span>#这条信息的意思是拒绝7 PID 是  25624的进程访间"/var/uww/html/Index.html",原因是主体的安全上下文和目标的安全上下文不匹配。</span>
<span>#其中，denied代表拒绝，path指定目标的文件名,scontext代表全体的安全上下文。tcontext代表目标的安全上下文，仔细看看，</span>
<span>#其实就是主体的安全上下文类型httpd_t和目标的安全上下文类型var_t不匹配导致的</span>
	Was caused by:
		Missing <span>type</span> enforcement <span>(</span>TE<span>)</span> allow rule.
		You can use audit2allow to generate a loadable module to allow this access.
<span>#给你的处理建议是使用audi t2allow命令来再次分析这个曰志文件</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="audit2allow-命令"> audit2allow 命令</h3>
<p><code>audit2allow</code> 命令的作用是分析日志，并提供允许的建议规则或拒绝的建议规则。这么说很难理解，我们还是尝试一下吧，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># audit2allow -a /var/log/audit/audit.log</span>
<span>#选项-a：指定日志文件名</span>
<span>#============= httpd_t ==============</span>
allow httpd_t var_t：file getattr<span>;</span>
<span>#提示非常简单，我们只需定义一个规则，允许httpd_t类型对var_t类型拥有getattr权限，即可解决这个问题</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>可是我们到现在还没有学习如果修改策略规则，这该如何是好？其实像这种因为主体和目标安全上下文类型不匹配的问题，全部可以使用 <code>restorecon</code> 命令恢复目标（文件）的安全上下文为默认安全上下文，即可解决问题，简单方便，完全不用自己定义规则。但是 <code>audit2allow</code> 命令对其他类型的  SELinux 错误还是很有帮助的。</p>
<h3 id="sealert-命令"> sealert 命令</h3>
<p><code>sealert</code> 命令是 setroubleshoot 客户端工具，也就是 SELinux 信息诊断客户端工具。虽然 setroubleshoot 服务已经不存在了，但是 <code>sealert</code> 命令还是可以使用的。命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># sealert [选项] 日志文件名</span>
选项：
	-a：分析指定的日志文件
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>也使用这个工具分析一下我们的 audit.log 日志，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># sealert -a /var/log/audit/audit.log</span>
<span>100</span>％ <span>done</span><span>'tuple'</span> object has no attribute <span>'split'</span>
<span>100</span>％ donefound <span>2</span> alerts <span>in</span> /var/log/audit/audit.log
———————————————————————————————————————————————————
SELinux is preventing /usr/sbin/httpd from getattr access on the 文 件 /var/www/html/index.html.
***插件 restorecon <span>(</span><span>94.8</span> 置信度<span>)</span> 建议 *********************************
If 您想要修复标签。
/var/www/html/index.html 默认标签应为 httpd_sys_content_t。
Then 您可以运行 restorecon。
Do
<span># /sbin/restorecon -v /var/www/html/index.html</span>
<span>#提示非常明确，只要运行以上命令，即可修复index.html文件的问题</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>有了这些日志分析工具，我们就能够处理常见的 SELinux 错误了。这些工具非常好用，要熟练掌握。</p>
<h2 id="selinux-策略规则"> SELinux 策略规则</h2>
<p>对于 SELinux 来说，所选择的策略类型直接决定了使用哪种策略规则来执行主体（进程）可以访问的目标（文件或目录资源）。不仅如此，策略类型还决定需要哪些特定的安全上下文属性。通过策略类型，读者可以更精确地了解 SELinux 所实现的访问控制。</p>
<p>SELinux 提供 3 种不同的策略可供选择，分别是 Targeted、MLS 以及 MiNimum。每个策略分别实现了可满足不同需求的访问控制，因此，为了正确地选择一个满足特定安全需求的策略，就不得不先了解这些策略类型。</p>
<h3 id="target-策略"> Target 策略</h3>
<p>Target 策略主要对系统中的服务进程进程访问控制，同时，它还可以限制其他进程和用户。服务进程都被放入沙盒，在此环境中，服务进程会被严格限制，以便使通过此类进程所引发的恶意攻击不会影响到其他服务或 Linux 系统。</p>
<p>沙盒（sandbox）是一种环境，在此环境中的进程可以运行，但对其他进程或资源的访问会被严格控制。换句话说，位于沙盒中的各个进程，都只是运行在自己的域（进程所运行的区域被称为“域”）内，它们无法访问其他进程或资源（除非被授予特殊的权限）。</p>
<p>通过使用此策略，可以更加安全地共享打印服务器、文件服务器、Web 服务器或其他服务，同时降低因访问这些服务而对系统中其他资源造成不利影响的风险。</p>
<h3 id="mls-策略"> MLS 策略</h3>
<p>MLS，是 Multi-Level Security 的缩写，该策略会对系统中的所有进程进行控制。启用 MLS 之后，用户即便执行最简单的指令（如 ls），都会报错。</p>
<h3 id="minimum-策略"> Minimum 策略</h3>
<p>Minimum 策略的意思是“最小限制”，该策略最初是针对低内存计算机或者设备（比如智能手机）而创建的。</p>
<p>从本质上来说，Minimun 和 Target 类似，不同之处在于，它仅使用基本的策略规则包。对于低内存设备来说，Minumun 策略允许 SELinux 在不消耗过多资源的情况下运行。</p>
<p>注意，你自己所使用的 Linux 发行版本中，可用的策略规则可能与以上所列出的策略规则不完全相同。比如说，在较早的 Linux  发行版本中，仍然可以使用 strict 策略，但在较新的发行版本中，strict 策略被合并在 Targeted  策略中，此策略也是默认使用的策略规则。</p>
<p>那么，我们如何查询当前系统中所使用的 SELinux 的策略是哪一种呢？这就要使用 <code>sestatus</code> 命令来查看了，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># sestatus</span>
SELinux status： enabled
<span>#SELinux启用</span>
SELinuxfs mount： /selinux
<span>#SELinux数据的挂载位置</span>
Current mode： enforcing
<span>#运行模式是强制模式</span>
Mode from config file： enforcing
<span>#配置文件所指定的模式也是强制模式</span>
Policy version： <span>24</span>
<span>#策略版本</span>
Policy from config file： targeted
<span>#目前策略是针对性保护策略</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="策略规则查看"> 策略规则查看</h3>
<p>我们知道，当前 SELinux 的默认策略是 targeted，那么这个策略中到底包含有多少个规则呢？使用 <code>seinfo</code> 命令即可查询。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># seinfo -b</span>
<span>#还记得-b选项吗？就是查询布尔值，也就是查询规则名字</span>
Conditional Booleans：187
<span>#当前系统中有187个规则</span>
allow_domain_fd_use
allow_ftpd_full_access
allow_sysadm_exec_content
allow_user_exec_content
allow_zebra_write_config
<span>..</span>.省略部分输出<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><code>seinfo</code> 命令只能看到所有规则的名称，如果想要知道规则的具体内容，就需要使用 <code>sesearch</code> 命令了。</p>
<p><code>sesearch</code> 命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># sesearch [选项] [规则类型] [表达式]</span>
选项：
	-h：显示帮助信息；

规则类型：
	--allow		：显示允许的规则；
	--neverallow：显示从不允许的规则；
	--all		：显示所有的规则；

表达式：
	-s 主体类型	：显示和指定主体的类型相关的规则（主体是访问的发起者，这个 s 是 <span>source</span> 的意思，也就是源类型）；
	-t 目标类型	：显示和指定目标的类型相关的规则（目标是被访问者，这个 t 是 target 的意思，也就是目标类型）；
	-b 规则名	：显示规则的具体内容（b 是 bool，也就是布尔值的意思，这里是指规则名）；
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>下面举几个例子。首先我们演示一下，如果我们知道的是规则的名称，则应该如何查询具体的规则内容。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># seinfo -b | grep http</span>
httpd_manage_ipa
<span>..</span>.省略部分输出<span>..</span>.
<span>#查询和apache相关的规则，有httpd_manage_ipa规则</span>
<span>[</span>root@localhost ~<span>]</span><span># sesearch --all -b httpd_manage_ipa</span>
<span># httpd_manage_ipa规则中具体定义了哪些规则内容呢？使用sesearch命令查询一下</span>
Found <span>4</span> semantic av rules：
allow httpd_t var_run_t：dir <span>{</span> getattr search <span>open</span> <span>}</span> <span>;</span>
allow httpd_t memcached_var_run_t：file <span>{</span> ioctl <span>read</span> <span>write</span> create getattr setattr lock append unlink <span>link</span> <span>rename</span> <span>open</span> <span>}</span> <span>;</span>
allow httpd_t memcached_var_run_t：dir <span>{</span> ioctl <span>read</span> <span>write</span> getattr lock add_name remove_name search <span>open</span> <span>}</span> <span>;</span>
allow httpd_t var_t：dir <span>{</span> getattr search <span>open</span> <span>}</span> <span>;</span>
Found <span>20</span> role allow rules：
allow system_r sysadm_r<span>;</span>
allow sysadm_r system_r<span>;</span>
<span>..</span>.省略部分输出<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>每个规则中都定义了大量的具体规则内容，这些内容比较复杂，一般不需要修改，会查询即可。</p>
<p>可是我们有时知道的是安全上下文的类型，而不是规则的名称。比如，我们已知 apache 进程的域是 httpd_t，而 <code>/var/www/html/</code> 目录的类型是 httpd_sys_content_t。而 apache 之所以可以访问 <code>/var/www/html/</code> 目录，是因为 httpd_t 域和 httpd_sys_content_t 类型匹配。</p>
<p>那么，该如何查询这两个类型匹配的规则呢？命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ps auxZ | grep httpd</span>
unconfined_u:system_r:httpd_t:s0 root <span>25620</span> <span>0.0</span> <span>0.5</span> <span>11188</span> 36X6 ? Ss
03:44 <span>0</span>:03 /usr/sbin/httpd
<span>#apache进程的域是httpd_t</span>
<span>[</span>root@localhost ~<span>]</span><span># ls -Zd /var/www/html/</span>
drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 /var/www/html/
<span>#/var/www/html/ 目录的类型是 httpd_sys_content_t</span>
<span>[</span>root@localhost ~<span>]</span><span># sesearch --all -s httpd_t -t httpd_sys_content_t Found 13 semantic av rules:</span>
<span>..</span>.省略部分输出<span>..</span>.
allow httpd_t httpd_sys_content_t <span>:</span> <span>file</span> <span>{</span> ioctl <span>read</span> getattr lock <span>open</span> <span>}</span><span>;</span>
allow httpd_t httpd_sys_content_t <span>:</span> <span>dir</span> <span>{</span> ioctl <span>read</span> getattr lock search <span>open</span> <span>}</span><span>;</span>
allow httpd_t httpd_sys_content_t <span>:</span> lnk_file <span>{</span> <span>read</span> getattr <span>}</span><span>;</span>
allow httpd_t httpd_sys_content_t <span>:</span> <span>file</span> <span>{</span> ioctl <span>read</span> getattr lock <span>open</span> <span>}</span><span>;</span>
<span>..</span>.省略部分输出<span>..</span>.
<span>#可以清楚地看到httpd_t域是允许访间和使用httpd_sys_content_t类型的</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="策略规则的开启和关闭"> 策略规则的开启和关闭</h3>
<p>默认情况下，并不是所有的规则都处于开启状态，因此，虽然我们无需修改规则的具体内容，但学习如何开启和关闭规则，还是很有必要的。</p>
<p>规则的开启与关闭并不困难，使用 <code>getsebool</code> 命令来查询规则的开启和关闭状态，使用 <code>setsebool</code> 命令来修改规则的开启与关闭状态。</p>
<h4 id="查询策略规则是否开启"> 查询策略规则是否开启</h4>
<p>先来看看如何知道哪些规则是启用的，哪些规则是关闭的。这时需要使用 <code>getsebool</code> 命令，命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># getsebool [-a] [规则名]</span>

	-a ：选项的含义是列出所有规则的开启状态。

例如：

<span>[</span>root@localhost ~<span>]</span><span># getsebool -a</span>
abrt_anon_write --<span>></span> off
abrt_handle_event --<span>></span> off
allow_console_login --<span>></span> on
allow_cvs_read_shadow --<span>></span> off
allow_daemons_dump_core --<span>></span> on
allow_daemons_use_tcp_wrapper --<span>></span> off
<span>..</span>.省略部分输出<span>..</span>.
<span>#getsebool命令明确地列出了规则的开启状态</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>除此之外，还可以使用 <code>semanage boolean -l</code> 命令（此命令需事先手动安装），此命令的输出结构同 <code>getsebool</code> 命令相比，输出信息中多了默认状态、当前状态以及相关描述等信息。感兴趣的读者，可以自己尝试运行，观看输出结果。</p>
<h4 id="修改规则的开启状态"> 修改规则的开启状态</h4>
<p>能够查询到规则的开启状态，我们使用 <code>setsebool</code> 命令就可以开启和关闭某个规则。当然，我们先应该通过 <code>sesearch</code> 命令确认这个规则的作用。</p>
<p><code>sesearch</code> 命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># setsebool [-P] 规则名=[0|1]</span>

	-P ：含义是将改变写入配置文件，永久生效。
		 规则名有 <span>2</span> 个值，分别是 <span>0</span> 和 <span>1</span>，0 代表将该规则关闭，1 代表将该规则开启。

举个例子：

<span>[</span>root@localhost ~<span>]</span><span># getsebool -a | grep httpd</span>
<span>#查询和apache相关的规则</span>
<span>..</span>.省略部分输出<span>..</span>.
httpd_enable_homedirs --<span>></span> off
<span>..</span>.省略部分输出<span>..</span>.
<span>#发现httpd_enable_homedirs规则是开启的，这个规则主要用于允许apache进程访问用户的家目录</span>
<span>#如果不开启这个规则，那么apache的userdir功能将不能使用</span>
<span>[</span>root@localhost ~<span>]</span><span># setsebool -P httpd_enable_homedirs=1</span>
<span>#开启httpd_enable_homedirs规则</span>
<span>[</span>root@localhost ~<span>]</span><span># getsebool httpd_enable_homedirs</span>
httpd_enable_homedirs --<span>></span> on
<span>#查询规则状态是开启</span>
<span>[</span>root@localhost ~<span>]</span><span># setsebool -P httpd_enable_homedirs=0</span>
<span>#关闭规则</span>
<span>[</span>root@localhost ~<span>]</span><span># getsebool httpd_enable_homedirs</span>
httpd_enable_homedirs --<span>></span> off
<span>#查询规则状态是关闭</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h4 id="selinux-导致-vsftpd-不能正常登录"> SELinux 导致 vsftpd 不能正常登录</h4>
<p>举个实际的例子，vsftpd 是 CentOS 默认的文件服务器，这个服务主要是用来进行文件的下载和上传的。不过，如果启动了 SELinux，则会发现 vsftpd 服务是不能登录的。我们来做一个实验，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># yum -y install vsftpd</span>
<span>#安装vsftpd服务器端</span>
<span>[</span>root@localhost ~<span>]</span><span># yum -y install ftp</span>
<span>#安装ftp命令，也就是ftp客户端</span>
<span>[</span>root@localhost ~<span>]</span><span># useradd user</span>
<span>[</span>root@localhost ~<span>]</span><span># passwd user</span>
<span>#添加测试用户，并配置密码</span>
<span>[</span>root@localhost ~<span>]</span><span># service vsftpd start</span>
<span>#启动vsftpd服务</span>
<span>[</span>root@localhost ~<span>]</span><span># ftp 192.168.4.210</span>
<span>#登录本机的ftp</span>
Connected to <span>192.168</span>.4.210 <span>(</span><span>192.168</span>.4.210<span>)</span>.2.0 <span>(</span>vsFTPd <span>2.2</span>.2<span>)</span>
Name <span>(</span><span>192.168</span>.4.210：root<span>)</span>：user			<span>&lt;</span>---输入用户名
<span>3.1</span> Please specify the password.
Password：									<span>&lt;</span>---输入密码
<span>5.0</span> OOPS：cannot change directory：/home/user
Login failed.
<span>#登录报错，不能正常登录</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>这很奇怪，vsftpd 是只要安装并启动就可以正常使用的，不用修改任何配置文件，因为默认配置是非常完善而且正确的。这时我们考虑是 SELinux 引起的问题，可以使用前面章节中关于日志查看的三个命令中的任意一个，来看看是否有关于 vsftpd 的报错。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># audit2why &lt; /var/log/audit/audit.log</span>
<span>#分析SELinux的日志</span>
type-AVC msg-audit<span>(</span><span>1370428985.525</span>:1146<span>)</span> <span>:</span> avc: denied <span>{</span>search <span>}</span> <span>for</span>  pid-28408
comm-<span>"vsftpd"</span> <span>name</span><span>=</span><span>"home"</span> <span>dev</span><span>=</span>sda3  <span>ino</span><span>=</span><span>1046530</span>
<span>scontext</span><span>=</span>unconfined_u:system_r:ftpd_t:s0-s0:c0.ol023
<span>tcontext</span><span>=</span>system_u:object_r:home_root_t:s0 <span>tclass</span><span>=</span>dir
<span>#有关于vsftpd的错.看来确实是SELinux引起的不能登陆</span>
<span>..</span>.省略部分输出<span>..</span>.
	Was caused by:
	One of the following booleans was <span>set</span> incorrectly.
	Description:
	Allow <span>ftp</span> servers to login to <span>local</span> <span>users</span> and read/write all files on the system, governed by DAC.
	Allow access by executing:
	<span># setsebool -P allow_ftpd_full_access 1</span>
	Description:
	Allow <span>ftp</span> to <span>read</span> and <span>write</span> files <span>in</span> the user home directories
	Allow access by executing:
	<span># setsebool -P ftp_home_dir 1</span>
<span>#建议执行此命令,运行ftp读取和写入用户的家目录</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>既然给出了建议命令，我们就试试吧：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># setsebool -P ftp_home_dir 1</span>
<span>#开启ftp_home_dir规则</span>
<span>[</span>root@localhost ~<span>]</span><span># ftp 192.168.4.210</span>
Connected to <span>192.168</span>.4.210 <span>(</span><span>192.168</span>.4.210<span>)</span>.2.0 <span>(</span>vsFTPd <span>2.2</span>.2<span>)</span>
Name <span>(</span><span>192.168</span>.4.210：root<span>)</span>：user			<span>&lt;</span>---输入用户名
<span>3.1</span> Please specify the password.
Password：									<span>&lt;</span>---输入密码
<span>2.0</span> Login successful.						<span>&lt;</span>---登录成功
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>通过这个例子，我们学习了如何通过日志来解决因为规则没有开启而导致的 SELinux 问题。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2022-01-26T06:11:29.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">linux高级文件系统管理</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_manage/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_manage/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="磁盘配额"> 磁盘配额</h2>
<h3 id="什么是磁盘配额"> 什么是磁盘配额</h3>
<p><strong>磁盘配额（Quota）就是 Linux 系统中用来限制特定的普通用户或用户组在指定的分区上占用的磁盘空间或文件个数的。</strong></p>
<p>在此概念中，有以下几个重点需要注意：</p>
<ol>
<li>磁盘配额限制的用户和用户组，只能是普通用户和用户组，也就是说超级用户 root 是不能做磁盘配额的；</li>
<li>磁盘配额限制只能针对分区，而不能针对某个目录，换句话说，磁盘配额仅能针对文件系统进行限制，举个例子，如果你的 <code>/dev/sda5</code> 是挂载在 <code>/home</code> 底下，那么，在 <code>/home</code> 下的所有目录都会受到磁盘配额的限制；</li>
<li>我们可以限制用户占用的磁盘容量大小（block），当然也能限制用户允许占用的文件个数（inode）。</li>
</ol>
<p>磁盘配额在实际生活中其实是很常见的，比如，我们的邮箱不管多大，都是有限制的，而不可能无限制地存储邮件；我们可以上传文件的服务器也是有容量限制的；网页中的个人空间也不可能让我们无限制地使用。</p>
<p>磁盘配额就好像我们出租写字楼，虽然整栋楼的空间非常大，但是酬整栋楼的成本太高。我们可以分开出租，用户如果觉得不够用，则还可以租用更大的空间。不过租用是不能随便进行的，其中有几个规矩必须遵守：</p>
<ul>
<li>我的楼是租给外来用户的（普通用户），可以租给一个人（用户），也可以租给一家公司（用户 组），但是这栋楼的所有权是我的，所以不能租给我自己（root 用户）；</li>
<li>如果要租用，则只能在每层租用一定大小的空间，而不能在一个房间中再划分出子空间来租用（配额只能针对分区，而不能限制某个目录）；</li>
<li>租户可以决定在某层租用多大的空间（磁盘容量限制），也可以在某层租用几个人员名额，这样只有这几个人员才能进入本层（文件个数限制）。</li>
</ul>
<p>磁盘配额要想正常使用，有以下几个前提条件：</p>
<ol>
<li>
<p>内核必须支持磁盘配额。Centos 6.x 版本的 Linux 默认支持磁盘配额，不需要做任何修改。如果不放心，则可以查看内核配置文件，看是否支持磁盘配额。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># grep CONFIG_QUOTA /boot/corrfig-2.6.32-279.el6.i686</span>
 <span>CONFIG_QUOTA</span><span>=</span>y
 <span>CONFIG_QUOTA_NETLINK_INTERFACE</span><span>=</span>y
 <span># CONFIG_QUOTA_DEBUG is not set</span>
 <span>CONFIG_QUOTA_TREE</span><span>=</span>y
 <span>CONFIG_QUOTACTL</span><span>=</span>y
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>可以看到，内核已经支持磁盘配额。如果内核不支持，就需要重新编译内核，加入 quota supper 功能。</p>
</li>
<li>
<p>系统中必须安装了 Quota 工具。我们的 Linux 中默认安装了 Quota 工具，查看命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># rpm -qa | grep quota</span>
quota-3.17-16.el6.i686
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>要支持磁盘配额的分区必须开启磁盘配额功能。这项功能可以手动开启，不再是默认开启的。</p>
</li>
</ol>
<p>磁盘配额可用于限制每个人可用网页空间、邮件空间以及网络硬盘空间的容量。除此之外，在 Linux 系统资源配置方面，使用磁盘配额，还可以限制某一群组或某一使用者所能使用的最大磁盘配额，以及以 Link 的方式，来使邮件可以作为限制的配额（更改 <code>/var/spool/mail</code> 这个路径）。</p>
<h3 id="磁盘配额中的常见概念"> 磁盘配额中的常见概念</h3>
<ol>
<li><strong>用户配额和组配额</strong></li>
</ol>
<p>用户配额是指针对用户个人的配额，而组配额是指针对整个用户组的配额。如果我们需要限制的用户数量并不多，则可以给每个用户单独指定配额。如果用户比较多，那么单独限制太过麻烦，这时我们可以把用户加入某个用户组，然后给组指定配额，就会简单得多。</p>
<p>需要注意的是，组中的用户是共享空间或文件数的。也就是说，如果用户 lamp1、lamp2 和 lamp3 都属于 brother 用户组，我给  brother 用户组分配 100MB 的磁盘空间，那么，这三个用户不是平均分配这 100MB 空间的，而是先到先得，谁先占用，谁就有可能占满这 100MB 空间，后来的就没有空间可用了。</p>
<ol start="2">
<li><strong>磁盘容量限制和文件个数限制</strong></li>
</ol>
<p>我们除了可以通过限制用户可用的 block 数量来限制用户可用的磁盘容量，也可以通过限制用户可用的 inode 数量来限制用户可以上传或新建的文件个数。</p>
<ol start="3">
<li><strong>软限制和硬限制</strong></li>
</ol>
<p>软限制可理解为警告限制，硬限制就是真正的限制了。比如，规定软限制为 100MB，硬限制为 200MB，那么，当用户使用的磁盘空间为 100~200MB 时，用户还可以继续上传和新建文件，但是每次登录时都会收到一条警告消息，告诉用户磁盘将满。</p>
<ol start="4">
<li><strong>宽限时间</strong></li>
</ol>
<p>如果用户的空间占用数处于软限制和硬限制之间，那么系统会在用户登录时警告用户磁盘将满，但是这个警告不会一直进行，而是有时间限制的，这个时间就是宽限时间，默认是 7 天。</p>
<p>如果到达宽限时间，用户的磁盘占用量还超过软限制，那么软限制就会升级为硬限制。也就是说，如果软限制是 100MB，硬限制是 200MB，宽限时间是 7天，此时用户占用了 120MB，那么今后 7 天用户每次登录时都会出现磁盘将满的警告，如果用户置之不理，7 天后这个用户的硬限制就会变成  100MB，而不是 200MB 了。</p>
<h3 id="磁盘配额启动的前期准备"> 磁盘配额启动的前期准备</h3>
<p>前面我们已经谈到，使用磁盘配额的前提，是必须要<strong>内核</strong>以及<strong>文件系统</strong>支持才行，这里假设大家使用的就是支持磁盘配额的内核，那么接下来就是要配置文件系统，使其支持配额限制。</p>
<p>由于 Quota 仅针对文件系统进行限制，因此我们有必要查一下，<code>/home</code> 是否是独立的文件系统，执行命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># df -h /home</span>
Filesystem   Size Used Avail Use% Mounted on
/dev/sda3   <span>4</span>.8G 740M <span>3</span>.8G <span>17</span>% /home			<span>&lt;</span>-- /home 确实是独立的！
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以看到，<code>/home</code> 确实是独立的文件系统，因此可以直接对其进行限制。但如果你所用系统中，<code>/home</code> 不是独立的文件系统，则可能就要针对根目录做磁盘配额了，但不建议大家这样做。</p>
<p>另外，由于 VFAT 文件系统并不支持磁盘配额功能，因此，这里需要查看 <code>/home</code> 的文件系统，执行命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mount | grep home</span>
/dev/hda3 on /home <span>type</span> ext4 <span>(</span>rw<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>显然，<code>/home</code> 的文件系统为 ext4，是支持磁盘配额的。</p>
<p>在此基础上，如果想要获得文件系统的支持，还需要为执行的文件系统添加挂载参数，分别是 <code>usrquota</code>（启用用户限额）和 <code>grpquota</code>（启动用户组限额），添加的方式有以下 2 种：</p>
<ol>
<li>
<p>如果只是想在本次启动中试验磁盘配额，则只需使用如下的方式手动添加挂载参数：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mount -o remount,usrquota,grpquota /home</span>
<span>[</span>root@localhost ~<span>]</span><span># mount | grep home</span>
/dev/sda3 on /home <span>type</span> ext4 <span>(</span>rw,usrquota,grpquota<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>手动添加的方式，会在下次重新挂载时消失，因此我们可以直接修改 <code>/etc/fstab</code> 文件，将挂载参数写入到配置文件中，这样，即便重新挂载也不会消失，执行命令如下：</p>
<div><pre><code><span>[</span>root@www ~<span>]</span><span># vi /etc/fstab</span>
<span>..</span><span>..</span><span>..</span>
<span>LABEL</span><span>=</span>/home  /home ext4  defaults,usrquota,grpquota <span>1</span> <span>2</span>
<span>[</span>root@www ~<span>]</span><span># umount /home</span>
<span>[</span>root@www ~<span>]</span><span># mount -a</span>
<span>[</span>root@www ~<span>]</span><span># mount | grep home</span>
/dev/sda3 on /home <span>type</span> ext4 <span>(</span>rw,usrquota,grpquota<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>注意，修改完 <code>/etc/fatab</code> 文件后，务必要亲自测试一下，有问题赶紧处理，因为此文件修改错误，将直接导致系统无法启动。</p>
</li>
</ol>
<p>由此，我们就成功启用了文件系统对磁盘配额的支持，但此时还是不能立即使用磁盘配额，还需进一步检测相应的文件系统，并建立磁盘配额文件，这就需要使用 <code>quotacheck</code> 命令。</p>
<h3 id="quotacheck-命令"> quotacheck 命令</h3>
<p>其实，磁盘配额（Quota）就是通过分析整个文件系统中每个用户和群组拥有的文件总数和总容量，再将这些数据记录在文件系统中的最顶层目录中，然后在此记录文件中使用各个用户和群组的配额限制值去规范磁盘使用量的。因此，建立 Quota 的记录文件是非常有必要的。</p>
<p><strong>扫描文件系统（必须含有挂载参数 usrquota 和 grpquota）并建立 Quota 记录文件，可以使用 <code>quotacheck</code> 命令</strong>。此命令的基本格式为：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># quotacheck [选项] 文件系统</span>
选项：
	-a	：扫瞄所有在 /etc/mtab 中，含有 <span>quota</span> 支持的 filesystem，加上此参数后，后边的文件系统可以不写
	-u	：针对使用者扫瞄文件与目录的使用情况，会创建 aquota.user
	-g	：针对群组扫瞄文件与目录的使用情况，会创建 aquota.group
	-v	：显示扫瞄的详细过程
	-f	：强制扫瞄文件系统，并写入新的 <span>quota</span> 记录文件
	-M	：强制以读写的方式扫瞄文件系统，只有在特殊情况下才会使用。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>在使用这些选项时，一般常用参数就是 “-avug” 。至于“ -f”和“-M”选项，是在文件系统以启动 <code>quota</code> 的情况下，还要重新扫描文件系统（担心有其他用户在使用 quota 中），才需要使用这两个选项。</p>
<div><p>说明</p>
<p>这里需要注意，如果采用命令的方式开启磁盘配额功能，那么只在本次开机中生效，一旦系统重新启动，这个功能就会失效。如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mount -o remount,usrquota,grpquota /home</span>
</code></pre>
<div><span>1</span><br></div></div><p>使用上面命令临时挂载分区，系统会同步更新到 <code>/etc/mtab</code> 文件。</p>
<p><strong><code>/etc/mtab</code> 和 <code>/etc/fstab</code> 的区别：</strong></p>
<p>其实 <code>/etc/mtab</code> 文件中记录的是操作系统已经挂载的文件系统（分区），包括操作系统建立的虚拟文件系统，所以，如果磁盘配额功能是临时生效的，那么使用命令修改的就是这个文件；而 <code>/etc/fistab</code> 文件中记录的是操作系统准备挂载的文件系统，也就是下次启动后系统会挂载的文件系统，所以，如果磁盘配额功能是永久生效的，就应该修改这个文件。</p>
</div>
<p>例如，我们可以使用如下的命令，对整个系统中含有挂载参数（usrquota 和 grpquota）的文件系统进行扫描：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># quotacheck -avug</span>
quotacheck: Scanning /dev/hda3 <span>[</span>/home<span>]</span> quotacheck: Cannot <span>stat</span> old user <span>quota</span>
file: No such <span>file</span> or directory					<span>&lt;</span>--有找到文件系统，但尚未制作记录文件！
quotacheck: Cannot <span>stat</span> old group <span>quota</span> file: No such <span>file</span> or directory
quotacheck: Cannot <span>stat</span> old user <span>quota</span> file: No such <span>file</span> or directory
quotacheck: Cannot <span>stat</span> old group <span>quota</span> file: No such <span>file</span> or directory
<span>done</span> 												<span>&lt;</span>--上面三个错误只是说明记录文件尚未创建而已，可以忽略不理！
quotacheck: Checked <span>130</span> directories and <span>107</span> files	<span>&lt;</span>--实际搜寻结果
quotacheck: Old <span>file</span> not found.
quotacheck: Old <span>file</span> not found.
<span># 若运行这个命令却出现如下的错误信息，表示你没有任何文件系统有启动 quota 支持！</span>
<span># quotacheck: Can't find filesystem to check or filesystem not mounted with quota option.</span>
 
<span>[</span>root@localhost ~<span>]</span><span># ll -d /home/a*</span>
-rw------- <span>1</span> root root <span>8192</span> Mar <span>6</span> <span>11</span>:58 /home/aquota.group
-rw------- <span>1</span> root root <span>9216</span> Mar <span>6</span> <span>11</span>:58 /home/aquota.user
<span># 可以看到，扫描的同时，会创建两个记录文件，放在 /home 底下</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>需要注意的是，此命令不要反复的执行，因为若启动 <code>Quota</code> 后还执行此命令，会破坏原有的记录文件，同时产生一些错误信息。</p>
<p>通过执行 <code>quotacheck</code> 命令，就可以成功创建支持配额的记录文件，千万不要去手动编辑这两个文件，一方面，这两个文件是 <code>Quota</code>  自己的数据文件，并不是纯文本文件；并且在你对该文件系统进行操作时，操作的结果会同步到这两个文件中，因此文件中的数据会发生变化。</p>
<p>通过学习，你只需要知道，要启动 <code>Quota</code>，需创建两个记录文件，分别为 aquota.group 和 aquota.user，而创建的工作，不是手动编辑的，需要使用 <code>quotacheck</code> 命令。</p>
<div><p>补充</p>
<p>如果用 <code>quotacheck</code> 命令创建磁盘配额的配置文件时权限不够，这是由于 SELinux 造成的，把 SELinux 关闭即可。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vi /etc/selinux/config</span>
<span>SELINUX</span><span>=</span>enforcing
<span>#把这句话改改成下面这样</span>
<span>SELINUX</span><span>=</span>disabled
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>然后再重新启动 Linux 系统，再重新执行 <code>quotacheck</code> 命令。</p>
</div>
<h3 id="quotaon-命令-开启磁盘配额限制"> quotaon 命令：开启磁盘配额限制</h3>
<p>通过前面的学习，我们已经使用 <code>quotacheck</code> 命令创建好了磁盘配额（Quota）的记录文件，接下来就可以启动 <code>Quota</code> 了，启动方法也很简单，直接使用 <code>quotaon</code> 命令即可。</p>
<p><code>quotaon</code> 命令的功能就是启动 <code>Quota</code> 服务，此命令的基本格式为：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># quotaon [选项] 文件系统名称</span>
选项：
	-a	：根据 /etc/mtab 文件中对文件系统的配置，启动相关的Quota服务，如果不使用 -a 选项，则此命令后面就需要明确写上特定的文件系统名称
	-u	：针对用户启动 Quota（根据记录文件 aquota.user）
	-g	：针对群组启动 Quota（根据记录文件 aquota.group）
	-v	：显示启动服务过程的详细信息
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>需要注意的是，<code>quotaon -auvg</code> 命令<u>只需要在第一次启动 Quota 服务时才需要进行，因为下次重新启动系统时，系统的 <code>/etc/rc.d/rc.sysinit</code> 初始化脚本会自动下达这个命令。</u></p>
<p>例 1：如果要同时启动针对用户和群组的 Quota 服务，可以使用如下命令：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># quotaon -auvg</span>
/dev/hda3 <span>[</span>/home<span>]</span>: group quotas turned on
/dev/hda3 <span>[</span>/home<span>]</span>: user quotas turned on
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>例 2：如果只针对用户启动 <code>/var</code> 的 Quota 支持，可以使用如下命令：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># quotaon -uv /var</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="quotaoff-命令-关闭磁盘配额限制"> quotaoff 命令：关闭磁盘配额限制</h3>
<p>磁盘配额（Quota）服务既然能使用 quotaon 命令手动开启，那么自然也能手动关闭，使用 quotaoff 命令即可。</p>
<p>quotaoff 命令的功能就是关闭 Quota 服务，此命令的基本格式同 quotaon 命令一样，如下所示：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># quotaoff [选项] 文件系统名称</span>
选项：
	-a	：根据 /etc/mtab 文件，关闭已启动的 Quota 服务，如果不使用 -a 选项，则此命令后面就需要明确写上特定的文件系统名称
	-u	：关闭针对用户启动的 Quota 服务。
	-g	：关闭针对群组启动的 Quota 服务。
	-v	：显示服务过程的详细信息
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>例 1：如果要关闭所有已开启的Quota服务，可以使用如下命令：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># quotaoff -auvg</span>
</code></pre>
<div><span>1</span><br></div></div><p>例 2：如果只针对用户关闭 <code>/var</code> 启动的 Quota 支持，可以使用如下命令：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># quotaoff -uv /var</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="edquota-命令-修改用户和组的磁盘配额"> edquota 命令：修改用户和组的磁盘配额</h3>
<p>针对用户和群组的配额限制（Quota），不仅可以手动控制开启和关闭，还可以手动修改配额参数，即使用 <code>edquota</code> 命令。</p>
<p><code>edquota</code> 命令，是 edit quota 缩写，用于修改用户和群组的配额限制参数，包括磁盘容量和文件个数限制、软限制和硬限制值、宽限时间，该命令的基本格式有以下 3 种：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># edquota [选项] [用户名或组名]</span>
选项：
	-u 用户名	：进入配额的 Vi 编辑界面，修改针对用户的配置值
	-g 组名		：进入配额的 Vi 编辑界面，修改针对群组的配置值
	-t			：修改配额参数中的宽限时间
	-p			：将源用户（或群组）的磁盘配额设置，复制给其他用户（或群组）
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>例如，以用户 myquota 为例，通过如下命令配置此命令的 Quota：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># edquota -u myquota</span>
Disk quotas <span>for</span> user myquota <span>(</span>uid <span>710</span><span>)</span>:
 Filesystem		blocks	soft	hard	inodes	soft	hard
 /dev/hda3		<span>80</span>		<span>0</span>		<span>0</span>		<span>10</span>		<span>0</span>		<span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>此命令的输出信息共 3 行，第一行指明了针对哪个用户进行配额限制，第二行是各个配额值的表头，共分为 7 列，其每一列的含义如表1-1 所示。</p>
<p><strong>表1-1	 <u>edquota 命令配额限制信息</u></strong></p>
<table>
<thead>
<tr>
<th>表头</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>文件系统（filesystem）</td>
<td>说明该限制值是针对哪个文件系统（或分区）；</td>
</tr>
<tr>
<td>磁盘容量（blocks）</td>
<td>此列的数值是 quota 自己算出来的，单位为 KB，不要手动修改；</td>
</tr>
<tr>
<td>磁盘容量的软限制（soft）</td>
<td>当用户使用的磁盘空间超过此限制值，则用户在登陆时会收到警告信息，<br />告知用户磁盘已满，单位为 KB；</td>
</tr>
<tr>
<td>磁盘容量的硬限制（hard）</td>
<td>要求用户使用的磁盘空间最大不能超过此限制值，单位为 KB；</td>
</tr>
<tr>
<td>文件数量（inodes）</td>
<td>同 blocks 一样，此项也是 quota自己计算出来的，无需手动修改；</td>
</tr>
<tr>
<td>文件数量的软限制（soft）</td>
<td>当用户拥有的文件数量超过此值，系统会发出警告信息；</td>
</tr>
<tr>
<td>文件数量的硬限制（hard）</td>
<td>用户拥有的文件数量不能超过此值。</td>
</tr>
</tbody>
</table>
<p>注意，当 soft/hard 为 0 时，表示没有限制。另外，在 Vi（或 Vim）中修改配额值时，填写的数据无法保证同表头对齐，只要保证此行数据分为 7 个栏目即可。</p>
<p>例 1：修改用户 myquota 的软限制值和硬限制值。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># edquota -u myquota</span>
Disk quotas <span>for</span> user myquota <span>(</span>uid <span>710</span><span>)</span>:
 Filesystem		blocks	soft	hard	inodes	soft	hard
 /dev/hda3		<span>80</span>		<span>250000</span>	<span>300000</span>	<span>10</span>		<span>0</span>		<span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>例 2：修改群组 mygrpquota 的配额。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># edquota -g mygrpquota</span>
Disk quotas <span>for</span> group mygrpquota <span>(</span>gid <span>713</span><span>)</span>:
 Filesystem		blocks	soft	hard	inodes	soft	hard
 /dev/hda3		<span>400</span>		<span>900000</span>	<span>1000000</span>	<span>50</span>		<span>0</span>		<span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>例 3：修改宽限天数。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># edquota -t</span>
Grace period before enforcing soft limits <span>for</span> users:
Time <span>units</span> may be: days, hours, minutes, or seconds
 Filesystem		Block grace period		Inode grace period
 /dev/hda3		14days					7days
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>例 4：配额复制。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># edquota -p lamp1 -u lamp2</span>
<span>#命令 -p 源用户 -u 目标用户</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="setquota-命令-非交互式设置磁盘配额"> setquota 命令：非交互式设置磁盘配额</h3>
<p>如果我们需要写脚本建立大量的用户，并给每个用户都自动进行磁盘配额，那么 <code>edquota</code> 命令就不能在脚本中使用了，因为这个命令的操作过程和 vi 类似，需要和管理员产生交互。</p>
<p>这种情况下就需要利用 <code>setquota</code> 命令进行设置，这个命令的好处是通过命令行设定配额，而不用和管理员交互设定。</p>
<p><code>edquota</code> 命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># setquota -u 用户名 容量软限制 容量硬限制 个数软限制 个数硬限制 分区名</span>
</code></pre>
<div><span>1</span><br></div></div><p>举个例子，我们再建立用户 lamp4，并用 <code>setquota</code> 命令设定磁盘配额。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># useradd lamp4</span>
<span>[</span>root@localhost ~<span>]</span><span># passwd lamp4</span>
<span>#建立用户</span>
<span>[</span>root@localhost ~<span>]</span><span># setquota -u lamp4 10000 20000 5 8 /disk</span>
<span>#设定用户在/disk分区中的容量软限制为10MB，硬限制为20MB；文件个数软限制为5个，硬限制为8个</span>
<span>[</span>root@localhost ~<span>]</span><span># quota -uvs lamp4</span>
Disk quotas <span>for</span> user Iamp4 <span>(</span>uid <span>503</span><span>)</span>:
 Filesystem		blocks	<span>quota</span>	limit	grace	files	<span>quota</span>	limit	grace
 /dev/sdbl		<span>0</span>		<span>10000</span>	<span>20000</span> 			<span>0</span>		<span>5</span>		<span>8</span>
<span>#查看一下，配额生效了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>这个命令在写脚本进行批量设置时更加方便。当然，在写脚本时也可以先建立一个模板用户，设定好磁盘配额，再进行配额复制。</p>
<h3 id="quota-和-repquota-命令-查询磁盘配额方法详解"> quota 和 repquota 命令：查询磁盘配额方法详解</h3>
<p>对于建立好的磁盘配额，还需要有效的查询配额的手段，这样才能知道系统中到底有哪些分区设定了哪些配额。</p>
<p>查询磁盘配额有两种方法：</p>
<ul>
<li>使用 <code>quota</code> 命令查询用户或用户组的配额；</li>
<li>使用 <code>repquota</code> 命令查询整个分区的配额情况。</li>
</ul>
<p><strong><code>quota</code> 命令查询用户或用户组配额，命令格式如下：</strong></p>
<div><pre><code><span>[</span>root@localhost~<span>]</span> <span># quota [选项] [用户名或组名]</span>
选项：
	-u 用户名	：查询用户配额
  	-g 组名		：查询组配额
  	-v			：显示详细信息
  	-s			：以习惯单位显示容量大小，如 M、G
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>例子：</p>
<div><pre><code><span>[</span>root@localhost 〜<span>]</span><span># quota -uvs lamp1</span>
Disk quotas <span>for</span> user lamp1 <span>(</span>uid <span>500</span><span>)</span>:
 Filesystem		blocks	<span>quota</span>	limit	grace	files	<span>quota</span>	limit	grace
 /dev/sda3		<span>20</span>		<span>0</span>		<span>0</span>				<span>6</span>		<span>0</span>		<span>0</span>
 /dev/sdbl		<span>0</span>		<span>40000</span>	<span>50000</span>			<span>0</span>		<span>8</span>		<span>10</span>
<span>#查看lamp1用户的配额值</span>
<span>[</span>root@localhost ~<span>]</span><span># quota -uvs lamp2</span>
Disk quotas <span>for</span> user lamp2 <span>(</span>uid <span>501</span><span>)</span>:
 Filesystem		blocks	<span>quota</span>	limit	grace	files	<span>quota</span>	limit	grace
 /dev/sda3		<span>36752</span>	<span>0</span>		<span>0</span>				<span>2672</span>	<span>0</span>		<span>0</span>
 /dev/sdbl		<span>0</span>		245M	293M			<span>0</span>		<span>0</span>		<span>0</span>
<span>#查看lamp2用户的配额值</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>lamp1 用户的配额值还不够大，所以没有换算成 MB 单位，但是 lamp2 用户已经换算了。在选项列当中多出了 grace 字段，这里是用来显示宽限时间的，我们现在还没有达到软限制，所以 grace 字段为空。</p>
<p><strong><code>repquota</code> 命令查询文件系统配额</strong></p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span> <span># repquota [选项] [分区名]</span>
选项：
	-a：依据 /etc/mtab 文件查询配额。如果不加 -a 选项，就一定要加分区名
	-u：查询用户配额
	-g：查询组配额
	-v：显示详细信息
	-s：以习惯单位显示容量太小
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>例子：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span> <span># repquota -augvs</span>
*** Report <span>for</span> user quotas on device /dev/sdbl
<span>#用户配额信息</span>
Block grace time: 8days<span>;</span> Inode grace time: 8days
			Block limits					File limits
User		used	soft	hard	grace	used	soft	hard	grace
root	--	<span>13</span>		<span>0</span>		<span>0</span>				<span>2</span>		<span>0</span>		<span>0</span>
lampl	--	<span>0</span>		<span>40000</span>	<span>50000</span>			<span>0</span>		<span>8</span>		<span>10</span>
lamp2	--	<span>0</span>		245M	293M			<span>0</span>		<span>0</span>		<span>0</span>
lamp3	--	<span>0</span>		245M	293M			<span>0</span>		<span>0</span>		<span>0</span>
<span>#用户的配额值</span>
Statistics:
Total blocks: <span>7</span>
Data blocks: <span>1</span>
Entries: <span>4</span>
Used average: <span>4.000000</span>
*** Report <span>for</span> group quotas on device /dev/sdbl
<span>#组配额信息</span>
Block grace time: 7days<span>;</span> Inode grace time: 7days
 Block limits File limits
Group		used	soft	hard	grace	used	soft	hard	grace
root	-- 	<span>13</span>		<span>0</span>		<span>0</span>				<span>2</span>		<span>0</span>		<span>0</span>
brother	--	<span>0</span>		440M	489M			<span>0</span>		<span>0</span>		<span>0</span>
<span>#组的配额值</span>
Statistics:
Total blocks: <span>7</span>
Data blocks: <span>1</span>
Entries: <span>2</span>
Used average: <span>2.000000</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h3 id="如何判断磁盘配额是否生效"> 如何判断磁盘配额是否生效？</h3>
<p>我们的磁盘配额已经生效，接下来测试一下是否会限制我们的用户。以 lamp1 用户为例，因为 lamp1 用户除容量被限制外，也限制了文件个数。先测试文件个数是否被限制了，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># chmod 777 /diak/</span>
<span>#给/disk 目录赋予权限，lanp1 用户要拥有写权限</span>
<span>[</span>root@localhost ~ <span>]</span><span># su - lamp1</span>
<span>#切换成lamp1用户</span>
<span>[</span>root@localhost ~ <span>]</span>$ <span>cd</span> /disk/
<span>#进入 /disk 目录</span>
<span>[</span>lamp1@localhost disk<span>]</span> $ <span>touch</span> <span>11</span>
<span>#建立文件</span>
<span>[</span>lamp@localhost disk<span>]</span> $ <span>touch</span> <span>22</span>
<span>[</span>lamp@localhost disk<span>]</span> $ <span>touch</span> <span>33</span>
<span>[</span>lamp@localhost disk<span>]</span> $ <span>touch</span> <span>44</span>
<span>[</span>lamp@localhost disk<span>]</span> $ <span>touch</span> <span>55</span>
<span>[</span>lamp@localhost disk<span>]</span> $ <span>touch</span> <span>66</span>
<span>[</span>lamp@localhost disk<span>]</span> $ <span>touch</span> <span>77</span>
<span>[</span>lamp@localhost disk<span>]</span> $ <span>touch</span> <span>88</span>
<span>[</span>lamp@localhost disk<span>]</span> $ <span>touch</span> <span>99</span>
sdb1:  warning, user <span>file</span> <span>quota</span> exceeded.
<span>[</span>lamp1@localhost disk<span>]</span>$ <span>ls</span>
<span>11</span> <span>22</span> <span>33</span> <span>44</span> <span>55</span> <span>66</span> <span>77</span> <span>88</span> <span>99</span> aquota.group aquota.user lost+found
<span>#虽然警告了，但是第 9 个文件依然建立</span>
<span>[</span>lamp1@localhost disk<span>]</span>$ <span>touch</span> <span>10</span>
<span>[</span>lamp1@localhost disk<span>]</span>$ <span>touch</span> <span>111</span>
sdb1: <span>write</span> failed, user <span>file</span> limit reached.
touch: 无法创建 <span>"111"</span><span>:</span> 超出磁盘配額
<span>[</span>lamp1@localhost disk<span>]</span>$ <span>ls</span>
<span>10</span> <span>11</span> <span>22</span> <span>33</span> <span>44</span> <span>55</span> <span>66</span> <span>77</span> <span>88</span> <span>99</span> aquota.group aquota.user lost+found
<span>#第 11 个文件没有建立</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>还记得吗？磁盘配额的概念是指定的普通用户在指定的分区中使用磁盘空间和文件个数的限制。所以一定要记得切换用户和建立文件的目录，否则默认全部写入 <code>/</code> 分区，而我们并没有在 <code>/</code> 分区上设定磁盘配额。我们切换到 root 身份，使用 <code>repquota</code> 命令查看一下。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># repquota -uvs /disk/</span>
*** Report <span>for</span> user quotas on device /dev/sdb1
Block grace time: Bdays<span>;</span> Inode grace time: 8days
		Block limits					File limits
User	used	soft	hard	grace	used	soft	hard	grace
-------------------------------------------------------------------------
root	--		<span>13</span>		<span>0</span>		<span>0</span>		<span>2</span>		<span>0</span>		<span>0</span>
lamp1	-+		<span>0</span>		<span>40000</span>	<span>50000</span>	<span>10</span>		<span>8</span>		<span>10</span>		7days
lamp2	--		<span>0</span>		245M	293M	<span>0</span>		<span>0</span>		<span>0</span>
lamp3	--		<span>0</span>		245M	<span>293</span>		<span>0</span>		<span>0</span>		<span>0</span>

statistics:
Total blocks: <span>7</span>
Data blooks: <span>1</span>
Entrles: <span>4</span>
Used average： <span>4.000000</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>看到了吗？lamp1 用户的文件个数的 grace 字段开始倒数了。</p>
<p>删除一个文件，然后建立一个大于 50MB 的文件，看看磁盘容量是否被限制了。命令如下：</p>
<div><pre><code><span>[</span>lampl@localhost disk<span>]</span>$ <span>rm</span> -rf <span>10</span>
<span>#删除文件10。空出文件个数</span>
<span>[</span>lamp1@localhost disk<span>]</span>$ <span>dd</span> <span>if</span><span>=</span>/dev/zero <span>of</span><span>=</span>/disk/testfile bs-1M <span>count</span><span>=</span><span>60</span>
<span>#建立 testfile 文件，指定文件大小为 60MB</span>
sdb1: warning, user block <span>quota</span> exceeded.
sdb1: <span>write</span> failed, user block limit reached.
dd：正在写人<span>"/disk/111"</span>：超出磁盘配额
<span>#报错，超出磁盘配额</span>
记录了 <span>49</span>+0 的读入
记录了 <span>48</span>+0 的写出
<span>51200000</span> 字节<span>(</span><span>51</span> MB<span>)</span>已复制，0.538582 秒, <span>95.1</span> MB/秒
<span>[</span>lamp1@localhost disk<span>]</span>$ ll -h testfile
-rw-rw-r-- <span>1</span> lamp1 lamp1 49M <span>4</span>月 <span>17</span> 02:52 testfile
<span>#查看一下 testfile 文件的大小，并沒有超出 50MB 的硬限制</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><p>关于 dd 命令</p>
<p>在 <code>dd</code> 命令中，if 用于指定输入项，这里我们用 <code>/dev/zero</code> 作为输入项，会不停地向目标文件中写 0；of 用于指定输出项，这里用 <code>/disk/testfile</code> 作为目标文件；bs 指定每次复制 1MB 数据；count 指定复制 60 次。也就是建立一个大小为 60MB 的 testfile 文件，但是这个文件大小超出了磁盘容量硬限制，所以只建立了 49MB，证明容量限制也生效了。</p>
</div>
<h2 id="lvm-逻辑卷管理"> LVM 逻辑卷管理</h2>
<p>我们在实际使用 Linux 服务器的时候，总会有一个让人头疼的问题，随着业务的增加，文件系统负载会越来越大，当到了空间不足的情况时，如果我们还在使用传统的分区方式管理硬盘，就不得不将现有的所有分区全部删除，并重新规划新的存储方案。</p>
<p>不仅如此，分区到底应该分多大呢？分得太大，会浪费硬盘空间；分得太小，又会面临不够使用的情况。如果在安装系统时规划不合理，这种困扰就会经常出现。如果真出现了分区不够用的情况，应该怎么解决呢？</p>
<p>在以往（2.4 内核以前）要想调整分区大小，要么先新建立一个更大的分区，然后复制旧分区中的内容到新分区，最后使用软链接来替代旧分区；要么使用调整分区大小的工具（如 <code>parted</code>），<code>parted</code> 虽然可以调整分区大小，但是它需要卸载分区之后才可以进行，也就是说需要停止服务。</p>
<p>其实，从一开始，我们就需要有一种管理机制来帮助我们动态地管理存储，LVM 就提供了这种功能。LVM 最大的好处就是可以随时调整分区的大小，分区中的现有数据不会丟失，并且不需要卸载分区、停止服务。</p>
<h3 id="lvm-的概念"> LVM 的概念</h3>
<p><strong>LVM 是 Logical Volume Manager 的简称，译为中文就是逻辑卷管理</strong>。它是 Linux 下对硬盘分区的一种管理机制。LVM 适合于管理大存储设备，并允许用户动态调整文件系统的大小。此外，LVM 的快照功能可以帮助我们快速备份数据。LVM 为我们提供了逻辑概念上的磁盘，使得文件系统不再关心底层物理磁盘的概念。</p>
<p><u>LVM 允许我们在逻辑卷在线的状态下将其复制到另一设备上，此成功被称为快照功能</u>。快照允许我们在复制的同时，保证运行关键任务的 Web 服务器或数据库服务继续工作。</p>
<p>LVM 是在硬盘分区之上建立一个逻辑层，这个逻辑层让多个硬盘或分区看起来像一块逻辑硬盘，然后将这块逻辑硬盘分成逻辑卷之后使用，从而大大提高了分区的灵活性。我们把真实的物理硬盘或分区称作物理卷（PV）；由多个物理卷组成一块大的逻辑硬盘，叫作卷组（VG）；将卷组划分成多个可以使用的分区，叫作逻辑卷（LV）。而在 LVM 中最小的存储单位不再是 block，而是物理扩展块（Physical Extend，PE）。我们通过图1-1 看看这些概念之间的联系。</p>
<div>
<p><img src="./assets/LVM.jpg" alt="LVM" loading="lazy"></p>
<p><strong>图1-1	<u>LVM 示意图</u></strong></p>
</div>
<ul>
<li><strong>物理卷（Physical Volume，PV）</strong>：就是真正的物理硬盘或分区。</li>
<li><strong>卷组（Volume Group，VG）</strong>：将多个物理卷合起来就组成了卷组。组成同一个卷组的物理卷可以是同一块硬盘的不同分区，也可以是不同硬盘上的不同分区。我们可以把卷组想象为一块逻辑硬盘。</li>
<li><strong>逻辑卷（Logical Volume，LV）</strong>：卷组是一块逻辑硬盘，硬盘必须分区之后才能使用，我们把这个分区称作逻辑卷。逻辑卷可以被格式化和写入数据。我们可以把逻辑卷想象为分区。</li>
<li><strong>物理扩展（Physical Extend，PE）</strong>：PE 是用来保存数据的最小单元，我们的数据实际上都是写入 PE 当中的。PE 的大小是可以配置的，默认是 4MB。</li>
</ul>
<p>也就是说，我们在建立 LVM 的时候，需要按照以下步骤来进行：</p>
<ol>
<li>把物理硬盘分成分区，当然也可以是整块物理硬盘</li>
<li>把物理分区建立为物理卷（PV），也可以直接把整块硬盘都建立为物理卷</li>
<li>把物理卷整合为卷组（VG）。卷组就已经可以动态地调整大小了，可以把物理分区加入卷组，也可以把物理分区从卷组中删除</li>
<li>把卷组再划分为逻辑卷（LV），当然逻辑卷也是可以直接调整大小的。我们说逻辑卷可以想象为分区，所以也需要格式化和挂载</li>
</ol>
<p>创建 LVM 的过程，会按照以上步骤，后续会逐个讲解。</p>
<p>其实，在安装 Linux 系统时，我们采用的图形安装界面就可以直接把硬盘配置成 LVM（RAID  也可以在安装时直接配置），但当时我们只分配了基本分区。那是因为 LVM 最主要的作用是调整分区大小，所以就算在安装时已经安装了  LVM，我们还是需要学习 LVM 的命令（后续章节会详解介绍）。</p>
<h3 id="pv-物理卷管理"> PV 物理卷管理</h3>
<p>其实，我们在安装系统时，是采用图形界面安装的，也可以用图形界面建立 LVM 分区的，非常方便，图形分区过程此处省略。</p>
<p>虽然使用图形界面方式建立 LVM 更加方便，但是 LVM 最主要的作用是在不丢失数据合不停机的情况下调整分区大小，所以我们一定会在系统安装完成之后，使用命令模式进行 LVM 调整。我们一步一步在命令模式下实现 LVM 吧。</p>
<ol>
<li><strong>硬盘分区</strong></li>
</ol>
<p>首先建立所需的物理分区，创建方式就是使用 <code>fdisk</code> 交互命令。需要注意的是，分区的系统 ID 不再是 Linux 默认的分区 ID 83，而要改成 LVM 的 ID 8e。在  <code>/dev/sdb</code> 硬盘中还有空闲空间，在这块硬盘中新建立 3 个分区，每 个分区的大小为 1GB。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># fdisk /dev/sdb</span>
<span>#建立分区的命令省略</span>
Command <span>{</span>m <span>for</span> <span>help</span><span>)</span>: p

Disk /dev/sdb: <span>21.5</span> GB, <span>21474836480</span> bytes <span>255</span> heads, <span>63</span> sectors/track, <span>2610</span> cylinders
Units <span>=</span> cylinders of <span>16065</span> * <span>512</span> <span>=</span> <span>8225280</span> bytes
Sector size <span>(</span>logical/physical<span>)</span>: <span>512</span> bytes / <span>512</span> bytes
I/O size <span>(</span>minimum/optimal<span>)</span>: <span>512</span> bytes / <span>512</span> bytes
Disk identifier: 0x00000ebd

Device Boot		Start	End		Blocks		Id	System
/dev/sdbl		<span>1</span>		<span>65</span>		<span>522081</span>		<span>83</span>	Linux
/dev/sdb2		<span>66</span>		<span>2610</span>	<span>20442712</span>+ 	<span>5</span>	Extended
/dev/sdb5		<span>66</span>		<span>197</span>		<span>1060258</span>+	<span>83</span>	Linux
/dev/sdb6		<span>198</span>		<span>329</span>		<span>1060258</span>+	<span>83</span>	Linux
/dev/sdb7		<span>330</span>		<span>461</span>		<span>1060258</span>+	<span>83</span>	Linux
<span>#建立了 /dev/sdb5~7 三个分区</span>

Command <span>(</span>m <span>for</span> <span>help</span><span>)</span>: t
Partition number <span>(</span><span>1</span>-7<span>)</span>: <span>5</span>
Hex code <span>(</span>type L to list codes<span>)</span>: 8e
Changed system <span>type</span> of partition <span>5</span> to 8e <span>(</span>Linux LVM<span>)</span>
<span>#把 dev/sdb5 的分区 ID 改为 8e，其他两个分区照做，改好后，查询结果如下：</span>

Command <span>(</span>m <span>for</span> <span>help</span><span>)</span>: p
Disk /dev/sdb: <span>21.5</span> GB, <span>21474836480</span> bytes <span>255</span> heads, <span>63</span> sectors/track, <span>2610</span> cylinders
Units <span>=</span> cylinders of <span>16065</span> * <span>512</span> <span>=</span> <span>8225280</span> bytes
Sector size <span>(</span>logical/physical<span>)</span>: <span>512</span> bytes / <span>512</span> bytes
I/O size <span>(</span>minimum/optimal<span>)</span>: <span>512</span> bytes / <span>512</span> bytes
Disk identifier: 0x00000ebd

Device Boot		Start	End		Blocks		Id	System
/dev/sdbl		<span>1</span>		<span>65</span>		<span>522081</span>		<span>83</span>	Linux
/dev/sdb2		<span>66</span>		<span>2610</span>	<span>20442712</span>+ 	<span>5</span>	Extended
/dev/sdb5		<span>66</span>		<span>197</span>		<span>1060258</span>+	8e	Linux
/dev/sdb6		<span>198</span>		<span>329</span>		<span>1060258</span>+	8e	Linux
/dev/sdb7		<span>330</span>		<span>461</span>		<span>1060258</span>+	8e	Linux
<span>#保存退出</span>
<span>[</span>root@localhost ~<span>]</span><span># partprobe</span>
<span>#记得重新读取分区表，否则重启系统</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><ol start="2">
<li><strong>建立物理卷</strong></li>
</ol>
<p>建立物理卷的命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># pvcreate [设备文件名]</span>
</code></pre>
<div><span>1</span><br></div></div><p>在建立物理卷时，我们既可以把整块硬盘都建立成物理卷，也可以把某个分区建立成物理卷。如果要把整块硬盘都建立成物理卷，则命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># pvcreate /dev/sdb</span>
</code></pre>
<div><span>1</span><br></div></div><p>在我们的使用中要把分区建立成物理卷，所以执行以下命令：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># pvcreate /dev/sdb5</span>
 Writing physical volume data to disk <span>"/dev/sdb5"</span>
 Physical volume <span>"/dev/sdb5"</span> successfully created
<span>[</span>root@localhost ~<span>]</span><span># pvcreate /dev/sdb6</span>
 Writing physical volume data to disk <span>"/dev/sdb6"</span>
 Physical volume <span>"/dev/sdb6"</span> successfully created
<span>[</span>root@localhost ~<span>]</span><span># pvcreate /dev/sdb7</span>
 Writing physical volume data to disk <span>"/dev/sdb7"</span>
 Physical volume 7dev/sdb7' successfully created
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ol start="3">
<li><strong>查看物理卷</strong></li>
</ol>
<p>查看物理卷的命令有两个，第一个是 <code>pvscan</code>，用来查询系统中哪些硬盘或分区是物理卷。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># pvscan</span>
 PV /dev/sdb5 Ivm2 <span>[</span><span>1.01</span> GiB<span>]</span>
 PV /dev/sdb6 Ivm2 <span>[</span><span>1.01</span> GiB<span>]</span>
 PV /dev/sdb7 Ivm2 <span>[</span><span>1.01</span> GiB<span>]</span>
 Total: <span>3</span> <span>[</span><span>3.03</span> GiB<span>]</span> /in no VG: <span>0</span> <span>[</span><span>0</span> <span>]</span> / <span>in</span> no VG: <span>3</span> <span>[</span><span>3.03</span> GiB<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>可以看到，在我们的系统中，<code>/dev/sdb5~7</code> 这三个分区是物理卷。最后一行的意思是：共有 3 个物理卷 [大小] / 使用了 0 个卷 [大小] / 空闲 3 个卷 [大小] 。</p>
<p>第二个查询命令是 <code>pvdisplay</code>，它可以查看到更详细的物理卷状态，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># pvdisplay</span>
 <span>"/dev/sdb5"</span> is a new physical volume of <span>"1.01 GiB"</span>
 ---NEW Physical volume ---
 PV Name		/dev/sdb5	<span>&lt;</span>--PV名
 VG Name					<span>&lt;</span>---属于的VG名，还没有分配，所以空白
 PV Size		<span>1.01</span> GiB	<span>&lt;</span>---PV 的大小
 Allocatable	NO			<span>&lt;</span>---是否已经分配
 PE Size		<span>0</span>			<span>&lt;</span>---PE大小，因为还没有分配，所以PE大小也没有指定
 Total PE		<span>0</span>			<span>&lt;</span>---PE总数
 Free PE		<span>0</span>			<span>&lt;</span>---空闲 PE数
 Allocated PE	<span>0</span>			<span>&lt;</span>---可分配的PE数
 PV UUID		CEsVz3-t0sD-e1w0-wkHZ-iaLq-06aV-xtQNTB		<span>&lt;</span>---PV的UUID
<span>..</span>.其它两个PV省略<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><ol start="4">
<li><strong>删除物理卷</strong></li>
</ol>
<p>如果不再需要物理卷，则使用 <code>pvremove</code> 命令删除，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># pvremove /dev/sdb7</span>
 Labels on physical volume <span>"/dev/sdb7"</span> successfully wiped
<span>#当然,在我们的使中还要用到 /dev/sdb7 物理卷，所以实验完成后，记得把它再添加回来</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>在删除物理卷时，物理卷必须不属于任何卷组，也就是需要先将物理卷从卷组中删除，再删除物理卷。其实所有的删除就是把创建过程反过来，建立时不能少某个步骤，删除时也同样不能跳过某一步直接删除。</p>
<h3 id="vg-卷组管理"> VG 卷组管理</h3>
<p>前面，物理分区已经建立，同时也把物理分区建立成了逻辑卷，按照步骤，接下来就建立卷组了。</p>
<p>前面说过，可以把卷组想象成基本分区中的硬盘，是由多个物理卷组成的。卷组就已经可以动态地调整空间大小了，当卷组空间不足时，可以向卷组中添加新的物理卷。</p>
<ol>
<li><strong>建立卷组</strong></li>
</ol>
<p>建立卷组使用的命令是 <code>vgcreate</code>，具体命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vgcreate [选项] 卷组名 物理卷名</span>
选项：
-s PE 大小	：指定 PE 的大小，单位可以是 MB、GB、TB 等。如果不写，则默认 PE 大小是 4MB。
				<span>#这里的卷组名指的就是要创建的卷组的名称，而物理卷名则指的是希望添加到此卷组的所有硬盘区分或者整个硬盘。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>我们有三个物理卷 <code>/dev/sdb5~7</code>，先把 <code>/dev/sdb5</code> 和 <code>/dev/sdb6</code> 加入卷组，留着 <code>/dev/sdb7</code> 一会实验调整卷组大小，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vgcreate -s 8MB scvg /dev/sdb5 /dev/sdb6</span>
 Volume group <span>"scvg"</span> successfully created
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>我们把 <code>/dev/sdb5</code> 和 <code>/dev/sdb6</code> 两个物理卷加入了卷组 scvg，并指定了 PE 的大小是 8MB。</p>
<ol start="2">
<li><strong>激活卷组</strong></li>
</ol>
<p>卷组创建完毕后，可以通过 <code>vgchange</code> 命令来激活卷组，而无法重启系统。</p>
<p><code>vgchange</code> 命令的基本格式如下：</p>
<div><pre><code><span>#激活卷组</span>
<span>[</span>root@localhost ~<span>]</span><span># vgchange -a y 卷组名</span>
<span>#停用卷组</span>
<span>[</span>root@localhost ~<span>]</span><span># vachange -a n 卷组名</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>通过使用 vgchange 命令，我们可以激活 scvg 卷组。</p>
<ol start="3">
<li><strong>查看卷组</strong></li>
</ol>
<p>查看卷组的命令同样有两个：<code>vgscan</code> 命令主要用于查看系统中是否有卷组；而 <code>vgdisplay</code> 命令则用于查看卷组的详细状态。命令如下：</p>
<div><pre><code><span>[</span>root@1ocalhost ~<span>]</span><span># vgscan</span>
 Reading all physical volumes. This may take a while<span>..</span>.
 Found volume group <span>"scvg"</span> using metadata <span>type</span> lvm2
<span>#scvg卷组确实存在</span>

<span>[</span>root@localhost ~<span>]</span><span># vgdisplay</span>
 ---Volume group ---
 VG Name				scvg			<span>&lt;</span>---卷组名
 System					ID
 Format					lvm2
 Metadata Areas			<span>2</span>
 Metadata Sequence No	<span>1</span>
 VG Access				read/write		<span>&lt;</span>---卷组访问状态
 VG Status				resizable		<span>&lt;</span>---卷组状态
 MAX LV					<span>0</span>				<span>&lt;</span>---最大逻辑卷数
 Cur LV					<span>0</span>
 Open LV				<span>0</span>
 Max PV					<span>0</span>				<span>&lt;</span>---最大物理卷数
 Cur PV					<span>2</span>				<span>&lt;</span>---当前物理卷数
 Act PV					<span>2</span>
 VG Size				<span>2.02</span> GiB		<span>&lt;</span>---卷组大小
 PE Size				<span>8.00</span> MiB		<span>&lt;</span>---PE大小
 Total PE				<span>258</span>				<span>&lt;</span>---PE总数
 Alloc PE / Size		<span>0</span>/0				<span>&lt;</span>---已用 PE 数量/大小
 Free PE / Size			<span>258</span> / <span>2</span>.02GiB	<span>&lt;</span>---空闲PE数量/大小
 VG UUID				Fs0dPf-LV7H-0Ir3-rthA-3UxC-LX5c-FLFriJ
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><ol start="4">
<li><strong>增加卷组容量</strong></li>
</ol>
<p>我们现在要把 <code>/dev/sdb7</code> 加入卷组，使用的命令是 <code>vgextend</code>。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vgextend scvg /dev/sdb7</span>
 Volume group <span>"scvg"</span> successfully extended
<span>#把/dev/sdb7物理卷也加入scvg卷组</span>

<span>[</span>root@localhost ~<span>]</span><span># vgdisplay</span>
 ---Volume group ---
 VG Name				scvg
 System					ID
 Format					lvm2
 Metadata Areas			<span>3</span>
 Metadata Sequence No	<span>2</span>
 VG Access				read/write
 VG Status				resizable
 MAX LV					<span>0</span>
 Cur LV					<span>0</span>
 Open LV				<span>0</span>
 Max PV					<span>0</span>
 Cur PV					<span>3</span>
 Act PV					<span>3</span>
 VG Size				<span>3.02</span> GiB		<span>&lt;</span>---卷组容量增加
 PE Size				<span>8.00</span> MiB
 Total PE				<span>387</span>				<span>&lt;</span>---PE 总数增加
 Alloc PE / Size		<span>0</span>/0
 Free PE / Size			<span>387</span> / <span>3.02</span> GiB
 VG UUID				Fs0dPf-LV7H-0Ir3-rthA-3UxC-LX5c-FLFriJ
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><ol start="5">
<li><strong>减少卷组容量</strong></li>
</ol>
<p>既然可以增加卷组容量，当然也可以减少卷组容量，我们使用 <code>vgreduce</code> 命令在卷组中删除物理卷。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vgreduce scvg /dev/sdb7</span>
 Removed <span>"/dev/sdb7"</span> from volume group <span>"scvg"</span>
<span>#在卷组中删除/dev/sdb7物理卷</span>

 <span>[</span>root@localhost ~<span>]</span><span># vgreduce -a</span>
<span>#删除所有未使用的物理卷</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>当然，删除之后记得再添加回来，以便下面再用于实验。</p>
<ol start="6">
<li><strong>删除卷组</strong></li>
</ol>
<p>删除卷组的命令是 <code>vgremove</code>。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vgremove scvg</span>
 Volume group <span>"scvg"</span> successfully removed
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>只有在删除卷组之后，才能删除物理卷。还要注意的是，scvg 卷组中还没有添加任何逻辑卷，如果拥有了逻辑卷，则记得先删除逻辑卷再删除卷组。再次强调，删除就是安装的反过程，每一步都不能跳过。</p>
<p>当然，删除之后记得再建立回来，否则逻辑卷的实验无法完成。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># vgcreate -s 8MB scvg /dev/sdb5 /dev/sdb6 /dev/sdb7</span>
 Volume group <span>"scvg"</span> successfully created
<span>#这次三个物理卷就一起加入卷组了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="lv-逻辑卷管理"> LV 逻辑卷管理</h3>
<p>那么，如何将卷组划分为逻辑卷，我们可以把逻辑卷想象成分区，那么这个逻辑卷当然也需要被格式化和挂载。另外，逻辑卷也是可以动态调整大小的，而且数据不会丟失，也不用卸载逻辑卷。</p>
<ol>
<li><strong>建立逻辑卷</strong></li>
</ol>
<p>我们现在已经建立了 3GB 大小的卷组 scvg，接下来需要在卷组中建立逻辑卷。命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># lvcreate [选项] [-n 逻辑卷名] 卷组名</span>
选项：
	-L 容量		：指定逻辑卷大小，单位为 MB、GB、TB 等
	-l 个数		：按照 PE 个数指定逻辑卷大小，这个参数需要换算容量，太麻烦
	-n 逻辑卷名	：指定逻辑卷名
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>我们建立一个 1.5GB 大小的 lamplv 逻辑卷，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># lvcreate -L 1.5G -n lamplv scvg</span>
 Logical volume <span>"lamplv"</span> created
<span>#在scvg卷组中建立一个1.5GB大小的lamplv逻辑卷</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>建立完逻辑卷，还要在格式化和挂载之后才能正常使用。格式化和挂载命令与操作普通分区时是一样的，不过需要注意的是，逻辑卷的设备文件名是 <code>/dev/卷组名/逻辑卷名</code>，如逻辑卷 lamplv 的设备文件名就是 <code>/dev/scvg/lamplv</code>。具体命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mkfs -t ext4 /dev/scvg/lamplv</span>
<span>#格式化</span>
<span>[</span>root@localhost ~<span>]</span><span># mkdir /disklvm</span>
<span>[</span>root@localhost ~<span>]</span><span># mount /dev/scvg/lamplv /disklvm/</span>
<span>#建立挂载点，并挂载</span>
<span>[</span>root@localhost ~<span>]</span><span># mount</span>
<span>..</span>.省略部分输出<span>..</span>.
/dev/mapper/scvg-lamplv on /disklvm <span>type</span> ext4<span>(</span>rw<span>)</span>
<span>#已经挂载了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>当然，如果需要开机后自动挂载，则要修改 <code>/etc/fstab</code> 文件。</p>
<ol start="2">
<li><strong>查看逻辑卷</strong></li>
</ol>
<p>查看命令同样有两个，第一个命令 <code>lvscan</code> 只能看到系统中是否拥有逻辑卷，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># lvscan</span>
 ACTIVE <span>'/dev/scvg/lamplv'</span> <span>[</span><span>1.50</span> GiB<span>]</span> inherit
<span>#能够看到激活的逻辑卷，大小是1.5GB</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>第二个命令 <code>lvdisplay</code> 可以看到逻辑卷的详细信息，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># lvdisplay</span>
 ---Logical volume---
 LV Path					/dev/scvg/lamplv	<span>&lt;</span>---逻辑卷的设备文件名
 LV Name					lamplv				<span>&lt;</span>---逻辑卷名
 VG Name					scvg				<span>&lt;</span>---所属的卷组名
 LV UUID					2kyKmn-Nupd-CldB-8ngY-NsI3-b8hV-QeUuna
 LV Write Access			read/write
 LV Creation host, <span>time</span>		localhost, <span>2013</span>-04-18 03:36:39 +0800
 LV Status					available
 <span># open						1</span>
 LV Size					<span>1.50</span> GiB			<span>&lt;</span>---逻辑卷大小
 Current LE					<span>192</span>
 Segments					<span>2</span>
 Allocation					inherit
 Read ahead sectors			auto
 -currently <span>set</span> to			<span>256</span>
 Block device				<span>253</span>:0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><ol start="3">
<li><strong>调整逻辑卷大小</strong></li>
</ol>
<p>我们可以使用 <code>lvresize</code> 命令调整逻辑卷的大小，不过我们一般不推荐减少逻辑卷的空间，因为这非常容易导致逻辑卷中的文件系统的数据丟失。所以，除非我们已经备份了逻辑卷中的数据，否则不要减少逻辑卷的空间。</p>
<p><code>lvresize</code> 命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># lvresize [选项] 逻辑卷的设备文件名</span>
选项：
	-L 容量	：安装容量调整大小，单位为 KB、GB、TB 等。使用 + 増加空间，- 代表减少空间。如果直接写容量，则代表设定逻辑卷大小为指定大小
	-l 个数	：按照 PE 个数调整逻辑卷大小
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>我们先在 <code>/disklvm</code> 分区中建立一些测试文件，一会儿调整完大小，再看看数据是否丟失了。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cd /disklvm/</span>
<span>[</span>root@localhost disklvm<span>]</span><span># touch testf</span>
<span>[</span>root@localhost disklvm<span>]</span><span># mkdir testd</span>
<span>[</span>root@localhost disklvm<span>]</span><span># ls</span>
lost+found testd testf
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>lamplv 逻辑卷的大小是 1.5GB，而 scvg 卷组中还有 1.5GB 的空闲空间，那么增加 lamplv 逻辑卷的大小到 2.5GB。命令如下：</p>
<div><pre><code><span>[</span>root@localhost disklvm<span>]</span><span># lvresize -L 2.5G /dev/scvg/lamplv</span>
 Extending logical volume lamplv to <span>2.50</span> GiB Logical volume lamplv successfully resized
<span>#增加 lamplv 逻辑卷的大小到2.5GB，当然命令也可以这样写</span>
<span>[</span>roots localhost disklvm<span>]</span> <span># lvresize -L +1G /dev/scvg/lamplv</span>
<span>[</span>root@localhost disklvm<span>]</span><span># lvdisplay</span>
 ---Logical volume ---
 LV Path					/dev/scvg/lamplv
 LV Name					lamplv
 VG Name					scvg
 LV UUID					2kyKmn-Nupd-CldB-8ngY-Ns13-b8hV-QeUuna
 LV Write Access			read/write
 LV Creation host, <span>time</span>		localhost, <span>2013</span>-04-18 03:36:39 +0800 LV Status available
 <span>\</span># <span>open</span>					<span>1</span>
 LV Size					<span>2.50</span> GiB				<span>&lt;</span>---大小改变了
 Current LE					<span>320</span>
 Segments					<span>3</span>
 Allocation					inherit
 Read ahead sectors			auto
 -currently <span>set</span> to			<span>256</span>
 Block device				<span>253</span>:0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>逻辑卷的大小已经改变了，但是好像有如下一些问题：</p>
<div><pre><code><span>[</span>root@localhost disklvm<span>]</span><span># df -h /disklvm/</span>
文件系统					容量		已用		可用		已用%%		挂载点
/dev/mapper/scvg-lamplv		<span>1</span>.5G	35M		<span>1</span>.4G	<span>3</span>%		/disklvm
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>怎么 <code>/disklvm</code> 分区的大小还是 1.5GB 啊？刚刚只是逻辑卷的大小改变了，如果要让分区使用这个新逻辑卷，则还要<strong>使用 <code>resize2fs</code> 命令来调整分区的大小</strong>。不过这里就体现出了 <strong>LVM 的优势：我们不需要卸载分区，直接就能调整分区的大小。</strong></p>
<p><strong><code>resize2fs</code> 命令的格式</strong>如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># resize2fs [选项] [设备文件名] [调整的大小]</span>
选项：
	-f			：强制调整
	设备文件名	：指定调整哪个分区的大小
	调整的大小	：指定把分区调整到多大，要加 M、G 等单位。如果不加大小，则会使用整个分区
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>我们已经把逻辑卷调整到 2.5GB，这时就需要把整个逻辑卷都加入 <code>/disklvm</code> 分区中，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># resize2fs /dev/scvg/lamplv</span>
resize2fs <span>1.41</span>.12<span>(</span><span>17</span>-May-2010<span>)</span>
Filesystem at /dev/scvg/lamplv is mounted on/ disklvm<span>;</span> on-line resizing required
old desc_blocks <span>=</span> <span>1</span>, new_desc_blocks <span>=</span> <span>1</span>
Performing an on-line resize of/dev/scvg/lamplv to <span>655360</span> <span>(</span>4k<span>)</span> blocks.
The filesystem on /dev/scvg/lamplv is now <span>655360</span> blocks long.
<span>#已经调整了分区大小</span>
<span>[</span>root@localhost ~<span>]</span><span># df -h /disklvm/</span>
文件系统					容量	已用	可用	已用%%	挂载点
/dev/mapper/scvg-lamplv	<span>2</span>.5G	35M		<span>2</span>.4G	<span>2</span>%		/disklvm
<span>#分区大小已经是2.5GB 了</span>
<span>[</span>root@localhost ~<span>]</span><span># ls /disklvm/</span>
lost+found testd testf
<span>#而且数据并没有丟失</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>如果要减少逻辑卷的容量，则只需把增加步骤反过来再做一遍就可以了。不过我们并不推荐减少逻辑卷的容量，因为这有可能导致数据丟失。</p>
<ol start="4">
<li><strong>删除逻辑卷</strong></li>
</ol>
<p>删除了逻辑卷，其中的数据就会丟失，所以要确定你真的需要删除这个逻辑卷。命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># lvremove 逻辑卷的设备文件名</span>
</code></pre>
<div><span>1</span><br></div></div><p>我们删除 lamplv 逻辑卷，记得在删除时要先卸载。 命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># umount /dev/scvg/lamplv</span>
<span>[</span>root@localhost ~<span>]</span><span># lvremove /dev/scvg/lamplv</span>
Do you really want to remove active logical volume lamplv? <span>[</span>y/n<span>]</span>: y
Logical volume <span>"lamplv"</span> successfully removed 

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="raid-磁盘阵列"> RAID 磁盘阵列</h2>
<p>LVM 最大的优势在于可以在不卸载分区和不损坏数据的情况下进行分区容量的调整，但是万一硬盘损坏了，那么数据一定会丢失。我们现在要说的 RAID（磁盘阵列）的优势在于硬盘读写性能更好，而且具有一定的数据冗余功能。</p>
<h3 id="raid-简介"> RAID 简介</h3>
<p>RAID（Redundant Arrays of Inexpensive Disks，磁盘阵列），翻译过来就是廉价的、具有冗余功能的磁盘阵列。其原理是通过软件或硬件将多块较小的硬盘或分区组合成一个容量较大的磁盘组。这个较大的磁盘组读写性能更好，更重要的是具有数据冗余功能。那什么是数据冗余呢？从字面上理解，冗余就是多余的、重复的。在磁盘阵列中，冗余是指由多块硬盘组成一个磁盘组，在这个磁盘组中，数据存储在多块硬盘的不同地方，这样即使某块硬盘出现问题，数据也不会丢失，也就是磁盘数据具有了保护功能。RAID 的组成可以是几块硬盘，也可以是几个分区，而硬盘更加容易理解，所以我们在讲解原理时使用硬盘举例，但是大家要知道不同的分区也可以组成 RAID。</p>
<p>常见的 RAID 有这样几种级别。</p>
<h3 id="raid-的级别"> RAID 的级别</h3>
<ol>
<li><strong>RAID 0</strong></li>
</ol>
<p>RAID 0 也叫 Stripe 或 Striping（带区卷）。是 RAID 级别中存储性能最好的一个，RAID 0 最好由相同容量的两块或两块以上的硬盘组成。如果组成 RAID 0 的两块硬盘大小不一致，则会影响 RAID 0 的性能。在这种模式下会先把硬盘分隔出大小相等的区块，当有数据需要写入硬盘时，会把数据也切割成相同大小的区块，然后分别写入各块硬盘。这样就相当于把一个文件分成几个部分同时向不同的硬盘中写入，数据的读/写速度当然就会非常快。从理论上讲，由几块硬盘组成 RAID 0，比如由 3 块硬盘组成 RAID 0，数据的写入速度就是同样的数据向块硬盘中写入速度的 3 倍。我们画一张 RAID 0 的示意图，如图1-2 所示。</p>
<div>
<p><img src="./assets/0.png" alt="0" loading="lazy"></p>
<p><strong>图1-2	<u>RAID 0 示意图</u></strong></p>
</div>
<p>解释一下这张示意图。我们准备了 3 块硬盘组成了 RAID 0，每块硬盘都划分了相等的区块。当有数据要写入 RAID 0 时，首先把数据按照区块大小进行分割，然后再把数据依次写入不同的硬盘。每块硬盘负责的数据写入量都是整体数据的 1/3，当然写入时间也只有原始时间的 1/3。所以，从理论上讲，由几块硬盘组成 RAID 0，数据的写入速度就是数据只写入一块硬盘速度的几倍。</p>
<p><strong>RAID 0 的优点如下：</strong></p>
<ul>
<li>
<p>通过把多块硬盘合并成一块大的逻辑硬盘，实现了数据跨硬盘存储。</p>
</li>
<li>
<p>通过把数据分割成等大小的区块，分别存入不同的硬盘，加快了数据的读/写速度。数据的读/写性能是几种 RAID 中最好的。</p>
</li>
<li>
<p>多块硬盘合并成 RAID 0，几块小硬盘组成了更大容量的硬盘，而且没有容量损失。RAID 0 的总容量就是几块硬盘的容量之和。</p>
</li>
</ul>
<p><strong>RAID 0 也有一个明显的缺点：</strong></p>
<ul>
<li>那就是没有数据冗余功能，RAID 0 中的任何一块硬盘损坏，RAID 0 中所有的数据都将丢失。也就是说，由几块硬盘组成 RAID 0，数据的损毁概率就是只写入一块硬盘的几倍。</li>
</ul>
<p>我们刚刚说了，组成 RAID 0 的硬盘的大小最好都是一样的。那有人说我只有两块不一样大小的硬盘，难道就不能组成 RAID 0 吗？答案是可以的。假设我有两块硬盘，一块大小是 100GB，另一块大小是 200GB。由这两块硬盘组成 RAID 0，那么当最初的 200GB 数据写入时，是分别存放在两块硬盘当中的；但是当数据大于 200GB 之后，第一块硬盘就写满了，以后的数据就只能写入第二块硬盘中，读/写性能也就随之下降了。</p>
<p>一般不建议企业用户使用 RIAD 0，因为数据损毁的概率更高。如果对数据的读/写性能要求非常高，但对数据安全要求不高时，RAID 0 就非常合适了。</p>
<ol start="2">
<li><strong>RAID 1</strong></li>
</ol>
<p>RAID 1 也叫 Mirror 或 Mirroring（镜像卷），由两块硬盘组成。两块硬盘的大小最好一致，否则总容量以容量小的那块硬盘为主。RAID 1 就具备了数据冗余功能，因为这种模式是把同一份数据同时写入两块硬盘。比如我有两块硬盘，组成了 RAID 1，当有数据写入时，相同的数据既写入硬盘 1，也写入硬盘 2。这样相当于给数据做了备份，所以任何一块硬盘损坏，数据都可以在另一块硬盘中找回。RAID 1 的示意图如图1-3 所示。</p>
<div>
<p><img src="./assets/1.png" alt="1" loading="lazy"></p>
<p><strong>图1-3	<u>RAID 1 示意图</u></strong></p>
</div>
<p>RAID 1 具有了数据冗余功能，但是硬盘的容量却减少了 50%，因为两块硬盘当中保存的数据是一样的，所以两块硬盘实际上只保存了一块硬盘这么多的数据，这也是我们把 RAID 1 称作镜像卷的原因。</p>
<p><strong>RAID 1 的优点如下：</strong></p>
<ul>
<li>
<p>具备了数据冗余功能，任何一块硬盘出现故障，数据都不会丢失。</p>
</li>
<li>
<p>数据的读取性能虽然不如 RAID 0，但是比单一硬盘要好，因为数据有两份备份在不同的硬盘上，当多个进程读取同一数据时，RAID 1 会自动分配读取进程。</p>
</li>
</ul>
<p>RAID 1 的缺点也同样明显：</p>
<ul>
<li>RAID 1 的容量只有两块硬盘容量的 50%，因为每块硬盘中保存的数据都一样。</li>
<li>数据写入性能较差，因为相同的数据会写入两块硬盘当中，相当于写入数据的总容量变大了。虽然 CPU 的速度足够快，但是负责数据写入的南桥芯片只有一个。</li>
</ul>
<ol start="3">
<li><strong>RAID 10 或 RAID 01</strong></li>
</ol>
<p>我们发现，RAID 0 虽然数据读/写性能非常好，但是没有数据冗余功能；而 RAID 1 虽然具有了数据冗余功能，但是数据写入速度实在是太慢了（尤其是软 RAID 1）。那么，我们能不能把 RAID 0 和 RAID 1 组合起来使用？当然可以，这样我们就既拥有了 RAID 0 的性能，又拥有了 RAID 1 的数据冗余功能。</p>
<p>我们先用两块硬盘组成 RAID 1，再用两块硬盘组成另一个 RAID 1，最后把这两个 RAID 1 组成 RAID 0，这种 RAID 方法我们就称作 RAID 10。那先组成 RATD 0，再组成 RAID 1 的方法我们就称作 RAID 01。我们通过图1-4 来看看 RAID 10。</p>
<div>
<p><img src="./assets/10.png" alt="10" loading="lazy"></p>
<p><strong>图1-4	<u>RAID 10 示意图</u></strong></p>
</div>
<p>我们把硬盘1 和硬盘2 组成了第一个 RAID 1，把硬盘3 和硬盘4 组成了第二个 RAID 1，这两个 RAID 1 组成了 RAID 0。因为先组成 RAID 1，再组成 RAID 0，所以这个 RAID 是 RAID 10。当有数据写入时，首先写入的是 RAID 0（RAID 0 后组成，所以数据先写入），所以数据1 和数据3 写入了第一个 RAID 1，而数据2 和数据4 写入了第二个 RAID 1。当数据1 和数据 3 写入第一个 RAID 1时，因为写入的是 RAID 1，所以在硬盘1 和硬盘2 中各写入了一份。数据2 和数据4 也一样。这样的组成方式，既有了 RAID 0 的性能优点，也有了 RAID 1 的数据冗余优点。但是大家要注意，虽然我们有了 4 块硬盘，但是由于 RAID 1 的缺点，所以真正的容量只有 4 块硬盘的 50%，另外的一半是用来备份的。</p>
<ol start="4">
<li><strong>RAID 5</strong></li>
</ol>
<p>RAID 5 最少需要由 3 块硬盘组成，当然硬盘的容量也应当一致。当组成 RAID 5时，同样需要把硬盘分隔成大小相同的区块。当有数据写入时，数据也被划分成等大小的区块，然后循环向 RAID 5 中写入。不过每次循环写入数据的过程中，在其中一块硬盘中加入一个奇偶校验值（Parity），这个奇偶校验值的内容是这次循环写入时其他硬盘数据的备份。当有一块硬盘损坏时，采用这个奇偶校验值进行数据恢复。通过示意图来看看 RAID 5 的存储过程，如图1-5 所示。</p>
<div>
<p><img src="./assets/5.png" alt="5" loading="lazy"></p>
<p><strong>图1-5	<u>RAID 5 示意图</u></strong></p>
</div>
<p>在这张示意图中，我们使用三块硬盘组成了 RAID 5。当有数据循环写入时，每次循环都会写入一个奇偶校验值（Parity），并且每次奇偶校验值都会写入不同的硬盘。这个奇偶校验值就是其他两块硬盘中的数据经过换算之后产生的。因为每次奇偶校验值都会写入不同的硬盘，所以任何一块硬盘损坏之后，都可以依赖其他两块硬盘中保存的数据恢复这块损坏的硬盘中的数据。</p>
<p>不过需要注意，每次数据循环写入时，都会有一块硬盘用来保存奇偶校验值，所以在 RAID 5 中可以使用的总容量是硬盘总数减去一块的容量之和。比如，在这张示意图中，由三块硬盘组成了 RAID 5，但是真正可用的容量是两块硬盘的容量之和，也就是说，越多的硬盘组成 RAID 5，损失的容量占比越小，因为不管由多少块硬盘组成 RAID 5，奇偶校验值加起来只占用一块硬盘。而且还要注意，RAID 5 不管是由几块硬盘组成的，只有损坏一块硬盘的情况才能恢复数据，因为奇偶校验值加起来只占用了一块硬盘，如果损坏的硬盘超过一块，那么数据就不能再恢复了。</p>
<p><strong>RAID 5 的优点如下：</strong></p>
<ul>
<li>
<p>因为奇偶校验值的存在，RAID 5 具有了数据冗余功能。</p>
</li>
<li>
<p>硬盘容量损失比 RAID 1 小，而且组成 RAID 5 的硬盘数量越多，容量损失占比越小，因为奇偶校验值加起来只占用一块硬盘。</p>
</li>
<li>
<p>RAID 5 的数据读/写性能要比 RAID 1 更好，但是在数据写入性能上比 RAID 0 差。</p>
</li>
</ul>
<p><strong>RAID 5 的缺点如下:</strong></p>
<ul>
<li>
<p>不管由多少块硬盘组成 RAID 5，只支持一块硬盘损坏之后的数据恢复。</p>
</li>
<li>
<p>RAID 5 的实际容量是组成 RAID 5 的硬盘总数减去一块的容量之和。也就是有一块硬盘用来保存奇偶校验值，但不能保存数据。</p>
</li>
</ul>
<p>从总体上来说，RAID 5 更像 RAID 0 和 RAID 1 的折中，性能比 RAID 1 好，但是不如 RAID 0；数据冗余比 RAID 0 好，而且不像 RAID 1 那样浪费了 50% 的硬盘容量。</p>
<ol start="5">
<li><strong>软 RAID 和硬 RAID</strong></li>
</ol>
<p>我们要想在服务器上实现 RAID，可以采用磁盘阵列卡（RAID 卡）来组成 RAID，也就是硬 RAID。RAID 卡上有专门的芯片负责 RAID 任务，因此性能要好得多，而且不占用系统性能，缺点是 RAID 卡比较昂贵。如果我们既不想花钱又想使用 RAID，那就只能使用软 RAID了。软 RAID 是指通过软件实现 RAID 功能，没有多余的费用，但是更加耗费服务器系统性能，而且数据的写入速度也较硬 RAID 慢。硬 RAID 是通过不同厂商的 RAID 卡实现的，每种 RAID 卡的系统都不太一样，需要参考各个 RAID 卡厂商的说明。我们接下来要讲解的是通过 Linux 系统实现的软 RAID。和 LVM 一样，软 RAID 可以在安装系统的同时配置，也可以在安装完成之后通过系统命令配置。</p>
<h3 id="命令模式配置-raid-5"> 命令模式配置 RAID 5</h3>
<p>图形界面确实方便，不过 RAID 和 LVM 一样，主要的应用还是在命令行当中，因为如果硬盘出现了数据损坏，总不能重新安装吧！那么我们学习在命令行界面中如何分配和使用 RAID，这次我们仍然使用相同大小的分区配置最为常见的 RAID 5。</p>
<ol>
<li><strong>准备分区</strong></li>
</ol>
<p>我们建立三个 2GB 大小的分区，构建 RAID 5。不过我们多建立了一个 2GB 大小的分区，这个分区用作备份分区。</p>
<p>这个备份分区的作用是什么呢？RAID 最大的好处就是具有数据冗余功能，当有一块硬盘或分区损坏时，数据不会丢失，只要插入新的硬盘或分区，依赖其他分区就会主动重建损坏的硬盘或分区中的数据。不过这仍然需要关闭服务器，手工插拔硬盘。如果在组成 RAID 的时候就加入了备份硬盘或备份分区，那么当硬盘或分区损坏时，RAID 会自动用备份硬盘或备份分区代替损坏的硬盘或分区，然后立即重建数据，而不需要人为手工参与。这样就避免了服务器停机和人为手工参与，非常方便，唯一的问题就是需要多余的硬盘或分区作为备份设备。</p>
<p>也就是说，我们在这个实验中需要 4 个 2GB 大小的分区，其中 3 个组成 RAID 5，1 个作为备份分区。建立分区的过程这里不再详细解释，建立完分区之后，可以使用 <code>fdisk -l</code> 命令查看。命令如下：</p>
<div><pre><code>[root@localhost ~]# fdisk -l
...省略部中输出...
Disk /dev/sdb: 21.5 GB, 21474836480 bytes
255 heads, 63 sectora/track, 2610 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
sector size (loglcal/physical): 512 bytes / 512 bytes
I/O size [minimum/optimal): 512 bytes / 512 bytes
Disk identifier: Oxba384969

Device Buot	start	End		Blocks		Id	System
/dev/sdb1	1		2610	20964793+	5	Extended 
/dev/sdb5	1		262		2104452		83	Linux
/dev/sdb6	263		524		2104483+	83	Linux
/dev/sab7	525		786		2104483+	83	Linux
/dev/sdb8	787		1048	2104483+	83	Linux
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>我们建立了 <code>/dev/sdb5</code>、<code>/dev/sdb6</code>、<code>/dev/sdb7</code> 和 <code>/dev/sdb8</code> 共 4 个 2GB 大小的分区。</p>
<ol start="2">
<li><strong>建立 RAID 5</strong></li>
</ol>
<p>建立 RAID 使用 <code>mdadm</code> 命令，命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mdadm [模式] [RAID 设备文件名] [选项]</span>
模式：
	Assemble	：加入一个已经存在的阵列
	Buiid		：创建一个没有超级块的阵列。
	Create		：创建一个阵列。每个设备都具有超级块
	Manage		：管理阵列，如添加设备和删除损坏设备
	Misc		：允许单独对阵列中的设备进行操作，如停止阵列
	Follow		：监控 RAID 状态
	<span>(</span>or Monitor<span>)</span>
	Grow		：改变 RAID 的容量或阵列中的数目
选项：
	~s,--scan				：扫描配置文件或 /proc/mdstat 文件，发现丢失的信息
	-D,--detail				：查看磁盘阵列详细信息
	-C,--create				：建立新的磁盘阵列，也就是调用 Create 模式
	-a,--auto-yes			：采用标准格式建立磁盘阵列
	-n,--raid-devices<span>=</span>数字	：使用几块硬盘或分区组成 RAID
	-l,--level<span>=</span>级别			：创建 RAID 的级别，可以是0,1,5
	-x,--spare-devices<span>=</span>数字	：使用几块硬盘或分区组成备份设备
	-a,--add 设备文件名		：在已经存在的 RAID 中加入设备
	-r,--remove 设备文件名	：在已经存在的 RAID 中移除设备
	-f,--fail 设备文件名		：把某个组成 RAID 的设备设置为错误状态
	-S,--stop				：停止 RAID 设备
	-A,--assemble			：按照配置文件加载 RAID
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>我们准备创建的是 RAID 5，所以使用以下命令创建：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mdadm --create --auto-yes /dev/md0 --level=5 --raid-devices=3 --spare-devices=1 /dev/sdb5 /dev/sdb6 /dev/sdb7 /dev/sdb8</span>
</code></pre>
<div><span>1</span><br></div></div><p>其中，<code>/dev/md0</code> 是第一个 RAID 设备的设备文件名，如果还有 RAID 设备，则可以使用 <code>/dev/md[0一9]</code> 来代表。我们建立了 RAID 5，使用了三个分区，并建立了一个备份分区。先查看一下新建立的 <code>/dev/md0</code>，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>|</span><span># mdadm --detail /dev/md0</span>
/dev/md0:											<span>&lt;</span>---设备文件名
		Version <span>:</span> <span>1.2</span>
  Creation Time <span>:</span> Tue Apr <span>23</span> <span>23</span>:13:48 <span>2013</span>			<span>&lt;</span>---创建时间
	 Raid Level <span>:</span> raid5								<span>&lt;</span>---RAID 级别
	 Array Size <span>:</span> <span>4206592</span> <span>(</span><span>4.01</span> GiB <span>4.31</span> GB<span>)</span>		<span>&lt;</span>---RAID 总容量
  Used Dev Gize <span>:</span> <span>2103296</span> <span>(</span><span>2.01</span> GiB <span>2.15</span> GB<span>)</span>		<span>&lt;</span>---每个分区的容量
   Raid Devices <span>:</span> <span>3</span>									<span>&lt;</span>---组成 RAID 的设备数
  Total Devices <span>:</span> <span>4</span>									<span>&lt;</span>---总设备数
	Persistence <span>:</span> Superblock is persistent
	Update Time <span>:</span> Tue Apr <span>23</span> <span>23</span>:14:52 <span>2013</span>
		  State ：clean
 Active Devices <span>:</span> <span>3</span>									<span>&lt;</span>---激活的设备数
Working Devices <span>:</span> <span>4</span>									<span>&lt;</span>---可用的设备数
 Failed Devicest: O									<span>&lt;</span>---错误的设备数
  Spare Devices <span>:</span> <span>1</span>									<span>&lt;</span>---备份设备数
		 Layout <span>:</span> left-symmetric
	 Chunk size <span>:</span> 512K
		   Name <span>:</span> localhost.localdomain:0 <span>(</span>local to <span>host</span> localhost.localdomain<span>)</span>
		   UUID <span>:</span> 15026b78:126a4930:89d8cf54:5bcb7e95
		 Events <span>:</span> <span>18</span>
Number	Major	Minor	RaidDevice	State
<span>0</span>		<span>8</span>		<span>21</span>		<span>0</span>			active <span>sync</span>	/dev/sdb5
<span>1</span>		<span>8</span>		<span>22</span>		<span>1</span>			active <span>sync</span>	/dev/sdb6
<span>4</span>		<span>8</span>		<span>23</span>		<span>2</span>			active <span>sync</span>	/dev/sdb7
<span>#三个激活的分区</span>
<span>3</span>		<span>9</span>		<span>24</span>		-			spare		/dev/sdb8		
<span>#备份分区</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>再查看一下 <code>/proc/mdstat</code> 文件，这个文件中也保存了 RAID 的相关信息。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cat /proc/mdstat</span>
Personalities <span>:</span> <span>[</span>raid6<span>]</span> <span>[</span>raid5<span>]</span> <span>[</span>raid4<span>]</span>
md0 <span>:</span> active raid5 sdb9<span>[</span><span>4</span><span>]</span><span>(</span>S<span>)</span> sdb5<span>[</span><span>0</span><span>]</span> sdb8<span>[</span><span>3</span><span>]</span> sdb6<span>[</span><span>1</span><span>]</span>
<span>#RAID名：	 级别	组成 RAID 的分区，[数字]是此分区在 RAID 中的顺序</span>
<span>#(S)代表备份分区</span>
	<span>4206592</span> blocks super <span>1.2</span> level <span>5</span>, 512k chunk, algorithm <span>2</span> <span>[</span><span>3</span>/3<span>]</span> <span>[</span>UUU<span>]</span>
	总block数				等级是5		区块大小	阵列算法<span>[</span>组成设备数/正常设备数<span>]</span>
unused devices: <span>&lt;</span>none<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ol start="3">
<li><strong>格式化与挂载 RAID</strong></li>
</ol>
<p>RAID 5 已经创建，但是要想正常使用，也需要格式化和挂载。格式化命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mkfs -t ext4 /dev/md0</span>
</code></pre>
<div><span>1</span><br></div></div><p>挂载命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mkdir /raid</span>
<span>#建文桂截点</span>
<span>[</span>root@localhost ~<span>]</span><span># mount /dev/md0 /raid</span>
<span>#挂载/dev/md0</span>
<span>[</span>root@localhost ~<span>]</span><span># mount</span>
<span>..</span>.省略部分输出<span>..</span>.
/dev/md0 on /raid <span>type</span> ext4 <span>(</span>rw<span>)</span>
<span>#查看一下，已经正常挂载</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ol start="4">
<li><strong>生成 mdadm 配置文件</strong></li>
</ol>
<p>在 CentOS 6.x中，mdadm 配置文件并不存在，需要手工建立。我们使用以下命令建立 <code>/etc/mdadm.conf</code> 配置文件：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># echo Device /dev/sab[5-8] >> /etc/mdadm.conf</span>
<span>#建立 /etc/mdadm.conf 配置文件，并把组成 RAID 的分区的设备文件名写入</span>
<span>#注意：如果有多个 RAID。则要把所有组成 RAID 的设备都放人配置文件中；否则 RAID 设备重启后会丢失</span>
<span>#比如组成 RAID 10，就既要把分区的设备文件名放入此文件中，也要把组成 RAID O 的 RAID 1 设备文件名放入</span>
<span>[</span>root@localhost ~<span>]</span><span># mdadm -Ds >> /etc/mdadm.conf</span>
<span>#查询和扫描 RAID 信息，并追加进 /etc/mdadm.conf 文件</span>
<span>[</span>root@localhost ~<span>]</span><span># cat /etc/mdadm.conf</span>
Device	/dev/sdb5 /dev/sdb6 /dev/sdb7 /dev/sdb8
ARRAY	/dev/md0	<span>metadata</span><span>=</span><span>1.2</span>	<span>spares</span><span>=</span><span>1</span>	<span>name</span><span>=</span>localhost.localdomain:0	uuip-dd821fe5:8597b126:460a3afd:857c7989
<span>#查看文件内容</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ol start="5">
<li><strong>设置开机后自动挂载</strong></li>
</ol>
<p>自动挂载也要修改 <code>/etc/fstab</code> 配置文件，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># iv /etc/fstab</span>
/dev/md0		/raid		ext4	dedaults	<span>1</span> <span>2</span>
<span>#加入此行</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果要重新启动，则一定要在这一步完成之后再进行，否则会报错。</p>
<ol start="6">
<li><strong>启动或停止 RAID</strong></li>
</ol>
<p>RAID 设备生效后，不用手工启动或停止。但是，如果需要卸载 RAID 设备，就必须手了停止 RAID。这里我们学习下启动和停让 RAID 的方法。先看看停止命令：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mdadm -S /dev/md0</span>
<span>#停止 /dev/md0 设备</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>当然。如果要删除 RAID，则要非常小心，要把所有和 RAID 相关的内容全部删除，才能保证系統不报错。需要进行的步骤如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># umount /dev/md0</span>
<span>#卸载 RAID</span>
<span>[</span>root@localhost ~<span>]</span><span># vi /etc/fstab</span>
/dev/md0		/raid		ext4	dedaults	<span>1</span> <span>2</span>
<span>#删除此行</span>
<span>[</span>root@localhost ~<span>]</span><span># mdadm -S /dev/md0</span>
mdadm: stopped dcv/md0
<span>#停止 RAID</span>
<span>[</span>root@localhost ~<span>]</span><span># vi /etc/mdadm.conf</span>
ARRAY	/dev/md0	<span>metadata</span><span>=</span><span>1.2</span>	<span>spares</span><span>=</span><span>1</span>	<span>name</span><span>=</span>localhost.localdomain:0	uuip-dd821fe5:8597b126:460a3afd:857c7989
<span>#删除或者注释此行</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>如果仅仅是停止，而不是删除，就没有这么麻烦了，只需先卸载。再停止即可。那停止完成之后，怎么再启动呢？启动 RAID 的命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mdadm -As /dev/md0</span>
mdadm: /dev/md0 has been started with <span>3</span> drives and <span>1</span> spare.
<span>#启动 /dev/md0</span>

<span>[</span>root@localhost ~<span>]</span><span># mount /dev/md0 /raid/</span>
<span>#启动 RAID 后，记得挂载</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ol start="7">
<li><strong>模拟分区出现故障</strong></li>
</ol>
<p>我们的 RAID 虽然配置完成了，但是它真的生效了吗？我们模拟磁盘报错，看看备份分区是否会自动代替错误分区。<code>mdadm</code> 命令有一个选项 “-f”。这个选项的作用就是把一块硬盘或分区变成错误状态，用来模拟 RAID 报错。命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mdadm /dev/md0 -f /dev/sdb7</span>
mdadm: <span>set</span> /dev/sdb7 faulty <span>in</span> /dev/md0
<span>#模拟/dev/sdb7 分区报错</span>
<span>[</span>root@localhost ~<span>]</span><span># mdadm -D /dev/md0</span>
/dev/md0:
<span>..</span>.省略部分输出<span>..</span>.
 Active Devices <span>:</span> <span>2</span>
Working Devices <span>:</span> <span>3</span>
 Failed Devices <span>:</span> <span>1</span>			<span>&lt;</span>---一个设备报错了
  Spare Devices <span>:</span> <span>1</span>

<span>..</span>.省略部分输出<span>..</span>.

	Number	Major	Minor	RaidDevice	State
	<span>0</span>		<span>8</span>		<span>21</span>		<span>0</span>			active <span>sync</span>  /dev/sdb5
	<span>1</span>		<span>8</span>		<span>21</span>		<span>1</span>			active <span>sync</span>  /dev/sdb6
	<span>3</span>		<span>8</span>		<span>24</span>		<span>2</span>			spare rebuilding  /dev/sdb8
	<span>#/dev/sdb8 分区正在准备修复</span>
	<span>4</span>		<span>8</span>		<span>23</span>		-			faulty spare  /dev/sdb7
	<span>#/dev/sdb7已经报错了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>要想看到上面的效果，查看时要快一点，否则修复就可能完成了。因为有备份分区的存在，所以分区损坏了，是不用管理员手工参与的。如果修复完成，再查看，就会出现下面的情况：</p>
<div><pre><code><span>[</span>root@localhost <span>]</span><span># mdadm -D /dev/md0</span>
	Number	Major	Minor	RaidDevice	State
	<span>0</span>		<span>8</span>		<span>21</span>		<span>0</span>			active <span>sync</span>  /dev/sdb5
	<span>1</span>		<span>8</span>		<span>21</span>		<span>1</span>			active <span>sync</span>  /dev/sdb6
	<span>3</span>		<span>8</span>		<span>24</span>		<span>2</span>			active <span>sync</span>  /dev/sdb8
	
	<span>4</span>		<span>8</span>		<span>23</span>		<span>2</span>			faulty spare  /dev/sdb7
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>备份分区 <code>/dev/sdb8</code> 已经被激活，但是 <code>/dev/sdb7</code> 分区失效了。</p>
<ol start="8">
<li><strong>移除错误分区</strong></li>
</ol>
<p>既然分区已经报错了，我们就把 <code>/dev/sdb7</code> 分区从 RAID 中删除。如果这是硬盘，就可以进行更换硬盘的处理了。移除命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mdadm /dev/md0 --remove /dev/sdb7</span>
mdadm: hot removed /dev/sdb7 from /dev/md0
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>9.添加新的备份分区</p>
<p>既然分区已经报错，那么我们还需要加入一个新的备份分区，以备下次硬盘或分区出现向题。既然要加入新的备份分区，当然还需要再划分出一个 2GB 大小的分区出来，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># fdisk -l</span>
Disk /dev/sdb: <span>21.5</span> GB, <span>21474836480</span> bytes
<span>255</span> heads, <span>63</span> sectors/track, <span>2610</span> cylinders
Unita <span>=</span> cylinders of <span>16065</span> * <span>512</span> <span>=</span> <span>8225280</span> bytes
Sector size <span>(</span>logical/physical<span>)</span>: <span>512</span> bytes / <span>512</span> bytes
I/0 size <span>(</span>minimum/optimal<span>)</span>: <span>512</span> bytes / <span>512</span> bytes
Disk identifier： 0x151a68a9

Device Boot		start	End		Blocks		Id	System
/dev/sdb1		<span>1</span>		<span>2610</span>	<span>20964793</span>+	<span>5</span>	Extended 
/dev/sdb5		<span>1</span>		<span>262</span>		<span>2104452</span>		<span>83</span>	Linux
/dev/sdb6		<span>263</span>		<span>524</span>		<span>2104483</span>+	<span>83</span>	Linux
/dev/sdb7		<span>525</span>		<span>786</span>		<span>2104483</span>+	<span>83</span>	Linux
/dev/sdb8		<span>787</span>		<span>1048</span>	<span>2104483</span>+	<span>83</span>	Linux
/dev/sdb9		<span>1049</span>	<span>1310</span>	<span>2104483</span>+	<span>83</span>	Linux
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>我们新建了 <code>/dev/sdb9</code> 分区，然后把它加入 <code>/dev/md0</code> 作为备份分区，命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># mdadm /dev/md0 --add /dev/sdb9</span>
mdadm: added /dev/sdb9
<span>#把 /dev/sdb9 加入/dev/md0</span>
<span>[</span>root@localhost ~<span>]</span><span># mdadm -D /dev/md0</span>
<span>..</span>.省略部分输出<span>..</span>.

	Number	Major	Minor	RaidDevice	State
	<span>0</span>		<span>8</span>		<span>21</span>		<span>0</span>			active <span>sync</span>  /dev/sdb5
	<span>1</span>		<span>8</span>		<span>21</span>		<span>1</span>			active <span>sync</span>  /dev/sdb6
	<span>3</span>		<span>8</span>		<span>24</span>		<span>2</span>			active <span>sync</span>  /dev/sdb8
	
	<span>4</span>		<span>8</span>		<span>25</span>		-			spare  /dev/sdb9
<span>#查看一下，/dev/sdb9 已经变成了备份分区</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div>]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2022-01-26T06:11:29.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">linux三剑客</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_mix/Linux_sed_grep_awk/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_mix/Linux_sed_grep_awk/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="grep-命令"> grep 命令</h2>
<p>很多时候，我们并不需要列出文件的全部内容，而是从文件中找到包含指定信息的那些行，要实现这个目的，可以使用 <code>grep</code> 命令。</p>
<p><code>grep</code> 命令作为 Linux 文本处理三剑客的一员，另外两个是 <code>sed</code> 和 <code>awk</code>。</p>
<p><code>grep</code> 命令的由来可以追溯到 UNIX 诞生的早期，在 UNIX 系统中，<u>搜索的模式（patterns）被称为正则表达式（regular  expressions）</u>，为了要彻底搜索一个文件，有的用户在要搜索的字符串前加上前缀  global（全面的），一旦找到相匹配的内容，用户就像将其输出（print）到屏幕上，而将这一系列的操作整合到一起就是 global  regular expressions print，而这也就是 <code>grep</code> 命令的全称。</p>
<p><code>grep</code>命令能够在一个或多个文件中，搜索某一特定的字符模式（也就是正则表达式），此模式可以是单一的字符、字符串、单词或句子。</p>
<p>正则表达式是描述一组字符串的一个模式，正则表达式的构成模仿了数学表达式，通过使用操作符将较小的表达式组合成一个新的表达式。正则表达式可以是一些纯文本文字，也可以是用来产生模式的一些特殊字符。为了进一步定义一个搜索模式，<code>grep</code> 命令支持如表1 所示的这几种正则表达式的元字符（也就是通配符）。</p>
<p><strong>表1	<u>正则表达式通配符</u></strong></p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>匹配前面的子表达式 0 次或多次。</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式 0 次或 1 次。</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式 1 次或多次。</td>
</tr>
<tr>
<td>.</td>
<td>将匹配任何一个字符，且只能是一个字符。</td>
</tr>
<tr>
<td>[a-z]</td>
<td>匹配方括号中的任意一个字符。</td>
</tr>
<tr>
<td>[^xyz]</td>
<td>匹配除方括号中字符外的所有字符。</td>
</tr>
<tr>
<td>|</td>
<td>指明两项之间的一个选择。</td>
</tr>
<tr>
<td>{n}</td>
<td>n 是一个非负整数。匹配确定的 n 次。</td>
</tr>
<tr>
<td>{n,}</td>
<td>n 是一个非负整数。至少匹配 n 次。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>m 和 n 均为非负整数，其中 n &lt;= m。最少匹配 n 次且最多匹配 m 次。</td>
</tr>
<tr>
<td>^</td>
<td>锁定行的开头。</td>
</tr>
<tr>
<td>$</td>
<td>锁定行的结尾。</td>
</tr>
<tr>
<td>\</td>
<td>转义字符。将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。</td>
</tr>
</tbody>
</table>
<p>需要注意的是，在基本正则表达式中，如通配符 <strong>*、+、{、|、(</strong> 和 <strong>)</strong> 等，已经失去了它们原本的含义，而若要恢复它们原本的含义，则要在之前添加反斜杠 <strong>\</strong>，如 <strong>\*、\+、\{、\|、\(</strong> 和 <strong>\)</strong>。</p>
<p><code>grep</code> 命令是用来在每一个文件中（或特定输出上）搜索特定的模式，当使用 <code>grep</code> 时，包含指定字符模式的每一行内容，都会被打印（显示）到屏幕上，但是使用 <code>grep</code> 命令并不改变文件中的内容。</p>
<h3 id="基本用法"> 基本用法</h3>
<p><code>grep</code> 命令的基本格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># grep [选项] 模式 文件名</span>
选项：
	-c：仅列出文件中包含模式的行数
	-i：忽略模式中的字母大小写
	-l：列出带有匹配行的文件名
	-n：在每一行的最前面列出行号
	-v：列出没有匹配模式的行
	-w：把表达式当做一个完整的单字符来搜寻，忽略那些部分匹配的行

模式	：要么是字符（串），要么是正则表达式。

文件名	：即要搜索匹配的源文件或者标准输入，标准输入常用管道符 <span>|</span> 连接 <span>grep</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><p>注意</p>
<p>如果是搜索多个文件，<code>grep</code> 命令的搜索结果只显示文件中发现匹配模式的文件名；而如果搜索单个文件，<code>grep</code> 命令的结果将显示每一个包含匹配模式的行。</p>
</div>
<p>例 1：假设有一份 <code>emp.data</code> 员工清单，现在要搜索此文件，找出职位为 CLERK 的所有员工，则执行命令如下：</p>
<div><pre><code><span># 来自文件</span>
<span>[</span>root@localhost ~<span>]</span><span># grep CLERK emp.data</span>

<span># 来自标准输入</span>
<span>[</span>root@localhost ~<span>]</span><span># cat emp.data | grep CLERK</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>而在此基础上，如果只想知道职位为 CLERK 的员工的人数，可以使用“-c”选项，执行命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># grep -c CLERK emp.data</span>
<span>#忽略输出内容</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>例 2：搜索 <code>emp.data</code> 文件，使用正则表达式找出以 78 开头的数据行，执行命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># grep ^78 emp.data</span>
<span>#忽略输出内容</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>grep</code> 命令的功能非常强大，通过利用它的不同选项以及变化万千的正则表达式，可以获取任何我们所需要的信息。本节所介绍的 grep  命令，只介绍了它的一部分基础知识，比如说，grep  命令可用的选项还有很多，且用法也五花八门，不过对于初学者来说，本节所介绍的内容已经足以应付多数 Linux 系统的日常工作了。</p>
<p>例 3：将 <code>/etc/passwd</code> 文件中，没有出现 root 和 nologin 的行打印出来，执行命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cat /etc/passwd | grep -v root | grep -v nologin</span>
<span>#忽略输出内容</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="egrep-或-grep-e"> egrep 或 grep -E</h3>
<p>使用 <code>egrep</code> 的主要好处是增加了额外的正则表达式元字符集。</p>
<p>打印所有包含 NW 或 EA 的行。如果不是使用 <code>egrep</code>，而是 <code>grep</code>，将不会有结果查出。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># egrep 'NW|EA' testfile     </span>
northwest       NW      Charles Main        <span>3.0</span>     .98     <span>3</span>       <span>34</span>
eastern         EA      TB Savage           <span>4.4</span>     .84     <span>5</span>       <span>20</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>对于标准 <code>grep</code>，如果在扩展元字符前面加 \，grep 会自动启用扩展选项 -E。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># grep 'NW\|EA' testfile</span>
northwest       NW      Charles Main        <span>3.0</span>     .98     <span>3</span>       <span>34</span>
eastern         EA      TB Savage           <span>4.4</span>     .84     <span>5</span>       <span>20</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>搜索所有包含一个或多个 3 的行。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># egrep '3+' testfile</span>
<span>[</span>root@localhost ~<span>]</span><span># grep -E '3+' testfile</span>
<span>[</span>root@localhost ~<span>]</span><span># grep '3\+' testfile        </span>
<span>#这3条命令将会</span>
northwest       NW      Charles Main          <span>3.0</span>     .98     <span>3</span>       <span>34</span>
western         WE      Sharon Gray           <span>5.3</span>     .97     <span>5</span>       <span>23</span>
northeast       NE      AM Main Jr.           <span>5.1</span>     .94     <span>3</span>       <span>13</span>
central         CT      Ann Stephens          <span>5.7</span>     .94     <span>5</span>       <span>13</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>搜索所有包含 0 个或 1 个小数点字符的行。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># egrep '2\.?[0-9]' testfile </span>
<span>[</span>root@localhost ~<span>]</span><span># grep -E '2\.?[0-9]' testfile</span>
<span>[</span>root@localhost ~<span>]</span><span># grep '2\.\?[0-9]' testfile </span>
<span>#首先含有2字符，其后紧跟着0个或1个点，后面再是0和9之间的数字。</span>
western         WE      Sharon Gray           <span>5.3</span>     .97     <span>5</span>       <span>23</span>
southwest       SW      Lewis Dalsass         <span>2.7</span>     .8      <span>2</span>       <span>18</span>
eastern         EA      TB Savage             <span>4.4</span>     .84     <span>5</span>       <span>20</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>搜索一个或者多个连续的 no 的行。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># egrep '(no)+' testfile</span>
<span>[</span>root@localhost ~<span>]</span><span># grep -E '(no)+' testfile</span>
<span>[</span>root@localhost ~<span>]</span><span># grep '\(no\)\+' testfile</span>
<span>#3个命令返回相同结果，</span>
northwest       NW      Charles Main        <span>3.0</span>     .98     <span>3</span>       <span>34</span>
northeast       NE       AM Main Jr.        <span>5.1</span>     .94     <span>3</span>       <span>13</span>
north           NO      Margot Weber        <span>4.5</span>     .89     <span>5</span>       <span>9</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="fgrep-或-grep-f"> fgrep 或 grep -F</h3>
<p><code>fgrep</code> 查询速度比 <code>grep</code> 命令快，但是不够灵活；它只能找固定的文本，而不是规则表达式。</p>
<p>如果你想在一个文件或者输出中找到包含星号字符的行</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># fgrep '*' /etc/profile</span>
<span>for</span> <span>i</span> <span>in</span> /etc/profile.d/*.sh <span>;</span> <span>do</span>

或
<span>[</span>root@localhost ~<span>]</span><span># grep -F '*' /etc/profile</span>
<span>for</span> <span>i</span> <span>in</span> /etc/profile.d/*.sh <span>;</span> <span>do</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="sed-命令"> sed 命令</h2>
<p>我们知道，Vim 采用的是交互式文本编辑模式，你可以用键盘命令来交互性地插入、删除或替换数据中的文本。</p>
<p><code>sed</code> 命令，它采用的是流编辑模式，最明显的特点是，在 <code>sed</code> 处理数据之前，需要预先提供一组规则，<code>sed</code> 会按照此规则来编辑数据。</p>
<p><code>sed</code> 会根据脚本命令来处理文本文件中的数据，这些命令要么从命令行中输入，要么存储在一个文本文件中，此命令执行数据的顺序如下：</p>
<ol>
<li>每次仅读取一行内容；</li>
<li>根据提供的规则命令匹配并修改数据。注意，<code>sed</code> 默认不会直接修改源文件数据，而是会将数据复制到缓冲区中，修改也仅限于缓冲区中的数据；</li>
<li>将执行结果输出。</li>
</ol>
<p>当一行数据匹配完成后，它会继续读取下一行数据，并重复这个过程，直到将文件中所有数据处理完毕。</p>
<p><code>sed</code> 命令的基本格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># sed [选项] '[脚本命令]' 文件名</span>
选项：
	-e 脚本命令		：该选项会将其后跟的脚本命令添加到已有的命令中
	-f 脚本命令文件	：该选项会将其后文件中的脚本命令添加到已有的命令中
	-n				：默认情况下，sed 会在所有的脚本指定执行完毕后，会自动输出处理后的内容，而该选项会屏蔽启动输出，需使用 print 命令来完成输出
	-i				：此选项会直接修改源文件，要慎用
	
脚本命令：
	s	：查找替换
	d	：删除定位行
	a<span>\</span>	：在当前行下面插入文本
	i<span>\</span>	：在当前行上面插入文本
	c<span>\</span>	：用新文本替换定位文本
	y	：转换（表示把一个字符翻译为另外的字符）
	p	：打印（和-n选项一起合用，打印匹配行）
	w	：把文本写到一个文件，类似输出重定向 <span>></span>
	r	：从另一个文件中读文本，类似输入重定向 <span>&lt;</span>
	q	：第一个模式匹配完成后退出或立即退出
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>成功使用 <code>sed</code> 命令的关键在于掌握各式各样的脚本命令及格式，它能帮你定制编辑文件的规则。</p>
<h3 id="sed-脚本命令"> sed 脚本命令</h3>
<h4 id="sed-s-替换脚本命令"> sed s 替换脚本命令</h4>
<p>此命令的基本格式为：</p>
<div><pre><code><span>[</span>address<span>]</span>s/pattern/replacement/flags

address：表示指定要操作的具体行
pattern：指的是需要替换的内容
replacement：指的是要替换的新内容
flags：
	n		：1~512 之间的数字，表示指定要替换的字符串出现第几次时才进行替换，例如，一行中有 <span>3</span> 个 A，但用户只想替换第二个 A，这是就用到这个标记
	g		：对数据中所有匹配到的内容进行替换，如果没有 g，则只会在第一次匹配成功时做替换操作。例如，一行数据中有 <span>3</span> 个 A，则只会替换第一个 A
	p		：会打印与替换命令中指定的模式匹配的行。此标记通常与 -n 选项一起使用
	w <span>file</span>	：将缓冲区中的内容写到指定的 <span>file</span> 文件中（相当于另存为）
	<span>&amp;</span>		：用正则表达式匹配的内容进行替换
	<span>\</span>n		：匹配第 n 个子串，该子串之前在 pattern 中用 <span>\</span><span>(</span><span>\</span><span>)</span> 指定
	<span>\</span>		：转义（转义替换部分包含：<span>&amp;</span>、<span>\</span> 等）
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>比如，可以指定 <code>sed</code> 用新文本替换第几处模式匹配的地方：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cat data1.txt</span>
This is a <span>test</span> of the <span>test</span> script.
This is the second <span>test</span> of the <span>test</span> script.
<span>[</span>root@localhost ~<span>]</span><span># sed 's/test/trial/2' data1.txt</span>
This is a <span>test</span> of the trial script.
This is the second <span>test</span> of the trial script.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>可以看到，使用数字 2 作为标记的结果就是，<code>sed</code> 编辑器只替换每行中第 2 次出现的匹配模式。</p>
<p>如果要用新文件替换所有匹配的字符串，可以使用 g 标记：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># sed 's/test/trial/g' data1.txt</span>
This is a trial of the trial script.
This is the second trial of the trial script.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>我们知道，-n 选项会禁止 <code>sed</code> 输出，但 p 标记会输出修改过的行，将二者匹配使用的效果就是只输出被替换命令修改过的行，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cat data2.txt</span>
This is a <span>test</span> line.
This is a different line.
<span>[</span>root@localhost ~<span>]</span><span># sed -n 's/test/trial/p' data2.txt</span>
This is a trial line.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>w 标记会将匹配后的结果保存到指定文件中，比如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># sed 's/test/trial/w test.txt' data2.txt</span>
This is a trial line.
This is a different line.
<span>[</span>root@localhost ~<span>]</span><span>#cat test.txt</span>
This is a trial line.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>在使用 s 脚本命令时，替换类似文件路径的字符串会比较麻烦，需要将路径中的正斜线进行转义，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># sed 's/\/bin\/bash/\/bin\/csh/' /etc/passwd</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="sed-d-替换脚本命令"> sed d 替换脚本命令</h4>
<p>此命令的基本格式为：</p>
<div><pre><code><span>[</span>address<span>]</span>d
</code></pre>
<div><span>1</span><br></div></div><p>如果需要删除文本中的特定行，可以用 d 脚本命令，它会删除指定行中的所有内容。但使用该命令时要特别小心，如果你忘记指定具体行的话，文件中的所有内容都会被删除，举个例子：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cat data3.txt</span>
The quick brown fox jumps over the lazy dog
The quick brown fox jumps over the lazy dog
The quick brown fox jumps over the lazy dog
The quick brown fox jumps over the lazy dog
<span>[</span>root@localhost ~<span>]</span><span># sed 'd' data3.txt</span>
<span>#什么也不输出，证明成了空文件</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>当和指定地址一起使用时，删除命令显然能发挥出大的功用。可以从数据流中删除特定的文本行。</p>
<p>address 的具体写法后续会做详细介绍，这里只给大家举几个简单的例子：</p>
<ul>
<li>
<p>通过行号指定，比如删除 data6.txt 文件内容中的第 3 行：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cat data4.txt</span>
This is line number <span>1</span>.
This is line number <span>2</span>.
This is line number <span>3</span>.
This is line number <span>4</span>.
<span>[</span>root@localhost ~<span>]</span><span># sed '3d' data4.txt</span>
This is line number <span>1</span>.
This is line number <span>2</span>.
This is line number <span>4</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></li>
<li>
<p>或者通过特定行区间指定，比如删除 data6.txt 文件内容中的第 2、3行：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># sed '2,3d' data4.txt</span>
This is line number <span>1</span>.
This is line number <span>4</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>也可以使用两个文本模式来删除某个区间内的行，但这么做时要小心，你指定的第一个模式会“打开”行删除功能，第二个模式会“关闭”行删除功能，因此，<code>sed</code> 会删除两个指定行之间的所有行（包括指定的行），例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span>#sed '/1/,/3/d' data4.txt</span>
<span>#删除第 1~3 行的文本数据</span>
This is line number <span>4</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>或者通过特殊的文件结尾字符，比如删除 data4.txt 文件内容中第 3 行开始的所有的内容：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># sed '3,$d' data4.txt</span>
This is line number <span>1</span>.
This is line number <span>2</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ul>
<p>在此强调，在默认情况下 <code>sed</code> 并不会修改原始文件，这里被删除的行只是从 <code>sed</code> 的输出中消失了，原始文件没做任何改变。</p>
<h4 id="sed-a-和-i-脚本命令"> sed a\ 和 i\ 脚本命令</h4>
<p>a\ 命令表示在指定行的后面附加一行，i\ 命令表示在指定行的前面插入一行，这里之所以要同时介绍这 2 个脚本命令，因为它们的基本格式完全相同，如下所示：</p>
<div><pre><code><span>[</span>address<span>]</span>a（或i）<span>\</span>新文本内容
</code></pre>
<div><span>1</span><br></div></div><p>下面分别就这 2 个命令，举几个例子。比如说，将一个新行插入到数据流第三行前，执行命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># sed '3i\</span>
<span>></span> This is an inserted line.' data4.txt
This is line number <span>1</span>.
This is line number <span>2</span>.
This is an inserted line.
This is line number <span>3</span>.
This is line number <span>4</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>再比如说，将一个新行附加到数据流中第三行后，执行命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># sed '3a\</span>
<span>></span> This is an appended line.' data4.txt
This is line number <span>1</span>.
This is line number <span>2</span>.
This is line number <span>3</span>.
This is an appended line.
This is line number <span>4</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>如果你想将一个多行数据添加到数据流中，只需对要插入或附加的文本中的每一行末尾（除最后一行）添加反斜线即可，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># sed '1i\</span>
<span>></span> This is one line of new text.<span>\</span>
<span>></span> This is another line of new text.' data6.txt
This is one line of new text.
This is another line of new text.
This is line number <span>1</span>.
This is line number <span>2</span>.
This is line number <span>3</span>.
This is line number <span>4</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>可以看到，指定的两行都会被添加到数据流中。</p>
<h4 id="sed-c-替换脚本命令"> sed c\ 替换脚本命令</h4>
<p>c\ 命令表示将指定行中的所有内容，替换成该选项后面的字符串。该命令的基本格式为：</p>
<div><pre><code><span>[</span>address<span>]</span>c<span>\</span>用于替换的新文本
</code></pre>
<div><span>1</span><br></div></div><p>举个例子：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># sed '3c\</span>
<span>></span> This is a changed line of text.<span>' data4.txt
This is line number 1.
This is line number 2.
This is a changed line of text.
This is line number 4.
在这个例子中，sed 编辑器会修改第三行中的文本，其实，下面的写法也可以实现此目的：
[root@localhost ~]# sed '</span>/number <span>3</span>/c<span>\</span>
<span>></span> This is a changed line of text.' data4.txt
This is line number <span>1</span>.
This is line number <span>2</span>.
This is a changed line of text.
This is line number <span>4</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h4 id="sed-y-转换脚本命令"> sed y 转换脚本命令</h4>
<p>y 转换命令是唯一可以处理单个字符的 <code>sed</code> 脚本命令，其基本格式如下：</p>
<div><pre><code><span>[</span>address<span>]</span>y/inchars/outchars/
</code></pre>
<div><span>1</span><br></div></div><p>转换命令会对 inchars 和 outchars 值进行一对一的映射，即 inchars 中的第一个字符会被转换为 outchars  中的第一个字符，第二个字符会被转换成 outchars 中的第二个字符...这个映射过程会一直持续到处理完指定字符。如果 inchars 和 outchars 的长度不同，则 sed 会产生一条错误消息。</p>
<p>举个简单例子：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cat data5.txt</span>
This is line number <span>1</span>.
This is line number <span>2</span>.
This is line number <span>3</span>.
This is line number <span>4</span>.
This is line number <span>1</span> again.
This is yet another line.
This is the last line <span>in</span> the file.
<span>[</span>root@localhost ~<span>]</span><span># sed 'y/123/789/' data5.txt</span>
This is line number <span>7</span>.
This is line number <span>8</span>.
This is line number <span>9</span>.
This is line number <span>4</span>.
This is line number <span>7</span> again.
This is yet another line.
This is the last line <span>in</span> the file.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>可以看到，inchars 模式中指定字符的每个实例都会被替换成 outchars 模式中相同位置的那个字符。</p>
<p>转换命令是一个全局命令，也就是说，它会在文本行中找到的所有指定字符自动进行转换，而不会考虑它们出现的位置，再打个比方：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># echo "This 1 is a test of 1 try." | sed 'y/123/456/'</span>
This <span>4</span> is a <span>test</span> of <span>4</span> try.
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>sed</code> 转换了在文本行中匹配到的字符 1 的两个实例，我们无法限定只转换在特定地方出现的字符。</p>
<h4 id="sed-p-打印脚本命令"> sed p 打印脚本命令</h4>
<p>p 命令表示搜索符号条件的行，并输出该行的内容，此命令的基本格式为：</p>
<div><pre><code>[address]p
</code></pre>
<div><span>1</span><br></div></div><p>p 命令常见的用法是打印包含匹配文本模式的行，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cat data6.txt</span>
This is line number <span>1</span>.
This is line number <span>2</span>.
This is line number <span>3</span>.
This is line number <span>4</span>.
<span>[</span>root@localhost ~<span>]</span><span># sed -n '/number 3/p' data6.txt</span>
This is line number <span>3</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>可以看到，用 -n 选项和 p 命令配合使用，我们可以禁止输出其他行，只打印包含匹配文本模式的行。</p>
<p>如果需要在修改之前查看行，也可以使用打印命令，比如与替换或修改命令一起使用。可以创建一个脚本在修改行之前显示该行，如下所示：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># sed -n '/3/{</span>
<span>></span> p
<span>></span> s/line/test/p
<span>></span> <span>}</span>' data6.txt
This is line number <span>3</span>.
This is <span>test</span> number <span>3</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><code>sed</code> 命令会查找包含数字 3 的行，然后执行两条命令。首先，脚本用 p 命令来打印出原始行；然后它用 s 命令替换文本，并用 p 标记打印出替换结果。输出同时显示了原来的行文本和新的行文本。</p>
<h4 id="sed-w-脚本命令"> sed w 脚本命令</h4>
<p>w 命令用来将文本中指定行的内容写入文件中，此命令的基本格式如下：</p>
<div><pre><code><span>[</span>address<span>]</span>w filename
</code></pre>
<div><span>1</span><br></div></div><p>这里的 filename 表示文件名，可以使用相对路径或绝对路径，但不管是哪种，运行 <code>sed</code> 命令的用户都必须有文件的写权限。</p>
<p>下面的例子是将数据流中的前两行打印到一个文本文件中：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># sed '1,2w test.txt' data6.txt</span>
This is line number <span>1</span>.
This is line number <span>2</span>.
This is line number <span>3</span>.
This is line number <span>4</span>.
<span>[</span>root@localhost ~<span>]</span><span># cat test.txt</span>
This is line number <span>1</span>.
This is line number <span>2</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>当然，如果不想让行直接输出，可以用 -n 选项，再举个例子：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cat data7.txt</span>
Blum, R    Browncoat
McGuiness, A Alliance
Bresnahan, C Browncoat
Harken, C   Alliance
<span>[</span>root@localhost ~<span>]</span><span># sed -n '/Browncoat/w Browncoats.txt' data7.txt</span>
<span>[</span>root@localhost ~<span>]</span><span># cat Browncoats.txt</span>
Blum, R    Browncoat
Bresnahan, C Browncoat
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>可以看到，通过使用 w 脚本命令，<code>sed</code> 可以实现将包含文本模式的数据行写入目标文件。</p>
<h4 id="sed-r-脚本命令"> sed r 脚本命令</h4>
<p>r 命令用于将一个独立文件的数据插入到当前数据流的指定位置，该命令的基本格式为：</p>
<div><pre><code><span>[</span>address<span>]</span>r filename
</code></pre>
<div><span>1</span><br></div></div><p><code>sed</code> 命令会将 filename 文件中的内容插入到 address 指定行的后面，比如说：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cat data8.txt</span>
This is an added line.
This is the second added line.
<span>[</span>root@localhost ~<span>]</span><span># sed '3r data8.txt' data6.txt</span>
This is line number <span>1</span>.
This is line number <span>2</span>.
This is line number <span>3</span>.
This is an added line.
This is the second added line.
This is line number <span>4</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>如果你想将指定文件中的数据插入到数据流的末尾，可以使用 $ 地址符，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># sed '$r data8.txt' data6.txt</span>
This is line number <span>1</span>.
This is line number <span>2</span>.
This is line number <span>3</span>.
This is line number <span>4</span>.
This is an added line.
This is the second added line.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h4 id="sed-q-退出脚本命令"> sed q 退出脚本命令</h4>
<p>q 命令的作用是使 <code>sed</code> 命令在第一次匹配任务结束后，退出 <code>sed</code> 程序，不再进行对后续数据的处理。</p>
<p>比如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># sed '2q' test.txt</span>
This is line number <span>1</span>.
This is line number <span>2</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以看到，<code>sed</code> 命令在打印输出第 2 行之后，就停止了，是 q 命令造成的，再比如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># sed '/number 1/{ s/number 1/number 0/;q; }' test.txt</span>
This is line number <span>0</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>使用 q 命令之后，<code>sed</code> 命令会在匹配到 number 1 时，将其替换成 number 0，然后直接退出。</p>
<h3 id="sed-脚本命令的寻址方式"> sed 脚本命令的寻址方式</h3>
<p>前面在介绍各个脚本命令时，我们一直忽略了对 address 部分的介绍。对各个脚本命令来说，address 用来表明该脚本命令作用到文本中的具体行。</p>
<p>默认情况下，<code>sed</code> 命令会作用于文本数据的所有行。如果只想将命令作用于特定行或某些行，则必须写明 address 部分，表示的方法有以下 2 种：</p>
<ol>
<li>以数字形式指定行区间；</li>
<li>用文本模式指定具体行区间。</li>
</ol>
<p>以上两种形式都可以使用如下这 2 种格式，分别是：</p>
<div><pre><code><span>[</span>address<span>]</span>脚本命令

 或者

 address <span>{</span>
   多个脚本命令
 <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>以上两种形式在前面例子中都有具体实例，因此这里不再做过多赘述。</p>
<h4 id="以数字形式指定行区间"> 以数字形式指定行区间</h4>
<p>当使用数字方式的行寻址时，可以用行在文本流中的行位置来引用。<code>sed</code> 会将文本流中的第一行编号为 1，然后继续按顺序为接下来的行分配行号。</p>
<p>在脚本命令中，指定的地址可以是单个行号，或是用起始行号、逗号以及结尾行号指定的一定区间范围内的行。这里举一个 <code>sed</code> 命令作用到指定行号的例子：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span>#sed '2s/dog/cat/' data9.txt</span>
The quick brown fox jumps over the lazy dog
The quick brown fox jumps over the lazy <span>cat</span>
The quick brown fox jumps over the lazy dog
The quick brown fox jumps over the lazy dog
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>可以看到，<code>sed</code> 只修改地址指定的第二行的文本。下面的例子中使用了行地址区间：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># sed '2,3s/dog/cat/' data9.txt</span>
The quick brown fox jumps over the lazy dog
The quick brown fox jumps over the lazy <span>cat</span>
The quick brown fox jumps over the lazy <span>cat</span>
The quick brown fox jumps over the lazy dog
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>在此基础上，如果想将命令作用到文本中从某行开始的所有行，可以用特殊地址---美元符（$）：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># sed '2,$s/dog/cat/' data9.txt</span>
The quick brown fox jumps over the lazy dog
The quick brown fox jumps over the lazy <span>cat</span>
The quick brown fox jumps over the lazy <span>cat</span>
The quick brown fox jumps over the lazy <span>cat</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="用文本模式指定行区间"> 用文本模式指定行区间</h4>
<p><code>sed</code> 允许指定文本模式来过滤出命令要作用的行，格式如下：</p>
<div><pre><code>/pattern/command
</code></pre>
<div><span>1</span><br></div></div><p>注意，必须用正斜线将要指定的 pattern 封起来，<code>sed</code> 会将该命令作用到包含指定文本模式的行上。</p>
<p>举个例子，如果你想只修改用户 demo 的默认 shell，可以使用 <code>sed</code> 命令，执行命令如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># grep demo /etc/passwd</span>
demo:x:502:502::/home/Samantha:/bin/bash
<span>[</span>root@localhost ~<span>]</span><span># sed '/demo/s/bash/csh/' /etc/passwd</span>
root:x:0:0:root:/root:/bin/bash
<span>..</span>.
demo:x:502:502::/home/demo:/bin/csh
<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>虽然使用固定文本模式能帮你过滤出特定的值，就跟上面这个用户名的例子一样，但其作用难免有限，因此，<code>sed</code> 允许在文本模式使用正则表达式指明作用的具体行。正则表达式允许创建高级文本模式匹配表达式来匹配各种数据。这些表达式结合了一系列通配符、特殊字符以及固定文本字符来生成能够匹配几乎任何形式文本的简练模式。</p>
<p>示例：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cat test.txt</span>
<span>&lt;</span>html<span>></span>
<span>&lt;</span>title<span>></span>First Wed<span>&lt;</span>/title<span>></span>
<span>&lt;</span>body<span>></span>
h1Helloh1
h2Helloh2
h3Helloh3
<span>&lt;</span>/body<span>></span>
<span>&lt;</span>/html<span>></span>
<span>#使用正则表示式给所有第一个的h1、h2、h3添加&lt;>，给第二个h1、h2、h3添加&lt;/></span>
<span>[</span>root@localhost ~<span>]</span><span># cat sed.sh</span>
/h<span>[</span><span>0</span>-9<span>]</span>/<span>{</span>
    s//<span>\</span><span>&lt;&amp;</span><span>\</span><span>></span>/1
    s//<span>\</span><span>&lt;</span><span>\</span>/<span>&amp;</span><span>\</span><span>></span>/2
<span>}</span>
<span>[</span>root@localhost ~<span>]</span><span># sed -f sed.sh test.txt</span>
<span>&lt;</span>h<span><span>1</span>></span>Hello<span>&lt;</span>/h<span><span>1</span>></span>
<span>&lt;</span>h<span><span>2</span>></span>Hello<span>&lt;</span>/h<span><span>2</span>></span>
<span>&lt;</span>h<span><span>3</span>></span>Hello<span>&lt;</span>/h<span><span>3</span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id="awk-命令"> awk 命令</h2>
<p>除了使用 <code>sed</code> 命令，Linux 系统中还有一个功能更加强大的文本数据处理工具，就是 <code>awk</code>。它诞生于 20 世纪 70 年代末期，这也许是它影响了众多 Linux 用户的原因之一。</p>
<p>曾有人推测 <code>awk</code> 命令的名字来源于 awkward 这个单词。其实不然，此命令的设计者有 3 位，他们的姓分别是 Aho、Weingberger 和 Kernighan，awk 就取自这 3 为大师姓的首字母。</p>
<p>和 <code>sed</code> 命令类似，<code>awk</code> 命令也是逐行扫描文件（从第 1 行到最后一行），寻找含有目标文本的行，如果匹配成功，则会在该行上执行用户想要的操作；反之，则不对行做任何处理。</p>
<p><code>awk</code> 命令的基本格式为：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># awk [选项] '[脚本命令]' 文件名</span>
选项：
	-F fs		：指定以 fs 作为输入行的分隔符，awk 命令默认分隔符为空格或制表符
	-f <span>file</span>		：从脚本文件中读取 <span>awk</span> 脚本指令，以取代直接在命令行中输入指令
	-v <span>var</span><span>=</span>val	：在执行处理过程之前，设置一个变量 var，并给其设备初始值为 val
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>awk</code> 的强大之处在于脚本命令，它由 2 部分组成，分别为匹配规则和执行命令，如下所示：</p>
<div><pre><code><span>'匹配规则{执行命令}'</span>
</code></pre>
<div><span>1</span><br></div></div><p>这里的匹配规则，和 <code>sed</code> 命令中的 address 部分作用相同，用来指定脚本命令可以作用到文本内容中的具体行，可以使用字符串（比如  /demo/，表示查看含有 demo 字符串的行）或者正则表达式指定。另外需要注意的是，<strong>整个脚本命令是用单引号 '  ' 括起，而其中的执行命令部分需要用大括号 {  } 括起来</strong>。</p>
<p>在 <code>awk</code> 程序执行时，如果没有指定执行命令，则默认会把匹配的行输出；如果不指定匹配规则，则默认匹配文本中所有的行。</p>
<p>举个简单的例子：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># awk '/^$/ {print "Blank line"}' test.txt</span>
</code></pre>
<div><span>1</span><br></div></div><p>在此命令中，<code>/^$/</code> 是一个正则表达式，功能是匹配文本中的空白行，同时可以看到，执行命令使用的是 print 命令，此命令经常会使用，它的作用很简单，就是将指定的文本进行输出。因此，整个命令的功能是，如果 test.txt 有 N 个空白行，那么执行此命令会输出 N 个 Blank line。</p>
<h3 id="awk-基本用法"> awk 基本用法</h3>
<h4 id="awk-对字段的提取-列"> awk 对字段的提取（列）</h4>
<p><code>awk</code> 的主要特性之一是其处理文本文件中数据的能力，它会自动给一行中的每个数据元素分配一个变量。</p>
<p>默认情况下，<code>awk</code> 会将如下变量分配给它在文本行中发现的数据字段：</p>
<ul>
<li>$0 代表整个文本行；</li>
<li>$1 代表文本行中的第 1 个数据字段；</li>
<li>$2 代表文本行中的第 2 个数据字段；</li>
<li>$N 代表文本行中的第 N 个数据字段；</li>
<li>$NF 代表文本行中的最后一个数据字段。</li>
</ul>
<p>前面说过，在 <code>awk</code> 中，默认的字段分隔符是任意的空白字符（例如空格或制表符）。 在文本行中，每个数据字段都是通过字段分隔符划分的。<code>awk</code> 在读取一行文本时，会用预定义的字段分隔符划分每个数据字段。</p>
<p>所以在下面的例子中，<code>awk</code> 程序读取文本文件，只显示第 1 个数据字段的值：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cat data2.txt</span>
One line of <span>test</span> text.
Two lines of <span>test</span> text.
Three lines of <span>test</span> text.
<span>[</span>root@localhost ~<span>]</span><span># awk '{print $1}' data2.txt</span>
One
Two
Three
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>该程序用 $1 字段变量来表示“仅显示每行文本的第 1 个数据字段”。当然，如果你要读取采用了其他字段分隔符的文件，可以用 -F 选项手动指定。</p>
<h4 id="awk-对记录的提取-行"> awk 对记录的提取（行）</h4>
<p>提取一个文本中的一行并打印输出，记录的提取方法有两种：</p>
<ul>
<li>通过行号</li>
<li>通过正则匹配</li>
</ul>
<p>例如：提取test中的第三行（指定行号为3）</p>
<div><pre><code><span>[</span>root@linux ~ <span>]</span><span># awk 'NR==3{print $0}' test</span>
<span>3</span> the quick brown fox jumps over the lazy cat.
<span>[</span>root@linux ~ <span>]</span><span># awk 'NR==1{print $1,$3,$5}' /etc/passwd</span>
root <span>0</span> root
<span>[</span>root@linux ~ <span>]</span><span># awk 'NR==1{print $1 "-" $3 "-" $5}' /etc/passwd</span>
root-0-root
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id="awk-脚本命令使用多个命令"> awk 脚本命令使用多个命令</h4>
<p><code>awk</code> 允许将多条命令组合成一个正常的程序。要在命令行上的程序脚本中使用多条命令，只要在命令之间放个分号即可，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># echo "My name is Rich" | awk '{$4="Christine"; print $0}'</span>
My name is Christine
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>第一条命令会给字段变量 $4 赋值。第二条命令会打印整个数据字段。可以看到，<code>awk</code> 程序在输出中已经将原文本中的第四个数据字段替换成了新值。</p>
<p>除此之外，也可以一次一行地输入程序脚本命令，比如说：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># awk '{</span>
<span>></span> <span>$4</span><span>=</span><span>"Christine"</span>
<span>></span> print <span>$0</span><span>}</span>'
My name is Rich
My name is Christine
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>在你用了表示起始的单引号后，bash shell 会使用 <code>&gt;</code> 来提示输入更多数据，我们可以每次在每行加一条命令，直到输入了结尾的单引号。</p>
<p>注意，此例中因为没有在命令行中指定文件名，<code>awk</code> 程序需要用户输入获得数据，因此当运行这个程序的时候，它会一直等着用户输入文本，此时如果要退出程序，只需按下 <kbd>Ctrl</kbd>+<kbd>D</kbd> 组合键即可。</p>
<h4 id="awk-从文件中读取程序"> awk 从文件中读取程序</h4>
<p>跟 <code>sed</code> 一样，<code>awk</code> 允许将脚本命令存储到文件中，然后再在命令行中引用，比如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cat awk.sh</span>
<span>{</span>print <span>$1</span> <span>"'s home directory is "</span> <span>$6</span><span>}</span>
<span>[</span>root@localhost ~<span>]</span><span># awk -F: -f awk.sh /etc/passwd</span>
root<span>'s home directory is /root
bin'</span>s home directory is /bin
daemon<span>'s home directory is /sbin
adm'</span>s home directory is /var/adm
lp<span>'s home directory is /var/spool/lpd
...
Christine'</span>s home directory is /home/Christine
Samantha<span>'s home directory is /home/Samantha
Timothy'</span>s home directory is /home/Timothy
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>awk.sh 脚本文件会使用 print 命令打印 <code>/etc/passwd</code> 文件的主目录数据字段（字段变量 $6），以及 userid 数据字段（字段变量 $1）。注意，在程序文件中，也可以指定多条命令，只要一条命令放一行即可，之间不需要用分号。</p>
<h4 id="awk-begin关键字"> awk BEGIN关键字</h4>
<p><code>awk</code> 中还可以指定脚本命令的运行时机。默认情况下，<code>awk</code> 会从输入中读取一行文本，然后针对该行的数据执行程序脚本，但有时可能需要在处理数据前运行一些脚本命令，这就需要使用 BEGIN 关键字。</p>
<p>BEGIN 会强制 <code>awk</code> 在读取数据前执行该关键字后指定的脚本命令，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cat data3.txt</span>
Line <span>1</span>
Line <span>2</span>
Line <span>3</span>
<span>[</span>root@localhost ~<span>]</span><span># awk 'BEGIN {print "The data3 File Contents:"}</span>
<span>></span> <span>{</span>print <span>$0</span><span>}</span>' data3.txt
The data3 File Contents:
Line <span>1</span>
Line <span>2</span>
Line <span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>可以看到，这里的脚本命令中分为 2 部分，BEGIN 部分的脚本指令会在 awk 命令处理数据前运行，而真正用来处理数据的是第二段脚本命令。</p>
<h4 id="awk-end关键字"> awk END关键字</h4>
<p>和 BEGIN 关键字相对应，END 关键字允许我们指定一些脚本命令，<code>awk</code> 会在读完数据后执行它们，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># awk 'BEGIN {print "The data3 File Contents:"}</span>
<span>></span> <span>{</span>print <span>$0</span><span>}</span>
<span>></span> END <span>{</span>print <span>"End of File"</span><span>}</span>' data3.txt
The data3 File Contents:
Line <span>1</span>
Line <span>2</span>
Line <span>3</span>
End of File
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>可以看到，当 <code>awk</code> 程序打印完文件内容后，才会执行 END 中的脚本命令。</p>
<p>上面介绍了 awk 程序的基本用法，下面继续介绍更高级的用法。</p>
<h3 id="awk-高级用法"> awk 高级用法</h3>
<p>其实在 <code>awk</code> 脚本程序中，还支持使用一些编程语言，比如变量、数组、分支结构（if-then-else）、循环结构（while）、函数等，下面一一给大家介绍。</p>
<h4 id="awk-使用变量"> awk 使用变量</h4>
<p>在 <code>awk</code> 的脚本程序中，支持使用变量来存取值。<code>awk</code> 支持两种不同类型的变量：</p>
<ul>
<li>内建变量：<code>awk</code> 本身就创建好，用户可以直接拿来用的变量，这些变量用来存放处理数据文件中的某些字段和记录的信息。</li>
<li>自定义变量：<code>awk</code> 支持用户自己创建变量。</li>
</ul>
<h4 id="内建变量"> 内建变量</h4>
<p><code>awk</code> 程序使用内建变量来引用程序数据里的一些特殊功能。常见的一些内建变量，包括上面介绍的数据字段变量（$0、$1、<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>2...</span></span></span></span>n）以及表2、表3 中所示的这些变量。</p>
<p><strong>表2	<u>字段和记录分隔符变量</u></strong></p>
<table>
<thead>
<tr>
<th>变量</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>FIELDWIDTHS</td>
<td>由空格分隔的一列数字，定义了每个数据字段的确切宽度。</td>
</tr>
<tr>
<td>FNR</td>
<td>当前输入文档的记录编号，常在有多个输入文档时使用。</td>
</tr>
<tr>
<td>NR</td>
<td>输入流的当前记录编号。</td>
</tr>
<tr>
<td>FS</td>
<td>输入字段分隔符，默认为空格。</td>
</tr>
<tr>
<td>RS</td>
<td>输入记录分隔符，默认为换行符 \n。</td>
</tr>
<tr>
<td>OFS</td>
<td>输出字段分隔符，默认为空格。</td>
</tr>
<tr>
<td>ORS</td>
<td>输出记录分隔符，默认为换行符 \n。</td>
</tr>
</tbody>
</table>
<p>在表2 中，变量 FS 和 OFS 定义了 <code>awk</code> 如何处理数据流中的数据字段。我们已经知道了如何使用变量 FS 来定义记录中的字段分隔符，变量 OFS 具备相同的功能，只不过是用在 print 命令的输出上，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cat data1</span>
data11,data12,data13,data14,data15
data21,data22,data23,data24,data25
data31,data32,data33,data34,data35
<span>[</span>root@localhost ~<span>]</span><span># awk 'BEGIN{FS=","; OFS="-"} {print $1,$2,$3}' data1</span>
data11-data12-data13
data21-data22-data23
data31-data32-data33
<span>[</span>root@localhost ~<span>]</span><span># awk 'BEGIN{FS=","; OFS="--"} {print $1,$2,$3}' data1</span>
data11--data12--data13
data21--data22--data23
data31--data32--data33
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>可以看到，print 命令会自动将 OFS 变量的值放置在输出中的每个字段间。通过设置 OFS 变量，可以在输出中使用任意字符串来分隔字段。</p>
<p>FIELDWIDTHS 变量允许用户不依靠字段分隔符来读取记录。在一些应用程序中，数据并没有使用字段分隔符，而是被放置在了记录中的特定列，这种情况下，必须设定 FIELDWIDTHS 变量来匹配数据在记录中的位置。</p>
<p>一旦设置了 FIELDWIDTH 变量，<code>awk</code> 就会忽略 FS 变量，并根据提供的字段宽度来计算字段，下面是个采用字段宽度而非字段分隔符的例子：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cat data2</span>
<span>1005.3247596</span>.37
<span>115</span>-2.349194.00
05810.1298100.1
<span>[</span>root@localhost ~<span>]</span><span># awk 'BEGIN{FIELDWIDTHS="3 5 2 5"}{print $1,$2,$3,$4}' data2</span>
<span>100</span> <span>5.324</span> <span>75</span> <span>96.37</span>
<span>115</span> -2.34 <span>91</span> <span>94.00</span>
058 <span>10.12</span> <span>98</span> <span>100.1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>注意，一旦设定了 FIELDWIDTHS 变量的值，就不能再改变了，因此，这种方法并不适用于变长的字段。</p>
<p>变量 RS 和 ORS 定义了 <code>awk</code> 程序如何处理数据流中的字段，默认情况下，awk 将 RS 和 ORS 设为换行符。默认的 RS  值表明，输入数据流中的每行新文本就是一条新纪录。  有时，你会在数据流中碰到占据多行的字段。典型的例子是包含地址和电话号码的数据，其中地址和电话号码各占一行，例如：</p>
<div><pre><code>Riley Mullen
123 Main Street
Chicago, IL 60601
(312)555-1234
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果你用默认的 FS 和 RS 变量值来读取这组数据，<code>awk</code> 就会把每行作为一条单独的记录来读取，并将记录中的空格当作字段分隔符，这并不是用户想要的。</p>
<p>要解决这个问题，只需把 FS 变量设置成换行符，这就表明数据流中的每行都是一个单独的字段，每行上的所有数据都属于同一个字段；与此同时，把 RS 变量设置成空字符串，然后在数据记录间留一个空白行，<code>awk</code> 会把每个空白行当作一个记录分隔符。例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cat data3</span>
Riley Mullen
<span>123</span> Main Street
Chicago, IL <span>60601</span>
<span>(</span><span>312</span><span>)</span><span>555</span>-1234

Frank Williams
<span>456</span> Oak Street
Indianapolis, IN <span>46201</span>
<span>(</span><span>317</span><span>)</span><span>555</span>-9876

Haley Snell
<span>4231</span> Elm Street
Detroit, MI <span>48201</span>
<span>(</span><span>313</span><span>)</span><span>555</span>-4938
<span>[</span>root@localhost ~<span>]</span><span># awk 'BEGIN{FS="\n"; RS=""} {print $1,$4}' data3</span>
Riley Mullen <span>(</span><span>312</span><span>)</span><span>555</span>-1234
Frank Williams <span>(</span><span>317</span><span>)</span><span>555</span>-9876
Haley Snell <span>(</span><span>313</span><span>)</span><span>555</span>-4938
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><div><p>了解</p>
<p><strong>表3	<u>环境信息变量</u></strong></p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>ARGC</td>
<td>命令行参数个数。</td>
</tr>
<tr>
<td>ARGIND</td>
<td>当前文件在 ARGC 中的位置。</td>
</tr>
<tr>
<td>ARGV</td>
<td>包含命令行参数的数组。</td>
</tr>
<tr>
<td>CONVFMT</td>
<td>数字的转换格式，默认值为 %.6g。</td>
</tr>
<tr>
<td>ENVIRON</td>
<td>当前 shell 环境变量及其值组成的关联数组。</td>
</tr>
<tr>
<td>ERRNO</td>
<td>当读取或关闭输入文件发生错误时的系统错误号。</td>
</tr>
<tr>
<td>FILENAME</td>
<td>当前输入文档的名称。</td>
</tr>
<tr>
<td>FNR</td>
<td>当前数据文件中的数据行数。</td>
</tr>
<tr>
<td>IGNORECASE</td>
<td>设成非 0 值时，忽略 awk 命令中出现的字符串的字符大小写。</td>
</tr>
<tr>
<td>NF</td>
<td>数据文件中的字段总数。</td>
</tr>
<tr>
<td>NR</td>
<td>已处理的输入记录数。</td>
</tr>
<tr>
<td>OFMT</td>
<td>数字的输出格式，默认值为 %.6g。</td>
</tr>
<tr>
<td>RLENGTH</td>
<td>由 match 函数所匹配的子字符串的长度。</td>
</tr>
<tr>
<td>TSTART</td>
<td>由 match 函数所匹配的子字符串的起始位置。</td>
</tr>
</tbody>
</table>
<p>其中，FNR 和 NR 变量虽然类似，但又略有不同。FNR 变量含有当前数据文件中已处理过的记录数，NR 变量则含有已处理过的记录总数。举个例子：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cat data1</span>
data11,data12,data13,data14,data15
data21,data22,data23,data24,data25
data31,data32,data33,data34,data35
<span>[</span>root@localhost ~<span>]</span><span># awk '</span>
<span>></span> BEGIN <span>{</span>FS<span>=</span><span>","</span><span>}</span>
<span>></span> <span>{</span>print <span>$1</span>,<span>"FNR="</span>FNR,<span>"NR="</span>NR<span>}</span>
<span>></span> END<span>{</span>print <span>"There were"</span>,NR,<span>"records processed"</span><span>}</span>' data1 data1
data11 <span>FNR</span><span>=</span><span>1</span> <span>NR</span><span>=</span><span>1</span>
data21 <span>FNR</span><span>=</span><span>2</span> <span>NR</span><span>=</span><span>2</span>
data31 <span>FNR</span><span>=</span><span>3</span> <span>NR</span><span>=</span><span>3</span>
data11 <span>FNR</span><span>=</span><span>1</span> <span>NR</span><span>=</span><span>4</span>
data21 <span>FNR</span><span>=</span><span>2</span> <span>NR</span><span>=</span><span>5</span>
data31 <span>FNR</span><span>=</span><span>3</span> <span>NR</span><span>=</span><span>6</span>
There were <span>6</span> records processed
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>由此可以看出，当只使用一个数据文件作为输入时，FNR 和 NR 的值是相同的；如果使用多个数据文件作为输入，FNR 的值会在处理每个数据文件时被重置，而 NR 的值则会继续计数直到处理完所有的数据文件。</p>
</div>
<h4 id="自定义变量"> 自定义变量</h4>
<p>和其他典型的编程语言一样，<code>awk</code> 允许用户定义自己的变量在脚本程序中使用。<code>awk</code> 自定义变量名可以是任意数目的字母、数字和下划线，但不能以数字开头。更重要的是，<code>awk</code> 变量名区分大小写。</p>
<p>举个简单的例子：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># awk '</span>
<span>></span> BEGIN<span>{</span>
<span>></span> <span>testing</span><span>=</span><span>"This is a test"</span>
<span>></span> print testing
<span>></span> <span>testing</span><span>=</span><span>45</span>
<span>></span> print testing
<span>></span> <span>}</span>'
This is a <span>test</span>
<span>45</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>可以看到，print 语句的输出是 testing 变量的当前值。</p>
<p>也可以用 <code>awk</code> 命令行来给程序中的变量赋值，这允许我们在正常的代码之外赋值，即时改变变量的值，比如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cat script1</span>
BEGIN<span>{</span>FS<span>=</span><span>","</span><span>}</span> <span>{</span>print <span>$n</span><span>}</span>
<span>[</span>root@localhost ~<span>]</span><span># awk -f script1 n=2 data1</span>
data12
data22
data32
<span>[</span>root@localhost ~<span>]</span><span># awk -f script1 n=3 data1</span>
data13
data23
data33
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>需要注意的是，使用命令行参数来定义变量值会有一个问题，即设置了变量后，这个值在代码的 BEGIN 部分不可用，如下所示：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cat script2</span>
BEGIN<span>{</span>print <span>"The starting value is"</span>,n<span>;</span> <span>FS</span><span>=</span><span>","</span><span>}</span>
<span>{</span>print <span>$n</span><span>}</span>
<span>[</span>root@localhost ~<span>]</span><span># awk -f script2 n=3 data1</span>
The starting value is
data13
data23
data33
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>解决这个问题，可以用 -v 命令行参数，它可以实现在 BEGIN 代码之前设定变量。在命令行上，-v 命令行参数必须放在脚本代码之前，如下所示：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># awk -v n=3 -f script2 data1</span>
The starting value is <span>3</span>
data13
data23
data33
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>注意，<code>awk</code> 脚本程序中输出函数还可以使用 C 语言中的 printf 函数。</p>
<h3 id="awk-使用数组"> awk 使用数组</h3>
<p>为了在单个变量中存储多个值，许多编程语言都提供数组，<code>awk</code> 使用关联数组提供数组功能。</p>
<p>关联数组跟数字数组不同之处在于，它的索引值可以是任意文本字符串。用户不需要用连续的数字来标识数组中的数据元素；相反，关联数组用各种字符串来引用值。每个索引字符串都必须能够唯一地标识出赋给它的数据元素。</p>
<p>如果你熟悉其他编程语言的话，其实关联数组和散列表、字典的用法类似。</p>
<h4 id="关联数组的定义和使用"> 关联数组的定义和使用</h4>
<p>在 <code>awk</code> 脚本程序中，定义一个数组变量可以使用标准复制语句，其基本格式为：</p>
<div><pre><code>var<span>[</span>index<span>]</span><span>=</span>element
</code></pre>
<div><span>1</span><br></div></div><p>其中，var 是数组名，index 是关联数组的索引值，element 是数据元素值。例如：</p>
<div><pre><code>capital<span>[</span><span>"Illinois"</span><span>]</span> <span>=</span> <span>"[Spring](http://c.biancheng.net/spring/)field"</span>
capital<span>[</span><span>"Indiana"</span><span>]</span> <span>=</span> <span>"Indianapolis"</span>
capital<span>[</span><span>"Ohio"</span><span>]</span> <span>=</span> <span>"Columbus"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>在引用数组变量时，必须用索引值（index）来提取相应的数据元素值，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># awk 'BEGIN{</span>
<span>></span> capital<span>[</span><span>"Illinois"</span><span>]</span> <span>=</span> <span>"Springfield"</span>
<span>></span> print capital<span>[</span><span>"Illinois"</span><span>]</span>
<span>></span> <span>}</span>'
Springfield
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>数组变量也是变量，也可以使用其进行基本的算术运算，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># awk 'BEGIN{</span>
<span>></span> var<span>[</span><span>1</span><span>]</span> <span>=</span> <span>34</span>
<span>></span> var<span>[</span><span>2</span><span>]</span> <span>=</span> <span>3</span>
<span>></span> total <span>=</span> var<span>[</span><span>1</span><span>]</span> + var<span>[</span><span>2</span><span>]</span>
<span>></span> print total
<span>></span> <span>}</span>'
<span>37</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h4 id="关联数组的遍历"> 关联数组的遍历</h4>
<p>在 <code>awk</code> 中遍历关联数组，可以用 for 语句的一种特殊形式：</p>
<div><pre><code><span>for</span> <span>(</span>var <span>in</span> array<span>)</span>
 <span>{</span>
	statements
 <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这个 for 语句会在每次循环时将关联数组 array 的下一个索引值赋给变量 var，然后执行一遍 statements。</p>
<p><strong>再次强调，整个遍历过程中，传给 var 的都是每个数组元素的索引值（也就是 index），不是数组元素的值。</strong></p>
<p>举个例子：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># awk 'BEGIN{</span>
<span>></span> var<span>[</span><span>"a"</span><span>]</span> <span>=</span> <span>1</span>
<span>></span> var<span>[</span><span>"g"</span><span>]</span> <span>=</span> <span>2</span>
<span>></span> var<span>[</span><span>"m"</span><span>]</span> <span>=</span> <span>3</span>
<span>></span> var<span>[</span><span>"u"</span><span>]</span> <span>=</span> <span>4</span>
<span>></span> <span>for</span> <span>(</span>test <span>in</span> var<span>)</span>
<span>></span> <span>{</span>
<span>></span>  print <span>"Index:"</span>,test,<span>" - Value:"</span>,var<span>[</span>test<span>]</span>
<span>></span> <span>}</span>
<span>></span> <span>}</span>'
Index: u - Value: <span>4</span>
Index: m - Value: <span>3</span>
Index: a - Value: <span>1</span>
Index: g - Value: <span>2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>注意，索引值不会按任何特定顺序返回，但它们都能够指向对应的数据元素值。</p>
<h4 id="删除数组变量"> 删除数组变量</h4>
<p><code>awk</code> 脚本程序还支持从关联数组中删除某个数组索引，使用 delete 命令就可以，此命令会从数组中删除指定的索引值及相关的数据元素的值。</p>
<p>delete 命令的基本格式如下：</p>
<div><pre><code>delete array<span>[</span>index<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>举个例子：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># awk 'BEGIN{</span>
<span>></span> var<span>[</span><span>"a"</span><span>]</span> <span>=</span> <span>1</span>
<span>></span> var<span>[</span><span>"g"</span><span>]</span> <span>=</span> <span>2</span>
<span>></span> <span>for</span> <span>(</span>test <span>in</span> var<span>)</span>
<span>></span> <span>{</span>
<span>></span>  print <span>"Index:"</span>,test,<span>" - Value:"</span>,var<span>[</span>test<span>]</span>
<span>></span> <span>}</span>
<span>></span> delete var<span>[</span><span>"g"</span><span>]</span>
<span>></span> print <span>"---"</span>
<span>></span> <span>for</span> <span>(</span>test <span>in</span> var<span>)</span>
<span>></span> <span>{</span>
<span>></span>  print <span>"Index:"</span>,test,<span>" - Value:"</span>,var<span>[</span>test<span>]</span>
<span>></span> <span>}</span>
<span>></span> <span>}</span>'
Index: a - Value: <span>1</span>
Index: g - Value: <span>2</span>
---
Index: a - Value: <span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>需要注意的是，一旦从关联数组中删除了索引值，就没法再用它来提取元素值。</p>
<h3 id="awk-使用分支结构"> awk 使用分支结构</h3>
<p><code>awk</code> 支持标准的 if-then-else 格式的 if 语句，其基本格式为：</p>
<div><pre><code><span>if</span> <span>(</span>condition<span>)</span>
	commands1；
 <span>else</span>
	commands2；
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>也可以将它放在一行上，像这样：</p>
<div><pre><code><span>if</span> <span>(</span>condition<span>)</span> statement1<span>;</span><span>else</span> statement2
</code></pre>
<div><span>1</span><br></div></div><p>举个简单的例子：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cat data4</span>
<span>10</span>
<span>5</span>
<span>13</span>
<span>50</span>
<span>34</span>
<span>[</span>root@localhost ~<span>]</span><span># awk '{if ($1 > 20) print $1 * 2; else print $1 / 2}' data4</span>
<span>5</span>
<span>2.5</span>
<span>6.5</span>
<span>100</span>
<span>68</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="awk-使用循环结构"> awk 使用循环结构</h3>
<p><code>awk</code> 脚本程序中，可以使用 while、do-while、for 这 3 种循环结构，它们各自的基本格式分别如表 3 所示。</p>
<h4 id="while-循环"> while 循环</h4>
<p>基本格式为：</p>
<div><pre><code><span>while</span> <span>(</span>condition<span>)</span> <span>{</span> 
	commands<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cat data5</span>
<span>130</span> <span>120</span> <span>135</span>
<span>160</span> <span>113</span> <span>140</span>
<span>145</span> <span>170</span> <span>215</span>
<span>[</span>root@localhost ~<span>]</span><span># awk '{</span>
<span>></span> total <span>=</span> <span>0</span>
<span>></span> i <span>=</span> <span>1</span>
<span>></span> <span>while</span> <span>(</span>i <span>&lt;</span> <span>4</span><span>)</span>
<span>></span> <span>{</span>
<span>></span>    total <span>+=</span> <span>$i</span>
<span>></span>    i++
<span>></span> <span>}</span>
<span>></span> avg <span>=</span> total / <span>3</span>
<span>></span> print <span>"Average:"</span>,avg
<span>></span> <span>}</span>' data5
Average: <span>128.333</span>
Average: <span>137.667</span>
Average: <span>176.667</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h4 id="do-while-循环"> do-while 循环</h4>
<p>基本格式为：</p>
<div><pre><code><span>do</span> <span>{</span>
	commmands<span>;</span>
<span>}</span>while <span>(</span>条件<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># awk '{</span>
<span>></span> total <span>=</span> <span>0</span>
<span>></span> i <span>=</span> <span>1</span>
<span>></span> <span>do</span>
<span>></span> <span>{</span>
<span>></span>    total <span>+=</span> <span>$i</span>
<span>></span>    i++
<span>></span> <span>}</span> <span>while</span> <span>(</span>total <span>&lt;</span> <span>150</span><span>)</span>
<span>></span> print total <span>}</span>' data5
<span>250</span>
<span>160</span>
<span>315</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h4 id="for-循环"> for 循环</h4>
<p>基本格式为：</p>
<div><pre><code>for<span>(</span>i<span>;</span>condition<span>;</span>count<span>)</span> <span>{</span>
	commands<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># awk '{</span>
<span>></span> total <span>=</span> <span>0</span>
<span>></span> <span>for</span> <span>(</span>i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> <span>4</span><span>;</span> i++<span>)</span>
<span>></span> <span>{</span>
<span>></span>    total <span>+=</span> <span>$i</span>
<span>></span> <span>}</span>
<span>></span> avg <span>=</span> total / <span>3</span>
<span>></span> print <span>"Average:"</span>,avg
<span>></span> <span>}</span>' data5
Average: <span>128.333</span>
Average: <span>137.667</span>
Average: <span>176.667</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>可以看出，<code>awk</code> 支持使用的循环结构的用法和 C 语言完全一样，除此之外，<code>awk</code> 还支持使用 break（跳出循环）、continue（终止当前循环）关键字，其用法和 C 语言中也完全相同。</p>
<h3 id="awk-循环控制"> awk 循环控制</h3>
<h4 id="break-跳出循环"> break：跳出循环</h4>
<p>跳出循环，继续执行循环外的后续语句</p>
<p>例：累加每行数值，和大于150停止累加</p>
<div><pre><code><span>[</span>root@linux ~ <span>]</span><span># awk '{</span>
<span>></span> <span>sum</span><span>=</span><span>0</span>
<span>></span> <span>i</span><span>=</span><span>1</span>
<span>></span> <span>while</span> <span>(</span>i<span>&lt;</span><span>4</span><span>)</span><span>{</span>
<span>></span>	<span>sum</span><span>+=</span><span>$i</span>
<span>></span>	<span>if</span> <span>(</span>sum<span>></span><span>150</span><span>)</span><span>{</span>
<span>></span>		<span>break</span>
<span>></span>	<span>}</span>
<span>></span>	i++
<span>></span> <span>}</span>
<span>></span> print <span>sum</span>
<span>></span> <span>}</span>' data5
<span>250</span>
<span>160</span>
<span>315</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h4 id="continue-终止本次循环"> continue：终止本次循环</h4>
<p>终止本次循环</p>
<p>例：累加每行数值，和大于 400 的打印出来，小于等于 400 的则退出该次循环。</p>
<div><pre><code><span>[</span>root@linux ~ <span>]</span><span># awk '{</span>
<span>></span> <span>sum</span><span>=</span><span>0</span>
<span>></span> <span>i</span><span>=</span><span>1</span>
<span>></span> <span>while</span> <span>(</span>i<span>&lt;</span><span>4</span><span>)</span><span>{</span>
	<span>sum</span><span>+=</span><span>$i</span>
	i++
	<span>if</span> <span>(</span>sum<span>></span><span>400</span><span>)</span>
		print <span>sum</span>
	<span>else</span>
		<span>continue</span>
	<span>}</span>
<span>}</span>' data5
<span>413</span>
<span>530</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="awk-使用函数"> awk 使用函数</h3>
<h4 id="内建函数"> 内建函数</h4>
<p>和内建变量类似，<code>awk</code> 也提供了不少内建函数，可进行一些常见的数学、字符串以及时间函数运算，如表4 所示。</p>
<p><strong>表4	<u>常见的内建函数</u></strong></p>
<table>
<tr>
	<td>函数分类</td>
	<td>函数原型</td>
	<td>函数功能 </td>
</tr>
<tr>
	<td rowspan=9>数学函数</td>
	<td>atan2(x,y)</td>
	<td>x/y 的反正切，x 和 y 以弧度为单位。</td>
</tr>
<tr>
	<td>cos(x)</td>
	<td>x 的余弦，x 以弧度为单位。</td>
</tr>
<tr>
	<td>exp(x)</td>
	<td>x 的指数函数。</td>
</tr>
<tr>
	<td>int(x)</td>
	<td>x 的整数部分，取靠近零一侧的值。</td>
</tr>
<tr>
	<td>log(x)</td>
	<td>x 的自然对数。</td>
</tr>
<tr>
	<td>srand(x)</td>
	<td>为计算随机数指定一个种子值。</td>
</tr>
<tr>
	<td>rand()</td>
	<td>比 0 大比 1 小的随机浮点值。</td>
</tr>
<tr>
	<td>sin(x)</td>
	<td>x 的正弦，x 以弧度为单位。</td>
</tr>
<tr>
	<td>sqrt(x)</td>
	<td>x 的平方根。</td>
</tr>
<tr>
	<td rowspan=6>位运算函数</td>
	<td>and(v1,v2)</td>
	<td>执行值 v1 和 v2 的按位与运算。</td>
</tr>
<tr>
	<td>compl(val)</td>
	<td>执行 val 的补运算。</td>
</tr>
<tr>
	<td>lshift(val,count)</td>
	<td>将值 val 左移 count 位。</td>
</tr>
<tr>
	<td>or(v1,v2) </td>
	<td>执行值 v1 和 v2 的按位或运算。</td>
</tr>
<tr>
	<td>rshift(val,count)</td>
	<td>将值 val 右移 count 位。</td>
</tr>
<tr>
	<td>xor(v1,v2)</td>
	<td>执行值 v1 和 v2 的按位异或运算。</td>
</tr>
<tr>
	<td rowspan=13>字符串函数</td>
	<td> asort(s [,d])</td>
	<td>将数组 s 按数据元素值排序。索引值会被替换成表示新的排序顺序的连续数字。<br>
另外，如果指定了 d，则排序后的数组会存储在数组 d 中。</td>
</tr>
<tr>
	<td>asorti(s [,d])</td>
	<td>将数组 s 按索引值排序。生成的数组会将索引值作为数据元素值，用连续数字索引来表明排序顺序。<br>
        另外如果指定了 d，排序后的数组会存储在数组 d 中。</td>
</tr>
<tr>
	<td>gensub(r,s,h [,t]</td>
	<td>查找变量 $0 或目标字符串 t（如果提供了的话）来匹配正则表达式 r。<br>如果 h 是一个以 g 或 G 开头的字符串，就用 s 替换掉匹配的文本。<br>如果 h 是一个数字，它表示要替换掉第 h 处 r 匹配的地方。</td>
</tr>
<tr>
	<td>gsub(r,s [,t])</td>
	<td>查找变量 $0 或目标字符串 t（如果提供了的话）来匹配正则表达式 r。<br>如果找到了，就全部替换成字符串 s。</td>
</tr>
<tr>
	<td>index(s,t)</td>
	<td>返回字符串 t 在字符串 s 中的索引值，如果没找到的话返回 0。</td>
</tr>
<tr>
	<td>length([s])</td>
	<td>返回字符串 s 的长度；如果没有指定的话，返回 $0 的长度。</td>
</tr>
<tr>
	<td>match(s,r [,a])</td>
	<td>返回字符串 s 中正则表达式 r 出现位置的索引。<br>如果指定了数组 a，它会存储 s 中匹配正则表达式的那部分。</td>
</tr>
<tr>
	<td>split(s,a [,r])</td>
	<td>将 s 用 FS 字符或正则表达式 r（如果指定了的话）分开放到数组 a 中，并返回字段的总数。</td>
</tr>
<tr>
	<td>sprintf(format,variables)</td>
	<td>用提供的 format 和 variables 返回一个类似于 printf 输出的字符串。</td>
</tr>
<tr>
	<td>sub(r,s [,t])</td>
	<td>在变量 $0 或目标字符串 t 中查找正则表达式 r 的匹配。如果找到了，就用字符串 s 替换掉第一处匹配。</td>
</tr>
<tr>
	<td>substr(s,i [,n])</td>
	<td>返回 s 中从索引值 i 开始的 n 个字符组成的子字符串。如果未提供 n，则返回 s 剩下的部分。</td>
</tr>
<tr>
	<td>tolower(s)</td>
	<td>将 s 中的所有字符转换成小写。</td>
</tr>
<tr>
	<td>toupper(s)</td>
	<td>将 s 中的所有字符转换成大写。</td>
</tr>
<tr>
	<td rowspan=3>时间函数</td>
	<td>mktime(datespec)</td>
	<td>将一个按 YYYY MM DD HH MM SS [DST] 格式指定的日期转换成时间戳值。</td>
</tr>
<tr>
	<td>strftime(format [,timestamp])</td>
	<td>将当前时间的时间戳或 timestamp（如果提供了的话）转化格式化日期（采用 shell 函数 date() 的格式）。</td>
</tr>
<tr>
	<td>systime()</td>
	<td>返回当前时间的时间戳。 </td>
</tr>
</table>
<p>时间戳指的是格林威治时间，即从 1970年1月1日起到现在的总秒数。</p>
<h4 id="自定义函数"> 自定义函数</h4>
<p>除了<code>awk</code> 中的内建函数，还可以在 <code>awk</code> 脚本程序中自定义函数，创建自定义函数的基本格式为：</p>
<div><pre><code><span>function</span> 函数名<span>(</span>参数1，参数2，<span>..</span>.<span>)</span>
<span>{</span>
	运行代码；
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>注意，自定义函数的函数名必须能够唯一标识此函数，换句话说，在同一个 <code>awk</code> 脚本程序中，多个函数的函数名不能相同。同时，函数的参数可以有多个（0 个、1 个或多个）。</p>
<p>例如：</p>
<div><pre><code><span>function</span> <span>printthird</span><span>(</span><span>)</span>
<span>{</span>
	print <span>$3</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>此函数会打印记录中的第三个数据字段。</p>
<p>函数还能用 return 语句返回值，例如：</p>
<div><pre><code><span>function</span> myrand<span>(</span>limit<span>)</span> <span>{</span>
	<span>return</span> int<span>(</span>limit * rand<span>(</span><span>))</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>需要注意的是，在定义函数时，它必须出现在所有代码块之前（包括 BEGIN 和 END代码块）。</p>
<h4 id="创建函数库"> 创建函数库</h4>
<p><code>awk</code> 提供了一种途径来将多个函数放到一个库文件中，这样用户就能在所有的 <code>awk</code> 脚本程序中使用了。为了方便大家理解，下面给大家举个实例。</p>
<p>首先，我们需要创建一个存储所有 <code>awk</code> 函数的文件：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cat funclib</span>
<span>function</span> <span>myprint</span><span>(</span><span>)</span> <span>{</span>
	<span>printf</span> <span>"%-16s - %s<span title="\n">\n</span>"</span>, <span>$1</span>, <span>$4</span>
<span>}</span>
<span>function</span> myrand<span>(</span>limit<span>)</span>
<span>{</span>
	<span>return</span> int<span>(</span>limit * rand<span>(</span><span>))</span>
<span>}</span>
<span>function</span> <span>printthird</span><span>(</span><span>)</span>
<span>{</span>
	print <span>$3</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>要想让 <code>awk</code> 成功读取 funclib 函数库文件，就需要使用 -f 选项，但此选项无法和 <code>awk</code> 脚本程序同时放到命令行中一起使用。因此，要使用库函数文件，只能再创建一个脚本程序文件，例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cat script4</span>
BEGIN<span>{</span> <span>FS</span><span>=</span><span>"<span title="\n">\n</span>"</span><span>;</span> <span>RS</span><span>=</span><span>""</span><span>}</span>
<span>{</span>
	myprint<span>(</span><span>)</span>
<span>}</span>
<span>[</span>root@localhost ~<span>]</span><span># awk -f funclib -f script4 data2</span>
Riley Mullen   - <span>(</span><span>312</span><span>)</span><span>555</span>-1234
Frank Williams  - <span>(</span><span>317</span><span>)</span><span>555</span>-9876
Haley Snell   - <span>(</span><span>313</span><span>)</span><span>555</span>-4938
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div>]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-04-09T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">linux大杂烩</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_mix/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Linux_mix/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="大杂烩"> 大杂烩</h2>
<p>所谓的 Linux 大杂烩，就是系统学习的知识之外，平时使用 Linux 时，遇到的一些问题的解决方法、或常规的经验总结。把这些非系统的知识总结起来，当然，这些内容很零散的汇集到此处，某些内容之间可能会有些许联系。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-04-09T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Shell脚本介绍</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/01.Shell_intro/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/01.Shell_intro/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="什么是-shell"> 什么是 Shell</h2>
<p>shell 是一个程序，采用 C 语言编写，是用户和 linux 内核沟通的桥梁。它既是一种命令语言，又是一种解释性的编程语言。通过一个图来查看一下 shell 的作用。</p>
<div>
<p><img src="./assets/shell.png" alt="shell" loading="lazy"></p>
</div>
<ul>
<li>Kernel：为软件服务，接收用户或软件指令驱动硬件，完成工作；</li>
<li>shell：命令解释器；</li>
<li>user：用户接口，对接用户。</li>
</ul>
<p>上图可以看出，shell 在操作系统中起到了承接用户和系统内核的作用。那为什么不直接用户对内核呢？</p>
<p>原因很简单，因为内核处理的都是二进制，而用户处理的都是高级语言。简而言之，如果没有 shell，你希望告诉妹子：我爱你。你需要经过以下步骤：</p>
<ol>
<li>将“我爱你”翻译成二进制</li>
<li>告诉内核</li>
<li>内核通过网卡发送给你的妹子</li>
<li>妹子计算机网卡收到你发送的二进制信息</li>
<li>网卡交给内核</li>
<li>内核再交给妹子</li>
<li>妹子看到的信息都是一串 01 组成的数字，什么鬼？</li>
</ol>
<p>妹子的计算机没有 shell，就没有把二进制信息解释为高级语言，你的表白也就石沉大海了。为了让所有人都能快速，方便的使用计算机，我们的系统开发人员通过 shell 解决了这个问题。使任何一个希望通过计算机来工作，娱乐的人都能够快速操作计算机。</p>
<h2 id="shell-功能"> Shell 功能</h2>
<ul>
<li>命令行解释功能</li>
<li>启动程序</li>
<li>输入输出重定向</li>
<li>管道连接</li>
<li>文件名替换</li>
<li>变量维护</li>
<li>环境控制</li>
<li>shell编程</li>
</ul>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-04-09T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Shell语法</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/02.Shell_grammar/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/02.Shell_grammar/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>shell 脚本就是将完成一个任务的所有命令按照执行的先后顺序，自上而下写入到一个文本文件中，然后给予执行权限。</p>
<h2 id="如何书写一个-shell-脚本"> 如何书写一个 shell 脚本</h2>
<h3 id="shell-脚本命名"> shell 脚本命名：</h3>
<p>名字要有意义，最好不要用 a、b、c、d、1、2、3、4 这种方式命名；虽然 linux 系统中，文件没有扩展名的概念，依然建议用 .sh 结尾；名字不要太长，最好能在 30 个字节以内解决。例如：check_memory.sh</p>
<h3 id="shell脚本格式"> shell脚本格式：</h3>
<p>shell 脚本开头必须指定脚本运行环境，以 #! 这个特殊符号组合来组成。例如：#!/bin/bash 来指定该脚本是运行解析由 /bin/bash 来完成的；
shell 中的注释使用 # 符号</p>
<div><pre><code><span>#shell脚本中，最好加入脚本说明字段</span>
<span>#!/bin/bash</span>
<span>#Author: Admin</span>
<span>#Created Time: 2021/02/02 16:23</span>
<span>#Release: 1.0</span>
<span>#Script Description: first shell study script</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="如何运行一个-shell-脚本"> 如何运行一个 shell 脚本</h2>
<p>脚本运行需要执行权限，当我们给一个文件赋予执行权限后，该脚本就可以运行。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># chmod u+x filename		#赋予执行权限</span>
<span>[</span>root@localhost ~<span>]</span><span># ./filename				#执行脚本333</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果不希望赋予脚本执行权限，那么可以使用 <code>bash</code> 命令来运行未给予执行权限的脚本</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># bash filename			#bash执行脚本</span>
<span>[</span>root@localhost ~<span>]</span><span># bash -x filename		#-x调试，把每条命令执行情况打印出来</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="shell-中的特殊符号"> shell 中的特殊符号</h3>
<p>有基础的同学不要和正则表达式中的符号含义搞混淆了。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>~</td>
<td>家目录。<code># cd ~</code>  代表进入用户家目录</td>
</tr>
<tr>
<td>!</td>
<td>执行历史命令。	<code>!!</code> 执行上一条命令</td>
</tr>
<tr>
<td>$</td>
<td>变量中取内容符</td>
</tr>
<tr>
<td>+  -  *  /  %</td>
<td>对应数学运算 加 减 乘 除 取余数</td>
</tr>
<tr>
<td>&amp;</td>
<td>后台执行</td>
</tr>
<tr>
<td>*</td>
<td>通配符，匹配所有</td>
</tr>
<tr>
<td>?</td>
<td>通配符，匹配除回车以外的一个字符</td>
</tr>
<tr>
<td>;</td>
<td>分号可以在shell中一行执行多个命令，命令之间用分号分割</td>
</tr>
<tr>
<td>|</td>
<td>管道符，上一个命令的输出作为下一个命令的输入</td>
</tr>
<tr>
<td>``</td>
<td>反引号，命令中优先执行反引号内的命令</td>
</tr>
<tr>
<td>'  '</td>
<td>单引号，脚本中的字符串可以用单引号引起来，单引号不能解释变量</td>
</tr>
<tr>
<td>&quot;  &quot;</td>
<td>双引号，脚本中的字符串可以用双引号引起来，双引号可以解释变量</td>
</tr>
</tbody>
</table>
<h3 id="shell-中的管道运用"> shell 中的管道运用</h3>
<ul>
<li>管道符 |</li>
</ul>
<p>管道符在 shell 中使用是最多的，很多组合命令都需要通过组合命令来完成输出。</p>
<p>管道符其实就是下一个命令对上一个命令的输出作处理。</p>
<h3 id="shell-重定向"> shell 重定向</h3>
<table>
<thead>
<tr>
<th>重定向符号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>&gt;</td>
<td>重定向输入，覆盖原数据。</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>重定向追加输入，在原数据的末尾添加。</td>
</tr>
<tr>
<td>&lt;</td>
<td>重定向输出。例如：<code>wc -l &lt; /etc/passwd</code></td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>重定向追加输出。例如：<code>fdisk /dev/sdb &lt;&lt; EOF...................EOF</code></td>
</tr>
</tbody>
</table>
<h3 id="shell-数学运算"> shell 数学运算</h3>
<ul>
<li><code>expr</code> 命令：</li>
</ul>
<p>只能做整数运算，格式比较古板，注意命令，数字和运算符之间有空格</p>
<div><pre><code><span>[</span>root@linux ~<span>]</span><span># expr 1 + 1</span>
<span>2</span>
<span>[</span>root@linux ~<span>]</span><span># expr 5 - 2</span>
<span>3</span>
<span>[</span>root@linux ~<span>]</span><span># expr 3 \* 7			#注意*出现应该转义，否则认为是通配符</span>
<span>21</span>
<span>[</span>root@linux ~<span>]</span><span># expr 5 / 2</span>
<span>2</span>
<span>[</span>root@linux ~<span>]</span><span># expr 10 % 3</span>
<span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>
<li><code>bc</code> 命令：</li>
</ul>
<p>使用 <code>bc</code> 计算器处理浮点运算，scale=2 代表小数点保留两位，quit 退出</p>
<div><pre><code><span>[</span>root@linux ~<span>]</span><span># echo "scale=2;3+100" | bc</span>
<span>103</span>
<span>[</span>root@linux ~<span>]</span><span># echo "scale=2;100-3" | bc</span>
<span>97</span>
<span>[</span>root@linux ~<span>]</span><span># echo "scale=2;100/3" | bc</span>
<span>33.33</span>
<span>[</span>root@linux ~<span>]</span><span>#echo "scale=2;100*3" | bc</span>
<span>300</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ul>
<li><code>(( ))</code>运算：</li>
</ul>
<p>双小圆括号运算，在 shell 中 <code>(( ))</code> 也可以用来作数学运算</p>
<div><pre><code><span>[</span>root@linux ~<span>]</span><span>#echo $((100+3))</span>
<span>103</span>
<span>[</span>root@linux ~<span>]</span><span>#echo $((100-3))</span>
<span>97</span>
<span>[</span>root@linux ~<span>]</span><span>#echo $((100*3))</span>
<span>300</span>
<span>[</span>root@linux ~<span>]</span><span>#echo $((100/3))</span>
<span>33</span>
<span>[</span>root@linux ~<span>]</span><span>#echo $((100%3))</span>
<span>1</span>
<span>[</span>root@linux ~<span>]</span><span>#echo $((10**3))				#开方运算</span>
<span>1000</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="退出脚本"> 退出脚本</h2>
<p><code>exit NUM</code> 退出脚本，释放系统资源，NUM 代表一个整数，代表返回值。</p>
<ul>
<li>exit 0：正常运行程序并退出程序；</li>
<li>exit 1：非正常运行导致退出程序；</li>
</ul>
<p><code>exit 0</code> 可以告知你的程序的使用者，你的程序是正常结束的。
如果 <code>exit 非0值</code>，那么你的程序的使用者通常会认为你的程序产生了一个错误。</p>
<p>在shell中调用完你的程序之后，用 <code>echo $?</code> 命令就可以看到你的程序的 exit 值。在 shell 脚本中，通常会根据上一个命令的 $? 值来进行一些流程控制。0 代表程序正确的执行。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-04-09T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Shell格式化输入</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/04.Shell_format_in/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/04.Shell_format_in/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="read-命令"> read 命令</h2>
<p>默认接收键盘的输入，回车符代表输入结束。</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># read [选项]</span>
选项：
	-p：打印信息，一般放在 -s -t -n 的后面，否则可能会出错
	-t：限定时，单位秒
	-s：不回显
	-n：输入字符个数
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="实例"> 实例</h2>
<ol>
<li>模拟系统登陆</li>
</ol>
<div><pre><code><span>#!/bin/bash</span>
<span>clear</span>

<span>#echo -n -e "Login:  "</span>
<span>#read acc</span>
<span>read</span> -p <span>"Login:  "</span> acc

<span>#echo -n -e "psssword:  "</span>
<span>#read -s -t10 -n8 pw</span>
<span>read</span> -s -t10 -n8 -p <span>"Password:  "</span> pw
<span>echo</span>
<span>echo</span> -e <span>"account:  <span>$acc</span><span title="\t">\t</span>password:  <span>$pw</span> "</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><ol start="2">
<li>利用管道读取文件内容</li>
</ol>
<div><pre><code><span>#!/bin/bash</span>
<span>count</span><span>=</span><span>1</span>								<span>#赋值语句，不加空格</span>
<span>cat</span> test.txt <span>|</span> <span>while</span> <span>read</span> line		<span>#cat的输出作为read的输入，read读到的值放入line</span>
<span>do</span>
	<span>echo</span> <span>"Line <span>$count</span>:<span>$line</span>"</span>
	<span>count</span><span>=</span>$<span>[</span> <span>$count</span> + <span>1</span> <span>]</span>			<span>#注意中括号中的空格</span>
<span>done</span>
<span>echo</span> <span>"Finish"</span>
<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>每次调用 <code>read</code> 命令都会读取文件中的 &quot;一行&quot; 文本（文本文件的每一行结尾都有一个回车符）。当文件没有可读的行时（即没有回车符时），<code>read</code> 命令将以非零状态退出。</p>
<p>通过什么样的方法将文件中的数据传给 <code>read</code> 呢？使用 <code>cat</code> 命令并通过管道将结果直接传送给包含 <code>read</code> 命令的 <code>while</code> 命令。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-04-09T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Shell变量</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/05.Shell_var/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/05.Shell_var/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="变量介绍"> 变量介绍</h2>
<p>在编程中，我们总有一些数据需要临时存放在内存，以待后续使用时快速读出。内存在系统启动的时候被按照1B一个单位划分若干个块，然后统一编号（16 进制编号），并对内存的使用情况做记录，保存在内存跟踪表中。</p>
<p>那么问题来了，1G 内存有多少个 1B 单位呢？</p>
<blockquote>
<p>计算机的存储容量单位：
1B = 8bit
1KB = 1024B
1MB = 1024KB
1GB = 1024MB
1TB = 1024GB
1PB = 1024TB
1EB = 1024PB
1ZB = 1024EB
. . .</p>
</blockquote>
<p>好了，已经够大了！当然还有 YB、BB 更大的单位，同样进制也是 1024。</p>
<p><code>1G = 1024*1024*1024 = 10737418248B</code></p>
<p>假如你将一个 1B 的字符存入内存，如何读出呢？有么有一种大海捞针的感觉阿！我们讨论一下计算机是如何让我们人类快速将数据存在内存，如何从内存中读出数据的。我们研究过变量后就明白了。</p>
<div><pre><code>**变量：是编程中最常用的一种临时在内存中存取数据的一种方式。**
</code></pre>
</div><div>
<p><img src="./assets/var.png" alt="变量存储原理图" loading="lazy"></p>
<p><strong><u>变量存储原理图</u></strong></p>
</div>
<p>从图片可以看出，当我们在脚本中定义变量存值的时候，可以从以下方面看到变化：</p>
<ul>
<li>
<p>内存占用：</p>
<p>如果存的是一个字符则占用 1 个字节，如果存的是字符串则是字符串长度再加上 1 个字节长度（\0 是一个特殊字符，代表字符串的结束）。</p>
</li>
<li>
<p>变量名也内存的空间关系：</p>
<p>计算机中会将对应的内存空间和变量名称绑定在一起，此时代表这段内存空间已经被程序占用，其他程序不可复用；然后将变量名对应的值存在对应内存地址的空间里。</p>
</li>
</ul>
<p>理解变量的存储与读取（STRING1=&quot;ABC&quot;）</p>
<h3 id="变量存储原理"> 变量存储原理</h3>
<ol>
<li>STRING1（逻辑地址）&lt;===&gt; 0x5...0x8（物理地址）	存取数据 ABC
STRING1 是逻辑地址，给人看的，方便热记忆；
0x5...0x8 是内存物理地址，是计算机寻址的依据；</li>
<li>对于人来说 STRING1 上存的数据是 ABC，对于计算机来说数据是存在物理地址上的；</li>
<li>在建立变量的时候，计算机自动将逻辑地址（变量名）和物理地址做了对应绑定。</li>
</ol>
<h3 id="变量读取原理"> 变量读取原理</h3>
<p>当调用STRING1的时候，计算机会根据对应关系，找到物理地址；
定位内存地址，读出数据并返回。</p>
<h2 id="变量分类"> 变量分类</h2>
<ol>
<li>本地变量：用户私有变量，只有本地用户可以使用，保存在家目录下的 <code>.bash_profile</code>、<code>.bashrc</code> 文件中</li>
<li>全局变量：所有用户都可以使用，保存在 <code>/etc/profile</code>、<code>/etc/bashrc</code> 文件中</li>
<li>用户自定义变量：用户自定义，比如脚本中的变量</li>
</ol>
<p><strong>补充说明：</strong></p>
<ol>
<li>计算机启动系统后，全局变量会先加载到内存中；</li>
<li>当用户登录系统成功之后，本地变量会加载到内存中；</li>
<li>打开一个终端或一个脚本，自定义临时变量会在关闭终端或脚本运行结束后，变量会自动从内存中释放。</li>
</ol>
<h2 id="定义变量"> 定义变量</h2>
<h3 id="定义变量-2"> 定义变量</h3>
<p>定义变量格式：<code>变量名=值</code></p>
<p>在shell编程中的变量和等号之间不能有空格。</p>
<p>变量名命名规则：</p>
<ul>
<li>命名只能使用英文字母、数字和下划线，首歌字符不能以数字开头；</li>
<li>中间不能有空格，可以使用下划线（_）;</li>
<li>不能使用标点符号；</li>
<li>不能使用 bash 里的关键字（可以使用 <code>help</code> 命令查看保留关键字）。</li>
</ul>
<p><strong>定义变量演示：</strong></p>
<div><pre><code><span>#变量赋值，此种方法设置为本地变量</span>
<span>[</span>root@linuc ~ <span>]</span><span># name="admin"</span>
<span>[</span>root@linuc ~ <span>]</span><span># var1="hello world!"</span>
<span>[</span>root@linuc ~ <span>]</span><span># age=30</span>
<span>[</span>root@linuc ~ <span>]</span><span># score=88</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>注意：字符串要用单引号或双引号引起来。</p>
<h3 id="读取变量内容"> 读取变量内容</h3>
<p>读取变量内容符：<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6944em;"></span><span>读取方法：</span><span>‘</span></span></span></span>变量名`</p>
<div><pre><code><span>#变量内容读取</span>
<span>[</span>root@localhost ~ <span>]</span><span># echo $name</span>
admin
<span>[</span>root@localhost ~ <span>]</span><span># echo $school</span>
jialidun
<span>[</span>root@localhost ~ <span>]</span><span># echo $age</span>
<span>30</span>
<span>[</span>root@localhost ~ <span>]</span><span># echo $score</span>
<span>88</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="取消变量"> 取消变量</h3>
<p>取消变量命令：<code>unset</code></p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># unset name</span>
<span>[</span>root@localhost ~ <span>]</span><span># echo $name</span>

<span>[</span>root@localhost ~ <span>]</span><span># </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>说明：对于本地变量和全剧变量，<code>unset</code> 只能临时取消，当用户重新登录或重启计算机后，变量就会恢复。</p>
<h3 id="定义永久变量"> 定义永久变量</h3>
<ul>
<li>本地变量：用户私有变量，只有本用户可以使用，保存在家目录下的 <code>.bash_profile</code>、<code>.bashrc</code> 文件中</li>
<li>全局变量：所有用户否可以使用，保存在 <code>/etc/profile</code>、<code>/etc/bashrc</code> 文件中</li>
</ul>
<p><strong>本地变量</strong></p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># tail -l ~/.bahs_profile</span>
<span>name</span><span>=</span><span>'admin'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>全局变量</strong></p>
<div><pre><code><span>[</span>root@linuc ~ <span>]</span><span># tail -l /etc/profile</span>
exprot <span>age</span><span>=</span><span>30</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><p>说明</p>
<p>只需要在对应的文件中定义所需要的变量即可，但定义全局变量时，需要在前面加上 export 才可以。</p>
</div>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-04-09T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Shell数组</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/06.Shell_array/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/06.Shell_array/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="数组介绍"> 数组介绍</h2>
<p>一个变量只能存一个值，但是现实中又有很多值需要存储，那么变量就有些拘谨了。比如做一个学员信息表，一个班 50 个人，每个人 6 条信息，我们需要定义 300 个变量才能完成。恐怖恐怖，这只是一个班的学生，如果一个学校呢？一个市呢？......我想静静了！</p>
<h2 id="基本数组"> 基本数组</h2>
<p>数组可以让用户一次赋予多个值，需要读取数据时只需要通过索引调用就可以方便读出了。</p>
<h3 id="数组语法"> 数组语法</h3>
<div><pre><code>数组名称<span>=</span><span>(</span>元素1 元素2 元素3 <span>..</span>.<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="数组读出"> 数组读出</h3>
<div><pre><code><span>${数组名称<span>[</span>索引<span>]</span>}</span>
</code></pre>
<div><span>1</span><br></div></div><p>索引是元素在数组中的排队编号，默认索引是从 0 开始</p>
<h3 id="数组赋值"> 数组赋值</h3>
<p>方法一：一次赋一个值</p>
<div><pre><code><span># array0[0]='tom'</span>
<span># array0[1]='jarry'</span>
<span># array0[2]='natasha'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>方法二：一次赋多个值</p>
<div><pre><code><span># array1=(tom jaky alice)</span>
<span># array2=(`ls ~`)</span>
<span># array3=(`cat /etc/passwd`)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="查看数组"> 查看数组</h3>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># declare -a</span>
</code></pre>
<div><span>1</span><br></div></div><p>例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># declare -a</span>
<span>declare</span> -a <span>array0</span><span>=</span><span>(</span><span>[</span><span>0</span><span>]</span><span>=</span><span>"tom"</span> <span>[</span><span>1</span><span>]</span><span>=</span><span>"jarry"</span> <span>[</span><span>2</span><span>]</span><span>=</span><span>"natasha"</span><span>)</span>
<span>declare</span> -a <span>array1</span><span>=</span><span>(</span><span>[</span><span>0</span><span>]</span><span>=</span><span>"pear"</span> <span>[</span><span>1</span><span>]</span><span>=</span><span>"apple"</span> <span>[</span><span>2</span><span>]</span><span>=</span><span>"orange"</span> <span>[</span><span>3</span><span>]</span><span>=</span><span>"peach"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="访问数组元素"> 访问数组元素</h3>
<div><pre><code><span># echo ${array1[0]}					访问数组中的第一个元素</span>
<span># echo ${array1[*]}					访问数组中所有有元素</span>
<span># echo ${array1[@]}					访问数组中所有有元素</span>
<span># echo ${#array1[@]}				统计数组元素的个数</span>
<span># echo ${!array1[@]}				获取数组元素的索引</span>
<span># echo ${array1[@]:1}				从数组下标1开始到最后一个元素</span>
<span># echo ${array1[@]:1:3}				从数组下标1开始，访问3个元素</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="遍历数组"> 遍历数组</h3>
<p>方法一：通过数组元素进行逐个遍历</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># echo ${array1[0]}</span>
peay
<span>[</span>root@localhost ~<span>]</span><span># echo ${array1[1]}</span>
apple
<span>[</span>root@localhost ~<span>]</span><span># echo ${array1[2]}</span>
orange
<span>[</span>root@localhost ~<span>]</span><span># echo ${array1[3]}</span>
peach
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>方法二：通过数组元素的索引进行循环遍历</p>
<div><pre><code><span>#!/bin/bash</span>
<span>fruits</span><span>=</span><span>(</span><span>[</span><span>0</span><span>]</span><span>=</span><span>"pear"</span> <span>[</span><span>1</span><span>]</span><span>=</span><span>"apple"</span> <span>[</span><span>2</span><span>]</span><span>=</span><span>"orange"</span> <span>[</span><span>3</span><span>]</span><span>=</span><span>"peach"</span><span>)</span>
<span>i</span><span>=</span><span>0</span>
<span>for</span> <span><span>((</span>i<span>=</span><span>0</span><span>;</span>i<span>&lt;</span>${#fruits[@]}<span>;</span>i<span>++</span><span>))</span></span><span>;</span><span>do</span>
<span>echo</span> <span>${fruits<span>[</span>$i<span>]</span>}</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="关联数组"> 关联数组</h2>
<p>关联数组可以允许用户自定义数组的索引,这样使用起来更加方便、高效.</p>
<h3 id="定义关联数组"> 定义关联数组</h3>
<p>声明关联数组变量</p>
<div><pre><code><span># declare -a ass_array1</span>
<span># declare -a ass_array2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="关联数组赋值"> 关联数组赋值</h3>
<p>方法一：一次赋一个值</p>
<div><pre><code><span># ass_array1[index1]=pear</span>
<span># ass_array1[index2]=apple</span>
<span># ass_array1[index3]=orange</span>
<span># ass_array1[index4]=peach</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>方法二：一次赋多个值</p>
<div><pre><code><span># ass_array2=([index1]=tom [index2]=jack [index3]=alice [index4]='bash shell')</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>查看数组</li>
</ul>
<div><pre><code><span># declare -a</span>
<span>ass_array1</span><span>=</span><span>(</span><span>[</span>index1<span>]</span><span>=</span>pear <span>[</span>index2<span>]</span><span>=</span>apple <span>[</span>index3<span>]</span><span>=</span>orange <span>[</span>index4<span>]</span><span>=</span>beach<span>)</span>
<span>ass_array2</span><span>=</span><span>(</span><span>[</span>index1<span>]</span><span>=</span>tom <span>[</span>index2<span>]</span><span>=</span>jack <span>[</span>index3<span>]</span><span>=</span>alice <span>[</span>index4<span>]</span><span>=</span><span>'bash shell'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>访问数组元素</li>
</ul>
<div><pre><code><span># echo ${ass_array2[index2]}			访问数组中的第二个元素</span>
<span># echo ${ass_array2[@]}					访问数组中所有元素</span>
<span># echo ${#ass_array2[@]}				获取数组元素的个数</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>遍历数组</li>
</ul>
<p>针对关联数组可以通过数组元素的索引进行遍历</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># echo ${ass_array2[index1]}</span>
tom
<span>[</span>root@localhost ~<span>]</span><span># echo ${ass_array2[index2]}</span>
jack
<span>[</span>root@localhost ~<span>]</span><span># echo ${ass_array2[index3]}</span>
alice
<span>[</span>root@localhost ~<span>]</span><span># echo ${ass_array2[index4]}</span>
<span>bash</span> shell
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="案例分享-学员信息系统"> 案例分享---学员信息系统</h2>
<div><pre><code><span>#!/bin/bash</span>
<span>for</span> <span><span>((</span>i<span>=</span><span>0</span><span>;</span>i<span>&lt;</span><span>3</span><span>;</span>i<span>++</span><span>))</span></span>
<span>do</span>
<span>read</span> -p <span>"输入第<span><span>$((</span>i <span>+</span> <span>1</span><span>))</span></span>个人名:"</span> name<span>[</span><span>$i</span><span>]</span>
<span>read</span> -p <span>"输入第<span><span>$((</span>i <span>+</span> <span>1</span><span>))</span></span>个年龄:"</span> age<span>[</span><span>$i</span><span>]</span>
<span>read</span> -p <span>"输入第<span><span>$((</span>i <span>+</span> <span>1</span><span>))</span></span>个性别:"</span> name<span>[</span><span>$i</span><span>]</span>
<span>done</span>
<span>clear</span>
<span>echo</span> -e <span>"<span title="\t">\t</span><span title="\t">\t</span><span title="\t">\t</span><span title="\t">\t</span>学员查询系统"</span>
<span>while</span> <span>:</span>
<span>do</span>
<span>cp</span><span>=</span><span>0</span>
<span>echo</span> -e <span>"<span title="\t">\t</span><span title="\t">\t</span><span title="\t">\t</span><span title="\t">\t</span>学员查询系统"</span>
<span>read</span> -p <span>"输入要查询的姓名："</span> xm
<span>[</span> <span>$xm</span> <span>==</span> <span>"Q"</span> <span>]</span><span>&amp;&amp;</span><span>exit</span>
<span>for</span> <span><span>((</span>i<span>=</span><span>0</span><span>;</span>i<span>&lt;</span><span>3</span><span>;</span>i<span>++</span><span>))</span></span><span>;</span><span>do</span>
<span>if</span> <span>[</span> <span>"<span>$xm</span>"</span> <span>==</span> <span>"<span>${name<span>[</span>$i<span>]</span>}</span>"</span> <span>]</span><span>;</span><span>then</span>
<span>echo</span> <span>"<span>${name<span>[</span>$i<span>]</span>}</span> <span>${age<span>[</span>$i<span>]</span>}</span> <span>${gender<span>[</span>$i<span>]</span>}</span>"</span>
<span>cp</span><span>=</span><span>1</span>
<span>fi</span>
<span>done</span>
<span>[</span> <span>$cp</span> -eq <span>0</span> <span>]</span><span>&amp;&amp;</span><span>echo</span> <span>"not found student"</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div>]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-04-09T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Shell运算</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/07.Shell_operation/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/07.Shell_operation/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="shell-中的运算"> Shell 中的运算</h2>
<h3 id="数学比较运算"> 数学比较运算</h3>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-eq</td>
<td>等于</td>
</tr>
<tr>
<td>-gt</td>
<td>大于</td>
</tr>
<tr>
<td>-lt</td>
<td>小于</td>
</tr>
<tr>
<td>-ge</td>
<td>大于等于</td>
</tr>
<tr>
<td>-le</td>
<td>小于等于</td>
</tr>
<tr>
<td>-ne</td>
<td>不等于</td>
</tr>
</tbody>
</table>
<h3 id="字符串比较运算"> 字符串比较运算</h3>
<p>注意字符串一定别忘了使用引号引起来</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>等于</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
</tr>
<tr>
<td>-n</td>
<td>检查字符串的长度是否大于 0</td>
</tr>
<tr>
<td>-z</td>
<td>检查字符串的长度是否为 0</td>
</tr>
</tbody>
</table>
<h3 id="文件比较与检查"> 文件比较与检查</h3>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>检查文件是否存在且为目录</td>
</tr>
<tr>
<td>-e</td>
<td>检查文件是否存在</td>
</tr>
<tr>
<td>-f</td>
<td>检查文件是否存在且为文件</td>
</tr>
<tr>
<td>-r</td>
<td>检查文件是否存在且可读</td>
</tr>
<tr>
<td>-w</td>
<td>检查文件是否存在且可写</td>
</tr>
<tr>
<td>-x</td>
<td>检查文件是否存在且可执行</td>
</tr>
<tr>
<td>-s</td>
<td>检查文件是否存在且不为空</td>
</tr>
<tr>
<td>-O</td>
<td>检查文件是否存在且被当前用户拥有</td>
</tr>
<tr>
<td>-G</td>
<td>检查文件是否存在且默认组为当墙用户组</td>
</tr>
<tr>
<td>file1 -nt file2</td>
<td>检查 file1 是否比 file2 新</td>
</tr>
<tr>
<td>file1 -ot file2</td>
<td>检查 file1 是否比 file2 旧</td>
</tr>
</tbody>
</table>
<h3 id="逻辑运算"> 逻辑运算</h3>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;&amp;</td>
<td>逻辑与运算</td>
</tr>
<tr>
<td>||</td>
<td>逻辑或运算</td>
</tr>
<tr>
<td>!</td>
<td>逻辑非运算</td>
</tr>
</tbody>
</table>
<div><p>口诀</p>
<p>逻辑与运算		真真为真、真假为假、假假为假</p>
<p>逻辑或运算		真真为真、真假为假、假假为假</p>
<p>逻辑非运算		非真为假、非假为真</p>
<p><strong>逻辑与、或运算都需要两个或两个以上条件，逻辑非运算只能有一个条件。</strong></p>
</div>
<h3 id="赋值运算"> 赋值运算</h3>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>赋值运算符，例<code># a=10	name=&quot;root&quot;</code></td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-04-09T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Shell流程控制---if判断语句</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/08.Shell_if/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/08.Shell_if/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>当我们在写程序的时候，时常对上一步执行是否成功如何判断苦恼，当我们学习了if判断语句就可以解决你的苦恼。if判断语句在我们程序中就是用来做判断的，以后不管学习什么语言，以后只要涉及到判断的部分，就可以直接拿if来使用，不同的语言之间的 if 只是语法不同，原理是相同的。</p>
<h2 id="if-语法"> if 语法</h2>
<h3 id="语法一"> 语法一</h3>
<p><code>if---then</code> 语句</p>
<p>适用范围：只需要一步判断，条件为真做什么。</p>
<div><pre><code><span>if</span> <span>[</span> condition <span>]</span><span>;</span><span>then</span>		<span>#如果 条件为真，则</span>
commands						<span>#执行commands代码块</span>
<span>fi</span>							<span>#结束</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>实例</p>
<div><pre><code><span>#!/bin/bahs</span>
<span>if</span> <span>[</span> -f /mnt/test <span>]</span><span>;</span><span>then</span>
<span>echo</span> <span>"/mnt/test文件已存在。"</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="语法二"> 语法二</h3>
<p><code>if---then---else</code> 语句</p>
<p>适用范围：两步判断，条件为真做什么，条件为假做什么。</p>
<div><pre><code><span>if</span> <span>[</span> condition <span>]</span><span>;</span><span>then</span>		<span>#如果 条件为真，则</span>
commands1						<span>#执行commands1代码块</span>
<span>else</span>						<span>#否则</span>
commands2						<span>#执行commands2代码块</span>
<span>fi</span>							<span>#结束</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>实例</p>
<div><pre><code><span>#!/binbahs</span>
<span>if</span> <span>[</span> <span>$USER</span> <span>==</span> <span>"root"</span> <span>]</span><span>;</span><span>then</span>
<span>echo</span> <span>"管理员，你好！"</span>
<span>else</span>
<span>echo</span> <span>"guest，你好！"</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="语法三"> 语法三</h3>
<p><code>if---thne---eliif---else</code> 语句</p>
<p>使用范围：多于两个以上的判断结果，也就是两个及以上的判断条件</p>
<div><pre><code><span>if</span> <span>[</span> condition1 <span>]</span><span>;</span><span>then</span>		<span>#如果 条件1为真，则</span>
	commands1					<span>#执行commands1代码块</span>
<span>elif</span> <span>[</span> condition2 <span>]</span><span>;</span><span>then</span>	<span>#如果 条件2为真，则</span>
	commands2					<span>#执行commands2代码块</span>
	<span>..</span>.							<span>#...</span>
<span>else</span>						<span>#否则</span>
	commandsX					<span>#执行commandsX代码块</span>
<span>fi</span>							<span>#结束</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>实例</p>
<div><pre><code><span>#!/bin/bash</span>
<span>read</span> -p <span>"请输入一个整数："</span> x
<span>if</span> <span>[</span> <span>$x</span> -gt <span>0</span><span>]</span><span>;</span><span>then</span>
	<span>echo</span> <span>"您输入的是一个正整数。"</span>
<span>elif</span> <span>[</span> <span>$x</span> -eq <span>0</span><span>]</span><span>;</span><span>then</span>
	<span>echo</span> <span>"您输入的是0。"</span>
<span>else</span>
	<span>echo</span> <span>"您输入的是一个负整数。"</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><p>补充</p>
<p>条件符号使用双圆括号，可以在条件中植入数学表达式</p>
<p>双圆括号中的比较运算符，使用的是我们传统的比较运算符 &gt;&gt;=、==、&lt;&lt;=、!=</p>
<p>使用双方括号，可以在条件中使用通配符</p>
</div>
<h2 id="作业"> 作业</h2>
<ul>
<li>判断一个机器是否存活（能 ping 通就算存活）</li>
<li>判断服务器上的某个服务是否开启</li>
<li>判断某年是否为闰年</li>
<li>写一个 Nginx 安装脚本，加入判断，当上一步执行成功再执行下一步，否则退出脚本</li>
<li>写一个备份脚本，将 A 机器当天修改果的文件=收集到 <code>/cache</code> 目录，打包并发送到B机器 <code>/opt/backup</code> 目录下，通过 MD5 值判断 B 机器上的备份的完整性</li>
</ul>
<div><pre><code><span>#nginx安装脚本</span>
<span>[</span>root@linux ~ <span>]</span><span># vim nginx_install.sh</span>
<span>#!/bin/bash</span>
yum -y <span>install</span> <span>wget</span> gcc pcre-devel zlib-devel
<span>wget</span> http://nginx.org/download/nginx-1.18.0.tar.gz
<span>if</span> <span>[</span> <span>$?</span> -eq <span>0</span> <span>]</span><span>;</span><span>then</span>
	<span>tar</span> -xf nginx-1.18.0.tar.gz
	<span>cd</span> nginx-1.18.0
	./configure --prefix<span>=</span>/usr/local/nginx
	<span>if</span> <span>[</span> <span>$?</span> -eq <span>0</span> <span>]</span><span>;</span><span>then</span>
		<span>make</span> -j <span>4</span>
		<span>if</span> <span>[</span> <span>$?</span> -eq <span>0</span> <span>]</span><span>;</span><span>then</span>
			<span>make</span> <span>install</span>
				<span>if</span> <span>[</span> <span>$?</span> -eq <span>0</span> <span>]</span><span>;</span><span>then</span>
					<span>echo</span> <span>"nginx安装成功"</span>
				<span>else</span> 
					<span>echo</span> <span>"nginx安装失败"</span>
				<span>fi</span>
		<span>else</span>
			<span>echo</span> <span>"nginx编译失败"</span>
		<span>fi</span>
	<span>else</span>
		<span>echo</span> <span>"nginx配置失败"</span>
	<span>fi</span>
<span>else</span>
	<span>echo</span> <span>"nginx下载失败"</span>
<span>fi</span>
<span>[</span>root@linux ~ <span>]</span><span># chmod 700 nginx_install.sh</span>
<span>[</span>root@linux ~ <span>]</span><span># ./nginx_install.sh</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div>]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-04-09T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Shell流程控制---for循环语句</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/09.Shell_for/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/09.Shell_for/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>脚本再执行任务的时候，总会遇到需要循环执行的时候，比如说我们需要脚本每隔五分钟执行一次 ping 的操作，除了计划任务，我们还可以使用脚本来完成，那么我们就用到了循环语句。</p>
<h2 id="for-循环介绍"> for 循环介绍</h2>
<p>很多人把for循环叫做条件循环，或者 <code>for-i-in</code>。其实前者说的就是 for 的特性，for 循环的次数和给予的条件是成正比的，你让它循环 5 次，它就循环 5 次；后者说的是 for 的语法。</p>
<h2 id="for-语法"> for 语法</h2>
<h3 id="for-语法一"> for 语法一</h3>
<div><pre><code><span>for</span> <span>var</span> <span>in</span> vlue1 value2 <span>..</span><span>..</span><span>..</span><span>;</span><span>do</span>
	commands
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>接下来看段代码吧，循环输出数字 1-9</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cat for_1.sh</span>
<span>#!/bin/bash</span>
<span>for</span> <span>i</span> <span>in</span> <span><span>`</span><span>seq</span> <span>1</span> <span>9</span><span>`</span></span><span>;</span><span>do</span>
	<span>echo</span> <span>$i</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="for-语法二-c-格式-for-循环"> for 语法二 （C 格式 for 循环）</h3>
<div><pre><code><span>for</span> <span><span>((</span>变量<span>;</span>条件<span>;</span>自增减运算<span>))</span></span><span>;</span><span>do</span>
	commands
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>还是刚才的循环输出数字 1-9</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cat for_2.sh</span>
<span>#!/bin/bash</span>
<span>for</span> <span><span>((</span>i<span>=</span><span>1</span><span>;</span>i<span>&lt;</span><span>10</span><span>;</span>i<span>++</span><span>))</span></span><span>;</span><span>do</span>
	<span>echo</span> <span>$i</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><p>补充</p>
<p><code>seq</code> 命令：<code>seq</code> 命令可以输出连续的数字，或者输出固定间隔的数字，或者输出指定格式的数字。</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># seq [选项] 首数 步进 尾数</span>
选项：
	-s	：指定输出的分隔符，默认为 <span>\</span>n，即默认为回车换行
	-w	：指定为定宽输出，不能和 -f 一起用
	-f	：按照指定的格式输出，不能和 -w 一起使用
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></div>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># echo `seq 1 5`			#1---5之间，默认步进为1的数字</span>
<span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>[</span>root@localhost ~ <span>]</span><span># echo `seq 10 -2 1`		#10---1之间，步进为-2的数字</span>
<span>10</span>
<span>8</span>
<span>6</span>
<span>4</span>
<span>2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="c-格式-for-循环双变量"> C 格式 for 循环双变量</h3>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># vim for_3.sh</span>
<span>#!/bin/bash</span>
<span>for</span> <span><span>((</span>m<span>=</span><span>9</span><span>,</span>n<span>=</span><span>1</span><span>;</span>m<span>></span><span>1</span><span>,</span>n<span>&lt;</span><span>10</span><span>;</span>m<span>--</span><span>,</span>n<span>++</span><span>))</span></span><span>;</span><span>do</span>
	<span>echo</span> -e <span>"<span>$m</span><span title="\t">\t</span><span>$n</span>"</span>
<span>done</span>
<span>[</span>root@localhost ~ <span>]</span><span># bash for_3.sh</span>
<span>9</span>	<span>1</span>
<span>8</span>	<span>2</span>
<span>7</span>	<span>3</span>
<span>6</span>	<span>4</span>
<span>5</span>	<span>5</span>
<span>4</span>	<span>6</span>
<span>3</span>	<span>7</span>
<span>2</span>	<span>8</span>
<span>1</span>	<span>9</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="循环控制语句"> 循环控制语句</h2>
<h3 id="sleep-n"> sleep N</h3>
<p><strong>脚本执行到该步休眠 N 秒</strong></p>
<p>看段代码吧</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># vim sllep.sh</span>
<span>#!/bin/bash</span>
<span>echo</span> -n <span>"倒计时："</span>
<span>for</span> <span>i</span> <span>in</span> <span><span>`</span><span>seq</span> <span>9</span> -1 <span>1</span><span>`</span></span><span>;</span><span>do</span>
	<span>echo</span> -n -e <span>"<span title="\b">\b</span><span>$i</span>"</span>
<span>sleep</span> <span>1</span>
<span>done</span>
<span>echo</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="continue"> continue</h3>
<p><strong>跳出循环中的某次循环</strong></p>
<p>继续看代码，默认循环输出 1-9，但是使用 continue 跳过输出 5</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># vim continue.sh</span>
<span>#!/bin/bash</span>
<span>for</span> <span><span>((</span>i<span>=</span><span>1</span><span>;</span>i<span>&lt;</span><span>10</span><span>;</span>i<span>++</span><span>))</span></span><span>;</span><span>do</span>
	<span>if</span> <span>[</span> <span>$i</span> -eq <span>5</span> <span>]</span><span>;</span><span>then</span>
		<span>continue</span>
	<span>else</span>
		<span>echo</span> <span>$i</span>
	<span>fi</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="break"> break</h3>
<p><strong>跳出循环继续执行后续代码</strong></p>
<p>还是看段代码，默认循环输出 1-9，当输出到5的时候跳出循环</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># vim break.sh</span>
<span>#!/bin/bash</span>
<span>for</span> <span>i</span> <span>in</span> <span><span>`</span><span>seq</span> <span>1</span> <span>9</span><span>`</span></span><span>;</span><span>do</span>
	<span>echo</span> <span>$i</span>
	<span>if</span> <span>[</span> <span>$i</span> -eq <span>5</span> <span>]</span><span>;</span><span>then</span>
		<span>break</span>
	<span>fi</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="示例"> 示例</h2>
<p>监控主机存活的脚本</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># vim ping.sh</span>
<span>#!/bin/bash</span>
<span>for</span> <span><span>((</span><span>;</span><span>;</span><span>))</span></span><span>;</span><span>do</span>
	<span>ping</span> -c1 <span>$1</span> <span>&amp;></span> /dev/null
	<span>if</span> <span>[</span> <span>$?</span> -eq <span>0</span> <span>]</span><span>;</span><span>then</span>
		<span>echo</span> -e <span>"<span><span>`</span><span>date</span> +<span>"%F %H:%M:%S"</span><span>`</span></span>：<span>$1</span> is <span title="\033">\033</span>[32m UP <span title="\033">\033</span>[0m"</span>
	<span>else</span>	
		<span>echo</span> -e <span>"<span><span>`</span><span>date</span> +<span>"%F %H:%M:%S"</span><span>`</span></span>：<span>$1</span> is <span title="\033">\033</span>[31m Down <span title="\033">\033</span>[0m"</span>
	<span>fi</span>
	<span>sleep</span> <span>5</span>		<span>#每隔5秒循环一次，生产环境建议1分钟以上</span>
<span>done</span>
<span>[</span>root@localhost ~ <span>]</span><span># bash ping.sh 192.168.2.123</span>
<span>2021</span>-2-7 <span>13</span>:32:21：192.168.2.123 is UP 
<span>2021</span>-2-7 <span>13</span>:32:26：192.168.2.123 is UP 
<span>2021</span>-2-7 <span>13</span>:32:31：192.168.2.123 is UP 
<span>2021</span>-2-7 <span>13</span>:32:36：192.168.2.123 is UP 
^C
<span>[</span>root@localhost ~ <span>]</span><span># bash ping.sh 192.168.2.321</span>
<span>2021</span>-2-7 <span>13</span>:33:13：192.168.2.321 is Down 
<span>2021</span>-2-7 <span>13</span>:32:18：192.168.2.321 is Down 
<span>2021</span>-2-7 <span>13</span>:32:23：192.168.2.321 is Down 
<span>2021</span>-2-7 <span>13</span>:32:28：192.168.2.321 is Down 
<span>[</span>root@localhost ~ <span>]</span><span># </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div>]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-04-09T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Shell流程控制---while循环语句</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/10.Shell_while/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/10.Shell_while/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="while-循环介绍"> while 循环介绍</h2>
<p>while 在 shell 中也是负责循环的语句，和 for 一样。因为功能一样，很多人在学习和工作中的脚本遇到循环，到底该使用 for 还是 while 呢？很多人不知道，就造就了有人一遇到循环就是 for 或者一味的 while。我觉得可以按照循环次数的情况来使用，如果已经知道循环次数，那么就建议使用 for，比如说一天需要循环 24 次；如果不知道要循环多少次，那么就使用 while，比如我们作业中要求写的猜数字，每个人猜对一个数字的次数都是不能固定的，也就是未知的。所以这样的循环我就建议大家用 while 了。</p>
<h2 id="while-循环语法"> while 循环语法</h2>
<p>语法格式</p>
<div><pre><code><span>while</span> <span>[</span> condition <span>]</span><span>;</span><span>do</span>
	commands
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><blockquote>
<p>注意：条件为真，while 才会循环；条件为假，while 停止循环</p>
<p>条件可以是之前学习的五种运算：数学比较、字符串比较、文件类型、逻辑运算、赋值运算</p>
</blockquote>
<p>小作业试写
while 循环输出 1-9，当输出到5的时候，停止循环。（break）
while 循环输出 1-9，当输出5的时候，跳过本次循环。（continue）
while 循环输出 1-9，每隔 1 秒输出一个数字。（sleep）
while 循环嵌套 for 循环，或者 for 循环嵌套while循环（九九乘法表）
while 循环输出 1-10 嵌套 if 判断（奇偶数判断）</p>
<p>补充：如果把某一段代码注释，不用每一行前面都加上#，可以利用定义函数方法来注释</p>
<div><pre><code><span>name</span><span>(</span><span>)</span><span>{</span>
	commands
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>运行脚本，上面花括号{ }内的代码将不会执行。</p>
<h2 id="while-实战"> while 实战</h2>
<p>使用 while 遍历文件内容（<code>grep</code> 过滤）</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># vim while_read.sh</span>
<span>#!/bin/bash</span>
<span>cat</span> /etc/passwd <span>|</span> <span>grep</span> <span>"bash"</span> <span>|</span> <span>while</span> <span>read</span> i<span>;</span><span>do</span>
	<span>echo</span> <span>$i</span>
<span>done</span> 
<span>[</span>root@localhost ~ <span>]</span><span># bash while_read.sh</span>
root:x:0:0:root:/root:/bin/bash
karin:x:1000:1000:karin,,,:/home/karin:/bin/bash
<span>[</span>root@localhost ~ <span>]</span><span># </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>九九乘法表（嵌套）</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># vim 99.sh</span>
<span>#!/bin/bash</span>
<span>n</span><span>=</span><span>1</span>
<span>while</span> <span>[</span> <span>$n</span> -lt <span>10</span> <span>]</span><span>;</span><span>do</span>
        <span>for</span> <span><span>((</span>m<span>=</span><span>1</span><span>;</span>m<span>&lt;=</span>$n<span>;</span>m<span>++</span><span>))</span></span><span>;</span><span>do</span>
                <span>echo</span> -n -e  <span>"<span>$m</span>*<span>$n</span>=<span><span>$((</span>n<span>*</span>m<span>))</span></span><span title="\t">\t</span>"</span>
        <span>done</span>
        <span>echo</span>
        <span>n</span><span>=</span><span><span>$((</span>n<span>+</span><span>1</span><span>))</span></span>
<span>done</span>
<span>[</span>root@linux ~ <span>]</span><span># bash 99.sh</span>
<span>1</span>*1<span>=</span><span>1</span>	
<span>1</span>*2<span>=</span><span>2</span>	<span>2</span>*2<span>=</span><span>4</span>	
<span>1</span>*3<span>=</span><span>3</span>	<span>2</span>*3<span>=</span><span>6</span>	<span>3</span>*3<span>=</span><span>9</span>	
<span>1</span>*4<span>=</span><span>4</span>	<span>2</span>*4<span>=</span><span>8</span>	<span>3</span>*4<span>=</span><span>12</span>	<span>4</span>*4<span>=</span><span>16</span>	
<span>1</span>*5<span>=</span><span>5</span>	<span>2</span>*5<span>=</span><span>10</span>	<span>3</span>*5<span>=</span><span>15</span>	<span>4</span>*5<span>=</span><span>20</span>	<span>5</span>*5<span>=</span><span>25</span>	
<span>1</span>*6<span>=</span><span>6</span>	<span>2</span>*6<span>=</span><span>12</span>	<span>3</span>*6<span>=</span><span>18</span>	<span>4</span>*6<span>=</span><span>24</span>	<span>5</span>*6<span>=</span><span>30</span>	<span>6</span>*6<span>=</span><span>36</span>	
<span>1</span>*7<span>=</span><span>7</span>	<span>2</span>*7<span>=</span><span>14</span>	<span>3</span>*7<span>=</span><span>21</span>	<span>4</span>*7<span>=</span><span>28</span>	<span>5</span>*7<span>=</span><span>35</span>	<span>6</span>*7<span>=</span><span>42</span>	<span>7</span>*7<span>=</span><span>4</span>
<span>1</span>*8<span>=</span><span>8</span>	<span>2</span>*8<span>=</span><span>16</span>	<span>3</span>*8<span>=</span><span>24</span>	<span>4</span>*8<span>=</span><span>32</span>	<span>5</span>*8<span>=</span><span>40</span>	<span>6</span>*8<span>=</span><span>48</span>	<span>7</span>*8<span>=</span><span>56</span>	<span>8</span>*8<span>=</span><span>64</span>	
<span>1</span>*9<span>=</span><span>9</span>	<span>2</span>*9<span>=</span><span>18</span>	<span>3</span>*9<span>=</span><span>27</span>	<span>4</span>*9<span>=</span><span>36</span>	<span>5</span>*9<span>=</span><span>45</span>	<span>6</span>*9<span>=</span><span>54</span>	<span>7</span>*9<span>=</span><span>63</span>	<span>8</span>*9<span>=</span><span>72</span>	<span>9</span>*9<span>=</span><span>81</span>
<span>[</span>root@localhost ~ <span>]</span><span># </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div>]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-04-09T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Shell流程控制---until循环语句</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/11.Shell_until/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/11.Shell_until/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="until-介绍"> until 介绍</h2>
<p>和 while 正好相反，until 是条件为假开始执行循环，条件为真停止循环。</p>
<h2 id="until-语法"> until 语法</h2>
<div><pre><code><span>until</span> <span>[</span> condition <span>]</span><span>;</span><span>do</span>
	commands
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>具体用法可以参照 while 循环，此处不多说明。</p>
<h2 id="案例"> 案例</h2>
<p>输出 10-20 数字</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># vim until_num.sh</span>
<span>#!/bin/bash</span>
<span>num</span><span>=</span><span>10</span>
<span>until</span> <span>[</span> <span>$num</span> -gt <span>18</span> <span>]</span><span>;</span><span>do</span>
<span>echo</span> <span>$num</span>
<span>num</span><span>=</span><span><span>$((</span>num<span>+</span><span>1</span><span>))</span></span>
<span>done</span>
<span>[</span>root@localhost ~ <span>]</span><span># bash until_num.sh</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>[</span>root@localhost ~ <span>]</span><span># </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>while 和 until 接力输出</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># vim while_until.sh</span>
<span>#!/bin/bash</span>
<span>num</span><span>=</span><span>1</span>
<span>while</span> <span>[</span> <span>$num</span> -lt <span>6</span> <span>]</span><span>;</span><span>do</span>				<span>#输出1-5</span>
	<span>echo</span> <span>$num</span>
	<span>num</span><span>=</span><span><span>$((</span>num<span>+</span><span>1</span><span>))</span></span>
	<span>until</span> <span>[</span> <span>$num</span> -lt <span>6</span> <span>]</span><span>;</span><span>do</span>			<span>#接力输出6-10</span>
		<span>echo</span> <span>$num</span>
		<span>num</span><span>=</span><span><span>$((</span>num<span>+</span><span>1</span><span>))</span></span>
			<span>if</span> <span>[</span> <span>$num</span> -eq <span>11</span> <span>]</span><span>;</span><span>then</span>
				<span>break</span>
			<span>fi</span>
	<span>done</span>
<span>done</span>
<span>[</span>root@localhost ~ <span>]</span><span># bash vim while_until.sh</span>
<span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>[</span>root@localhost ~ <span>]</span><span># </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div>]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-04-09T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Shell流程控制---case分支语句</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/12.Shell_case/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/12.Shell_case/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="case-介绍"> case 介绍</h2>
<p>在生产环境中，我们总会遇到一个问题需要根据不同的状况来执行不同的预案，那么我们要处理这样的问题，首先根据可能出现的情况先写出对应预案，之后根据出现的情况来加载不同的预案。</p>
<p>特点：根据给予的不同条件执行不同的代码块。</p>
<blockquote>
<p><u>比如你去相亲，遇到对方家人要怎样称呼</u></p>
<p>看到对方父亲：伯父好</p>
<p>看到对方母亲：伯母好</p>
<p>看到对方奶奶：奶奶好</p>
</blockquote>
<blockquote>
<p><u>再比如计算机系统监控内存使用率</u></p>
<p>内存使用率低于 80%，脚本输出：绿色字体的 Memory use xx%</p>
<p>内存使用率大于 80% 小于 90%，脚本输出：黄色字体的 Memory use xx%</p>
<p>内存使用率大于 90%，脚本输出：红色字体的 Memory use xx%</p>
</blockquote>
<h2 id="case-语法"> case 语法</h2>
<div><pre><code><span>case</span> var <span>in</span>
condition1<span>)</span>
	commands1
<span>;</span><span>;</span>
condition2<span>)</span>
	commands2
<span>;</span><span>;</span>
<span>..</span><span>..</span><span>..</span>
<span>esac</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><p>注意</p>
<p>每个代码块执行完毕要以&quot;&quot; <strong>;;</strong> &quot;&quot;结尾代表结束，case 结尾要以其倒过来写的 esac 来结束。</p>
</div>
<p>实例：</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># vim zmn.sh</span>
<span>#!/bin/bash</span>
<span>case</span> <span>$1</span> <span>in</span>
zmn<span>|</span>ZMN<span>)</span>
	<span>echo</span> <span>"伯母好"</span>
	<span>echo</span> <span>"伯母辛苦了"</span>
lzr<span>|</span>LZR<span>)</span>
	<span>echo</span> <span>"伯父好"</span>
	<span>echo</span> <span>"伯父真帅气"</span>
lnn<span>|</span>LNN<span>)</span>
	<span>echo</span> <span>"奶奶好"</span>
	<span>echo</span> <span>"奶奶吉祥"</span>
lyy<span>|</span>LYY<span>)</span>
	<span>echo</span> <span>"爷爷好"</span>
	<span>echo</span> <span>"爷爷万岁"</span>
*<span>)</span>
	<span>echo</span> <span>"输入无效，使用方法：<span>$0</span> zmn|lzr|lnn|lyy"</span>
<span>esac</span>
<span>[</span>root@localhost ~ <span>]</span><span># bash zmn.sh lzr</span>
伯父好
伯父真帅气
<span>[</span>root@localhost ~ <span>]</span><span># bash zmn.sh lyy</span>
爷爷好
爷爷万岁
<span>[</span>root@localhost ~ <span>]</span><span># bash zmn.sh sdf</span>
输入无效，使用方法：zmn.sh zmn<span>|</span>lzr<span>|</span>lnn<span>|</span>lyy
<span>[</span>root@localhost ~ <span>]</span><span># bash zmn.sh zmn</span>
伯母好
伯母辛苦了
<span>[</span>root@localhost ~ <span>]</span><span># </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h2 id="shell-特殊变量"> shell 特殊变量</h2>
<p>特殊参数</p>
<table>
<thead>
<tr>
<th>参数符号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>$*</td>
<td>代表所有参数，其间隔为IFS内定参数的第一个单元</td>
</tr>
<tr>
<td>$@</td>
<td>与 $* 类同，不同之处在于不参照 IFS</td>
</tr>
<tr>
<td>$#</td>
<td>代表参数的数量</td>
</tr>
<tr>
<td>$？</td>
<td>执行上一个指令的返回值</td>
</tr>
<tr>
<td>$$</td>
<td>本身的 PID（process ID）</td>
</tr>
<tr>
<td>$_</td>
<td>显示出最后一个执行的命令</td>
</tr>
<tr>
<td>$N</td>
<td>shell 的第几个外传参数</td>
</tr>
</tbody>
</table>
<ul>
<li>示例</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># vim special.sh</span>
<span>#!/bin/bash</span>
<span>echo</span> <span>"脚本文件名：<span>$0</span>"</span>
<span>echo</span> <span>"脚本所有外传参数：<span>$*</span>"</span>
<span>echo</span> <span>"脚本所有外传参数：<span>$@</span>"</span>
<span>echo</span> <span>"脚本外传参数数量：<span>$#</span>"</span>
<span>echo</span> <span>"上一个命令的返回值：<span>$?</span>"</span>
<span>echo</span> <span>"脚本执行的进程号PID：<span>$$</span>"</span>
<span>echo</span> <span>"执行最后一次执行的命令：<span>$_</span>"</span>
<span>echo</span> <span>"第3个外传参数：<span>$3</span> "</span>
<span>[</span>root@localhost ~ <span>]</span><span># bash special.sh aaa bbb ccc ddd</span>
<span>#脚本文件名：special.sh</span>
<span>#脚本所有外传参数：aaa bbb ccc ddd</span>
<span>#脚本所有外传参数：aaa bbb ccc ddd</span>
<span>#脚本外传参数数量：4</span>
<span>#上一个命令的返回值：0</span>
<span>#脚本执行的进程号PID：17306</span>
<span>#执行最后一次执行的命令：脚本执行的进程号PID：17306</span>
<span>#第3个外传参数：ccc</span>
<span>[</span>root@localhost ~ <span>]</span><span># </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div>]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-04-09T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Shell函数</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/13.Shell_function/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/13.Shell_function/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="函数介绍"> 函数介绍</h2>
<p>写代码的时候，我们很多人习惯从头写到结束，完成以后再一起测试。但是到测试阶段才发现：错误一大堆，上帝啊！弄死我吧！</p>
<p>为了解决这个问题，建议大家把代码模块化，一个模块实现一个功能，哪怕是一个很小的功能都可以，这样的话我们写代码，逻辑上就会比较简单，代码量比较少，排错简单，这也就是函数的好处。</p>
<h3 id="函数的优点"> 函数的优点</h3>
<p>代码模块化，调用方便，节省内存
代码模块化，代码量少，排错简单
代码模块化，可以改变代码的执行顺序</p>
<h3 id="函数的语法"> 函数的语法</h3>
<h4 id="定义函数"> 定义函数</h4>
<p>语法一：</p>
<div><pre><code>函数名 <span>(</span><span>)</span> <span>{</span>
	commands
	<span>return</span> N
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>语法二：</p>
<div><pre><code><span>function</span> 函数名<span>{</span>
	commands
	<span>return</span> N
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>补充：</p>
<p>return 在 shell 中意义不大，可以省略不写。</p>
<p>function 定义函数没有小括号 ( )。
定义好的函数默认不会执行，需要调用</p>
<h4 id="调用函数"> 调用函数</h4>
<div><pre><code>函数名
</code></pre>
<div><span>1</span><br></div></div><p>说明：直接在脚本中输入函数名，即可调用已定义的函数。</p>
<p>实例</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># vim fun.sh</span>
<span>#!/bin/bash</span>
<span>start</span> <span>(</span><span>)</span> <span>{</span>
<span>echo</span> <span>"Apache start ............................... [OK]"</span>
<span>}</span>

<span>stop</span> <span>(</span><span>)</span> <span>{</span>
<span>echo</span> <span>"Apache stop ............................... [FALIL]"</span>
<span>}</span>
start
start
start
stop
stop
stop
stop
<span>[</span>root@localhost ~ <span>]</span><span># bash fun.sh</span>
Apache start <span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span>. <span>[</span>OK<span>]</span>
Apache start <span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span>. <span>[</span>OK<span>]</span>
Apache start <span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span>. <span>[</span>OK<span>]</span>
Apache stop <span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span>. <span>[</span>FALIL<span>]</span>
Apache stop <span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span>. <span>[</span>FALIL<span>]</span>
Apache stop <span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span>. <span>[</span>FALIL<span>]</span>
Apache stop <span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span><span>..</span>. <span>[</span>FALIL<span>]</span>
<span>[</span>root@localhost ~ <span>]</span><span># </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div>]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-04-09T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Shell正则表达式</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/14.Shell_regular/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/14.Shell_regular/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="正则表达式介绍"> 正则表达式介绍</h2>
<p>正则表达式是一种文本模式匹配，包括普通字符（例如：a到z之间的字母）和特殊字符（称为”元字符“）。它是一种字符串匹配的模式，可以用来检查一个字符串是否含有某子字串、将匹配的子串替换或者从某个字符串中取出某个条件的子串。</p>
<p>正则表达式就像数学公式一样，我们可以通过正则表达式提供的一些特殊字符来生成一个匹配对应字符串的公式，用此来从海量数据中匹配出自己想要的数据。</p>
<p>正则表达式是一个第三方产品，常被计算机语言广泛使用，比如：Shell、PHP、python、Java、js 等。</p>
<p>shell 也支持正则表达式，但不是所有的命令都支持正则表达式，常见的命令中只有 <code>grep</code>、<code>sed</code>、<code>awk</code> 命令支持正则表达式。</p>
<h2 id="特殊字符"> 特殊字符</h2>
<h3 id="定位符"> 定位符：</h3>
<p>同时锚定开头和结尾，做精确匹配；单一锚定开头或结尾，做模糊匹配。</p>
<table>
<thead>
<tr>
<th>定位符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>锚定开头； ^a：以 a 开头，默认锚定一个字符</td>
</tr>
<tr>
<td>$</td>
<td>锚定结尾； a$：以 a 结尾，默认锚定一个字符</td>
</tr>
</tbody>
</table>
<h3 id="匹配符"> 匹配符：</h3>
<p>匹配字符串</p>
<table>
<thead>
<tr>
<th>匹配符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>匹配除回车以外的任意一个字符</td>
</tr>
<tr>
<td>( )</td>
<td>字符串分组；(a|b)：a 或 b</td>
</tr>
<tr>
<td>[ ]</td>
<td>字符类，匹配方括号 [ ] 之中的一个字符，[1-9]</td>
</tr>
<tr>
<td>[^]</td>
<td>匹配方括号 [ ] 中字符类之外的一个字符，[^a-g]</td>
</tr>
<tr>
<td>\</td>
<td>转义字符</td>
</tr>
<tr>
<td>|</td>
<td>或</td>
</tr>
</tbody>
</table>
<h3 id="限定符"> 限定符：</h3>
<p>对前面的字符或者字符串做限定说明。</p>
<table>
<thead>
<tr>
<th>限定符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>某个字符之后出现，表示该字符不出现或出现多次；0 次及以上</td>
</tr>
<tr>
<td>?</td>
<td>某个字符之后出现，表示该字符出现一次或不出现；0 次或 1 次</td>
</tr>
<tr>
<td>+</td>
<td>某个字符之后出现，表示其前面字符出现一次或多次；1 次及以上</td>
</tr>
<tr>
<td>{n,m}</td>
<td>某个字符之后出现，表示该字符出现最少 n 次，最多 m 次</td>
</tr>
<tr>
<td>{m}</td>
<td>某个字符之后出现，表示该字符正好出现了 m 次</td>
</tr>
</tbody>
</table>
<h3 id="元字符"> 元字符：</h3>
<p>元字符是一种 Perl 风格的正则表达式，只有一部分文本处理工具支持它，并不是所有的文本处理工具都支持。shell 好行并不支持元字符的正则表达式。</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\b</td>
<td>匹配一个单词边界，也就是指单词和空格间的位置。</td>
</tr>
<tr>
<td>\B</td>
<td>匹配非单词边界。</td>
</tr>
<tr>
<td>\d</td>
<td>匹配一个数字字符。等价于 [0-9]</td>
</tr>
<tr>
<td>\D</td>
<td>匹配一个非数字字符。等价于 [^0-9]</td>
</tr>
<tr>
<td>\f</td>
<td>匹配一个换页符。</td>
</tr>
<tr>
<td>\n</td>
<td>匹配一个换行符。</td>
</tr>
<tr>
<td>\r</td>
<td>匹配一个回车符。</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符。等价于 [^ \f\n\r\t\v]</td>
</tr>
<tr>
<td>\t</td>
<td>匹配一个制表符。</td>
</tr>
<tr>
<td>\v</td>
<td>匹配一个垂直制表符。</td>
</tr>
<tr>
<td>\w</td>
<td>匹配包括下划线的任何单词字符。等价于[A-Za-z0-9_]</td>
</tr>
<tr>
<td>\W</td>
<td>匹配任何非单词字符。等价于 [^A-Za-z0-9_]</td>
</tr>
</tbody>
</table>
<h3 id="posix-特殊字符"> POSIX 特殊字符：</h3>
<table>
<thead>
<tr>
<th>特殊字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>[:alnum:]</td>
<td>匹配任意字母数字字（0-9、a-z、A-Z）</td>
</tr>
<tr>
<td>[:alpha:]</td>
<td>匹配任意字母，大写或小写（a-z、A-Z）</td>
</tr>
<tr>
<td>[:digit:]</td>
<td>匹配任意数字（0-9）</td>
</tr>
<tr>
<td>[:graph:]</td>
<td>非空字符（非空格控制字符）</td>
</tr>
<tr>
<td>[:lower:]</td>
<td>小写字符（a-z）</td>
</tr>
<tr>
<td>[:upper:]</td>
<td>大写字符（A-Z）</td>
</tr>
<tr>
<td>[:cntrl:]</td>
<td>控制字符</td>
</tr>
<tr>
<td>[:print:]</td>
<td>非控制字符（包括空格）</td>
</tr>
<tr>
<td>[:punct:]</td>
<td>标点符号</td>
</tr>
<tr>
<td>[:blank:]</td>
<td>空格和 TAB 字符</td>
</tr>
<tr>
<td>[:xdigit:]</td>
<td>16 进制数字</td>
</tr>
<tr>
<td>[:space:]</td>
<td>所有空白字符（新行、空格、制表符）</td>
</tr>
</tbody>
</table>
<p><strong>注意：</strong></p>
<p>[[  ]] 双中括号的意思：第一个中括号是匹配符 [ ]，匹配中括号 [ ] 中的任意的一个字符；第二个中括号 [ ] 是格式，如 [:digit:]。</p>
<p>例：</p>
<blockquote>
<p>匹配中文汉字： [\u4e00-\u9fa5]</p>
<p>匹配 e-mail 地址：\w+([-+.]\w+)<em>@\w+([-.]\w+)</em>.\w+([-.]\w+)*</p>
<p>匹配网址 URL：http://(/[\w-]+.)+[\w-]+(/[\w- ./?%&amp;=]*)?</p>
</blockquote>
<div><p>补充</p>
<p>Linux 的三剑客 <code>grep</code>、<code>sed</code>、<code>awk</code> 都支持正则表达式</p>
<p>后续将学习三剑客的命令</p>
</div>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-04-09T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Shell对文本的搜索---grep命令</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/15.Shell_grep/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/15.Shell_grep/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="介绍"> 介绍</h2>
<p><code>grep</code> 是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。这也是一个我们比较常用的命令之一，好多时候虽然没通过系统的学习，但是我们还是会经常用到。当文本为标准输入时，经常和管道符 | 结合使用。</p>
<h2 id="grep-命令"> grep 命令</h2>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># grep [选项] [模式] [文件]</span>
选项：
	-E	：pattern被视为一个扩展的正则表达式；egrep
	-F	：pattern是一个以换行符隔开的字符串集合；fgrep不承认正则表达式
	-c	：计算匹配到的行数
	-r	：第归搜索
	-n	：显示匹配内容的行号
	-i	：不区分大小写
	-v	：反向选择，即选择不匹配的行
	-c	：只显示匹配行总数    
	-w	：匹配整词
	-x	：匹配整行
	-l	：只显示文件名，不显示内容
	-s	：不显示错误信息
	--color<span>=</span>auto	：搜索匹配的关键词显示颜色

模式：
	要搜索的字符串或正则表达式

文件：
	即要搜索匹配的源文件或者标准输入，标准输入常用管道符 <span>|</span> 连接grep
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><ul>
<li>来自文件</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># cat /etc/passwd | grep "root" </span>
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>来自标准输入</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># cat /etc/passwd | grep "root" </span>
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>当 <code>grep</code> 的输入既来自文件也来自标准输入时，<code>grep</code> 将忽略标准输入的内容不做处理，除非使用符号 - 来代表标准输入。此时，<code>grep</code> 会标明哪些结果来自于文件哪些来自于标准输入。</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># cat /etc/passwd | grep root /etc/passwd -</span>
/etc/passwd:root:x:0:0:root:/root:/bin/bash
/etc/passwd:operator:x:11:0:operator:/root:/sbin/nologin
<span>(</span>standard input<span>)</span>:root:x:0:0:root:/root:/bin/bash
<span>(</span>standard input<span>)</span>:operator:x:11:0:operator:/root:/sbin/nologin
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>将 <code>/etc/passwd</code> 文件中，没有出现 root 和 nologin 的行打印出来</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># cat /etc/passwd | grep -v root | grep -v nologin</span>
sync:x:4:65534:sync:/bin:/bin/sync
speech-dispatcher:x:111:29:Speech Dispatcher,,,:/var/run/speech-dispatcher:/bin/false
whoopsie:x:112:117::/nonexistent:/bin/false
hplip:x:118:7:HPLIP system user,,,:/var/run/hplip:/bin/false
gnome-initial-setup:x:120:65534::/run/gnome-initial-setup/:/bin/false
gdm:x:121:125:Gnome Display Manager:/var/lib/gdm3:/bin/false
karin:x:1000:1000:karin,,,:/home/karin:/bin/bash
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>将 <code>/etc/passwd</code> 文件中，结尾是 bash 的行打印出来（正则）</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># cat /etc/passwd | grep -E "bash$"</span>
root:x:0:0:root:/root:/bin/bash
karin:x:1000:1000:karin,,,:/home/karin:/bin/bash
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>查找 sshd 进程</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># ps -ef | grep sshd</span>
root       <span>787</span>     <span>1</span>  <span>0</span> 09:56 ?        00:00:00 /usr/sbin/sshd -D
karin     <span>2855</span>  <span>2763</span>  <span>0</span> <span>10</span>:35 pts/0    00:00:00 <span>grep</span> --color<span>=</span>auto sshd
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="黄金搭档"> 黄金搭档</h2>
<p><code>grep</code> 常与 <code>sort</code>、<code>find</code>、<code>xargs</code> 命令组合使用</p>
<h3 id="sort-命令"> sort 命令</h3>
<p>用于将文本文件内容加以排序。如果未给定文件，则读取标准输入，在将排序好的数据写至标准输出。</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># sort [选项] [文件]</span>
选项：
	-n	：按数值大小排序 
	-r	：降序排序 
	-t	：指定分隔符，和cut命令的-d一个作用 
	-k	：用-t指定分隔符后，将第几段进行排序，和cut命令的-f一个作用 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>将 <code>/etc/passwd</code> 文件中每行内容以冒号为分隔符，选取第三段内容按数值大小排序</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># sort -n -t: -k3 /etc/passwd</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="find-命令"> find 命令</h3>
<p><code>find</code> 命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则 <code>find</code> 命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># find 路径 [搜索条件] [搜索内容]</span>
路径：
<span>#find命令接受一个或多个路径（paths）作为搜索范围，并在该路径下递归地搜索。</span>
	<span>.</span>	:当前目录
	~	:家目录
	/	:根目录
	
搜索条件：
<span>#可根据文件名、文件类型、文件大小等属性进行搜索。</span>
	-name	：根据文件名（区分大小写），-iname不区分文件名大小写
	-type	：根据文件类型（f：文件；d：目录；l：符号链接）
	-empty	：检索为空的文件或目录（-type f <span>!</span> -empty非空文件）
	-user	：根据文件或目录的归属
	-mtime	：根据最后一次文件内容有过更改的时间点（单位为天）
	-atime	：根据最后一次文件有被读取过的时间点（atime <span>2</span>两天前）
	-ctime	：根据最后一次文件有被变更过的时间点（-2两天内；+2超过两天）
	-c		：根据文件大小（c：字节；k：Kb；M：Mb；G：Gb；+-表示大于小于）
	-perm	 ：根据文件权限
	
搜索内容：
	要搜索的内容
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>具体请看 <a href="https://ryukarin.github.io/blog/project/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/06.linux%E6%90%9C%E7%B4%A2%E5%91%BD%E4%BB%A4/#find-%E5%91%BD%E4%BB%A4" target="_blank" rel="noopener noreferrer">linux搜索命令</a></p>
<h3 id="xargs-命令"> xargs 命令</h3>
<p>将前一个命令的标准输出传递给下一个命令，作为它的参数，<code>xargs</code> 的默认命令是 <code>echo</code>，空格是默认定界符；将多行输入转换为单行</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># [前一个命令] | xargs [选项] [后一个命令]</span>
选项：
	-n	：指定一次处理的参数个数
	-d	：自定义参数界定符
	-p	：询问是否运行 later <span>command</span> 参数
	-t	：表示先打印命令，然后再执行
	-i	：逐项处理
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="小知识-xargs-与管道-的区别"> 小知识：<code>xargs</code> 与管道 <code>|</code> 的区别</h3>
<p>管道 <code>|</code> 用来将前一个命令的标准输出传递到下一个命令的标准输入，<code>xargs</code> 将前一个命令的标准输出传递给下一个命令，作为它的参数。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-04-09T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Shell对文件的操作---sed命令</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/16.Shell_sed/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/16.Shell_sed/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="介绍"> 介绍</h2>
<p>在 shell 脚本编写中，时常会用到对文件的相关操作，比如增加内容、修改内容、删除部分内容、查看部分内容等，但是上述的这些操作一般都是需要在文本编辑器中才能操作，常用的文本编辑器有：<code>gedit</code>、<code>vim</code>、<code>nano</code> 等，又是交互式文本编辑器，脚本无法自己独立完成必须有人参与才可以完成。如果这样的话又违背了我们编写脚本的目的（全部由机器来完成，减少人的工作压力，提升工作效率）。emm......如何才能让这些操作全部脚本自己就搞定，而不需要人的参与（即完全自动化），而且又能按照我们的脚本预案来完成呢？</p>
<p>为了解决上述问题，linux 为我们提供了一些命令，比如：<code>perl</code>、<code>sed</code> 等命令，下面我们就来学习一下 <code>sed</code> 命令。</p>
<h2 id="sed-命令"> sed 命令</h2>
<p><code>sed</code> 命令是 linux 中提供的一个外部命令，它是一个行（流）编辑器，非交互式的对文件内容进行增删改查的操作，使用者只能在命令行输入编辑命令、指定文件名，然后在屏幕上查看输出。它和文本编辑器有本质的区别。</p>
<p><strong>区别：</strong></p>
<ul>
<li>文本编辑器：编辑对象是文件</li>
<li>行编辑器：编辑对象是文件中的行</li>
</ul>
<p>也就是前者一次处理一个文本，而后者是一次处理一个文本中的一行。这个是我们应该弄清楚且必须牢记的，否则可能无法理解 <code>sed</code> 的运行原理和使用精髓。</p>
<h3 id="sed数据处理原理"> sed数据处理原理</h3>
<div>
<p><img src="./assets/sed.png" alt="数据处理" loading="lazy"></p>
<p><u>读取的数据在缓存中处理，然后默认输出到屏幕</u></p>
</div>
<h3 id="sed-命令格式"> sed 命令格式</h3>
<p><strong>命令格式如下：</strong></p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># sed [选项] '{内部命令}[标志]' [文件]</span>
选项：
	-e		:将脚本中指定的命令添加到处理输入时执行的命令中；一行中要有多个条件
	-f		:将文件中指定的命令添加到处理输入时的命令中
	-n		:抑制自动输出
	-i		:编辑文件内容
	-i.bak	:编辑文件内容同时创建.bak的备份文件
	-r		:使用扩展的正则表达式
	<span>!</span>		:取反（跟在模式条件后，与shell有所区别）
	
内部命令：	
	a	：在匹配后面添加
	i	：在匹配前面添加
	p	：打印
	d	：删除
	s	：查找替换
	c	：编辑更改
	y	：转换（	N	D	P	）
	
标志：
	数字：表示新文本替换模式
	g	：表示用新文本替换现有文本的全部实例
	p	：表示打印原始的内容
	w	：将替换的结果写入文件
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h2 id="sed-使用小技巧"> sed 使用小技巧</h2>
<p><code>$=</code> ：统计文本有多少行</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># sed '=' date</span>
<span>1</span>
hello world<span>!</span>
<span>2</span>
you can you Up
<span>3</span>
bye bye
<span>[</span>root@localhost ~ <span>]</span><span># sed -n '$=' date</span>
<span>3</span>
<span>[</span>root@localhost ~ <span>]</span><span># </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="实例说明"> 实例说明</h2>
<div><pre><code><span>#cat查看文件内容</span>
<span>[</span>root@localhost ~ <span>]</span><span># cat data</span>
<span>1</span>.the quick brown fox jumps over the lazy dog.dog
<span>2</span>.the quick brown fox jumps over the lazy dog.dog
<span>3</span>.the quick brown fox jumps over the lazy dog.dog
<span>4</span>.the quick brown fox jumps over the lazy dog.dog
<span>5</span>.the quick brown fox jumps over the lazy dog.dog
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="sed-内部命令"> sed 内部命令</h3>
<div><pre><code><span>#每行后面追加</span>
<span>[</span>root@localhost ~ <span>]</span><span># sed 'a\hello world' data</span>
<span>1</span>.the quick brown fox jumps over the lazy dog.dog
hello world
<span>2</span>.the quick brown fox jumps over the lazy dog.dog
hello world
<span>3</span>.the quick brown fox jumps over the lazy dog.dog
hello world
<span>4</span>.the quick brown fox jumps over the lazy dog.dog
hello world
<span>5</span>.the quick brown fox jumps over the lazy dog.dog
hello world
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code><span>#第3行后面追加</span>
<span>[</span>root@localhost ~ <span>]</span><span># sed '3a\hello world' data</span>
<span>1</span>.the quick brown fox jumps over the lazy dog.dog
<span>2</span>.the quick brown fox jumps over the lazy dog.dog
<span>3</span>.the quick brown fox jumps over the lazy dog.dog
hello world
<span>4</span>.the quick brown fox jumps over the lazy dog.dog
<span>5</span>.the quick brown fox jumps over the lazy dog.dog
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span>#第2-4行之间每行后面追加</span>
<span>[</span>root@localhost ~ <span>]</span><span># sed '2,4a\hello world' data</span>
<span>1</span>.the quick brown fox jumps over the lazy dog.dog
<span>2</span>.the quick brown fox jumps over the lazy dog.dog
hello world
<span>3</span>.the quick brown fox jumps over the lazy dog.dog
hello world
<span>4</span>.the quick brown fox jumps over the lazy dog.dog
hello world
<span>5</span>.the quick brown fox jumps over the lazy dog.dog
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span>#匹配3.the的行后面追加</span>
<span>[</span>root@localhost ~ <span>]</span><span># sed '/3.the/a\hello world' data</span>
<span>1</span>.the quick brown fox jumps over the lazy dog.dog
<span>2</span>.the quick brown fox jumps over the lazy dog.dog
<span>3</span>.the quick brown fox jumps over the lazy dog.dog
hello world
<span>4</span>.the quick brown fox jumps over the lazy dog.dog
<span>5</span>.the quick brown fox jumps over the lazy dog.dog
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>总结</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># sed 'i\hello world' data				#每行前面插入</span>
<span>[</span>root@localhost ~ <span>]</span><span># sed '3i\hello world' data				#第3行前面插入</span>
<span>[</span>root@localhost ~ <span>]</span><span># sed '2,4i\hello world' data			#第2-4行之间每行前面插入</span>
<span>[</span>root@localhost ~ <span>]</span><span># sed '/3.the/i\hello world' data		#匹配3.the的行前面插入</span>
<span>[</span>root@localhost ~ <span>]</span><span># sed ‘d’ data							#删除所有</span>
<span>[</span>root@localhost ~ <span>]</span><span># sed ‘3d’ data							#删除第3行</span>
<span>[</span>root@localhost ~ <span>]</span><span># sed ‘2,4d’ data						#删除第2-4行</span>
<span>[</span>root@localhost ~ <span>]</span><span># sed ‘/3.the/d’ data					#删除匹配3.the的那一行</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span>#每一行中第一次出现的dog替换成cat</span>
<span>[</span>root@localhost ~ <span>]</span><span># sed 's/dog/cat/' data</span>
<span>1</span>.the quick brown fox jumps over the lazy cat.dog
<span>2</span>.the quick brown fox jumps over the lazy cat.dog
<span>3</span>.the quick brown fox jumps over the lazy cat.dog
<span>4</span>.the quick brown fox jumps over the lazy <span>cat</span>
<span>5</span>.the quick brown fox jumps over the lazy <span>cat</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><pre><code><span>#第3行中第一次出现的dog替换成cat</span>
<span>[</span>root@localhost ~ <span>]</span><span># sed '3s/dog/cat/' data</span>
<span>#第2-4行中第一次出现的dog替换成cat</span>
<span>[</span>root@localhost ~ <span>]</span><span># sed '2,4s/dog/cat/' data</span>
<span>#匹配3.the那行第一次出现的dog替换成cat</span>
<span>[</span>root@linux ~ <span>]</span><span># sed '3.the/s/dog/cat/' data</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span>#每一行内容都更改为hello world</span>
<span>[</span>root@localhost ~ <span>]</span><span># sed 'c\hello world' data</span>
hello world
hello world
hello world
hello world
hello world
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><pre><code><span>#第3行内容更改为hello world</span>
<span>[</span>root@localhost ~ <span>]</span><span># sed '3c\hello world' data</span>
<span>1</span>.the quick brown fox jumps over the lazy dog.dog
<span>2</span>.the quick brown fox jumps over the lazy dog.dog
hello world
<span>4</span>.the quick brown fox jumps over the lazy dog
<span>5</span>.the quick brown fox jumps over the lazy dog
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><pre><code><span>#第2-4行删掉，加入一行hello world</span>
<span>[</span>root@localhost ~ <span>]</span><span># sed '2,4c\hello world' data</span>
<span>1</span>.the quick brown fox jumps over the lazy dog.dog
hello world
<span>5</span>.the quick brown fox jumps over the lazy dog
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>#匹配3.the那行内容更改为hello world</span>
<span>[</span>root@localhost ~ <span>]</span><span># sed '/3.the/c\hello world' data</span>
<span>1</span>.the quick brown fox jumps over the lazy dog.dog
<span>2</span>.the quick brown fox jumps over the lazy dog.dog
hello world
<span>4</span>.the quick brown fox jumps over the lazy dog
<span>5</span>.the quick brown fox jumps over the lazy dog
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><pre><code><span>#转换abcdefg/ABCDEFG一一对应</span>
<span>[</span>root@localhost ~ <span>]</span><span># sed 'y/abcdefg/ABCDEFG' data</span>
<span>1</span>.thE quiCk Brown Fox jumps ovEr thE lAzy DoG.DoG
<span>2</span>.thE quiCk Brown Fox jumps ovEr thE lAzy DoG.DoG

<span>3</span>.thE quiCk Brown Fox jumps ovEr thE lAzy DoG.DoG
<span>4</span>.thE quiCk Brown Fox jumps ovEr thE lAzy DoG
<span>5</span>.thE quiCk Brown Fox jumps ovEr thE lAzy DoG
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span>#把每行再打印一次，即每行打印2次</span>
<span>[</span>root@localhost ~ <span>]</span><span># sed 'p' data</span>
<span>#把第三行打印2次</span>
<span>[</span>root@localhost ~ <span>]</span><span># sed '3p' data</span>
<span>1</span>.the quick brown fox jumps over the lazy dog.dog
<span>2</span>.the quick brown fox jumps over the lazy dog.dog
<span>3</span>.the quick brown fox jumps over the lazy dog.dog
<span>3</span>.the quick brown fox jumps over the lazy dog.dog
<span>4</span>.the quick brown fox jumps over the lazy dog
<span>5</span>.the quick brown fox jumps over the lazy dog
<span>#把第2-4之间的行，每行打印2次</span>
<span>[</span>root@localhost ~ <span>]</span><span># sed '2,4p' data</span>
<span>#把匹配3.the的那行，打印2次</span>
<span>[</span>root@localhost ~ <span>]</span><span># sed '/3.the/p' data</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="sed-命令标志"> sed 命令标志</h3>
<div><pre><code><span>#把每行的所有dog都替换成cat</span>
<span>[</span>root@localhost ~ <span>]</span><span># sed ‘s/dog/cat/g’ data</span>
<span>1</span>.the quick brown fox jumps over the lazy cat.cat
<span>2</span>.the quick brown fox jumps over the lazy cat.cat
<span>3</span>.the quick brown fox jumps over the lazy cat.cat
<span>4</span>.the quick brown fox jumps over the lazy <span>cat</span>
<span>5</span>.the quick brown fox jumps over the lazy <span>cat</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><pre><code><span>#把每行的第2次出现的dog替换成cat</span>
<span>[</span>root@localhost ~ <span>]</span><span># sed ‘s/dog/cat/2’ data</span>
<span>1</span>.the quick brown fox jumps over the lazy dog.cat
<span>2</span>.the quick brown fox jumps over the lazy dog.cat
<span>3</span>.the quick brown fox jumps over the lazy dog.cat
<span>4</span>.the quick brown fox jumps over the lazy dog
<span>5</span>.the quick brown fox jumps over the lazy dog
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><pre><code><span>#把第3行第1次出现的dog替换成cat并打印2次</span>
<span>[</span>root@localhost ~ <span>]</span><span># sed ‘3s/dog/cat/p’ data</span>
<span>1</span>.the quick brown fox jumps over the lazy dog.dog
<span>2</span>.the quick brown fox jumps over the lazy dog.dog
<span>3</span>.the quick brown fox jumps over the lazy cat.dog
<span>3</span>.the quick brown fox jumps over the lazy cat.dog

<span>4</span>.the quick brown fox jumps over the lazy dog
<span>5</span>.the quick brown fox jumps over the lazy dog
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><pre><code><span>#把修改内容部分另存为data.bk</span>
<span>[</span>root@localhost ~ <span>]</span><span># sed ‘3s/dog/cat/w data.bk’ data</span>
<span>[</span>root@localhost ~ <span>]</span><span># ls</span>
data		data.bk
<span>[</span>root@localhost ~ <span>]</span><span># cat data.bk</span>
<span>3</span>.the quick brown fox jumps over the lazy cat.dog
<span>[</span>root@localhost ~ <span>]</span><span># </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="sed-命令选项"> sed 命令选项</h3>
<div><pre><code><span>#不打印原本文本的内容</span>
<span>[</span>root@localhost ~ <span>]</span><span># sed -n ‘3s/dog/cat/p’ data</span>
<span>3</span>.the quick brown fox jumps over the lazy cat.dog
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>#多条件替换</span>
<span>[</span>root@localhost ~ <span>]</span><span># sed -e ‘s/brown/white/;5s/dog/cat/’ data</span>
<span>5</span>.the quick white fox jumps over the lazy <span>cat</span>
<span>[</span>root@localhost ~ <span>]</span><span># vim cmd_op</span>
5s/brown/white/
5s/dog/cat/
<span>#文件内容当作命令</span>
<span>[</span>root@localhost ~ <span>]</span><span># sed -f cmd_op data	</span>
<span>5</span>.the quick white fox jumps over the lazy <span>cat</span>
<span>#修改原文件，不可逆，慎用</span>
<span>[</span>root@localhost ~ <span>]</span><span># sed -i ‘s/dog/cat/’ data</span>
<span>#修改原文件前先备份一个.bak的文件</span>
<span>[</span>root@localhost ~ <span>]</span><span># sed -i.bak ‘s/dog/cat/’ data			</span>
<span>[</span>root@localhost ~ <span>]</span><span># ls</span>
data		data.bk		data.bak
<span>[</span>root@localhost ~ <span>]</span><span># </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="补充说明"> 补充说明</h3>
<p>除了<code>sed -i</code> 会修改原文件内容，且一但修改则不能取消；
其他参数命令不会修改原文件内容，只是修改缓存中的内容并打印输出。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-04-09T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Shell对输出流的处理---awk命令</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/17.Shell_awk/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/17.Shell_awk/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>在日常计算机管理中，总会有很多数据输出到屏幕或者文件，这些输出包含了标准输出、标准错误输出。默认情况下，这些信息全部输出到默认输出设备---屏幕。然而，大量的数据输出中，只有一小部分是我们需要重点关注的，把我们需要的或关注的这些信息，过滤或者提取，以备后续需要是调用。早先的学习中，我们学过使用 <code>grep</code> 来过滤这些数据，使用 <code>cut</code>、<code>tr</code> 命令提取某些字段，但是它们都不具备提取并处理数据的能力，都必须先过滤，再提取转存到变量，然后再通过变量提取去处理。</p>
<p>比如：内存使用率的统计步骤</p>
<blockquote>
<p>通过 <code>free -m</code> 提取出内存总量，赋值给变量 memory_totle</p>
<p>通过 <code>free -m</code> 提取出内存使用量，赋值给变量 memory_use</p>
<p>通过数学运算，计算出内存使用率</p>
</blockquote>
<p>需要执行多步才能得到内存使用率，那么有没有一个能够集过滤、提取、运算为一体的命令呢？当然，就是我们即将学习的 <code>awk</code> 命令。</p>
<h2 id="awk-介绍"> awk 介绍</h2>
<p><code>awk</code> 是一种可以处理数据、产生格式化报表的语言，功能十分强大。<code>awk</code> 认为文件中的每一行是一条记录，记录与记录之间的分割符为换行符；每一列是一个字段，字段与字段的分割符默认是一个或多个的空格或 tab 制表符。</p>
<p><code>awk</code> 的工作方式是读取数据，将每一行数据视为一条记录（record），每条记录以字段分割符分割成若干个字段，然后输出各个字段的值。</p>
<h3 id="awk-命令格式"> awk 命令格式</h3>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># awk [选项] [BEGIMN]{program}[END] [file]</span>
选项：
	-F	：fs指定描绘一行中数据字段的分割符，默认为空格
	-f	：指定读取程序的文件名
	-v	：定义awk程序中使用的变量和默认值
	
程序运行优先级：
	BEGIN	：在开始处理数据之前执行，可选项
	program	：如何处理数据流，必选项
	END		：处理完数据流后执行，可选项
	
注意：
	<span>awk</span> 程序脚本由左大括号和右大括号定义。脚本命令必须防止在两个大括号之间。由于 <span>awk</span> 命令行假定脚本是单文本字符串，还必须将脚本放在单引号中。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="awk-的基本用法"> awk 的基本用法</h2>
<h3 id="awk-对字段的提取-列"> awk 对字段的提取（列）</h3>
<p>字段提取：提取一个文本中的一列数据并打印输出
字段相关内置变量</p>
<blockquote>
<p>$0		表示正行文本</p>
<p>$1		表示文本行中的第一个数据字段</p>
<p>$2		表示文本行中的第二个数据字段</p>
<p>$N		表示文本行中的第N个数据字段</p>
<p>$NF		表示文本行中的最后一个数据字段</p>
</blockquote>
<ul>
<li>读入test文件每行数据并把每行数据打印出来</li>
</ul>
<div><pre><code><span>[</span>root@linux ~ <span>]</span><span># awk '{print $0}' test</span>
<span>1</span> the quick brown fox jumps over the lazy <span>cat</span> <span>.</span> dog
<span>2</span> the quick brown fox jumps over the lazy <span>cat</span> <span>.</span> dog
<span>3</span> the quick brown fox		 jumps over the lazy <span>cat</span> <span>.</span> dog
<span>4</span> the quick brown fox jumps over the lazy <span>cat</span> <span>.</span> dog
<span>5</span> the quick brown fox jumps over the lazy <span>cat</span> <span>.</span> dog
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>
<li>打印test文件的第六个字段</li>
</ul>
<div><pre><code><span>[</span>root@linux ~ <span>]</span><span># awk '{print $6}' test</span>
jumps
jumps
jumps
jumps
jumps
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>
<li>打印test文件的最后一个字段</li>
</ul>
<div><pre><code><span>[</span>root@linux ~ <span>]</span><span># awk '{print $NF}' test</span>
dog
dog
dog
dog
dog
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="awk-对记录的提取-行"> awk 对记录的提取（行）</h3>
<p>记录提取：提取一个文本中的一行并打印输出
记录的提取方法有两种：</p>
<ol>
<li>通过行号</li>
<li>通过正则匹配</li>
</ol>
<ul>
<li>NR：指定行号</li>
</ul>
<p>提取 test 中的第三行（指定行号为3）</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># awk 'NR==3{print $0}' test</span>
<span>3</span> the quick brown fox		 jumps over the lazy <span>cat</span> <span>.</span> dog
<span>[</span>root@localhost ~ <span>]</span><span># awk 'NR==1{print $1,$3,$5}' /etc/passwd</span>
root <span>0</span> root
<span>[</span>root@localhost ~ <span>]</span><span># awk 'NR==1{print $1 "-" $3 "-" $5}' /etc/passwd</span>
root-0-root
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="awk-命令选项详解"> awk 命令选项详解</h3>
<ul>
<li>-F：指定字段与字段的分割符</li>
</ul>
<p>当输出的数据流字段格式不是 <code>awk</code> 默认的字段格式时，我们可以使用 -F 命令选项来重新定义数据流字段分割符号。比如：</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># awk -F ':' '{print $1,$3,$NF}' /etc/passwd</span>
root <span>0</span> /bin/bash
daemon <span>1</span> /usr/sbin/nologin
<span>..</span><span>..</span><span>..</span>
karin <span>1000</span> /bin/bash
sshd <span>122</span> /usr/sbin/nologin
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>
<li>-f：如果 <code>awk</code> 命令是日常重复工作，而又没有太多变化，可以将程序写入文件，每次使用-f调用程序文件就可以了，方便且高效。</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># vim abc</span>
<span>{</span>print <span>$1</span>,<span>$1</span>,<span>$NF</span><span>}</span>
<span>[</span>root@localhost ~ <span>]</span><span># awk -f abc test</span>
<span>1</span> quick dog
<span>2</span> quick dog
<span>3</span> quick dog
<span>4</span> quick dog
<span>5</span> quick dog
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ul>
<li>-v：定义变量，既然作者写awk的时候就是按着语言去写的，那么语言中最重要的要素---变量肯定不能缺席，所以可以使用 -v 命令选项定义变量</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># awk -v name='root' 'BEGIN{print name}'</span>
root
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="awk-对字符串的提取-行列交汇"> awk 对字符串的提取（行列交汇）</h3>
<p>记录和字段的汇合点就是字符串
打印 test 第三行的第六个字段</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># awk 'NR==3{print $6}' test</span>
jumps
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="awk-程序的优先级"> awk 程序的优先级</h3>
<p>关于 <code>awk</code> 程序的优先级，BEGIN 是优先级最高的代码块，是在执行 program 之前执行的，不需要提供数据源，因为不涉及到任何数据处理，也不依赖于 program 代码块；program 代码块是对数据流干什么，是必选代码块，也是默认代码块。所以在执行时必须提供数据源；END 是处理完数据流后的操作，如果需要执行 END 代码块，就必须需要 program 的支持，单个无法执行。</p>
<h3 id="优先级显示"> 优先级显示</h3>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># awk 'BEGIN{print "hello world"}{print $0}END{print "bye bye"}' test</span>
hello world
<span>1</span> the quick brown fox jumps over the lazy <span>cat</span> <span>.</span> dog
<span>2</span> the quick brown fox jumps over the lazy <span>cat</span> <span>.</span> dog
<span>3</span> the quick brown fox		 jumps over the lazy <span>cat</span> <span>.</span> dog
<span>4</span> the quick brown fox jumps over the lazy <span>cat</span> <span>.</span> dog
<span>5</span> the quick brown fox jumps over the lazy <span>cat</span> <span>.</span> dog
bye bye
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ul>
<li>不需要数据源，可以直接执行</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># awk 'BEGIN{print "hello world"}'</span>
hello world
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>没有提供数据源，所以无法执行成功</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># awk '{print "hello world"}'</span>
<span>[</span>root@localhost ~ <span>]</span><span># awk 'END{print "hello world"}'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="awk-高级用法"> awk 高级用法</h2>
<p><code>awk</code> 是一门语言，那么就会符合语言的特性，除了可以定义变量外，还可以定义数组，还可以进行运算，流程控制。</p>
<h3 id="awk-定义数组"> awk 定义数组</h3>
<p>数组定义方式：</p>
<div><pre><code>数组名<span>[</span>索引<span>]</span><span>=</span>值
</code></pre>
<div><span>1</span><br></div></div><p>定义数组 array，有两个元素，分别是 100，200，打印数组元素。</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># awk 'BEIGN{array[0]=100;array[1]=200;print array[0],array[1]}'</span>
<span>100</span> <span>200</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="awk-运算"> awk 运算</h3>
<blockquote>
<p>赋值运算		=</p>
<p>比较运算		&gt;、&gt;=、==、&lt;=、&lt;、!=</p>
<p>数学运算		+、-、*、/、%、**、++、--</p>
<p>逻辑运算		&amp;&amp;、||</p>
<p>匹配运算		<sub>、!</sub></p>
</blockquote>
<ul>
<li>赋值运算：主要是对变量或者数组赋值</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># read -2 /proc/meminfo | awk 'NR==1{t=$2}NR==2{f=$2;print (t-f)*100/t "%"}'</span>
<span>8.7528</span>%
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>比较运算：如果比较字符串则按 ascii 编码顺序表比较，比较结果 1 则为真，0 则为假</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># awk 'BEGIN{print "a" >= "b" }'</span>
<span>0</span>
<span>[</span>root@localhost ~ <span>]</span><span># awk 'BEGIN{print 99 >= 1 }'</span>
<span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>数学运算：支持幂运算，支持小数点</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># awk 'BEGIN{print 9-1 }'</span>
<span>8</span>
<span>[</span>root@localhost ~ <span>]</span><span># awk 'BEGIN{print 100%3 }'</span>
<span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>逻辑运算：与、或运算</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># awk 'BEGIN{print 100>3 &amp;&amp; 28&lt;=9 }'</span>
<span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>匹配运算：精确匹配 ==，精确不匹配  !==；模糊匹配 ~，模糊不匹配  !~</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># awk -F: '$1=="root"{print $0}' /etc/passwd</span>
root:x:0:0:root:/root:/bin/bash
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="awk-环境变量"> awk 环境变量</h3>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>FIELDWIDTHS</td>
<td>以空格分隔的数字列表，用空格定义每个数据字段的精确宽度</td>
</tr>
<tr>
<td>FS</td>
<td>输入字段分隔符号</td>
</tr>
<tr>
<td>OFS</td>
<td>输出字段分隔符号</td>
</tr>
<tr>
<td>RS</td>
<td>输入记录分隔符号</td>
</tr>
<tr>
<td>ORS</td>
<td>输出记录分隔符号</td>
</tr>
</tbody>
</table>
<p>FIELDWIDTHS：重新定义列宽并打印，注意不可以使用 $0 打印所有，因为 $0 是打印本行全内容，不会打印你定义的字段</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># awk 'BEGIN{FIELDWIDTHS="5 2 8"}NR==1{print $1,$2,$3}' /etc/passwd</span>
root: x: <span>0</span>:0:root
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>FS：指定数据源中字段分隔符，类似命令选项 -F</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># awk 'BEGIN{FS=":"}NR==1{print $1,$3,$NF}‘ /etc/passwd</span>
root <span>0</span> /bin/bash
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>OFS：指定输出到屏幕后字段的分隔符</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># awk 'BEGIN{FS=":";OFS="-"}NR==1{print $1,$3,$NF}' /etc/passwd</span>
root-0-/bin/bash
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>RS：指定记录的分隔符，将记录的分隔符修改为空后，所有的行会变成一行</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># awk 'BEGIN{RS=""}{print $1,$2,$3}' num</span>
<span>1</span> <span>2</span> <span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>ORS：输出到屏幕后记录的分隔符，默认为回车</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># awk 'BEGIN{RS="";ORS="*"}{print $1,$2,$3,$4,$5}' num</span>
<span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span>*<span>[</span>root@localhost ~ <span>]</span><span># </span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>#可以看出，提示符和输出在一行了，因为默认回车换成了*（ORS=&quot;*&quot;）</p>
<h3 id="流程控制"> 流程控制</h3>
<ol>
<li>if 判断语句</li>
<li>for 循环语句</li>
<li>while 循环语句</li>
<li>do...while 语句</li>
<li>循环控制</li>
</ol>
<ul>
<li>if 判断语句</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># awk '{if ($1&lt;5)print $1*2;else print $1/2}' num</span>
<span>2</span>
<span>4</span>
<span>6</span>
<span>8</span>
<span>2.5</span>
<span>3</span>
<span>3.5</span>
<span>4</span>
<span>4.5</span>
<span>5</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ul>
<li>for 循环语句</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># vim num2</span>
<span>60</span> <span>50</span> <span>100</span>
<span>150</span> <span>30</span> <span>10</span>
<span>70</span> <span>100</span> <span>40</span>
<span>[</span>root@localhost ~ <span>]</span><span># awk '{sum=0;for (i=1;i&lt;4;i++){sum+=$i}print sum}' sum2</span>
<span>210</span>
<span>190</span>
<span>210</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ul>
<li>while 循环语句</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># awk '{sum=0;i=1;while(i&lt;4){sum+=$i;i++}print sum}' num2</span>
<span>210</span>
<span>190</span>
<span>210</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>do...while 语句</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># awk '{sum=0;i=1;do{sum+=$i;i++}while(i&lt;4);print sum}' num2</span>
<span>210</span>
<span>190</span>
<span>210</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>循环控制语句</li>
</ul>
<p>break：跳出循环，继续执行后续语句。</p>
<p>continue：停止本次循环，继续下一次循环。</p>
<p>累加每行数值，和大于 150 停止累加</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># awk '{</span>
<span>></span> <span>sum</span><span>=</span><span>0</span>
<span>></span> <span>i</span><span>=</span><span>1</span>
<span>></span> <span>while</span> <span>(</span>i<span>&lt;</span><span>4</span><span>)</span><span>{</span>
<span>></span> 	<span>sum</span><span>+=</span><span>$i</span>
<span>></span> 	<span>if</span> <span>(</span>sum<span>></span><span>150</span><span>)</span><span>{</span>
<span>></span> 		<span>break</span>
<span>></span> 	<span>}</span>
<span>></span> 	i++
<span>></span> <span>}</span>
<span>></span> print <span>sum</span>
<span>></span> <span>}</span>' num2
<span>210</span>
<span>180</span>
<span>170</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="awk小技巧"> awk小技巧</h2>
<ul>
<li>打印 test 文本的行数</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># awk 'END{print NR}' test</span>
<span>5</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>打印 test 文本最后一行内容</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># awk 'END{print $0}' test</span>
<span>5</span> the quick brown fox jumps over the lazy <span>cat</span> <span>.</span> dog
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>打印 test 文本列数</li>
</ul>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># awk 'END{print NF}' test</span>
<span>12</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-04-09T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Shell监控脚本</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/18.Shell_monitor_script/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/18.Shell_monitor_script/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="脚本目的"> 脚本目的</h2>
<ul>
<li>监控一个机器的存活状态</li>
<li>监控一个端口的开启状态</li>
<li>监控内存使用率脚本</li>
<li>找出使用 CPU 或 memory 前十的进程</li>
<li>监控硬盘 IO 脚本</li>
</ul>
<h2 id="试写脚本"> 试写脚本</h2>
<p>下面的几个脚本实例中，脚本的开头信息省略，大致内容如下：</p>
<div><pre><code><span>#Description: xxx</span>
<span>#Author: xxx</span>
<span>#Created Time: yyyy/mm/dd hh:mm</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>脚本如何写，需要一个思路框架，比如：</p>
<blockquote>
<p>需要用什么命令，命令的具体用法；</p>
<p>需要循环时如何去循环，匹配时如何去匹配；</p>
<p>如何一步一步的接近脚本的目的；</p>
<p>……</p>
</blockquote>
<p>不同的脚本需要不同的思路方法，就需要具体情况具体对待；当然，同一个脚本可以有不同的写法，前期只要能达目的就好，后期则需要慢慢去优化脚本，毕竟效率高能节省很多系统资源和时间。</p>
<h3 id="监控一个机器的存活状态"> 监控一个机器的存活状态</h3>
<p><strong>思路：</strong></p>
<blockquote>
<ul>
<li>
<p>监控方法：<code>ping</code></p>
<ul>
<li>
<p><code>ping</code> 得通：host up</p>
</li>
<li>
<p><code>ping</code> 不通：host down</p>
</li>
</ul>
</li>
<li>
<p>问题：关于禁 <code>ping</code>，禁的是陌生人（禁止所有，允许你的）</p>
</li>
<li>
<p>条件：网络延迟，假报警问题</p>
</li>
<li>
<p><code>ping</code> 的取值，<code>ping</code> 几次，间隔几秒，<code>ping</code> 都失败判断机器状态为 down</p>
</li>
</ul>
</blockquote>
<p>代码：</p>
<div><pre><code><span>[</span>root@localhost~ <span>]</span><span># vim host_status.sh</span>
<span>#!/bin/bash</span>
<span>#测试代码，ping3次</span>
<span>for</span> <span><span>((</span>i<span>=</span><span>1</span><span>;</span>i<span>&lt;</span><span>4</span><span>;</span>i<span>++</span><span>))</span></span><span>;</span><span>do</span>
	<span>if</span> <span>ping</span> -c1 <span>$1</span> <span>&amp;></span>/dev/null<span>;</span><span>then</span>
		<span>export</span> ping_count<span>"<span>$i</span>"</span><span>=</span><span>1</span>
	<span>else</span>	
		<span>export</span> ping_count<span>"<span>$i</span>"</span><span>=</span><span>0</span>
	<span>fi</span>
<span>#每次ping的时间间隔（秒）</span>
	<span>sleep</span> <span>3</span>
<span>done</span>
<span>#如果3次ping都失败则报警机器存活状态为down</span>
<span>if</span> <span>[</span> <span>$ping_count</span> -eq <span>$ping_count2</span> <span>]</span> <span>&amp;&amp;</span> <span>[</span> <span>$ping_count2</span> -eq <span>$ping_count3</span> <span>]</span> <span>&amp;&amp;</span> <span>[</span><span>$ping_count1</span> -eq <span>0</span> <span>]</span><span>;</span><span>then</span>
	<span>echo</span> <span>"<span>$1</span> is down"</span>
<span>else</span>	
	<span>echo</span> <span>"<span>$1</span> is up"</span>
<span>fi</span>
<span>unset</span> ping_count1
<span>unset</span> ping_count2
<span>unset</span> ping_count3
<span>[</span>root@localhost ~ <span>]</span><span># bash host_status.sh 192.168.2.88</span>
<span>192.168</span>.2.88 is up
<span>[</span>root@localhost ~ <span>]</span><span># bash host_status.sh 192.168.2.99</span>
<span>192.168</span>.2.99 is down
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h3 id="监控一个端口的开启状态"> 监控一个端口的开启状态</h3>
<p><strong>思路：</strong></p>
<blockquote>
<ul>
<li>监控方法：当系统压力过大或服务 donw 了，a、b、c 方法也还可能监测到，不推荐
a. systemctl、service 服务启动状态
b. <code>lsof</code> 查看端口是否存在
c. <code>ps</code> 查看进程是否存在
d. <code>telnet</code> 测试端口是否有响应------推荐</li>
<li><code>telnet</code> 工具是否存在，没有的话需要安装</li>
</ul>
</blockquote>
<p>代码：</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># vim port_status.sh</span>
<span>#!/bin/bash</span>
<span>port_status</span><span>(</span><span>)</span><span>{</span>
<span>temp_file</span><span>=</span><span><span>`</span>mktemp port_status.XXX<span>`</span></span>
<span>#判断依赖命令telnet是否存在</span>
<span>[</span> <span>!</span> -x /usr/bin/telnet <span>]</span> <span>&amp;&amp;</span> <span>echo</span> <span>"telnet: not found command"</span> <span>&amp;&amp;</span> <span>exit</span> <span>1</span>
<span>#测试端口 $1 ：IP	  $2：port</span>
<span>(</span> telnet <span>$1</span> <span>$2</span> <span>&lt;&lt;</span> <span>EOF
quit
EOF</span>
<span>)</span> <span>&amp;></span> <span>$temp_file</span>

<span>#分析文件中的内容，判断结果</span>
<span>if</span> <span>egrep</span> <span>"\^]"</span> <span>$temp_file</span> <span>&amp;></span> /dev/null<span>;</span><span>then</span>
	<span>echo</span> <span>"<span>$1</span> :<span>$2</span> is open"</span>
<span>else</span>
	<span>echo</span> <span>"<span>$1</span>:<span>$2</span> is close"</span>
<span>fi</span>
<span>rm</span> -f <span>$temp_file</span>
<span>}</span>
<span>#调用函数，别忘带参数</span>
port_status <span>$1</span> <span>$2</span>
<span>[</span>root@localhost ~ <span>]</span><span># bash port_status.sh 192.168.2.88 22</span>
<span>192.168</span>.2.88:22 is <span>open</span>
<span>[</span>root@localhost ~ <span>]</span><span># bash port_status.sh 192.168.2.88 23</span>
<span>192.168</span>.2.88:23 is close
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h3 id="监控内存使用率脚本"> 监控内存使用率脚本</h3>
<p><strong>思路：</strong></p>
<blockquote>
<ul>
<li>监控方法：
a. <code>free</code>
b. <code>cat /proc/meminfo</code></li>
<li>知识：内存的申请顺序 free---&gt;cache---&gt;buffer---&gt;swap</li>
</ul>
</blockquote>
<p>代码：</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># vim memory_use.sh</span>
<span>#!/bin/bash</span>
memory_use<span>{</span>
<span>memory_used</span><span>=</span><span><span>`</span><span>head</span> -2 /proc/meminfo <span>|</span> <span>awk</span> <span>'NR==1{t=$2}NR==2{f=$2;print (t-f)*100/t"%"}'</span><span>`</span></span>
<span>memory_cache</span><span>=</span><span><span>`</span><span>head</span> -5 /proc/meminfo <span>|</span> <span>awk</span> <span>'NR==1{t=$2}NR==5{c=$2;print c*100/t"%"}'</span><span>`</span></span>
<span>memory_buffer</span><span>=</span><span><span>`</span><span>head</span> -4 /proc/meminfo <span>|</span> <span>awk</span> <span>'NR==1{t=$2}NR==2{b=$2;print b*100/t"%"}'</span><span>`</span></span>
<span>echo</span> -e <span>"memory_used: <span>$memory_used</span><span title="\t">\t</span>cache: <span>$memory_cache</span><span title="\t">\t</span>buffer: <span>$memory_buffer</span>"</span>
<span>}</span>
memory_use
<span>[</span>root@localhost ~ <span>]</span><span># bash memory_use.sh</span>
memory_used: <span>8.83752</span>%		cache: <span>0.03784</span>%		buffer: <span>5.74635</span>%
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="监控使用-cpu-或内存前十名的进程"> 监控使用 CPU 或内存前十名的进程</h3>
<p><strong>思路：</strong></p>
<blockquote>
<p>监控方法：
<code>ps</code> 命令
<code>top</code> 命令
整合：对任务管理器的进程进行排序、整合（按 CPU 或内存）</p>
</blockquote>
<p>代码：</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># vim cpu_memory_use.sh</span>
<span>memory</span><span>(</span><span>)</span><span>{</span>
<span>#收集任务管理器进程信息</span>
<span>temp_file</span><span>=</span><span><span>`</span>mktemp memory.XXX<span>`</span></span>
<span>top</span> -b -n <span>1</span> <span>></span> <span>$temp_file</span>
<span>#按进程统计内存使用大小</span>
<span>tail</span> -n +8 <span>$temp_file</span> <span>|</span> <span>awk</span> <span>'{array[$NF]+=$6}END{for (i in array) print array[i],i}'</span> <span>|</span> <span>sort</span> -k <span>1</span> -n -r <span>|</span> <span>head</span> -10
<span>rm</span> -f <span>$temp_file</span>
<span>}</span>
<span>cpu</span><span>(</span><span>)</span><span>{</span>
<span>#收集任务管理器进程信息</span>
<span>temp_file</span><span>=</span><span><span>`</span>mktemp cpu.XXX<span>`</span></span>
<span>top</span> -b -n <span>1</span> <span>></span> <span>$temp_file</span>
<span>#按进程统计cpu使用大小</span>
<span>tail</span> -n +8 <span>$temp_file</span> <span>|</span> <span>awk</span> <span>'{array[$NF]+=$9}END{for (i in array) print array[i],i}'</span> <span>|</span> <span>sort</span> -k <span>1</span> -n -r <span>|</span> <span>head</span> -10
<span>rm</span> -f <span>$temp_file</span>
<span>}</span>
<span>echo</span> 占用memory前十进程：
memory
<span>echo</span> 占用cpu前十进程：
cpu
<span>[</span>root@localhost ~ <span>]</span><span># bash cpu_memory_use.sh</span>
占用memory前十进程：
<span>614380</span> Content
<span>363520</span> gnome-shell
<span>324108</span> firefox
<span>158612</span> Xorg
<span>154868</span> gnome-software
<span>151000</span> Cont
<span>131300</span> evolution-calen
<span>114968</span> WebExtensions
<span>62176</span> nautilus-deskto
<span>55484</span> evolution-addre
占用cpu前十进程：
<span>23.5</span> <span>top</span>
<span>11.8</span> gnome-shell
<span>11.8</span> Content
<span>5.9</span> Xorg
<span>5.9</span> firefox
<span>0</span> xdg-permission-
<span>0</span> writeback
<span>0</span> wpa_supplicant
<span>0</span> whoopsie
<span>0</span> WebExtensions
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><h3 id="监控硬盘-io-脚本"> 监控硬盘 IO 脚本</h3>
<p><strong>思路：</strong></p>
<blockquote>
<p>监控命令：
<code>iostat</code>（详解）
<code>iozone</code>（第三方提供）
监控指标：IO 队列长度、IOPS、磁盘吞吐量</p>
</blockquote>
<ul>
<li><code>iostat</code> 命令详解
用法：<code>iostat [选项] [&lt;时间间隔&gt; [次数]]</code>
<ul>
<li>选项说明：
-c：只显示系统 CPU 统计信息
-d：只显示 Device 结果
-k/-m：输出结果以 kB/mB 为单位
-x：输出更详细的 io 设备统计信息
interval/count：每次输出间隔时间/输出次数（不带 count 则循环输出）</li>
</ul>
</li>
</ul>
<p>代码：</p>
<div><pre><code><span>[</span>root@localhost ~ <span>]</span><span># vim io.sh</span>
<span>#!/bin/bash</span>
<span>io</span><span>(</span><span>)</span><span>{</span>
<span>decice_num</span><span>=</span><span><span>`</span>iostat -x <span>|</span> <span>egrep</span> <span>"^sd[a-z]"</span> <span>|</span> <span>wc</span> -l<span>`</span></span>
iostat -x <span>1</span> <span>3</span> <span>|</span> <span>egrep</span> <span>"^sd[a-z]"</span> <span>|</span> <span>tail</span> -n +<span><span>$((</span>device_num<span>+</span><span>1</span><span>))</span></span> <span>|</span> <span>awk</span> <span>'{io_long[$1]+=$9}END{for (i in io_long)print io_long[i],i}'</span>
<span>}</span>
io
<span>[</span>root@localhost ~ <span>]</span><span># bash io.sh</span>
<span>72.28</span>  sda
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="监控脚本的总结"> 监控脚本的总结</h3>
<ul>
<li>监控项：机器、服务、资源、进程、端口……</li>
<li>阈值：根据预设监控项的阈值，分多种情况</li>
<li>监控方法：命令、思路、定义函数、运行方法、调用方法……</li>
<li>返回值：根据监控项的阈值，来返回对应的值</li>
</ul>
<p>上面的几个脚本都是常见的监控脚本写法，以后遇到监控脚步要会举一反三。当然具体如何监控的细节，需要自己去思考。</p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-04-09T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Shell脚本---lamp环境安装</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/19.Shell_lamp_install_script/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/19.Shell_lamp_install_script/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="lamp-环境安装"> lamp 环境安装</h2>
<p><strong>思路：</strong></p>
<ul>
<li>lamp 安装
<ul>
<li>apache（apr 及其相关包）</li>
<li>mysql（mysql 的配置，安装时调用配置）</li>
<li>php（php 相关包）</li>
</ul>
</li>
</ul>
<p>代码：</p>
<div><pre><code><span>#!/bin/bash</span>
<span>#变量定义===========================================================</span>
<span>PACKAGES</span><span>=</span><span>"../soft"</span>
<span>CURRENT</span><span>=</span><span><span>`</span><span>pwd</span><span>`</span></span>
<span>APR</span><span>=</span>apr-1.5.2.tar.bz2
<span>APR_UTIL</span><span>=</span>apr-util-1.5.4.tar.bz2
<span>APR_ICONV</span><span>=</span>apr-iconv-1.2.1.tar.bz2
<span>APACHE</span><span>=</span>httpd-2.4.12.tar.bz2
<span>MYSQL</span><span>=</span>mysql-5.5.29.tar.gz
<span>LIBICONV</span><span>=</span>libiconv-1.14.tar.gz
<span>LIBMCRYPT</span><span>=</span>libmcrypt-2.5.8.tar.gz
<span>MCRYPT</span><span>=</span>mcrypt-2.6.8.tar.gz
<span>MHASH</span><span>=</span>mhash-0.9.9.9.tar.gz
<span>PHP</span><span>=</span>php-5.6.9.tar.bz2
<span>INS_PATH</span><span>=</span><span>"/usr/local"</span>
<span>SOU_PATH</span><span>=</span><span>"/usr/src"</span>
<span>#定义函数========================================================</span>
<span>#确认是否为root用户----------------------</span>
<span>check</span><span>(</span><span>)</span><span>{</span>
<span>[</span> <span>$UID</span> -ne <span>0</span> <span>]</span> <span>&amp;&amp;</span> <span>echo</span> <span>"need to root is that"</span> <span>&amp;&amp;</span> <span>exit</span> <span>1</span>
<span>#安装依赖---------------------------------------</span>
yum seach elink <span>&amp;></span>/dev/null
<span>if</span> <span>[</span> <span>$?</span> -eq <span>0</span> <span>]</span><span>;</span><span>then</span>
	yum -y <span>install</span> gcc gcc-c++ openssl-devel pcre-devel ncurses-devel libtool libxml2-devel bzip2-cevel net-snmp-devel curl-devel libpng-devel freetype-devel libjpeg-devel zlib-devel cmake
<span>[</span> <span>$?</span> -eq <span>0</span> <span>]</span> <span>&amp;&amp;</span> <span>echo</span> <span>"YUM: ERROR"</span> <span>&amp;&amp;</span> <span>exit</span> <span>1</span>
<span>else</span>
	<span>echo</span> <span>"YUM: ERROR"</span><span>;</span><span>exit</span> <span>1</span>
<span>fi</span>
<span>}</span>
<span>#安装apache-----------------------------------------------------------------------------------------------</span>
<span>apr</span><span>(</span><span>)</span><span>{</span>
<span>if</span> <span>[</span> -f <span>$PACKAGES</span>/<span>$APR</span> <span>]</span><span>;</span><span>then</span>
	<span>tar</span> -xf <span>$PACKAGES</span>/<span>$APR</span> -C <span>$SOU_PATH</span>
	<span>CUR_PACKAGE</span><span>=</span><span><span>`</span><span>echo</span> $APR <span>|</span> <span>awk</span> -F <span>".tar"</span> <span>'{print $1}'</span><span>`</span></span>
	<span>if</span> <span>[</span> -d <span>$SOU_PATH</span>/<span>$CUR_PACKAGE</span> <span>]</span><span>;</span><span>then</span>
		<span>cd</span> <span>$SOU_PATH</span>/<span>$CUR_PACKAGE</span>
		./configure --prefix<span>=</span><span>$INS_PATH</span>/apr <span><span>1</span>></span>/dev/null
		<span>if</span> <span>[</span> <span>$?</span> -eq <span>0</span> <span>]</span><span>;</span><span>then</span>
			<span>make</span> <span><span>1</span>></span>/dev/null
			<span>if</span> <span>[</span> <span>$?</span> -eq <span>0</span> <span>]</span><span>;</span><span>then</span>
				<span>make</span> <span>install</span> <span><span>1</span>></span>/dev/null
				<span>if</span> <span>[</span> <span>$?</span> -ne <span>0</span> <span>]</span><span>;</span><span>then</span>
					<span>echo</span> <span>"APR: make install ERROR , EXIT......"</span><span>;</span><span>exit</span> <span>1</span>
				<span>else</span>
					<span>cd</span> -<span>;</span><span>rm</span> -rf <span>$SOU_PATH</span>/CUR_PACKAGE
				<span>fi</span>
			<span>else</span>
				<span>echo</span> <span>"APR: make ERROR , EXIT......"</span><span>;</span><span>exit</span> <span>1</span>
			<span>fi</span>
		<span>else</span>
			<span>echo</span> <span>"APR: configure ERROR , ECXIT......"</span><span>;</span><span>exit</span> <span>1</span>
		<span>fi</span>
	<span>else</span>
		<span>echo</span> <span>"APR: tar command ERROR , EXIT......"</span><span>;</span><span>exit</span> <span>1</span>
	<span>fi</span>
<span>else</span>
	<span>echo</span> <span>"APR: not found <span>$APR</span> , EXIT"</span><span>;</span><span>exit</span> <span>1</span>
<span>fi</span>
<span>}</span>

<span>apr_util</span><span>(</span><span>)</span><span>{</span>
<span>if</span> <span>[</span> -f <span>$PACKAGES</span>/<span>$APR_UTIL</span> <span>]</span><span>;</span><span>then</span>
	<span>tar</span> -xf <span>$PACKAGES</span>/<span>$APR_UTIL</span> -C <span>$SOU_PATH</span>
	<span>CUR_PACKAGE</span><span>=</span><span><span>`</span><span>echo</span> $APR_UTIL <span>|</span> <span>awk</span> -F <span>".tar"</span> <span>'{print $1}'</span><span>`</span></span>
	<span>if</span> <span>[</span> -d <span>$SOU_PATH</span>/<span>$CUR_PACKAGE</span> <span>]</span><span>;</span>thne
		<span>cd</span> <span>$SOU_PATH</span>/SUR_PACKAGE
		./configure --prefix<span>=</span><span>$INS_PATH</span>/apr-util --with-apr<span>=</span><span>$INS_PATH</span>/apr/ <span><span>1</span>></span>/dev/null
		<span>if</span> <span>[</span> <span>$?</span> -eq <span>0</span> <span>]</span><span>;</span><span>then</span>
			<span>make</span> <span><span>1</span>></span>/dev/null
			<span>if</span> <span>[</span> <span>$?</span> -eq <span>0</span> <span>]</span><span>;</span><span>then</span>
				<span>make</span> <span>install</span> <span><span>1</span>></span>/dev/null
				<span>if</span> <span>[</span> <span>$?</span> -ne <span>0</span> <span>]</span><span>;</span><span>then</span>
					<span>echo</span> <span>"APR-UTIL: make install ERROR , EXIT......"</span><span>;</span><span>exit</span> <span>1</span>
				<span>else</span>
					<span>cd</span> -<span>;</span><span>rm</span> -rf <span>$SOU_PATH</span>/CUR_PACKAGE
				<span>fi</span>
			<span>else</span>
				<span>echo</span> <span>"APR-UTIL: make ERROR , EXIT......"</span><span>;</span><span>exit</span> <span>1</span>
			<span>fi</span>
		<span>else</span>
			<span>echo</span> <span>"APR-UTIL: configure ERROR , ECXIT......"</span><span>;</span><span>exit</span> <span>1</span>
		<span>fi</span>
	<span>else</span>
		<span>echo</span> <span>"APR-UTIL: tar command ERROR , EXIT......"</span><span>;</span><span>exit</span> <span>1</span>
	<span>fi</span>
<span>else</span>
	<span>echo</span> <span>"APR-UTIL: not found <span>$APR_UTIL</span> , EXIT"</span><span>;</span><span>exit</span> <span>1</span>
<span>fi</span>
<span>}</span>

<span>apr_iconv</span><span>(</span><span>)</span><span>{</span>
<span>if</span> <span>[</span> -f <span>$PACKAGES</span>/<span>$APR_ICONV</span> <span>]</span><span>;</span><span>then</span>
	<span>tar</span> -xf <span>$PACKAGES</span>/<span>$APR_ICONV</span> -C <span>$SOU_PATH</span>
	<span>CUR_PACKAGE</span><span>=</span><span><span>`</span><span>echo</span> $APR_ICONV <span>|</span> <span>awk</span> -F <span>".tar"</span> <span>'{print $1}'</span><span>`</span></span>
	<span>if</span> <span>[</span> -d <span>$SOU_PATH</span>/<span>$CUR_PACKAGE</span> <span>]</span><span>;</span>thne
		<span>cd</span> <span>$SOU_PATH</span>/SUR_PACKAGE
		./configure --prefix<span>=</span><span>$INS_PATH</span>/apr-iconv --with-apr<span>=</span><span>$INS_PATH</span>/apr/ <span><span>1</span>></span>/dev/null
		<span>if</span> <span>[</span> <span>$?</span> -eq <span>0</span> <span>]</span><span>;</span><span>then</span>
			<span>make</span> <span><span>1</span>></span>/dev/null
			<span>if</span> <span>[</span> <span>$?</span> -eq <span>0</span> <span>]</span><span>;</span><span>then</span>
				<span>make</span> <span>install</span> <span><span>1</span>></span>/dev/null
				<span>if</span> <span>[</span> <span>$?</span> -ne <span>0</span> <span>]</span><span>;</span><span>then</span>
					<span>echo</span> <span>"APR-ICONV: make install ERROR , EXIT......"</span><span>;</span><span>exit</span> <span>1</span>
				<span>else</span>
					<span>cd</span> -<span>;</span><span>rm</span> -rf <span>$SOU_PATH</span>/CUR_PACKAGE
				<span>fi</span>
			<span>else</span>
				<span>echo</span> <span>"APR-ICONV: make ERROR , EXIT......"</span><span>;</span><span>exit</span> <span>1</span>
			<span>fi</span>
		<span>else</span>
			<span>echo</span> <span>"APR-ICONV: configure ERROR , ECXIT......"</span><span>;</span><span>exit</span> <span>1</span>
		<span>fi</span>
	<span>else</span>
		<span>echo</span> <span>"APR-ICONV: tar command ERROR , EXIT......"</span><span>;</span><span>exit</span> <span>1</span>
	<span>fi</span>
<span>else</span>
	<span>echo</span> <span>"APR-ICONV: not found <span>$APR_ICONV</span> , EXIT"</span><span>;</span><span>exit</span> <span>1</span>
<span>fi</span>
<span>}</span>

<span>apache</span><span>(</span><span>)</span><span>{</span>
apr<span>;</span>apr_util<span>;</span>apr_iconv
<span>[</span> <span>$?</span> -ne <span>0</span> <span>]</span> <span>&amp;&amp;</span> <span>echo</span> <span>"ERROR: please check apr install"</span> <span>&amp;&amp;</span> <span>exit</span> <span>1</span>
<span>if</span> <span>[</span> -f <span>$PACKAGES</span>/<span>$APACHE</span> <span>]</span><span>;</span><span>then</span>
	<span>tar</span> -xf <span>$PACKAGES</span>/<span>$APACHE</span> -C <span>$SOU_PATH</span>
	<span>CUR_PACKAGE</span><span>=</span><span><span>`</span><span>echo</span> $APACHE <span>|</span> <span>awk</span> -F <span>".tar"</span> <span>'{print $1}'</span><span>`</span></span>
	<span>if</span> <span>[</span> -d <span>$SOU_PATH</span>/<span>$CUR_PACKAGE</span> <span>]</span><span>;</span>thne
		<span>cd</span> <span>$SOU_PATH</span>/SUR_PACKAGE
		./configure --prefix<span>=</span><span>$INS_PATH</span>/apache --with-apr<span>=</span><span>$INS_PATH</span>/apr --with-apr-util<span>=</span>INS_PATH/apr-util --enable-module<span>=</span>so --enable-deflate<span>=</span>shared --enable-expires<span>=</span>shared --enable-rewite<span>=</span>shared --enable-cache<span>=</span>shared --enable-file-cache --enable-mem-cache --enable-disk-cache --enable-static-support --enable-static-ab --disable-userdir --with-mpm<span>=</span>prefork --enable-nonportable-atomics --disable-ipv6 --with-sendfile <span><span>1</span>></span>/dev/null
		<span>if</span> <span>[</span> <span>$?</span> -eq <span>0</span> <span>]</span><span>;</span><span>then</span>
			<span>make</span> <span><span>1</span>></span>/dev/null
			<span>if</span> <span>[</span> <span>$?</span> -eq <span>0</span> <span>]</span><span>;</span><span>then</span>
				<span>make</span> <span>install</span> <span><span>1</span>></span>/dev/null
				<span>if</span> <span>[</span> <span>$?</span> -ne <span>0</span> <span>]</span><span>;</span><span>then</span>
					<span>echo</span> <span>"APACHE: make install ERROR , EXIT......"</span><span>;</span><span>exit</span> <span>1</span>
				<span>else</span>
					<span>cd</span> -<span>;</span><span>rm</span> -rf <span>$SOU_PATH</span>/CUR_PACKAGE
				<span>fi</span>
			<span>else</span>
				<span>echo</span> <span>"APACHE: make ERROR , EXIT......"</span><span>;</span><span>exit</span> <span>1</span>
			<span>fi</span>
		<span>else</span>
			<span>echo</span> <span>"APACHE: configure ERROR , ECXIT......"</span><span>;</span><span>exit</span> <span>1</span>
		<span>fi</span>
	<span>else</span>
		<span>echo</span> <span>"APACHE: tar command ERROR , EXIT......"</span><span>;</span><span>exit</span> <span>1</span>
	<span>fi</span>
<span>else</span>
	<span>echo</span> <span>"APACHE: not found <span>$APR_ICONV</span> , EXIT"</span><span>;</span><span>exit</span> <span>1</span>
<span>fi</span>
<span>}</span>

<span>#安装mysql--------------------------------------------------------------------------------------------------</span>
<span>#mysql配置</span>
<span>mysql_install_post_set</span><span>(</span><span>)</span><span>{</span>
<span>useradd</span> -s /sbin/nologin -r mysql
<span>mkdir</span> -pv /usr/local/mysql/data
<span>cp</span> support-files/my-innodb-heavy-4G.cnf /etc/my.cnf
<span>cp</span> support-files/mysql.server /etc/init.d/mysql
<span>chmod</span> <span>755</span> etc/init.d/mysql
<span>chown</span> mysql:mysql /use/local/mysql/ -R
<span>ln</span> -s /usr/local/mysql/bin/* /usr/bin/
<span>ln</span> -s /usr/local/mysql/lib/* /usr/lib/
<span>ln</span> -s /usr/local/mysql/libexec/* /usr/local/libexec
<span>ln</span> -s /usr/local/mysql/share/man/man1/* /usr/share/man/man1
<span>ln</span> -s /usr/local/mysql/share/man/man8/* /usr/share/man/man8
<span>sh</span> scripts/mysql_install_db --user<span>=</span>mysql --basedir<span>=</span>/usr/local/mysql/ --datadir<span>=</span>/usr/local/mysql/data/ <span><span>1</span>></span>/dev/null
<span>}</span>
<span>mysql</span><span>(</span><span>)</span><span>{</span>
<span>if</span> <span>[</span> -f <span>$PACKSGES</span>/<span>$MYSQL</span> <span>]</span><span>;</span><span>then</span>
	<span>tar</span> -xf <span>$PACKAGES</span>/<span>$MYSQL</span> -C <span>$SOU_PATH</span>
	<span>CUR_PACKAGE</span><span>=</span><span><span>`</span><span>echo</span> $APACHE <span>|</span> <span>awk</span> -F <span>".tar"</span> <span>'{print $1}'</span><span>`</span></span>
	<span>if</span> <span>[</span> -d <span>$SOU_PATH</span>/<span>$CUR_PACKAGE</span> <span>]</span><span>;</span><span>then</span>
		<span>cd</span> <span>$SOU_PATH</span>/SUR_PACKAGE
		cmake <span>.</span> -DCMAKE_INSTALL_PREFIX<span>=</span>/usr/local/mysql -DMYSQL_DATADIR<span>=</span>/usr/local/mysql/data/ -DMYSQL_UNIX_ADDR<span>=</span>/usr/local/mysql.sock -DWITH_INNODBBASE_STOTRAGE_ENGINE<span>=</span><span>1</span> -DENABLE_LOCAL_INFILE<span>=</span><span>1</span> -DEXTRA_CHARSETS<span>=</span>all -DDEFAULT_CHARSET<span>=</span>utf8 -DDEFAULT_COLLATION<span>=</span>utf8_general_ci -DMYSQL_USER<span>=</span>mysql -DWITH_DEBUG<span>=</span><span>0</span> -DWITH_EMBEDED_SERVER<span>=</span><span>0</span> <span><span>1</span>></span>/dev/null
		<span>if</span> <span>[</span> <span>$?</span> -eq <span>0</span> <span>]</span><span>;</span><span>then</span>
			<span>make</span> <span><span>1</span>></span>/dev/null
			<span>if</span> <span>[</span> <span>$?</span> -eq <span>0</span> <span>]</span><span>;</span><span>then</span>
				<span>make</span> <span>install</span> <span><span>1</span>></span>/dev/null
				<span>if</span> <span>[</span> <span>$?</span> -ne <span>0</span> <span>]</span><span>;</span><span>then</span>
					<span>echo</span> <span>"MYSQL: make install ERROR , EXIT......"</span><span>;</span><span>exit</span> <span>1</span>
				<span>else</span>
					mysql_install_port_set
					<span>cd</span> -<span>;</span><span>rm</span> -rf <span>$SOU_PATH</span>/CUR_PACKAGE
				<span>fi</span>
			<span>else</span>
				<span>echo</span> <span>"MYSQL: make ERROR , EXIT......"</span><span>;</span><span>exit</span> <span>1</span>
			<span>fi</span>
		<span>else</span>
			<span>echo</span> <span>"MYSQL: configure ERROR , ECXIT......"</span><span>;</span><span>exit</span> <span>1</span>
		<span>fi</span>
	<span>else</span>
		<span>echo</span> <span>"MYSQL: tar command ERROR , EXIT......"</span><span>;</span><span>exit</span> <span>1</span>
	<span>fi</span>
		<span>else</span>
	<span>echo</span> <span>"MYSQL: not found <span>$MYSQL</span> , EXIT"</span><span>;</span><span>exit</span> <span>1</span>
<span>fi</span>
<span>}</span>

<span>#安装php---------------------------------------------------------------------------------------------------------</span>
<span>libiconv</span><span>(</span><span>)</span><span>{</span>
<span>if</span> <span>[</span> -f <span>$PACKAGES</span>/<span>$LIBICONV</span> <span>]</span><span>;</span><span>then</span>
	<span>tar</span> -xf <span>$PACKAGES</span>/<span>$LIBICONV</span> -C <span>$SOU_PATH</span>
	<span>CUR_PACKAGE</span><span>=</span><span><span>`</span><span>echo</span> $LIBICONV <span>|</span> <span>awk</span> -F <span>".tar"</span> <span>'{print $1}'</span><span>`</span></span>
	<span>if</span> <span>[</span> -d <span>$SOU_PATH</span>/<span>$CUR_PACKAGE</span> <span>]</span><span>;</span>thne
		<span>cd</span> <span>$SOU_PATH</span>/SUR_PACKAGE
		./configure --prefix<span>=</span>/usr/local --with-apr<span>=</span><span>$INS_PATH</span>/apr <span><span>1</span>></span>/dev/null
		<span>if</span> <span>[</span> <span>$?</span> -eq <span>0</span> <span>]</span><span>;</span><span>then</span>
			<span>make</span> <span><span>1</span>></span>/dev/null
			<span>if</span> <span>[</span> <span>$?</span> -eq <span>0</span> <span>]</span><span>;</span><span>then</span>
				<span>make</span> <span>install</span> <span><span>1</span>></span>/dev/null
				<span>if</span> <span>[</span> <span>$?</span> -ne <span>0</span> <span>]</span><span>;</span><span>then</span>
					<span>echo</span> <span>"LIBICONV: make install ERROR , EXIT......"</span><span>;</span><span>exit</span> <span>1</span>
				<span>else</span>
					<span>cd</span> -<span>;</span><span>rm</span> -rf <span>$SOU_PATH</span>/CUR_PACKAGE
				<span>fi</span>
			<span>else</span>
				<span>echo</span> <span>"LIBICONV: make ERROR , EXIT......"</span><span>;</span><span>exit</span> <span>1</span>
			<span>fi</span>
		<span>else</span>
			<span>echo</span> <span>"LIBICONV: configure ERROR , ECXIT......"</span><span>;</span><span>exit</span> <span>1</span>
		<span>fi</span>
	<span>else</span>
		<span>echo</span> <span>"LIBICONV: tar command ERROR , EXIT......"</span><span>;</span><span>exit</span> <span>1</span>
	<span>fi</span>
<span>else</span>
	<span>echo</span> <span>"LIBICONV: not found <span>$LIBICONV</span> , EXIT"</span><span>;</span><span>exit</span> <span>1</span>
<span>fi</span>
<span>}</span>

<span>libmcrypt</span><span>(</span><span>)</span><span>{</span>
<span>if</span> <span>[</span> -f <span>$PACKAGES</span>/<span>$LIBMCRYPYT</span> <span>]</span><span>;</span><span>then</span>
	<span>tar</span> -xf <span>$PACKAGES</span>/<span>$LIBMCRYPYT</span> -C <span>$SOU_PATH</span>
	<span>CUR_PACKAGE</span><span>=</span><span><span>`</span><span>echo</span> $LIBMCRYPYT <span>|</span> <span>awk</span> -F <span>".tar"</span> <span>'{print $1}'</span><span>`</span></span>
	<span>if</span> <span>[</span> -d <span>$SOU_PATH</span>/<span>$CUR_PACKAGE</span> <span>]</span><span>;</span>thne
		<span>cd</span> <span>$SOU_PATH</span>/SUR_PACKAGE
		./configure --prefix<span>=</span><span>$INS_PATH</span>/libmcrypt <span><span>1</span>></span>/dev/null
		<span>if</span> <span>[</span> <span>$?</span> -eq <span>0</span> <span>]</span><span>;</span><span>then</span>
			<span>make</span> <span><span>1</span>></span>/dev/null
			<span>if</span> <span>[</span> <span>$?</span> -eq <span>0</span> <span>]</span><span>;</span><span>then</span>
				<span>make</span> <span>install</span> <span><span>1</span>></span>/dev/null
				<span>if</span> <span>[</span> <span>$?</span> -ne <span>0</span> <span>]</span><span>;</span><span>then</span>
					<span>echo</span> <span>"LIBMCRYPYT: make install ERROR , EXIT......"</span><span>;</span><span>exit</span> <span>1</span>
				<span>else</span>
					/sbin/ldconfig
					<span>cd</span> libltdl/
					./configure --enable-ltdl-install <span><span>1</span>></span>/dev/null
					<span>make</span> <span><span>1</span>></span>/dev/null
					<span>make</span> <span>install</span> <span><span>1</span>></span>/dev/null
					<span>if</span> <span>[</span> <span>$?</span> -eq <span>0</span> <span>]</span><span>;</span><span>then</span>
						<span>echo</span> <span>"export LD_LIBRARY_PATH=<span>$INS_PATH</span>/libmcrypt/lib:LD_LIBRARY_PATH"</span> <span>>></span> /etc/profile
						<span>source</span> /etc/profile
						<span>cd</span> <span>$CURRENT</span><span>;</span><span>rm</span> -rf <span>$SOU_PATH</span>/CUR_PACKAGE
					<span>else</span>
						<span>echo</span> <span>"LIBMCRYPT(libltdl): ERROR , EXIT......"</span><span>;</span><span>exit</span> <span>1</span>
					<span>fi</span>
				<span>fi</span>
			<span>else</span>
				<span>echo</span> <span>"LIBMCRYPT: make ERROR , EXIT......"</span><span>;</span><span>exit</span> <span>1</span>
			<span>fi</span>
		<span>else</span>
			<span>echo</span> <span>"LIBMCRYPT: configure ERROR , ECXIT......"</span><span>;</span><span>exit</span> <span>1</span>
		<span>fi</span>
	<span>else</span>
		<span>echo</span> <span>"LIBMCRYPT: tar command ERROR , EXIT......"</span><span>;</span><span>exit</span> <span>1</span>
	<span>fi</span>
<span>else</span>
	<span>echo</span> <span>"LIBMCRYPT: not found <span>$LIBMCRYPT</span> , EXIT"</span><span>;</span><span>exit</span> <span>1</span>
<span>fi</span>
<span>}</span>

<span>mhash</span><span>(</span><span>)</span><span>{</span>
<span>if</span> <span>[</span> -f <span>$PACKAGES</span>/<span>$MHASH</span> <span>]</span><span>;</span><span>then</span>
	<span>tar</span> -xf <span>$PACKAGES</span>/<span>$MHASH</span> -C <span>$SOU_PATH</span>
	<span>CUR_PACKAGE</span><span>=</span><span><span>`</span><span>echo</span> $MHASH <span>|</span> <span>awk</span> -F <span>".tar"</span> <span>'{print $1}'</span><span>`</span></span>
	<span>if</span> <span>[</span> -d <span>$SOU_PATH</span>/<span>$CUR_PACKAGE</span> <span>]</span><span>;</span>thne
		<span>cd</span> <span>$SOU_PATH</span>/SUR_PACKAGE
		./configure <span><span>1</span>></span>/dev/null
		<span>if</span> <span>[</span> <span>$?</span> -eq <span>0</span> <span>]</span><span>;</span><span>then</span>
			<span>make</span> <span><span>1</span>></span>/dev/null
			<span>if</span> <span>[</span> <span>$?</span> -eq <span>0</span> <span>]</span><span>;</span><span>then</span>
				<span>make</span> <span>install</span> <span><span>1</span>></span>/dev/null
				<span>if</span> <span>[</span> <span>$?</span> -ne <span>0</span> <span>]</span><span>;</span><span>then</span>
					<span>echo</span> <span>"MHASH: make install ERROR , EXIT......"</span><span>;</span><span>exit</span> <span>1</span>
				<span>else</span>
					<span>ln</span> -s /usr/local/lib* /usr/lib/
					<span>ln</span> -s /usr/local/bin/libmcrypt-config /usr/bin/
					<span>cd</span> -<span>;</span><span>rm</span> -rf <span>$SOU_PATH</span>/CUR_PACKAGE
				<span>fi</span>
			<span>else</span>
				<span>echo</span> <span>"MHASH: make ERROR , EXIT......"</span><span>;</span><span>exit</span> <span>1</span>
			<span>fi</span>
		<span>else</span>
			<span>echo</span> <span>"MHASH: configure ERROR , ECXIT......"</span><span>;</span><span>exit</span> <span>1</span>
		<span>fi</span>
	<span>else</span>
		<span>echo</span> <span>"MHASH: tar command ERROR , EXIT......"</span><span>;</span><span>exit</span> <span>1</span>
	<span>fi</span>
<span>else</span>
	<span>echo</span> <span>"MHASH: not found <span>$MHASH</span> , EXIT"</span><span>;</span><span>exit</span> <span>1</span>
<span>fi</span>
<span>}</span>

<span>mcrypt</span><span>(</span><span>)</span><span>{</span>
<span>if</span> <span>[</span> -f <span>$PACKAGES</span>/<span>$MCRYPT</span> <span>]</span><span>;</span><span>then</span>
	<span>tar</span> -xf <span>$PACKAGES</span>/<span>$MCRYPT</span> -C <span>$SOU_PATH</span>
	<span>CUR_PACKAGE</span><span>=</span><span><span>`</span><span>echo</span> $MCRYPT <span>|</span> <span>awk</span> -F <span>".tar"</span> <span>'{print $1}'</span><span>`</span></span>
	<span>if</span> <span>[</span> -d <span>$SOU_PATH</span>/<span>$CUR_PACKAGE</span> <span>]</span><span>;</span>thne
		<span>cd</span> <span>$SOU_PATH</span>/SUR_PACKAGE
		./configure --with-libmcrypt-prefix<span>=</span><span>$INS_PATH</span>.libmcrypt <span><span>1</span>></span>/dev/null
		<span>if</span> <span>[</span> <span>$?</span> -eq <span>0</span> <span>]</span><span>;</span><span>then</span>
			<span>make</span> <span><span>1</span>></span>/dev/null
			<span>if</span> <span>[</span> <span>$?</span> -eq <span>0</span> <span>]</span><span>;</span><span>then</span>
				<span>make</span> <span>install</span> <span><span>1</span>></span>/dev/null
				<span>if</span> <span>[</span> <span>$?</span> -ne <span>0</span> <span>]</span><span>;</span><span>then</span>
					<span>echo</span> <span>"MCRYPT: make install ERROR , EXIT......"</span><span>;</span><span>exit</span> <span>1</span>
				<span>else</span>
					<span>cd</span> -<span>;</span><span>rm</span> -rf <span>$SOU_PATH</span>/CUR_PACKAGE
				<span>fi</span>
			<span>else</span>
				<span>echo</span> <span>"MCRYPT: make ERROR , EXIT......"</span><span>;</span><span>exit</span> <span>1</span>
			<span>fi</span>
		<span>else</span>
			<span>echo</span> <span>"MCRYPT: configure ERROR , ECXIT......"</span><span>;</span><span>exit</span> <span>1</span>
		<span>fi</span>
	<span>else</span>
		<span>echo</span> <span>"MCRYPT: tar command ERROR , EXIT......"</span><span>;</span><span>exit</span> <span>1</span>
	<span>fi</span>
<span>else</span>
	<span>echo</span> <span>"MCRYPT: not found <span>$MCRYPT</span> , EXIT"</span><span>;</span><span>exit</span> <span>1</span>
<span>fi</span>
<span>}</span>

<span>php</span><span>(</span><span>)</span><span>{</span>
libiconv<span>;</span>libmcrypt<span>;</span>mhash<span>;</span>mcrypt
<span>[</span> <span>$?</span> -ne <span>0</span> <span>]</span> <span>&amp;&amp;</span> <span>echo</span> <span>"check libiconv and encrypt install"</span> <span>&amp;&amp;</span> <span>exit</span> <span>1</span>
<span>if</span> <span>[</span> -f <span>$PACKAGES</span>/<span>$PHP</span> <span>]</span><span>;</span><span>then</span>
	<span>tar</span> -xf <span>$PACKAGES</span>/<span>$PHP</span> -C <span>$SOU_PATH</span>
	<span>CUR_PACKAGE</span><span>=</span><span><span>`</span><span>echo</span> $PHP <span>|</span> <span>awk</span> -F <span>".tar"</span> <span>'{print $1}'</span><span>`</span></span>
	<span>if</span> <span>[</span> -d <span>$SOU_PATH</span>/<span>$CUR_PACKAGE</span> <span>]</span><span>;</span>thne
		<span>cd</span> <span>$SOU_PATH</span>/SUR_PACKAGE
		./configure --prefix<span>=</span><span>$INS_PATH</span>/php --with-config-file-path<span>=</span><span>$INS_PATH</span>/php/etc --with-mysql<span>=</span><span>$INS_PATH</span>/mysql/ --with-mysql<span>=</span><span>$INS_PATH</span>/mysql/bin/mysql_config --with-pdo-mysql<span>=</span><span>$INS_PATH</span>/mysql --with-iconv-dir<span>=</span>/usr/local/ --enable-fpm --with-fpm-user<span>=</span>apache --with-fpm-group<span>=</span>apache --with-pcre-regex --with-zlib --with-bz2 --enable-calendar --disable-phar --with-curl --enable-dba --with-libxml-dir --enable-ftp --with-gd --with-jpeg-dir --with-png-dir --with-zlib-dir --with-freetype-dir --enable-gd-native-ttf --enable-gd-jis-conv --with-mhash --enable-mbstring --with-mcrypt<span>=</span><span>$INS_PATH</span>/libmcrypt --enable-opcache<span>=</span>no --enable-pcntl --enable-xml --disable-rpath --enable-shmop --enable-sockets --enable-zip --enable-bcmath --with-snmp --disable-ipv6 --disable-rpath --disable-debug --with-apxs2<span>=</span><span>$INS_PATH</span>/apache/bin/apxs <span><span>1</span>></span>/dev/null
		<span>if</span> <span>[</span> <span>$?</span> -eq <span>0</span> <span>]</span><span>;</span><span>then</span>
			<span>make</span> <span>ZEND_EXTRA_LIBS</span><span>=</span><span>'-liconv'</span> <span><span>1</span>></span>/dev/null
			<span>if</span> <span>[</span> <span>$?</span> -eq <span>0</span> <span>]</span><span>;</span><span>then</span>
				<span>make</span> <span>install</span> <span><span>1</span>></span>/dev/null
				<span>if</span> <span>[</span> <span>$?</span> -ne <span>0</span> <span>]</span><span>;</span><span>then</span>
					<span>echo</span> <span>"PHP: make install ERROR , EXIT......"</span><span>;</span><span>exit</span> <span>1</span>
				<span>else</span>
					<span>sed</span> -i.bak <span>'/libphp5.so/a\AddType application/x-httpd-php .php'</span> 						<span>$INS_PATH</span>/apache/conf/httpd.con
					<span>cp</span> php.ini-production <span>$INS_PATH</span>/php/etc/php.ini
					<span>cd</span> -<span>;</span><span>rm</span> -rf <span>$SOU_PATH</span>/CUR_PACKAGE
				<span>fi</span>
			<span>else</span>
				<span>echo</span> <span>"PHP: make ERROR , EXIT......"</span><span>;</span><span>exit</span> <span>1</span>
			<span>fi</span>
		<span>else</span>
			<span>echo</span> <span>"PHP: configure ERROR , ECXIT......"</span><span>;</span><span>exit</span> <span>1</span>
		<span>fi</span>
	<span>else</span>
		<span>echo</span> <span>"PHP: tar command ERROR , EXIT......"</span><span>;</span><span>exit</span> <span>1</span>
	<span>fi</span>
<span>else</span>
	<span>echo</span> <span>"PHP: not found <span>$PHP</span> , EXIT"</span><span>;</span><span>exit</span> <span>1</span>
<span>fi</span>
<span>}</span>

<span>#调用函数===========================================================</span>
<span>case</span> <span>$1</span> <span>in</span>
apache<span>)</span> apache<span>;</span><span>;</span>
mysql<span>)</span> mysql<span>;</span><span>;</span>
lamp<span>)</span> check<span>;</span>apache<span>;</span>mysql<span>;</span>php<span>;</span><span>;</span>
*<span>)</span> <span>echo</span> <span>"<span>$0</span>: apache|mysql|lamp"</span><span>;</span><span>;</span>
<span>esac</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br><span>196</span><br><span>197</span><br><span>198</span><br><span>199</span><br><span>200</span><br><span>201</span><br><span>202</span><br><span>203</span><br><span>204</span><br><span>205</span><br><span>206</span><br><span>207</span><br><span>208</span><br><span>209</span><br><span>210</span><br><span>211</span><br><span>212</span><br><span>213</span><br><span>214</span><br><span>215</span><br><span>216</span><br><span>217</span><br><span>218</span><br><span>219</span><br><span>220</span><br><span>221</span><br><span>222</span><br><span>223</span><br><span>224</span><br><span>225</span><br><span>226</span><br><span>227</span><br><span>228</span><br><span>229</span><br><span>230</span><br><span>231</span><br><span>232</span><br><span>233</span><br><span>234</span><br><span>235</span><br><span>236</span><br><span>237</span><br><span>238</span><br><span>239</span><br><span>240</span><br><span>241</span><br><span>242</span><br><span>243</span><br><span>244</span><br><span>245</span><br><span>246</span><br><span>247</span><br><span>248</span><br><span>249</span><br><span>250</span><br><span>251</span><br><span>252</span><br><span>253</span><br><span>254</span><br><span>255</span><br><span>256</span><br><span>257</span><br><span>258</span><br><span>259</span><br><span>260</span><br><span>261</span><br><span>262</span><br><span>263</span><br><span>264</span><br><span>265</span><br><span>266</span><br><span>267</span><br><span>268</span><br><span>269</span><br><span>270</span><br><span>271</span><br><span>272</span><br><span>273</span><br><span>274</span><br><span>275</span><br><span>276</span><br><span>277</span><br><span>278</span><br><span>279</span><br><span>280</span><br><span>281</span><br><span>282</span><br><span>283</span><br><span>284</span><br><span>285</span><br><span>286</span><br><span>287</span><br><span>288</span><br><span>289</span><br><span>290</span><br><span>291</span><br><span>292</span><br><span>293</span><br><span>294</span><br><span>295</span><br><span>296</span><br><span>297</span><br><span>298</span><br><span>299</span><br><span>300</span><br><span>301</span><br><span>302</span><br><span>303</span><br><span>304</span><br><span>305</span><br><span>306</span><br><span>307</span><br><span>308</span><br><span>309</span><br><span>310</span><br><span>311</span><br><span>312</span><br><span>313</span><br><span>314</span><br><span>315</span><br><span>316</span><br><span>317</span><br><span>318</span><br><span>319</span><br><span>320</span><br><span>321</span><br><span>322</span><br><span>323</span><br><span>324</span><br><span>325</span><br><span>326</span><br><span>327</span><br><span>328</span><br><span>329</span><br><span>330</span><br><span>331</span><br><span>332</span><br><span>333</span><br><span>334</span><br><span>335</span><br><span>336</span><br><span>337</span><br><span>338</span><br><span>339</span><br><span>340</span><br><span>341</span><br><span>342</span><br><span>343</span><br><span>344</span><br><span>345</span><br><span>346</span><br><span>347</span><br><span>348</span><br><span>349</span><br><span>350</span><br><span>351</span><br><span>352</span><br><span>353</span><br><span>354</span><br><span>355</span><br><span>356</span><br><span>357</span><br><span>358</span><br><span>359</span><br><span>360</span><br><span>361</span><br><span>362</span><br><span>363</span><br><span>364</span><br><span>365</span><br><span>366</span><br><span>367</span><br><span>368</span><br><span>369</span><br><span>370</span><br><span>371</span><br><span>372</span><br><span>373</span><br><span>374</span><br></div></div>]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-04-09T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Shell脚本笔记</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="shell-脚本"> Shell 脚本</h2>
<p>日常运维工作大部分是一些繁琐的重复的工作，每天 80% 的工作就是重复昨天的事情，而且工作量还比较大，那么摆在运维面前的选择就是：</p>
<ul>
<li>
<p>自己搞定一切</p>
</li>
<li>
<p>让机器搞定一切</p>
</li>
</ul>
<p>当然，谁不愿意喝着茶水，逗着前台妹子过完愉快的一天呢！如何让机器搞定一切，得以解放自己，就是我们要学习的内容。Shell 脚本是入门最快、最高效的一个脚本语言。
学习 shell 可以分为以下几个阶段，大家逐步提升就好。</p>
<ol>
<li>能看懂 shell 脚本</li>
<li>能修改 shell 脚本</li>
<li>能自己写 shell 脚本</li>
<li>能够优化 shell 脚本</li>
</ol>
<p>好了，经过这几个阶段，你就是 shell 大神了。</p>
<h2 id="学习大纲"> 学习大纲</h2>
<p><img src="./assets/shell_gudie.png" alt="guide" loading="lazy"></p>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-04-09T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">Shell格式化输出</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/03.Shell_format_out/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Shell/03.Shell_format_out/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>一个程序需要有 0 个或以上输入，1 个或以上输出。</p>
<h2 id="echo-命令介绍"> echo 命令介绍</h2>
<p><strong>功能：将内容输出到默认显示设备。</strong></p>
<p><code>echo</code> 命令的功能是在显示器上显示一段文件，一般起到一个提示的作用。</p>
<p>命令格式如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># echo [选项] [字符串]</span>
选项：
	-n：不要在最后换行
	-e：若字符串中出 现以下转义字符，则特别加以处理，而不会将它当成一般字符串输出。
	
转义字符：
	<span>\</span>a	：发出警告声；
	<span>\</span>b	：删除前一个字符；
	<span>\</span>c	：最后不加上换行；
	<span>\</span>f	：换行但光标仍旧停留在原来的位置；
	<span>\</span>n	：换行且光标移至行首；
	<span>\</span>t	：插入制表符tab；
	<span>\</span>v	：与 <span>\</span>f 相同；
	<span>\</span><span>\</span>	：插入 <span>\</span>字符；
	<span>\</span>nnn：插入 nnn（八进制）所代表的ASCII字符；
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>补充说明：echo会将输入的字符串送往标准输出。输出的字符串以空白字符隔开，并在最后加上换行号。</p>
<p><strong>举例说明：输出一个菜单</strong></p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># cat fruits_shop.sh</span>
<span>#!/bin/bash</span>
<span>#Author: Admin</span>
<span>#created Time: 2021/02/03 16:25</span>
<span>#Script Description: shpo view script</span>

ehco -e <span>"<span title="\t">\t</span><span title="\t">\t</span><span title="\t">\t</span>Fruits Shop"</span>
<span>echo</span> -e <span>"<span title="\t">\t</span>1) Apple"</span>
<span>echo</span> -e <span>"<span title="\t">\t</span>2) Orange"</span>
<span>echo</span> -e <span>"<span title="\t">\t</span>3) Banana<span title="\n">\n</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>执行脚本输出如下：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># bash fruits_shop.sh</span>
	Fruits Shop
	<span>1</span><span>)</span> Apple
	<span>2</span><span>)</span> Orange
	<span>3</span><span>)</span> Banana
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="颜色代码"> 颜色代码</h2>
<p>脚本中 <code>echo</code> 显示内容带颜色，<code>echo</code> 显示背景带颜色，需要使用参数 -e</p>
<p><strong>格式如下：</strong></p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># echo -e "\033[字背景颜色;字体颜色m字符串\033[特效m"</span>
</code></pre>
<div><span>1</span><br></div></div><p>例如：</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># echo -e "\033[41;34msomething here\033[0m"</span>

说明：其中41的位置代表背景色，34的位置是代表字体颜色，0的位置代表效果

a. 背景颜色和字体颜色之间是英文的分号<span>";"</span>
b. 字体颜色后面有个m
c. 字符串前后没有空格，如果有的话，输出也是同样有空格
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>下面是相应的字体和背景颜色，可以自己来尝试搭配</p>
<ul>
<li>字体颜色：30-37</li>
</ul>
<div><pre><code><span>echo</span> -e <span>"<span title="\033">\033</span>[30m黑色字体<span title="\033">\033</span>[0m"</span>
<span>echo</span> -e <span>"<span title="\033">\033</span>[31m红色字体<span title="\033">\033</span>[0m"</span>
<span>echo</span> -e <span>"<span title="\033">\033</span>[32m绿色字体<span title="\033">\033</span>[0m"</span>
<span>echo</span> -e <span>"<span title="\033">\033</span>[33m黄色字体<span title="\033">\033</span>[0m"</span>
<span>echo</span> -e <span>"<span title="\033">\033</span>[34m蓝色字体<span title="\033">\033</span>[0m"</span>
<span>echo</span> -e <span>"<span title="\033">\033</span>[35m紫色字体<span title="\033">\033</span>[0m"</span>
<span>echo</span> -e <span>"<span title="\033">\033</span>[36m天蓝色字体<span title="\033">\033</span>[0m"</span>
<span>echo</span> -e <span>"<span title="\033">\033</span>[37m白色字体<span title="\033">\033</span>[0m"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ul>
<li>字体背景颜色：40-47</li>
</ul>
<div><pre><code><span>echo</span> -e <span>"<span title="\033">\033</span>[40;37m黑底白字<span title="\033">\033</span>[0m"</span>
<span>echo</span> -e <span>"<span title="\033">\033</span>[41;37m红底白字<span title="\033">\033</span>[0m"</span>
<span>echo</span> -e <span>"<span title="\033">\033</span>[42;37m绿底白字<span title="\033">\033</span>[0m"</span>
<span>echo</span> -e <span>"<span title="\033">\033</span>[43;37m黄底白字<span title="\033">\033</span>[0m"</span>
<span>echo</span> -e <span>"<span title="\033">\033</span>[44;37m蓝底白字<span title="\033">\033</span>[0m"</span>
<span>echo</span> -e <span>"<span title="\033">\033</span>[45;37m紫底白字<span title="\033">\033</span>[0m"</span>
<span>echo</span> -e <span>"<span title="\033">\033</span>[46;37m天蓝底白字<span title="\033">\033</span>[0m"</span>
<span>echo</span> -e <span>"<span title="\033">\033</span>[47;30m白底黑字<span title="\033">\033</span>[0m"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ul>
<li>输出效果格式控制：</li>
</ul>
<div><pre><code><span>\</span>033<span>[</span>0m					关闭所有效果属性
<span>\</span>033<span>[</span>1m					设置高亮度
<span>\</span>033<span>[</span>4m					下划线
<span>\</span>033<span>[</span>5m					闪烁
<span>\</span>033<span>[</span>7m					反显
<span>\</span>033<span>[</span>8m					消隐
<span>\</span>033<span>[</span>30m -- <span>\</span>033<span>[</span>37m	设置前景色
<span>\</span>033<span>[</span>40m -- <span>\</span>033<span>[</span>37m	设置背景色
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ul>
<li>光标位置相关格式控制：</li>
</ul>
<div><pre><code><span>\</span>033<span>[</span>nA					光标上移n行
<span>\</span>033<span>[</span>nB					光标下移n行
<span>\</span>033<span>[</span>nC					光标右移n行
<span>\</span>033<span>[</span>nD					光标左移n行
<span>\</span>033<span>[</span>y<span>;</span>xH				设置光标位置
<span>\</span>033<span>[</span>2J					清屏
<span>\</span>033<span>[</span>K					清除从光标到行尾的内容
<span>\</span>033<span>[</span>s					保存光标位置
<span>\</span>033<span>[</span>u					恢复光标位置
<span>\</span>033<span>[</span>?25l				隐藏光标
<span>\</span>033<span>[</span>?25h				显示光标
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-04-09T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">博客主页</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2022-01-26T06:11:29.000Z</published>
    <rights>Copyright © 2021 karin</rights>
  </entry>
  <entry>
    <title type="html">VBA 之 控件与用户窗体1</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Excel/10.VBA_controls_form_1/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Excel/10.VBA_controls_form_1/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="_98、限制文本框的输入"> 98、限制文本框的输入</h2>
<p>用户在使用文本框输入数据时，往往希望能限制输入数据的类型，比如只能输入数字。但是没有内置的属性能限制在文本框中只能输入数字，只能在文本框的事件过程中使用代码来测试输入的是哪类字符，然后只允许输入数字字符和一个“-”号、一个“.”号，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> TextBox1_KeyPress<span>(</span><span>ByVal</span> KeyANSI <span>As</span> MSForms<span>.</span>ReturnInteger<span>)</span>
	<span>Select</span> <span>Case</span> KeyANSI
		<span>Case</span> Asc<span>(</span><span>"0"</span><span>)</span> <span>To</span> Asc<span>(</span><span>"9"</span><span>)</span>
		<span>Case</span> Asc<span>(</span><span>"-"</span><span>)</span>
			<span>If</span> InStr<span>(</span><span>1</span><span>,</span> <span>Me</span><span>.</span>TextBox1<span>.</span>Text<span>,</span> <span>"-"</span><span>)</span> <span>></span> <span>0</span> <span>Or</span> <span>_</span>
				<span>Me</span><span>.</span>TextBox1<span>.</span>SelStart <span>></span> <span>0</span> <span>Then</span>
				KeyANSI <span>=</span> <span>0</span>
			<span>End</span> <span>If</span>
		<span>Case</span> Asc<span>(</span><span>"."</span><span>)</span>
			<span>If</span> InStr<span>(</span><span>1</span><span>,</span> <span>Me</span><span>.</span>TextBox1<span>.</span>Text<span>,</span> <span>"."</span><span>)</span> <span>></span> <span>0</span> <span>Then</span>
				KeyANSI <span>=</span> <span>0</span>
			<span>End</span> <span>If</span>
		<span>Case</span> <span>Else</span>
			KeyANSI <span>=</span> <span>0</span>
	<span>End</span> <span>Select</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>代码解析：</p>
<p>文本框的 KeyPress 事件过程，测试键盘输入的是哪类字符，只允许输入数字字符和一个“-”号、一个“.”号。</p>
<p>KeyPress 事件的语法如下：</p>
<div><pre><code><span>Private</span> <span>Sub</span> object_KeyPress<span>(</span> <span>ByVal</span> KeyANSI <span>As</span> MSForms<span>.</span>ReturnInteger<span>)</span>

参数<span>Object</span>是必需的，一个有效的对象。
参数KeyANSI是可选的，整数值，代表标准的数字ANSI 键代码。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第 2 行代码使用 Case Else 语句测试文本框 KeyPress 事件的 KeyANSI 参数值。</p>
<p>第 3 行代码，如果键盘输入的是 0 到 9 之间的数字字符，则允许输入。如果想在文本框中允许其它类型的字符输入，在此句代码中列出允许输入的字符即可。</p>
<p>第 4 行到第 8 行代码，如果键盘输入的是“-”号，先使用 InStr 函数测试文本框中是否已有“-”号，如果 InStr 函数返回值大于 0，说明文本框中已有“-”号。接下来使用文本框的 SelStart  属性来测试插入点，如果文本框的 SelStart  属性值大于 0，说明“-”号的插入点不是第一个。如果以上两个条件中有任何一个成立，将 KeyAscii 参数值设置为 0，使文本框只能在第一位输入一个“-”号。</p>
<p>第 9 行到第 12 行代码，如果键盘输入的是“.”号的话，使用 InStr 函数测试文本框中是否已有“.”号，如果已有“.”号，将 KeyAscii 参数值设置为 0，使文本框只能输入一个“.”号。</p>
<p>第 13、14 行代码，如果键盘输入的是其他字符则将 KeyAscii 参数值设置为 0，使文本框不能输入其他字符。</p>
<p>经过以上设置文本框只允许输入数字字符和一个“-”号、一个“.”号，但是能输入中文字符。如果希望限制中文字符的输入，可以在文本框的 Change 事件中进行设置，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> TextBox1_Change<span>(</span><span>)</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>Dim</span> s <span>As</span> <span>String</span>
	<span>With</span> TextBox1
		<span>For</span> i <span>=</span> <span>1</span> <span>To</span> Len<span>(</span><span>.</span>Text<span>)</span>
			s <span>=</span> Mid<span>(</span><span>.</span>Text<span>,</span> i<span>,</span> <span>1</span><span>)</span>
			<span>Select</span> <span>Case</span> s
				<span>Case</span> <span>"."</span><span>,</span> <span>"-"</span><span>,</span> <span>"0"</span> <span>To</span> <span>"9"</span>
				<span>Case</span> <span>Else</span>
					<span>.</span>Text <span>=</span> Replace<span>(</span><span>.</span>Text<span>,</span> s<span>,</span> <span>""</span><span>)</span>
			<span>End</span> <span>Select</span>
		<span>Next</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>代码解析：</p>
<p>文本框的 Change 事件，判断输入的字符是否为数字字符和“-”号、“.”号，如果不是则使用 Replace 函数将文本框中输入的其他字符替换成空白。</p>
<p>第 5、6 行代码在文本框输入的所有字符中循环。</p>
<p>第 8 行代码列出允许输入的字符。如果想在文本框中允许其它字符输入，在此句代码中列出即可。</p>
<p>第 9、10 行代码，如果不是允许输入的字符，使用 Replace 函数替换成空白。</p>
<p>经过以上的设置，文本框中只能在第一位输入一个“-”号、一个“.”号和“0”到“9”的数字。</p>
<h2 id="_99、文本框添加右键快捷菜单"> 99、文本框添加右键快捷菜单</h2>
<p>VBA 中的控件没有提供右键快捷菜单，用户可以使用 Excel 中的命令栏自已添加右键快捷菜单。</p>
<ul>
<li>步骤 1：按 &lt;Alt+F11&gt; 组合键进入 VBE 窗口，单击菜单“插入”→“模块”，在其代码窗口输入以下代码：</li>
</ul>
<div><pre><code><span>Private</span> ActiveTB <span>As</span> MSForms<span>.</span>TextBox
<span>Public</span> <span>Sub</span> CreateShortCutMenu<span>(</span><span>)</span>
	<span>Dim</span> ShortCutMenu <span>As</span> CommandBar
	<span>Dim</span> ShortCutMenuItem <span>As</span> CommandBarButton
	<span>Dim</span> sCaption <span>As</span> <span>Variant</span>
	<span>Dim</span> iFaceId <span>As</span> <span>Variant</span>
	<span>Dim</span> sAction <span>As</span> <span>Variant</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	sCaption <span>=</span> Array<span>(</span><span>"剪切(&amp;C)"</span><span>,</span> <span>"复制(&amp;T)"</span><span>,</span> <span>"贴粘(&amp;P)"</span><span>,</span> <span>"删除(&amp;D)"</span><span>)</span>
	iFaceId <span>=</span> Array<span>(</span><span>21</span><span>,</span> <span>19</span><span>,</span> <span>22</span><span>,</span> <span>1786</span><span>)</span>
	sAction <span>=</span> Array<span>(</span><span>"Action_Cut"</span><span>,</span> <span>"Action_Copy"</span><span>,</span> <span>"Action_Paste"</span><span>,</span> <span>"Action_Delete"</span><span>)</span>
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	Application<span>.</span>CommandBars<span>(</span><span>"ShortCut"</span><span>)</span><span>.</span>Delete
	<span>Set</span> ShortCutMenu <span>=</span> Application<span>.</span>CommandBars<span>.</span>Add<span>(</span><span>"ShortCut"</span><span>,</span> msoBarPopup<span>)</span>
	<span>With</span> ShortCutMenu
		<span>For</span> i <span>=</span> <span>0</span> <span>To</span> <span>3</span>
			<span>Set</span> ShortCutMenuItem <span>=</span> <span>.</span>Controls<span>.</span>Add<span>(</span>msoControlButton<span>)</span>
			<span>With</span> ShortCutMenuItem
				<span>.</span>Caption <span>=</span> sCaption<span>(</span>i<span>)</span>
				<span>.</span>faceID <span>=</span> Val<span>(</span>iFaceId<span>(</span>i<span>)</span><span>)</span>
				<span>.</span>OnAction <span>=</span> sAction<span>(</span>i<span>)</span>
			<span>End</span> <span>With</span>
		<span>Next</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>代码解析：</p>
<p>第 1 行代码，在模块级别中声明变量 ActiveTB 是用来对应窗体中的文本框所触发的所有事件的变量。</p>
<p>CreateShortCutMenu 过程用来创建标题为“ShortCut”的右键快捷菜单，并添加 4 个菜单项。关于自定义右键快捷菜单请参阅 86 。</p>
<div><pre><code><span>Public</span> <span>Sub</span> ShowPopupMenu<span>(</span>txtCtr <span>As</span> MSForms<span>.</span>TextBox<span>)</span>
	<span>Dim</span> Action <span>As</span> <span>Variant</span>
	<span>Set</span> ActiveTB <span>=</span> txtCtr
	<span>With</span> Application<span>.</span>CommandBars<span>(</span><span>"ShortCut"</span><span>)</span>
		<span>.</span>Controls<span>(</span><span>1</span><span>)</span><span>.</span>Enabled <span>=</span> txtCtr<span>.</span>SelLength <span>></span> <span>0</span>
		<span>.</span>Controls<span>(</span><span>2</span><span>)</span><span>.</span>Enabled <span>=</span> <span>.</span>Controls<span>(</span><span>1</span><span>)</span><span>.</span>Enabled
		<span>.</span>Controls<span>(</span><span>3</span><span>)</span><span>.</span>Enabled <span>=</span> txtCtr<span>.</span>CanPaste
		<span>.</span>Controls<span>(</span><span>4</span><span>)</span><span>.</span>Enabled <span>=</span> <span>.</span>Controls<span>(</span><span>1</span><span>)</span><span>.</span>Enabled
		<span>.</span>ShowPopup
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>代码解析：</p>
<p>ShowPopupMenu 过程根据文本框中字符的选中状态设置右键快捷菜单菜单项的 Enabled 属性后使用 ShowPopup 方法显示右键快捷菜单。</p>
<p>第 5 行代码，如果当前文本框中已有选中的字符则“剪切”按钮有效。</p>
<p>第 6 行代码，如果当前文本框中已有选中的字符则“复制”按钮有效。</p>
<p>第 7 行代码，如果剪贴板中包含对象支持的数据。则“贴粘”按钮有效。</p>
<p>第 8 行代码，如果当前文本框中已有选中的字符则“删除”按钮有效。</p>
<p>第 9 行代码，显示快捷菜单。</p>
<div><pre><code><span>Public</span> <span>Sub</span> Action_Cut<span>(</span><span>)</span>
	ActiveTB<span>.</span>Cut
<span>End</span> <span>Sub</span>
<span>Public</span> <span>Sub</span> Action_Copy<span>(</span><span>)</span>
	ActiveTB<span>.</span>Copy
<span>End</span> <span>Sub</span>
<span>Public</span> <span>Sub</span> Action_Paste<span>(</span><span>)</span>
	ActiveTB<span>.</span>Paste
<span>End</span> <span>Sub</span>
<span>Public</span> <span>Sub</span> Action_Delete<span>(</span><span>)</span>
	<span>Dim</span> s <span>As</span> <span>String</span>
	<span>With</span> ActiveTB
		s <span>=</span> <span>.</span>SelText
		<span>.</span>Value <span>=</span> Replace<span>(</span><span>.</span>Value<span>,</span> s<span>,</span> <span>""</span><span>)</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>代码解析：</p>
<p>Action_Cut 过程是快捷菜单中单击“剪切”菜单项所运行的过程。使用 Cut 方法将当前选中的文本框中的文本删除并移至剪贴板。</p>
<p>Action_Copy 过程是快捷菜单中单击“复制”菜单项所运行的过程。使用 Copy 方法将文本框选中的文本复制到剪贴板上。</p>
<p>Action_Paste 过程是快捷菜单中单击“贴粘”菜单项所运行的过程。使用 Paste 方法把剪贴板上的内容传送到一个文本框中。</p>
<p>Action_Delete 过程是快捷菜单中单击“贴粘”菜单项所运行的过程。使用 Replace 函数将文本框中选中的文本的文本替换成空字符。</p>
<div><pre><code><span>Public</span> <span>Sub</span> DeleteShortCutMenu<span>(</span><span>)</span>
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	Application<span>.</span>CommandBars<span>(</span><span>"ShortCut"</span><span>)</span><span>.</span>Delete
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>代码解析：</p>
<p>DeleteShortCutMenu 过程删除创建的右键快捷菜单。</p>
<ul>
<li>步骤 2：在VBE 窗口中，单击菜单“插入”→“用户窗体”，在窗体上添加两个文本框控件。双击窗体，在其代码窗口中输入下面的代码。</li>
</ul>
<div><pre><code><span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	<span>Call</span> CreateShortCutMenu
<span>End</span> <span>Sub</span>
<span>Private</span> <span>Sub</span> TextBox1_MouseUp<span>(</span><span>ByVal</span> Button <span>As</span> <span>Integer</span><span>,</span> <span>ByVal</span> Shift <span>As</span> <span>Integer</span><span>,</span> <span>ByVal</span> X <span>As</span> <span>Single</span><span>,</span> <span>ByVal</span> Y <span>As</span> <span>Single</span><span>)</span>
	<span>If</span> Button <span>=</span> <span>2</span> <span>Then</span> ShowPopupMenu ActiveControl
<span>End</span> <span>Sub</span>
<span>Private</span> <span>Sub</span> TextBox2_MouseUp<span>(</span><span>ByVal</span> Button <span>As</span> <span>Integer</span><span>,</span> <span>ByVal</span> Shift <span>As</span> <span>Integer</span><span>,</span> <span>ByVal</span> X <span>As</span> <span>Single</span><span>,</span> <span>ByVal</span> Y <span>As</span> <span>Single</span><span>)</span>
	<span>If</span> Button <span>=</span> <span>2</span> <span>Then</span> ShowPopupMenu ActiveControl
<span>End</span> <span>Sub</span>
<span>Private</span> <span>Sub</span> UserForm_QueryClose<span>(</span>Cancel <span>As</span> <span>Integer</span><span>,</span> CloseMode <span>As</span> <span>Integer</span><span>)</span>
	<span>Call</span> DeleteShortCutMenu
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>代码解析：</p>
<p>第 1 行到第 3 行代码，窗体的 Initialize 事件，在窗体初始化时运行 CreateShortCutMenu 过程创建右键快捷菜单。</p>
<p>第 4 行到第 9 行代码，文本框的 MouseUp 事件，当用户右健单击文本框时运行 ShowPopupMenu 过程在选中的菜单项上显示右键快捷菜单。</p>
<p>第 10 行到第 12 行代码，窗体的 QueryClose 事件，在关闭窗体时运行 DeleteShortCutMenu 过程删除右键快捷菜单。</p>
<p>窗体运行后，右键单击文本框显示右键快捷菜单，如图 99-1 所示。</p>
<div>
<p><img src="./assets/99-1.png" alt="" loading="lazy"></p>
<p><u>图 99-1</u>	文本框快捷菜单</p>
</div>
<h2 id="_100、文本框回车自动输入"> 100、文本框回车自动输入</h2>
<p>在使用文本框向工作表输入数据时，为了加快输入速度，可以利用文本框的 KeyDown 事件，回车后自动输入并清空文本框，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> TextBox1_KeyDown<span>(</span><span>ByVal</span> KeyCode <span>As</span> MSForms<span>.</span>ReturnInteger<span>,</span> <span>ByVal</span> Shift <span>As</span> <span>Integer</span><span>)</span>
	<span>With</span> TextBox1
		<span>If</span> Len<span>(</span>Trim<span>(</span><span>.</span>Value<span>)</span><span>)</span> <span>></span> <span>0</span> <span>Then</span>
			<span>If</span> KeyCode <span>=</span> vbKeyReturn <span>Then</span>
				Sheet1<span>.</span>Range<span>(</span><span>"A65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Offset<span>(</span><span>1</span><span>,</span> <span>0</span><span>)</span> <span>=</span> <span>.</span>Value
				<span>.</span>Text <span>=</span> <span>""</span>
			<span>End</span> <span>If</span>
		<span>End</span> <span>If</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>代码解析：</p>
<p>文本框的 KeyDown 事件，在输入数据并按 &lt;Enter&gt; 键后自动将数据录入到工作表 A 列最后一个非空单元格的下一个单元格中。</p>
<p>KeyDown 事件在按下键盘按键时发生，语法如下：</p>
<div><pre><code><span>Private</span> <span>Sub</span> object_KeyDown<span>(</span> <span>ByVal</span> KeyCode <span>As</span> MSForms<span>.</span>ReturnInteger<span>,</span> <span>ByVal</span> Shift <span>As</span> fmShiftState<span>)</span>

参数<span>object</span>是必需的，一个有效的对象。
参数KeyCode是必需的，代表被按下的键的键代码。
参数Shift是可选的，Shift、Ctrl 和Alt的状态。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>第 3 行代码，为了防止误输入空白数据，使用 Len 函数和 Trim 函数检查文本框内是否为有效数据。</p>
<p>第 4 行代码，根据 KeyCode 参数值判断是否按下了回车键。如果用户按下了回车键，KeyCode 参数返回常数 vbKeyReturn。</p>
<p>第 5、6 行代码，将文本框数据输入到工作表A列的最后一个单元格内，同时清空文本框内容准备下一次输入。</p>
<h2 id="_101、自动选择文本框内容"> 101、自动选择文本框内容</h2>
<p>如果希望光标进入文本框时能自动选择文本框内容，可以在文本框的 MouseUp 事件中来完成，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> TextBox1_MouseUp<span>(</span><span>ByVal</span> Button <span>As</span> <span>Integer</span><span>,</span> <span>ByVal</span> Shift <span>As</span> <span>Integer</span><span>,</span> <span>ByVal</span> X <span>As</span> <span>Single</span><span>,</span> <span>ByVal</span> Y <span>As</span> <span>Single</span><span>)</span>
	<span>With</span> TextBox1
		<span>If</span> Button <span>=</span> <span>2</span> <span>Then</span>
			<span>.</span>SelStart <span>=</span> <span>0</span>
			<span>.</span>SelLength <span>=</span> Len<span>(</span><span>.</span>Text<span>)</span>
		<span>End</span> <span>If</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>代码解析：</p>
<p>文本框的 MouseUp 事件，在光标进入文本框释放鼠标右键时自动选择文本框内容。</p>
<p>MouseUp 事件在用户释放鼠标按键时发生，语法如下：</p>
<div><pre><code><span>Private</span> <span>Sub</span> object_MouseUp<span>(</span> <span>ByVal</span> Button <span>As</span> fmButton<span>,</span> <span>ByVal</span> Shift <span>As</span> fmShiftState<span>,</span> <span>ByVal</span> X <span>As</span> <span>Single</span><span>,</span> <span>ByVal</span> Y <span>As</span> <span>Single</span><span>)</span>

参数<span>object</span>是必需的，一个有效的对象。
参数Button是可选的，设置引起该事件的鼠标按键的整数值，如表格<span>101</span><span>-</span><span>1</span>所示。
参数Shift是可选的，Shift、Ctrl 和Alt的状态。
参数X和参数Y是可选的，窗体、框架或页的位置的横坐标与纵坐标。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><u>表格 101-1</u>	Button参数值</p>
<table>
<thead>
<tr>
<th>常数</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>fmButtonLeft</td>
<td>1</td>
<td>按下左键。</td>
</tr>
<tr>
<td>fmButtonRight</td>
<td>2</td>
<td>按下右键。</td>
</tr>
<tr>
<td>fmButtonMiddle</td>
<td>3</td>
<td>按下中键。</td>
</tr>
</tbody>
</table>
<p>第 3 行到第 6 行代码，如果用户进入文本框释放鼠标右键，设置文本框的 SelStart 属性为 0， SelLength 属性为文本框的全部字符数。</p>
<p>SelStart 属性指定选中文本的起点，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>SelStart [<span>=</span> <span>Long</span>]

参数<span>object</span>是必需的，一个有效的对象。
参数<span>Long</span>是可选的，指定选中文本的起点。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>SelLength 属性指定文本框或组合框的文本部分中选中的字符数，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>SelLength [<span>=</span> <span>Long</span>]

参数<span>object</span>是必需的，一个有效的对象。
参数<span>Long</span>是可选的，指定选中的字符数。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>运行窗体，当光标进入文本框释放鼠标右键时自动选择文本框内容，如图 101-1 所示。</p>
<div>
<p><img src="./assets/101-1.png" alt="" loading="lazy"></p>
<p><u>图 101-1</u>	自动选择文本框内容</p>
</div>
<h2 id="_102、设置文本框数据格式"> 102、设置文本框数据格式</h2>
<p>文本框在用来输入数据时，除了限制输入的数据类型外，还可以设置文本框的数据格式，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> TextBox1_Exit<span>(</span><span>ByVal</span> Cancel <span>As</span> MSForms<span>.</span>ReturnBoolean<span>)</span>
	TextBox1 <span>=</span> Format<span>(</span>TextBox1<span>,</span> <span>"0.00"</span><span>)</span>
<span>End</span> <span>Sub</span>
<span>Private</span> <span>Sub</span> TextBox2_Exit<span>(</span><span>ByVal</span> Cancel <span>As</span> MSForms<span>.</span>ReturnBoolean<span>)</span>
	TextBox2 <span>=</span> Format<span>(</span>TextBox2<span>,</span> <span>"0.00"</span><span>)</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>代码解析：</p>
<p>文本框的 Exit 事件过程，在文本框输入数据时使用 Format 函数格式化为两位小数格式。</p>
<p>控件的 Exit 事件在同一窗体中的一个控件即将把焦点转移到另一个控件之前发生，语法如下：</p>
<div><pre><code><span>Private</span> <span>Sub</span> object_Exit<span>(</span> <span>ByVal</span> Cancel <span>As</span> MSForms<span>.</span>ReturnBoolean<span>)</span>

参数<span>Object</span>是必需的，一个有效的对象。
参数Cancel是必需的，事件状态。如果设置为<span>False</span>表示由该控件处理这个事件（默认方式）。设置为<span>True</span>表示由应用程序处理这个事件，并且焦点留在当前控件上。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>当文本框在输入完数据失去焦点时使用Format函数格式化自定义数值格式。Format 函数语法如下：</p>
<div><pre><code>Format<span>(</span>expression[<span>,</span> format[<span>,</span> firstdayofweek[<span>,</span> firstweekofyear]]]<span>)</span>

参数expression是必需的，任何有效的表达式。
参数format是可选的，有效的命名表达式或用户自定义格式表达式。
参数firstdayofweek是可选的，常数，表示一星期的第一天。
参数firstweekofyear是可选的，常数，表示一年的第一周。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>在本例中，将文本框的数据格式化成自定义的两位小数的数值格式，关于 Format 函数格式化日期和时间等其他数据请参阅 VBA 中 Format 函数的帮助。</p>
<div><pre><code><span>Private</span> <span>Sub</span> TextBox1_Change<span>(</span><span>)</span>
	TextBox3 <span>=</span> Format<span>(</span>Val<span>(</span>TextBox1<span>)</span> <span>*</span> Val<span>(</span>TextBox2<span>)</span><span>,</span> <span>"0.00"</span><span>)</span>
<span>End</span> <span>Sub</span>
<span>Private</span> <span>Sub</span> TextBox2_Change<span>(</span><span>)</span>
	TextBox3 <span>=</span> Format<span>(</span>Val<span>(</span>TextBox1<span>)</span> <span>*</span> Val<span>(</span>TextBox2<span>)</span><span>,</span> <span>"0.00"</span><span>)</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>代码解析：</p>
<p>文本框的 Change 事件过程，在两个文本框输入完数据后，使用文本框的 Change 事件使 TextBox3 显示其相乘的金额并格式化为两位小数的数据格式。</p>
<p>Change 事件在控件的 Value 属性改变时发生，语法如下：</p>
<div><pre><code><span>Private</span> <span>Sub</span> object_Change<span>(</span> <span>)</span>

参数<span>object</span>是必需的，一个有效的对象。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>Change 事件过程可以使显示在控件上的数据同步或一致。在本例中，当 TextBox1 或 TextBox2 的数据发生改变时，两者相乘的金额的金额也随之改变并在 TextBox3 中显示。</p>
<p>因为文本框的数据类型是文本字符串，不能直接进行计算的，所以计算前先使用 Val 函数转换为数字，才能进行计算。</p>
<p>运行窗体，输入数据后格式化为两位小数的数据格式，如图 102-1 所示。</p>
<div>
<p><img src="./assets/102-1.png" alt="" loading="lazy"></p>
<p><u>图 102-1</u>	设置文本框的数据格式</p>
</div>
<h2 id="_103、限制文本框的输入长度"> 103、限制文本框的输入长度</h2>
<p>在使用文本框输入数据时，可能希望限制能输入的字符长度，即只能输入一定长度的字符，超过设置数值就不能输入，这时可以通过设置文本框的 MaxLength 属性来实现，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Worksheet_Activate<span>(</span><span>)</span>
	<span>Me</span><span>.</span>TextBox1<span>.</span>MaxLength <span>=</span> <span>6</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>工作表的激活事件过程，将文本框的 MaxLength 属性设置为 6，使文本框只能输入 6 个字符，超过 6 个字符即不能输入。</p>
<p>应用于文本框控件的 MaxLength 属性规定用户可以在文本框中输入的最多字符数，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>MaxLength [<span>=</span> <span>Long</span>]

参数<span>object</span>是必需的，一个有效的对象。
参数<span>Long</span>是可选的，整数，表示所允许的字符数。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果将 MaxLength 属性设置为 0，表示只要内存允许则没有限制。</p>
<h2 id="_104、将光标返回文本框中"> 104、将光标返回文本框中</h2>
<p>在用文本框往工作表录入数据时，一般会在录入到工作表前验证输入的数据是否正确，如果错误，则清空文本框内容，提示用户重新输入。但此时光标已经不在文本框中，需要重新选择文本框才能输入。</p>
<p>可以在 Exit 事件中可以设置 Cancel 参数值使光标停留在当前文本框中，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> TextBox1_Exit<span>(</span><span>ByVal</span> Cancel <span>As</span> MSForms<span>.</span>ReturnBoolean<span>)</span>
	<span>With</span> TextBox1
		<span>If</span> <span>.</span>Text <span>&lt;</span><span>></span> <span>""</span> <span>And</span> Len<span>(</span>Trim<span>(</span><span>.</span>Text<span>)</span><span>)</span> <span>&lt;</span><span>></span> <span>15</span> <span>And</span> Len<span>(</span>Trim<span>(</span><span>.</span>Text<span>)</span><span>)</span> <span>&lt;</span><span>></span> <span>18</span> <span>Then</span>
			<span>.</span>Text <span>=</span> <span>""</span>
			MsgBox <span>"身份证号码录入错误!"</span>
			Cancel <span>=</span> <span>True</span>
		<span>End</span> <span>If</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>代码解析：</p>
<p>文本框的 Exit 事件，在输入身份证号码后即将把焦点转移到录入按钮控件之前检查输入的身份证号码是否正确。</p>
<p>Exit 事件在一个控件从同一窗体的另一个控件实际接收到焦点之前发生,语法如下:</p>
<div><pre><code><span>Private</span> <span>Sub</span> object_Exit<span>(</span> <span>ByVal</span> Cancel <span>As</span> MSForms<span>.</span>ReturnBoolean<span>)</span>

Cancel参数为事件状态。<span>False</span>表示由该控件处理这个事件（这是默认方式）。<span>True</span>表示由应用程序处理这个事件，并且焦点应当留在当前控件上。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>第 3 行代码，使用 Len 函数和 Trim 函数检查输入的身份证号码是否为 15 位或 18 位。</p>
<p>第 4 行到第 6 行代码，如果输入的身份证号码不正确，清空文本框以便重新输入并提示用户，设置 Cancel 参数为 True 使光标停留在文本框中。</p>
<p>在 Exit 事件中之所以把文本框为空也做为通过验证的条件之一，因为如果不加上“ <u>TextBox1.Text &lt;&gt; &quot;&quot;</u> ”这一条件，那么在窗体显示后，如果用户取消输入或关闭输入窗体，也会提示输入错误。所以在录入到工作表之前再验证文本框是否为空，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> CommandButton1_Click<span>(</span><span>)</span>
	<span>With</span> TextBox1
		<span>If</span> <span>.</span>Text <span>&lt;</span><span>></span> <span>""</span> <span>Then</span>
			Sheet1<span>.</span>Range<span>(</span><span>"a65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Offset<span>(</span><span>1</span><span>,</span> <span>0</span><span>)</span> <span>=</span> <span>.</span>Text
			<span>.</span>Text <span>=</span> <span>""</span>
		<span>Else</span>
			MsgBox <span>"请输入身份证号码!"</span>
		<span>End</span> <span>If</span>
			<span>.</span>SetFocus
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>代码解析：</p>
<p>输入按钮的 Click 事件，把文本框数据录入到工作表 A 列最后一个单元格中并重新选择文本框准备下一次输入。</p>
<p>第 3 行代码，在输入到工作表前检查文本框是否为空。</p>
<p>第 4、5 行代码，如果文本框不为空，录入数据到工作表并清空文本框内容。</p>
<p>第 7 行代码，如果文本框为空，提示用户输入数据。</p>
<p>第 8 行代码，使用 SetFocus 方法将光标返回到文本框中以便重新输入。</p>
<p>SetFocus 方法将焦点移动到对象的实例中，语法如下 ：</p>
<div><pre><code><span>object</span><span>.</span>SetFocus

参数<span>object</span><span>.</span>是必需的，一个有效的对象。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>运行窗体，在输入框中输入身份证号码后自动验证输入的数据，如果输入数据错误，清空文本框并提示用户重新输入，如图 104-1 所示。</p>
<div>
<p><img src="./assets/104-1.png" alt="" loading="lazy"></p>
<p><u>图 104-1</u>	提示用户重新输入</p>
</div>
<h2 id="_105、文本框的自动换行"> 105、文本框的自动换行</h2>
<p>在使用使用文本框显示或录入一段很长的文本时，需要将文本框设置成多行显示，否则文本内容只能在一行中显示，示例代码如下：</p>
<div><pre><code><span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	<span>With</span> TextBox1
		<span>.</span>WordWrap <span>=</span> <span>True</span>
		<span>.</span>MultiLine <span>=</span> <span>True</span>
		<span>.</span>Text <span>=</span> Space<span>(</span><span>4</span><span>)</span> <span>&amp;</span> <span>"VBA(Visual Basic for Application)是"</span> <span>_</span>
				<span>&amp;</span> <span>"微软公司为了加强Office软件的二次开发能力而附加"</span> <span>_</span>
				<span>&amp;</span> <span>"于其中的编程语言。VBA的确非常强大，其与VB完全一"</span> <span>_</span>
				<span>&amp;</span> <span>"致的语法结构，高效控制Office对象模型的能力，令无"</span> <span>_</span>
				<span>&amp;</span> <span>"数人为之折腰。利用VBA，几乎可以在Office里面做任何"</span> <span>_</span>
				<span>&amp;</span> <span>"其他程序能做的事情。但是，应该清楚的认识到VBA是依"</span> <span>_</span>
				<span>&amp;</span> <span>"托其宿主─—Excel（或其他Office组件）而存在的，对"</span> <span>_</span>
				<span>&amp;</span> <span>"于Excel用户来讲，VBA只不过是锦上添花的东西，切不可"</span> <span>_</span>
				<span>&amp;</span> <span>"本末倒置，捡了芝麻丢了西瓜，把明明能够利用Excel内置"</span> <span>_</span>
				<span>&amp;</span> <span>"功能完成的任务，硬是搬到VBA里面去做，以为用代码实现"</span> <span>_</span>
				<span>&amp;</span> <span>"就是高人一头的表现。其实，真正的高手，会尽量发挥"</span> <span>_</span>
				<span>&amp;</span> <span>"Excel自身的威力，不到万不得已的时候是不会去&lt;Alt+F11>的。"</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>代码解析：</p>
<p>窗体的 Initialize 事件过程，在窗体显示时将文本框设置成多行显示文本。</p>
<p>第 3 行代码设置文本框的 WordWrap 属性。WordWrap 属性指定一个控件的内容在行末是否自动换行，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>WordWrap [<span>=</span> <span>Boolean</span>]

参数<span>object</span>是必需的，一个有效的对象。
参数<span>Boolean</span>是可选的，控件是否扩展以适应文本的大小，设置为<span>True</span>，文本换行，设置为<span>False</span>，文本不换行。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第 4 行代码设置文本框的 MultiLine 属性。MultiLine 属性规定控件能否接受和显示多行文本，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>MultiLine [<span>=</span> <span>Boolean</span>]

参数<span>object</span>是必需的，一个有效的对象。
参数<span>Boolean</span>是可选的，控件是否支持多行文本，设置为<span>True</span>，以多行显示文本，设置为<span>False</span>，不多行显示文本。如果将多行文本框的MultiLine属性设置为<span>False</span>，则文本框的所有字符都将合并为一行，包括非打印字符（如，回车和换行）。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>对于既支持 WordWrap 属性又支持 MultiLine 属性的控件，当 MultiLine 属性为 False 时，WordWrap 属性被忽略。</p>
<p>运行窗体，文本框显示如图 105-1 所示。</p>
<div>
<p><img src="./assets/105-1.png" alt="" loading="lazy"></p>
<p><u>图 105-1</u>	文本框自动换行</p>
</div>
<h2 id="_106、多个文本框数据相加"> 106、多个文本框数据相加</h2>
<p>在 102 中，我们在 TextBox1、TextBox2 中输入完数据后，利用文本框的 Change 事件使 TextBox3 显示其两者相乘的金额，但是如果窗体中有多个文本框，需要在每一个文本框的 Change 事件中写上相同的重复代码，因此使用类模块可以简化代码。</p>
<p>在附件的窗体有七个文本框，其中六个用来输入数据，一个用来显示其他六个文本框相加后的合计数，首先打开 VBE，插入一个类模块建立一个类，类模块的名字就是类的名字修改为“cmds”，在类模块中输入下面的代码：</p>
<div><pre><code><span>Public</span> <span>WithEvents</span> cmd <span>As</span> MSForms<span>.</span>TextBox
</code></pre>
<div><span>1</span><br></div></div><p>代码解析：</p>
<p>使用 Public 语句声明变量 cmd 是用来响应由 TextBox 对象触发的事件的对象变量。</p>
<p>在窗体的 Initialize 事件中写入下面的代码：</p>
<div><pre><code><span>Dim</span> col <span>As</span> <span>New</span> Collection
<span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>Dim</span> myc <span>As</span> cmds
	<span>For</span> i <span>=</span> <span>1</span> <span>To</span> <span>6</span>
		<span>Set</span> myc <span>=</span> <span>New</span> cmds
		<span>Set</span> myc<span>.</span>cmd <span>=</span> <span>Me</span><span>.</span>Controls<span>(</span><span>"TextBox"</span> <span>&amp;</span> i<span>)</span>
		col<span>.</span>Add myc
	<span>Next</span>
	<span>Set</span> myc <span>=</span> <span>Nothing</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>代码解析：</p>
<p>第 1 行代码在模块顶部声明变量 col 的类型为集合。</p>
<p>第 5 行到第 9 行代码，将窗体中的六个文本框赋给 col 集合。</p>
<p>（关于类模块请参阅论坛中有关的资料。）</p>
<p>在类模块中写入下面的代码：</p>
<div><pre><code><span>Private</span> <span>Sub</span> cmd_Change<span>(</span><span>)</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>Dim</span> Dval <span>As</span> <span>Double</span>
	<span>For</span> i <span>=</span> <span>1</span> <span>To</span> <span>6</span>
		Dval <span>=</span> Dval <span>+</span> Val<span>(</span>UserForm1<span>.</span>Controls<span>(</span><span>"TextBox"</span> <span>&amp;</span> i<span>)</span><span>)</span>
		UserForm1<span>.</span>TextBox7<span>.</span>Value <span>=</span> Dval
	<span>Next</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>代码解析：</p>
<p>窗体中的六个文本框统一的 Change 事件，当任何一个文本框中的数据发生变化时，所有文本框相加的合计数显示在最后一个文本框中。</p>
<p>运行窗体在文本框中输入数据结果如图 106-1 所示。</p>
<div>
<p><img src="./assets/106-1.png" alt="" loading="lazy"></p>
<p><u>图 106-1</u>	多个文本框数据相加</p>
</div>
<h2 id="_107、控件跟随活动单元格"> 107、控件跟随活动单元格</h2>
<p>在工作表中使用控件时一般都把控件放在工作表的上部，如果工作表中数据较多，当页面滚动到工作表下面的区域时，控件会离开当前可视区域，这时操作起来很不方便。解决方法除了冻结工作表的第一行放置控件的外，还可以使控件出现在选定的单元格位置，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Worksheet_SelectionChange<span>(</span><span>ByVal</span> Target <span>As</span> Range<span>)</span>
	<span>With</span> <span>Me</span><span>.</span>CommandButton1
		<span>.</span>Top <span>=</span> Target<span>.</span>Top
		<span>.</span>Left <span>=</span> Target<span>.</span>Left <span>+</span> Target<span>.</span>Width
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>代码解析：</p>
<p>工作表的 SelectionChange 事件，使工作表中的按钮控件出现在选定单元格的右边。</p>
<p>第 3 行代码，设置按钮的 Top 属性等于选定单元格的 Top 属性。Top 属性设置对象顶端到第一行顶端的距离。</p>
<p>第 4 行代码，设置按钮的 Left 属性等于选定单元格的 Left 属性加上选定单元格的宽度，即按钮出现在选定单元格的右边。Left 属性设置对象左边界至 A 列左边界的距离。</p>
<p>当单击工作表区域的任一单元格，按钮出现在单元格的右边，如图 107-1 所示。</p>
<div>
<p><img src="./assets/107-1.png" alt="" loading="lazy"></p>
<p><u>图 107-1</u>	控件跟随活动单元格</p>
</div>
<h2 id="_108、高亮显示按钮"> 108、高亮显示按钮</h2>
<p>为了达到当鼠标掠过按钮时以高亮和凸起显示按钮的效果，可以在窗体和按钮的 MouseMove 事件中进行模拟，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> CommandButton1_MouseMove<span>(</span><span>ByVal</span> Button <span>As</span> <span>Integer</span><span>,</span> <span>ByVal</span> Shift <span>As</span> <span>Integer</span><span>,</span> <span>ByVal</span> X <span>As</span> <span>Single</span><span>,</span> <span>ByVal</span> Y <span>As</span> <span>Single</span><span>)</span>
	<span>With</span> <span>Me</span><span>.</span>CommandButton1
		<span>.</span>BackColor <span>=</span> <span>&amp;HFFFF00</span>
		<span>.</span>Width <span>=</span> <span>62</span>
		<span>.</span>Height <span>=</span> <span>62</span>
		<span>.</span>Top <span>=</span> <span>69</span>
		<span>.</span>Left <span>=</span> <span>31</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
<span>Private</span> <span>Sub</span> UserForm_MouseMove<span>(</span><span>ByVal</span> Button <span>As</span> <span>Integer</span><span>,</span> <span>ByVal</span> Shift <span>As</span> <span>Integer</span><span>,</span> <span>ByVal</span> X <span>As</span> <span>Single</span><span>,</span> <span>ByVal</span> Y <span>As</span> <span>Single</span><span>)</span>
	<span>With</span> <span>Me</span><span>.</span>CommandButton1
		<span>.</span>BackColor <span>=</span> <span>Me</span><span>.</span>BackColor
		<span>.</span>Width <span>=</span> <span>60</span>
		<span>.</span>Height <span>=</span> <span>60</span>
		<span>.</span>Top <span>=</span> <span>70</span>
		<span>.</span>Left <span>=</span> <span>32</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>代码解析：</p>
<p>窗体和按钮的 MouseMove 事件过程，以高亮和凸起显示按钮。</p>
<p>当用户在窗体中移动鼠标时，分别在窗体和按钮的 MouseMove 事件设置按钮的 BackColor 属性值，指定按钮的背景色，当鼠标移动到按钮时以高亮显示，当鼠标移动到窗体时恢复原来的设置。接下来分别设置按钮不同的 Width 属性、Height 属性、Top 属性和 Left 属性值，以模拟按钮凸起的效果。</p>
<p>运行窗体，当鼠标掠过按钮时效果如图 108-1 所示。</p>
<div>
<p><img src="./assets/108-1.png" alt="" loading="lazy"></p>
<p><u>图 108-1</u>	高亮和凸起显示按钮</p>
</div>
<h2 id="_109、组合框和列表框添加列表项的方法"> 109、组合框和列表框添加列表项的方法</h2>
<p>组合框和列表框是 Excel 中最常用的控件，可以用来显示工作表中的数据。为组合框和列表框添加列表项的方法有多种，下面以列表框为例演示添加列表项的方法。</p>
<h3 id="_1-使用-rowsource-属性添加列表项"> 1）使用 RowSource 属性添加列表项</h3>
<p>使用 RowSource 属性将列表框直接与工作表上的一个单元格区域相链接，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	<span>Dim</span> iRow <span>As</span> <span>Integer</span>
	iRow <span>=</span> Sheet1<span>.</span>Range<span>(</span><span>"A65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row
	<span>Me</span><span>.</span>ListBox1<span>.</span>RowSource <span>=</span> <span>"sheet1!a1:a"</span> <span>&amp;</span> iRow
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>代码解析：</p>
<p>在窗体初始化时使用 RowSource 属性为列表框添加列表项。</p>
<p>RowSource 属性的语法如下：</p>
<div><pre><code><span>object</span><span>.</span>RowSource [<span>=</span> <span>String</span>]

参数<span>object</span>是必需的，一个有效的对象。
参数<span>String</span>是可选的，组合框或列表框列表的来源。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>RowSource 属性也可以使用单元格地址，第4行代码可以改成下面的代码：</p>
<div><pre><code><span>Me</span><span>.</span>ListBox1<span>.</span>RowSource <span>=</span> Sheet1<span>.</span>Range<span>(</span><span>"A1:A"</span> <span>&amp;</span> iRow<span>)</span><span>.</span>Address<span>(</span>External<span>:</span><span>=</span><span>True</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>需要注意的是，如果 RowSource 属性指定的工作表区域不是活动工作表的话，Address 属性的 External 参数是不可缺的，设置为 True 表示是外部引用，如果缺省此参数或为 False，将不能为列表框添加列表项。</p>
<p>RowSource 属性还可以使用命名的单元格区域，如果已把工作表区域命名为“城市”，第 4 行代码可以改成下面的代码：</p>
<div><pre><code><span>Me</span><span>.</span>ListBox1<span>.</span>RowSource <span>=</span> <span>"城市"</span>
</code></pre>
<div><span>1</span><br></div></div><p>对于工作表中的列表框控件或使用窗体添加的列表框控件不能使用 RowSource 属性，需要使用 ListFillRange 属性指定填充列表框的工作表区域，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> ListFillRange<span>(</span><span>)</span>
	<span>Dim</span> iRow <span>As</span> <span>Integer</span>
	iRow <span>=</span> Sheet1<span>.</span>Range<span>(</span><span>"A65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row
	Sheet2<span>.</span>ListBox1<span>.</span>ListFillRange <span>=</span> <span>"Sheet1!a1:a"</span> <span>&amp;</span> iRow
	Sheet2<span>.</span>Shapes<span>(</span><span>"列表框"</span><span>)</span><span>.</span>ControlFormat<span>.</span>ListFillRange <span>=</span> <span>"Sheet1!a1:a"</span> <span>&amp;</span> iRow
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>代码解析：</p>
<p>ListFillRange 过程为工作表中的列表框的填充区域，ListFillRange 属性用于指定填充列表框的工作表区域。</p>
<p>第 4 行代码对于使用窗体添加的列表框控件需要使用 ControlFormat 属性来返回窗体控件以后才能设置其 ListFillRange 属性。</p>
<h3 id="_2-使用-list-属性添加列表项"> 2）使用 List 属性添加列表项</h3>
<p>使用 List 属性为列表框添加列表项，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	<span>Dim</span> Arr <span>As</span> <span>Variant</span>
	<span>Dim</span> iRow <span>As</span> <span>Integer</span>
	iRow <span>=</span> Sheet1<span>.</span>Range<span>(</span><span>"A65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row
	Arr <span>=</span> Sheet1<span>.</span>Range<span>(</span><span>"A1:A"</span> <span>&amp;</span> iRow<span>)</span>
	<span>Me</span><span>.</span>ListBox1<span>.</span>List <span>=</span> Arr
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>在窗体初始化时使用List属性为列表框添加列表项。</p>
<p>List 属性的语法如下：</p>
<div><pre><code><span>object</span><span>.</span>List<span>(</span> row<span>,</span> column <span>)</span> [<span>=</span> <span>Variant</span>]

参数<span>object</span>是必需的，一个有效对象。
参数row是必需的，取值范围为 <span>0</span> 到列表条目数减 <span>1</span> 之间的数值。
参数column是必需的，取值范围为 <span>0</span> 到总列数减 <span>1</span> 之间的数值。
参数<span>Variant</span>是可选的，列表框中指定条目的内容。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>第 6 行代码，使用 List 属性把数组复制到列表框控件上。</p>
<p>除了使用数组外，List 属性还可以使用命名的单元格区域，如果已把工作表区域命名为“城市”，可以改成下面的代码：</p>
<div><pre><code><span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	<span>Me</span><span>.</span>ComboBox1<span>.</span>List <span>=</span> Range<span>(</span><span>"城市"</span><span>)</span><span>.</span>Value
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>对于工作表中使用窗体添加的列表框控件使用 List 属性添加列表项，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> List<span>(</span><span>)</span>
	<span>Dim</span> Arr <span>As</span> <span>Variant</span>
	<span>Dim</span> iRow <span>As</span> <span>Integer</span>
	<span>Dim</span> myObj <span>As</span> <span>Object</span>
	iRow <span>=</span> Sheet1<span>.</span>Range<span>(</span><span>"A65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row
	Arr <span>=</span> Sheet1<span>.</span>Range<span>(</span><span>"A1:A"</span> <span>&amp;</span> iRow<span>)</span>
	<span>Set</span> myObj <span>=</span> Sheet2<span>.</span>Shapes<span>(</span><span>"列表框"</span><span>)</span><span>.</span>ControlFormat
	myObj<span>.</span>List <span>=</span> Arr
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>代码解析：</p>
<p>List 过程设置列表框的 List 性，用于指定填充列表框的工作表区域。</p>
<h3 id="_3-使用-additem-方法添加列表项"> 3）使用 AddItem 方法添加列表项</h3>
<p>使用 AddItem 方法添加列表项，对于单列的列表框，在列表中添加一项。对于多列的列表框，在列表中添加一行，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	<span>Dim</span> iRow <span>As</span> <span>Integer</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	iRow <span>=</span> Sheet1<span>.</span>Range<span>(</span><span>"A65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row
	<span>For</span> i <span>=</span> <span>1</span> <span>To</span> iRow
		<span>Me</span><span>.</span>ListBox1<span>.</span>AddItem <span>(</span>Sheet1<span>.</span>Cells<span>(</span>i<span>,</span> <span>1</span><span>)</span><span>)</span>
	<span>Next</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>代码解析：</p>
<p>在窗体初始化时使用 AddItem 方法为列表框添加列表项。</p>
<p>AddItem 方法的语法如下：</p>
<div><pre><code><span>object</span><span>.</span>AddItem [ item [<span>,</span> varIndex]]

参数<span>object</span>是必需的，一个有效的对象。
参数item是可选的，指定要添加的项或行。第一个项或行的编号为 <span>0</span>；第二个项或行的编号为 <span>1</span>，依此类推。
参数varIndex是可选的，指定新的项或行在对象中的位置。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>如果提供一个有效的 varIndex 的值，AddItem 方法就把项或行放在列表中的那个位置。如果忽略 varIndex，此方法就把项或行添加在列表的末尾。对于多列列表框或者组合框，AddItem 方法插入一个完整的行，为控件的每一列都插入一项。为了给第一列后面的项赋值，可用 List 或 Column 属性来规定项的行和列。</p>
<p>对于工作表中使用窗体添加的列表框控件使用 AddItem 方法添加列表项，如下面的代码所示。</p>
<div><pre><code><span>Sub</span> AddItem<span>(</span><span>)</span>
	<span>Dim</span> iRow <span>As</span> <span>Integer</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	iRow <span>=</span> Sheet1<span>.</span>Range<span>(</span><span>"A65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row
	<span>With</span> Sheet2<span>.</span>Shapes<span>(</span><span>"列表框"</span><span>)</span><span>.</span>ControlFormat
		<span>.</span>RemoveAllItems
		<span>For</span> i <span>=</span> <span>1</span> <span>To</span> iRow
			<span>.</span>AddItem Sheet1<span>.</span>Cells<span>(</span>i<span>,</span> <span>1</span><span>)</span>
		<span>Next</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>代码解析：</p>
<p>AddItem 过程设置使用 AddItem 方法添加为工作表中使用窗体控件添加的列表框添加列表项。</p>
<p>其中第 5 行代码使用 ControlFormat 属性来返回窗体控件，第 6 行代码使用 RemoveAllItems 方法删除窗体控件中的列表框的所有数据项，如果控件是 ActiveX  列表框则需要使用 Clear 方法。</p>
<h2 id="_110、去除列表框数据源的重复值和空格"> 110、去除列表框数据源的重复值和空格</h2>
<p>列表框的数据源引用工作表的数据时，如果工作表数据有重复值和空格，列表框也会出现重复值和空格，如图 110-1 所示。</p>
<div>
<p><img src="./assets/110-1.png" alt="" loading="lazy"></p>
<p><u>图 110-1</u>	列表框中的重复值和空格</p>
</div>
<p>为了在窗体显示时去除列表框的重复值和空格，可以使用 Add 方法，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	<span>Dim</span> Col <span>As</span> <span>New</span> Collection
	<span>Dim</span> rng <span>As</span> Range<span>,</span> arr
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>For</span> <span>Each</span> rng <span>In</span> Range<span>(</span><span>"A1:A"</span> <span>&amp;</span> [a65536]<span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row<span>)</span>
		<span>If</span> Trim<span>(</span>rng<span>)</span> <span>&lt;</span><span>></span> <span>""</span> <span>Then</span>
			Col<span>.</span>Add rng<span>,</span> key<span>:</span><span>=</span><span>CStr</span><span>(</span>rng<span>)</span>
		<span>End</span> <span>If</span>
	<span>Next</span>
	<span>ReDim</span> arr<span>(</span><span>1</span> <span>To</span> Col<span>.</span>Count<span>)</span>
	<span>For</span> i <span>=</span> <span>1</span> <span>To</span> Col<span>.</span>Count
		arr<span>(</span>i<span>)</span> <span>=</span> Col<span>(</span>i<span>)</span>
	<span>Next</span>
	<span>Me</span><span>.</span>ListBox1<span>.</span>List <span>=</span> arr
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>代码解析：</p>
<p>窗体的初始化事件，去除列表框引用工作表数据中的重复值和空格。</p>
<p>第 2 行代码，错误处理语句，忽略错误。</p>
<p>第 3 行到第 5 行代码，声明变量类型。</p>
<p>第 6 行到第 9 行代码代码，在列表框引用的工作表数据中循环，把工作表数据源中的空格去除后使用 Add 方法添加到变量 Col 中。Add 方法添加一个成员到 Collection 对象，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>Add item<span>,</span> key<span>,</span> before<span>,</span> after

参数<span>object</span>是必需的，一个有效的对象。
参数Item是必需的，任意类型的表达式，指定要添加到集合中的成员。
参数Key是可选的，唯一字符串表达式，指定可以使用的键字符串，代替位置索引来访问集合中的成员。
如果指定的key和集合中现有成员的key发生重复，则会导致错误发生。所以在第<span>2</span>行代码中使用错误处理语句，忽略错误，继续执行下一句代码，这样就将数据源中的重复值去除。
参数before是可选的，指定集合中的相对位置。在集合中将添加的成员放置在before参数识别的成员之前。如果参数是数值表达式，则before必须是介于 <span>1</span> 和集合Count属性值之间的值。如果参数是字符串表达式，则当添加一个被引用的成员到集合时，before 必须对应于指定的key值。可以指定before位置或after位置，但不能同时指定这两个位置。
参数after是可选的，指定集合中的相对位置。在集合中将添加的成员放置在After参数识别的成员之后。如果参数是数值表达式，则after必须是介于 <span>1</span> 和集合Count属性值之间的值；如果参数是字符串表达式，则当添加一个被引用的成员到集合时，after 必须对应于指定的key值。可以指定before位置或after位置，但不能同时指定这两个位置。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>第 10 行到第 14 行代码，重新定义数组 arr 大小，把 Col 中数据赋给数组。</p>
<p>第 15 行代码，把数组 arr 复制到列表框中。</p>
<p>运行窗体，窗体中的列表框引用去除重复值和空格后的工作表数据，如图 110-2 所示。</p>
<div>
<p><img src="./assets/110-2.png" alt="" loading="lazy"></p>
<p><u>图 110-2</u>	去除重复值和空格的列表框</p>
</div>
<h2 id="_111、移动列表框条目"> 111、移动列表框条目</h2>
<p>将列表框中的条目进行上下移动，如下面的代码所示。</p>
<div><pre><code><span>Dim</span> Intlist <span>As</span> <span>Integer</span>
<span>Dim</span> Strlist <span>As</span> <span>String</span>
<span>Private</span> <span>Sub</span> CommandButton1_Click<span>(</span><span>)</span> 
	<span>With</span> <span>Me</span><span>.</span>ListBox1
		Intlist <span>=</span> <span>.</span>ListIndex
		<span>Select</span> <span>Case</span> Intlist
			<span>Case</span> <span>-</span><span>1</span>
				MsgBox <span>"请选择一行后再移动!"</span>
			<span>Case</span> <span>0</span>
				MsgBox <span>"已经是最上一行了!"</span>
			<span>Case</span> <span>Is</span> <span>></span> <span>0</span>
				Strlist <span>=</span> <span>.</span>List<span>(</span>Intlist<span>)</span>
				<span>.</span>List<span>(</span>Intlist<span>)</span> <span>=</span> <span>.</span>List<span>(</span>Intlist <span>-</span> <span>1</span><span>)</span>
				<span>.</span>List<span>(</span>Intlist <span>-</span> <span>1</span><span>)</span> <span>=</span> Strlist
				<span>.</span>ListIndex <span>=</span> Intlist <span>-</span> <span>1</span>
		<span>End</span> <span>Select</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
<span>Private</span> <span>Sub</span> CommandButton2_Click<span>(</span><span>)</span> 
	<span>With</span> ListBox1
		Intlist <span>=</span> <span>.</span>ListIndex
		<span>Select</span> <span>Case</span> Intlist
			<span>Case</span> <span>-</span><span>1</span>
				MsgBox <span>"请选择一行后再移动!"</span>
			<span>Case</span> <span>.</span>ListCount <span>-</span> <span>1</span>
				MsgBox <span>"已经是最下一行了!"</span>
			<span>Case</span> <span>Is</span> <span>&lt;</span> <span>.</span>ListCount <span>-</span> <span>1</span>
				Strlist <span>=</span> <span>.</span>List<span>(</span>Intlist<span>)</span>
				<span>.</span>List<span>(</span>Intlist<span>)</span> <span>=</span> <span>.</span>List<span>(</span>Intlist <span>+</span> <span>1</span><span>)</span>
				<span>.</span>List<span>(</span>Intlist <span>+</span> <span>1</span><span>)</span> <span>=</span> Strlist
				<span>.</span>ListIndex <span>=</span> Intlist <span>+</span> <span>1</span>
		<span>End</span> <span>Select</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><p>代码解析：</p>
<p>第 1、2 行代码在模块顶部声明两个变量分别用于保存列表框当前选中行的索引和内容。</p>
<p>第 3 行到第 18 行代码，将列表框当前选中行的内容上移一行的代码。其中第 5 行代码使用变量 Intlist 保存列表框当前选中行的索引号，第 6 行代码判断索引号,，第 7、8 行代码如果变量 Intlist 值为 -1 ，说明当前没有选中的行，显示一个消息框进行提示。第 9、10 行代码变量 Intlist 值为 0 ，说明当前选中的行已是第一行了。</p>
<p>列表框的 ListIndex 属性指定当前选中的列表框或组合框条目，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>ListIndex [<span>=</span> <span>Variant</span>]

参数<span>object</span>是必需的，一个有效的对象。
参数<span>Variant</span>是可选的，控件中当前被选的条目。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第 11 行到第 15 行代码将当前选中的行向下移动一行，其中第 12 行代码将当前选中的行的内容赋给变量 Strlist，第 13 行代码将当前选中行的内容更改为下面一行的内容，第 14 行代码将当前选中行的下面一行的内容更改为变量 Strlist 保存的内容，第 15 行代码将选中行向下移动一行，这样就将当前选中的行向下移动了一行。</p>
<p>第 19 行到第 34 行代码将当前选中的行向上移动一行。</p>
<p>将移动后的列表框条目保存到工作表中的代码如下：</p>
<div><pre><code><span>Private</span> <span>Sub</span> CommandButton3_Click<span>(</span><span>)</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>For</span> i <span>=</span> <span>1</span> <span>To</span> ListBox1<span>.</span>ListCount
		Sheet1<span>.</span>Cells<span>(</span>i <span>+</span> <span>1</span><span>,</span> <span>1</span><span>)</span> <span>=</span> ListBox1<span>.</span>List<span>(</span>i <span>-</span> <span>1</span><span>)</span>
	<span>Next</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>代码解析：</p>
<p>窗体中“保存”按钮的单击过程，将移动后的列表框条目保存到工作表。</p>
<p>第 3 行到第 5 行代码使用 For...Next 语句循环遍历列表框所有条目，将 List 属性返回的列表框的列表条目写入到工作表中。List 属性返回或设置列表框或组合框的列表条目数，语法请参阅 109-2。</p>
<p>运行窗体效果如所示。</p>
<div>
<p><img src="./assets/111-1.png" alt="" loading="lazy"></p>
<p><u>图 111-1</u>	移动列表框条目</p>
</div>
<h2 id="_112、允许多项选择的列表框"> 112、允许多项选择的列表框</h2>
<p>一般情况下在显示的列表框中用户只能选择一个列表项，而经过简单的设置，列表框条目前可以显示选项按钮，允许进行多项选择，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	<span>Dim</span> arr <span>As</span> <span>Variant</span>
	arr <span>=</span> Array<span>(</span><span>"经理室"</span><span>,</span> <span>"办公室"</span><span>,</span> <span>"生技科"</span><span>,</span> <span>"财务科"</span><span>,</span> <span>"营业部"</span><span>,</span> <span>"制水车间"</span><span>,</span> <span>"污水厂"</span><span>,</span> <span>"安装公司"</span><span>,</span> <span>"其他"</span><span>)</span>
	<span>With</span> <span>Me</span><span>.</span>ListBox1
		<span>.</span>List <span>=</span> arr
		<span>.</span>ListStyle <span>=</span> <span>1</span>
		<span>.</span>MultiSelect <span>=</span> <span>1</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>代码解析：</p>
<p>窗体的 Initialize 事件过程，在窗体初始化时对列表框进行设置。</p>
<p>其中第 5 行代码使用 List 属性为列表框添加列表项，请参阅 109-2。</p>
<p>第 6 行代码将列表框的 ListStyle 属性设置为 1（fmListStyleOption），显示用于多重选择列表的复选框，ListStyle 属性规定列表框或组合框中的列表的外观，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>ListStyle [<span>=</span> fmListStyle]

参数<span>object</span>是必需的，一个有效的对象。
参数fmListStyle是可选的，列表的可视风格，设置值如表格 <span>112</span><span>-</span><span>1</span>所示。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><u>表格 112-1</u>	fmListStyle 设置值</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>fmListStylePlain</td>
<td>0</td>
<td>外观与常规的列表框相似，条目的背景为高亮</td>
</tr>
<tr>
<td>fmListStyleOption</td>
<td>1</td>
<td>显示选项按钮，或显示用于多重选择列表的复选框（默认）。当用户选定组中的条目时，与该条目相关的选项按钮即被选中，而该组其他条目的选项按钮则被取消选择</td>
</tr>
</tbody>
</table>
<p>ListStyle 属性可用来改变列表框或组合框的可视外观。通过一种不同于 fmListStylePlain 的设置，可以将任意控件的内容作为一组单独项目演示，每个项目都包含一个可视记号用以表示它是否被选中。</p>
<p>如果控件支持单一选择（MultiSelect 属性被设置为 mMultiSelectSingle），则可按下组中的一个按钮。如果控件支持多重选择，则可以按下组中两个或更多的按钮。</p>
<p>第 7 行代码将 MultiSelect 属性设置为 1（fmMultiSelectMulti），允许列表框进行多项选择，MultiSelect 属性表示对象是否允许多项选择，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>MultiSelect [<span>=</span> fmMultiSelect]

参数<span>object</span>是必需的，一个有效的对象。
参数fmMultiSelect是可选的，控件所用的选择方式，设置值如表格 <span>112</span><span>-</span><span>2</span> 所示。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><u>表格 112-2</u>	fmMultiSelect 设置值</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>fmMultiSelectSingle</td>
<td>0</td>
<td>只可选择一个条目（默认）</td>
</tr>
<tr>
<td>fmMultiSelectMulti</td>
<td>1</td>
<td>按空格键或单击鼠标以选定列表中一个条目或取消选定</td>
</tr>
<tr>
<td>fmMultiSelectExtended</td>
<td>2</td>
<td>按 Shift 并单击鼠标，或按 Shift 的同时按一个方向键，将所选条目由前一项扩展到当前项。按 Ctrl 的同时单击鼠标可选定或取消选定</td>
</tr>
</tbody>
</table>
<p>经过以上设置，列表框显示时可以进行多项选择并且条目前都有一个选项按钮用以表示它是否被选中，如图 112-1 所示。</p>
<div>
<p><img src="./assets/112-1.png" alt="" loading="lazy"></p>
<p><u>图 112-1</u>	允许多项选择的列表框</p>
</div>
<p>如果将列表框的 ListStyle 属性设置为 0 则与常规的列表框相似。</p>
<p>如果将列表框的 MultiSelect 属性设置 0 则列表框只能进行单项选择，如图 112-2 所示。</p>
<div>
<p><img src="./assets/112-2.png" alt="" loading="lazy"></p>
<p><u>图 112-2</u>	允许单项选择的列表框</p>
</div>
<p>通过列表框的 Selected 属性值可以判断列表框中条目的选定状态，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> CommandButton1_Click<span>(</span><span>)</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>Dim</span> s <span>As</span> <span>String</span>
	<span>For</span> i <span>=</span> <span>0</span> <span>To</span> ListBox1<span>.</span>ListCount <span>-</span> <span>1</span>
		<span>If</span> ListBox1<span>.</span>Selected<span>(</span>i<span>)</span> <span>=</span> <span>True</span> <span>Then</span>
			s <span>=</span> s <span>&amp;</span> ListBox1<span>.</span>List<span>(</span>i<span>)</span> <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span>
		<span>End</span> <span>If</span>
	<span>Next</span>
	<span>If</span> s <span>&lt;</span><span>></span> <span>""</span> <span>Then</span>
		MsgBox <span>"你选择了："</span> <span>&amp;</span> Chr<span>(</span><span>13</span><span>)</span> <span>&amp;</span> s
	<span>Else</span>
		MsgBox <span>"请最少选择一个部门!"</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>代码解析：</p>
<p>按钮的单击过程，将列表框中选中的条目使用消息框显示出来。</p>
<p>第 4 行到第 8 行代码使用 For...Next 语句循环遍历列表框所有条目，通过返回的 Selected 属性值判断列表框中条目的选定状态，如果处于选中状态，第 6 行代码将列表框选中条目的值赋给字符串变量 s。</p>
<p>Selected 属性判断列表框中条目的选定状态，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>Selected<span>(</span> index <span>)</span> [<span>=</span> <span>Boolean</span>]

参数<span>object</span>是必需的，一个有效的对象。
参数index是必需的，整数，取值范围是<span>0</span>到列表中的条目数减<span>1</span>之间的数值。
参数<span>Boolean</span>是必需的，判断一个条目是否被选中。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>第 9 行到第 13 行代码使用消息框显示列表框中选中的条目。</p>
<p>运行窗体结果如图 112-3 所示。</p>
<div>
<p><img src="./assets/112-3.png" alt="" loading="lazy"></p>
<p><u>图 112-3</u>	允许多项选择的列表框</p>
</div>
<h2 id="_113、多列组合框和列表框的设置"> 113、多列组合框和列表框的设置</h2>
<h3 id="_1-多列组合框和列表框添加列表项"> 1）多列组合框和列表框添加列表项</h3>
<p>如果组合框和列表框是多列的话，除了使用 109 的方法外，还需要设置控件的其他属性，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	<span>Dim</span> iRow <span>As</span> <span>Integer</span>
	<span>Dim</span> Arr <span>As</span> <span>Variant</span>
	iRow <span>=</span> Sheet1<span>.</span>Range<span>(</span><span>"A65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row
	Arr <span>=</span> Sheet1<span>.</span>Range<span>(</span><span>"A1:G"</span> <span>&amp;</span> iRow<span>)</span>
	<span>With</span> <span>Me</span><span>.</span>ListBox1
		<span>.</span>ColumnCount <span>=</span> <span>7</span>
		<span>.</span>ColumnWidths <span>=</span> <span>"45,45,45,45,45,30,45"</span>
		<span>.</span>BoundColumn <span>=</span> <span>1</span>
		<span>.</span>Column <span>=</span> Application<span>.</span>WorksheetFunction<span>.</span>Transpose<span>(</span>Arr<span>)</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>代码解析：</p>
<p>在窗体初始化时为多列列表框添加列表项。</p>
<p>第 4 行代码，设置列表框显示的列数。ColumnCount  属性指定列表框或组合框的显示列数，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>ColumnCount [<span>=</span> <span>Long</span>]

参数<span>object</span>是必需的，一个有效的对象。
参数<span>Long</span>是可选的，指定需显示的列数。
如果将ColumnCount设为 <span>-</span><span>1</span>，将显示所有列。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>第 8 行代码，设置列表框各列的宽度。ColumnWidths 属性指定多列的组合框或列表框中的各列的宽度，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>ColumnWidths [<span>=</span> <span>String</span>]

参数<span>object</span>是必需的，一个有效的对象。
参数<span>String</span>是可选的，以磅为单位设置列的宽度。
如将ColumnWidths 属性设为 <span>-</span><span>1</span> 或空，则将控件宽度等分，给予列表中的各列。设为 <span>0</span> 则隐藏该列，大于 <span>0</span> 的数值则是该列的精确宽度值。若要指定另一种不同的度量单位，设置时必须包括该度量单位。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>第 9 行代码，设置多列列表框中的第一列为数据的来源。BoundColumn 属性标识多列组合框或列表框中的数据的来源，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>BoundColumn [<span>=</span> <span>Variant</span>]

参数<span>object</span>是必需的，一个有效的对象。
参数<span>Variant</span>是可选的，标识选择 BoundColumn 属性值的方法，设置值如表格 <span>113</span><span>-</span><span>1</span>所示：
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><u>表格 113-1</u>	Variant 的设置值</p>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>将 ListIndex 属性的值赋予控件。</td>
</tr>
<tr>
<td>1 或者大于 1</td>
<td>将指定列中的值赋予控件。当采用此属性时，列从 1 开始计数（默认值）。</td>
</tr>
</tbody>
</table>
<p>当选择了多列列表框的一行时，BoundColumn 属性标识出将该行的哪一条目作为控件的值存储。BoundColumn 属性设为 0，将所选行的行号赋予控件，作为控件的值。如果 BoundColumn 属性设为 1 或者大于 1，则将指定列中的值赋予控件。</p>
<p>第 10 行代码，设置多列列表框中列表的来源。在设置列表来源时除了可以使用 109 所介绍的方法外，还可以使用 Column 属性指定列表框中的一个或多个条目，Column 属性语法如下：</p>
<div><pre><code><span>object</span><span>.</span>Column<span>(</span> column<span>,</span> row <span>)</span> [<span>=</span> <span>Variant</span>]

参数<span>object</span>是必需的，一个有效对象。
参数column是可选的，取值范围为<span>0</span>到总列数减<span>1</span>之间的数值。
参数row是可选的，取值范围为<span>0</span>到总行数减<span>1</span>之间的数值。
参数<span>Variant</span>是可选的，指定欲加载到列表框的一个值、一列值或一个二维数组。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><p>注意</p>
<p>当从一个二维数组中复制数据时，使用 Column 属性将转置控件中数组的内容，所以在加载时需使用 Transpose 函数对数组进行转置。</p>
</div>
<p>多列列表框设置完成后效果如图 113-1 所示。</p>
<div>
<p><img src="./assets/113-1.png" alt="" loading="lazy"></p>
<p><u>图 113-1</u>	多列列表框</p>
</div>
<h3 id="_2-多列列表框写入工作表"> 2）多列列表框写入工作表</h3>
<p>在把多列列表框的写入工作表中时，只能把 BoundColumn 属性所指定列中的值写入工作表中，不能把选中的整行内容写入到工作表中。如果需要把多列列表框中选中行的整行内容写入工作表中，可以使用循环语句将列表框各列的写入工作表，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	<span>Dim</span> iRow <span>As</span> <span>Integer</span>
	iRow <span>=</span> Sheet2<span>.</span>Range<span>(</span><span>"A65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row
	<span>With</span> <span>Me</span><span>.</span>ListBox1
		<span>.</span>ColumnCount <span>=</span> <span>7</span>
		<span>.</span>ColumnWidths <span>=</span> <span>"45,45,45,45,45,30,45"</span>
		<span>.</span>BoundColumn <span>=</span> <span>1</span>
		<span>.</span>ColumnHeads <span>=</span> <span>True</span>
		<span>.</span>RowSource <span>=</span> Sheet2<span>.</span>Range<span>(</span><span>"A2:G"</span> <span>&amp;</span> iRow<span>)</span><span>.</span>Address<span>(</span>External<span>:</span><span>=</span><span>True</span><span>)</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
<span>Private</span> <span>Sub</span> ListBox1_Click<span>(</span><span>)</span>
	<span>Dim</span> iRow <span>As</span> <span>Integer</span>
	<span>Dim</span> i <span>As</span> <span>Byte</span>
	iRow <span>=</span> Sheet1<span>.</span>Range<span>(</span><span>"A65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row <span>+</span> <span>1</span>
	<span>For</span> i <span>=</span> <span>1</span> <span>To</span> ListBox1<span>.</span>ColumnCount
		Sheet1<span>.</span>Cells<span>(</span>iRow<span>,</span> i<span>)</span> <span>=</span> ListBox1<span>.</span>Column<span>(</span>i <span>-</span> <span>1</span><span>)</span>
	<span>Next</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>代码解析：</p>
<p>第 1 行到第 11 行代码窗体的 Initialize 事件过程，在窗体初始化时为多列列表框添加列表项，请参阅 113-1。</p>
<p>第 8 行代码，设置多列列表框中的第一行为列标题行。ColumnHeads 属性显示列表框、组合框及接受列题注的对象中的列标题行，语法如下：</p>
<div><pre><code>object.ColumnHeads [= Boolean]

参数object是必需的，一个有效的对象。
参数Boolean是可选的，指定是否显示列标题。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>将 ColumnHeads 属性设置为 True，多列列表框的第一行显示为列标题，默认值为 False，不显示列标题。</p>
<p>需要注意的是，当数据项中的第一行作为列标题时，则不可选中该行。</p>
<p>第 9 行代码，使用 RowSource 属性设置多列列表框中列表的来源。关于 RowSource 属性请参阅 109-1。</p>
<div><p>注意</p>
<p>如果已将多列列表框中列表项来源的第一行设置为列标题，在设置 RowSource 属性时应从列表项来源的第二行开始设置。</p>
</div>
<p>第 12 行到第 19 行代码列表框的 Click 事件，单击多列列表框时把选中行的整行内容写入工作表中。其中第 17 行代码，使用循环语句将多列列表框选中行的各列的值写入工作表对应的单元格中。关于 Column 属性请参阅 113-1，在本例中没有指定 row 参数，所以是把当前选中行的内容写入工作表。</p>
<p>运行窗体后，单击列表框将选中的整行内容写入工作表中，如图 113-2 所示。</p>
<div>
<p><img src="./assets/113-2.png" alt="" loading="lazy"></p>
<p><u>图 113-2</u>	多列列表框选中的整行内容写入工作表</p>
</div>
<h2 id="_114、输入时逐步提示信息"> 114、输入时逐步提示信息</h2>
<p>用户在录入数据时，比如在工作表中输入产品名称，除了希望有所有产品名称的下拉列表供选择外，更希望能逐步给出提示信息。比如在输入一两个字符后把符合条件的数据筛选出来供选择，最好是中英文、拼音首字母、大小写能混合查询，如输入“LJ”或“六角”后所有以“六角”开头的产品名称都筛选到列表中供选择，这将大大提高录入速度和正确率。</p>
<p>为了达到这一目的，首先在工作簿需要有如图 114-1 所示的基础数据表。</p>
<div>
<p><img src="./assets/114-1.png" alt="" loading="lazy"></p>
<p><u>图 114-1</u>	基础数据表</p>
</div>
<p>基础数据表中 A 列保存不重复的产品名称，为了能用中英文、拼音首字母、大小写混合查询，要把产品名称转换成小写的拼音首字母保存在 B 列。</p>
<ul>
<li>步骤 1：在 VBE 窗口单击菜单“插入”→“模块”，在代码窗口写入下面的代码。</li>
</ul>
<div><pre><code><span>Public</span> <span>Function</span> LChin<span>(</span>Str <span>As</span> <span>String</span><span>)</span> <span>As</span> <span>Variant</span>
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	Str <span>=</span> StrConv<span>(</span>Str<span>,</span> vbNarrow<span>)</span>
	<span>If</span> Asc<span>(</span>Str<span>)</span> <span>></span> <span>0</span> <span>Or</span> Err<span>.</span>Number <span>=</span> <span>1004</span> <span>Then</span> LChin <span>=</span> <span>""</span>
	LChin <span>=</span> WorksheetFunction<span>.</span>VLookup<span>(</span>Str<span>,</span> [<span>{</span><span>"吖"</span><span>,</span><span>"a"</span>;<span>"八"</span><span>,</span><span>"b"</span>;<span>"嚓"</span><span>,</span><span>"c"</span>;<span>"咑"</span><span>,</span><span>"d"</span>;<span>"鵽"</span><span>,</span><span>"e"</span>;<span>"发"</span><span>,</span><span>"f"</span>;<span>"猤"</span><span>,</span><span>"g"</span>;<span>"铪"</span><span>,</span><span>"h"</span>;<span>"夻"</span><span>,</span><span>"j"</span>;<span>"咔"</span><span>,</span><span>"k"</span>;<span>"垃"</span><span>,</span><span>"l"</span>;<span>"嘸"</span><span>,</span><span>"m"</span>;<span>"旀"</span><span>,</span><span>"n"</span>;<span>"噢"</span><span>,</span><span>"o"</span>;<span>"妑"</span><span>,</span><span>"p"</span>;<span>"七"</span><span>,</span><span>"q"</span>;<span>"囕"</span><span>,</span><span>"r"</span>;<span>"仨"</span><span>,</span><span>"s"</span>;<span>"他"</span><span>,</span><span>"t"</span>;<span>"屲"</span><span>,</span><span>"w"</span>;<span>"夕"</span><span>,</span><span>"x"</span>;<span>"丫"</span><span>,</span><span>"y"</span>;<span>"帀"</span><span>,</span><span>"z"</span><span>}</span>]<span>,</span> <span>2</span><span>)</span>
<span>End</span> <span>Function</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>代码解析：</p>
<p>自定义 LChin 函数，该函数把中文字符转换为拼音首字母。</p>
<ul>
<li>步骤 2：在 VBE 窗口双击 Sheet2 表，在代码窗口写入下面的代码。</li>
</ul>
<div><pre><code><span>Private</span> <span>Sub</span> Worksheet_Change<span>(</span><span>ByVal</span> Target <span>As</span> Range<span>)</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>Dim</span> myStr <span>As</span> <span>String</span>
	<span>With</span> Target
		<span>If</span> <span>.</span>Column <span>&lt;</span><span>></span> <span>1</span> <span>Or</span> <span>.</span>Count <span>></span> <span>1</span> <span>Then</span> <span>Exit</span> <span>Sub</span>
		<span>If</span> WorksheetFunction<span>.</span>CountIf<span>(</span>Sheet2<span>.</span>Range<span>(</span><span>"A:A"</span><span>)</span><span>,</span> <span>.</span>Value<span>)</span> <span>></span> <span>1</span> <span>Then</span>
			<span>.</span>Value <span>=</span> <span>""</span>
			MsgBox <span>"不能输入重复的产品名称!"</span><span>,</span> <span>64</span>
			<span>Exit</span> <span>Sub</span>
		<span>End</span> <span>If</span>
		<span>For</span> i <span>=</span> <span>1</span> <span>To</span> Len<span>(</span><span>.</span>Value<span>)</span>
			<span>If</span> Asc<span>(</span>Mid<span>$</span><span>(</span><span>.</span>Value<span>,</span> i<span>,</span> <span>1</span><span>)</span><span>)</span> <span>></span> <span>255</span> <span>Or</span> Asc<span>(</span>Mid<span>$</span><span>(</span><span>.</span>Value<span>,</span> i<span>,</span> <span>1</span><span>)</span><span>)</span> <span>&lt;</span> <span>0</span> <span>Then</span>
				myStr <span>=</span> myStr <span>&amp;</span> LChin<span>(</span>Mid<span>$</span><span>(</span><span>.</span>Value<span>,</span> i<span>,</span> <span>1</span><span>)</span><span>)</span>
			<span>Else</span>
				myStr <span>=</span> myStr <span>&amp;</span> LCase<span>(</span>Mid<span>$</span><span>(</span><span>.</span>Value<span>,</span> i<span>,</span> <span>1</span><span>)</span><span>)</span>
			<span>End</span> <span>If</span>
		<span>Next</span>
		<span>.</span>Offset<span>(</span><span>,</span> <span>1</span><span>)</span><span>.</span>Value <span>=</span> myStr
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>代码解析：</p>
<p>工作表的 Change 事件，当 A 列输入不重复的产品名称后，转换成小写的字母保存在 B 列的单元格中，便于以后的查询。</p>
<p>第 11 行代码，设置事件触发的条件，只有在 A 列输入产品名称后才触发 Change 事件。</p>
<p>第 12 行到第 16 行代码，使用工作表 CountIf 函数检查输入的产品名称是否重复。</p>
<p>第 17 行到第 23 行代码，字符的转换过程。首先检查是否是中文字符，如果是使用自定义函数 LChin 转换成小写拼音首字母。如果是大写的英文字母使用 LCase 函数转换成小写字母。</p>
<p>第 24 行代码，将转换后的字符保存到 B 列。</p>
<ul>
<li>步骤 3：基础数据表完成后，在工作表“录入表”中添加一个文本框控件和一个列表框控件。在 VBE 窗口中双击 Sheet1 表，写入下面的代码。</li>
</ul>
<div><pre><code><span>Private</span> <span>Sub</span> Worksheet_SelectionChange<span>(</span><span>ByVal</span> Target <span>As</span> Range<span>)</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>If</span> Target<span>.</span>Count <span>=</span> <span>1</span> <span>Then</span>
		<span>If</span> Target<span>.</span>Column <span>=</span> <span>1</span> <span>And</span> Target<span>.</span>Row <span>></span> <span>1</span> <span>Then</span>
			<span>With</span> <span>Me</span><span>.</span>TextBox1
				<span>.</span>Visible <span>=</span> <span>True</span>
				<span>.</span>Top <span>=</span> Target<span>.</span>Top
				<span>.</span>Left <span>=</span> Target<span>.</span>Left
				<span>.</span>Width <span>=</span> Target<span>.</span>Width
				<span>.</span>Height <span>=</span> Target<span>.</span>Height
				<span>.</span>Activate
			<span>End</span> <span>With</span>
			<span>With</span> <span>Me</span><span>.</span>ListBox1
				<span>.</span>Visible <span>=</span> <span>True</span>
				<span>.</span>Top <span>=</span> Target<span>.</span>Top
				<span>.</span>Left <span>=</span> Target<span>.</span>Left <span>+</span> Target<span>.</span>Width
				<span>.</span>Width <span>=</span> Target<span>.</span>Width
				<span>.</span>Height <span>=</span> Target<span>.</span>Height <span>*</span> <span>5</span>
				<span>For</span> i <span>=</span> <span>2</span> <span>To</span> Sheet2<span>.</span>Range<span>(</span><span>"A65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row
					<span>.</span>AddItem Sheet2<span>.</span>Cells<span>(</span>i<span>,</span> <span>1</span><span>)</span><span>.</span>Value
				<span>Next</span>
			<span>End</span> <span>With</span>
		<span>Else</span>
			<span>Me</span><span>.</span>ListBox1<span>.</span>Clear
			<span>Me</span><span>.</span>TextBox1 <span>=</span> <span>""</span>
			<span>Me</span><span>.</span>ListBox1<span>.</span>Visible <span>=</span> <span>False</span>
			<span>Me</span><span>.</span>TextBox1<span>.</span>Visible <span>=</span> <span>False</span>
		<span>End</span> <span>If</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>代码解析：</p>
<p>工作表的 SelectionChange 事件，当用户选定工作表 A 列第 2 行以下的单个单元格时，设置文本框和列表框的 Visible 为 True，使它们成为可见的，并设置其外观，同时给列表框加载列表项。当用户选定其他列的单元格时隐藏文本框和列表框控件。</p>
<ul>
<li>步骤 4：在设计模式下双击文本框，在代码窗口写入下面的代码。</li>
</ul>
<div><pre><code><span>Private</span> <span>Sub</span> TextBox1_KeyUp<span>(</span><span>ByVal</span> KeyCode <span>As</span> MSForms<span>.</span>ReturnInteger<span>,</span> <span>ByVal</span> Shift <span>As</span> <span>Integer</span><span>)</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>Dim</span> Language <span>As</span> <span>Boolean</span>
	<span>Dim</span> myStr <span>As</span> <span>String</span>
	<span>Me</span><span>.</span>ListBox1<span>.</span>Clear
	<span>With</span> <span>Me</span><span>.</span>TextBox1
		<span>For</span> i <span>=</span> <span>1</span> <span>To</span> Len<span>(</span><span>.</span>Value<span>)</span>
			<span>If</span> Asc<span>(</span>Mid<span>$</span><span>(</span><span>.</span>Value<span>,</span> i<span>,</span> <span>1</span><span>)</span><span>)</span> <span>></span> <span>255</span> <span>Or</span> Asc<span>(</span>Mid<span>$</span><span>(</span><span>.</span>Value<span>,</span> i<span>,</span> <span>1</span><span>)</span><span>)</span> <span>&lt;</span> <span>0</span> <span>Then</span>
				Language <span>=</span> <span>True</span>
				myStr <span>=</span> myStr <span>&amp;</span> Mid<span>$</span><span>(</span><span>.</span>Value<span>,</span> i<span>,</span> <span>1</span><span>)</span>
			<span>Else</span>
				myStr <span>=</span> myStr <span>&amp;</span> LCase<span>(</span>Mid<span>$</span><span>(</span><span>.</span>Value<span>,</span> i<span>,</span> <span>1</span><span>)</span><span>)</span>
			<span>End</span> <span>If</span>
		<span>Next</span>
	<span>End</span> <span>With</span>
	<span>With</span> Sheet2
		<span>For</span> i <span>=</span> <span>2</span> <span>To</span> <span>.</span>Range<span>(</span><span>"A65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row
			<span>If</span> Language <span>=</span> <span>True</span> <span>Then</span>
				<span>If</span> Left<span>(</span><span>.</span>Cells<span>(</span>i<span>,</span> <span>1</span><span>)</span><span>.</span>Value<span>,</span> Len<span>(</span>myStr<span>)</span><span>)</span> <span>=</span> myStr <span>Then</span>
					<span>Me</span><span>.</span>ListBox1<span>.</span>AddItem <span>.</span>Cells<span>(</span>i<span>,</span> <span>1</span><span>)</span><span>.</span>Value
				<span>End</span> <span>If</span>
			<span>Else</span>
				<span>If</span> Left<span>(</span><span>.</span>Cells<span>(</span>i<span>,</span> <span>2</span><span>)</span><span>.</span>Value<span>,</span> Len<span>(</span>myStr<span>)</span><span>)</span> <span>=</span> myStr <span>Then</span>
					<span>Me</span><span>.</span>ListBox1<span>.</span>AddItem <span>.</span>Cells<span>(</span>i<span>,</span> <span>1</span><span>)</span><span>.</span>Value
				<span>End</span> <span>If</span>
			<span>End</span> <span>If</span>
		<span>Next</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>代码解析：</p>
<p>文本框的 KeyUp 事件，在文本框输入查询条件时筛选符合条件的数据加载到列表框。</p>
<p>第 3 行代码，声明变量 Language 为 Boolean 数据类型，在下面的代码中使用 Language 的值判断输入的是否为中文。</p>
<p>第 5 行代码，使用 Clear 方法删除列表框所有的列表项，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>Clear

参数<span>object</span>是必需的，一个有效的对象。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><p>注意</p>
<p>如果列表框绑定了数据，Clear 方法将会失败。</p>
</div>
<p>第 6 行到第 15 行代码，判断文本框输入的是否为中文字符。如果是中文字符，将变量 Language 赋值为 True，并把文本框中的字符赋给变量 myStr。如果是英文字符则转换成小写字母后赋变量 myStr。</p>
<p>第 16 行到第 29 行代码，如果变量 Language 的值为 True，在基础数据表的 A 列中使用 Left 函数查找与文本框字符相符的单元格并加载到列表框，否则就在 B 列查找。</p>
<ul>
<li>步骤 5：在设计模式下双击文本框，在代码窗口写入下面的代码。</li>
</ul>
<div><pre><code><span>Private</span> <span>Sub</span> TextBox1_KeyDown<span>(</span><span>ByVal</span> KeyCode <span>As</span> MSForms<span>.</span>ReturnInteger<span>,</span> <span>ByVal</span> Shift <span>As</span> <span>Integer</span><span>)</span>
	<span>If</span> KeyCode <span>=</span> vbKeyReturn <span>Then</span>
		Sheet1<span>.</span>ListBox1<span>.</span>Activate
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>代码解析：</p>
<p>文本框的 KeyDown 事件，当用户在文本框中输入完成，列表框中已显示所需的内容后按回车键后选择列表框。</p>
<ul>
<li>步骤 6：在设计模式下双击列表框，在代码窗口写入下面的代码</li>
</ul>
<div><pre><code><span>Private</span> <span>Sub</span> ListBox1_GotFocus<span>(</span><span>)</span>
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	ListBox1<span>.</span>ListIndex <span>=</span> <span>0</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>代码解析：</p>
<p>列表框的 GotFocus 事件，当用户在文本框中输入完成按回车键后，选定列表框中第 1 个条目，方便用户进行下一步操作。</p>
<div><pre><code><span>Private</span> <span>Sub</span> ListBox1_KeyDown<span>(</span><span>ByVal</span> KeyCode <span>As</span> MSForms<span>.</span>ReturnInteger<span>,</span> <span>ByVal</span> Shift <span>As</span> <span>Integer</span><span>)</span>
	<span>If</span> KeyCode <span>=</span> vbKeyReturn <span>Then</span>
		ActiveCell<span>.</span>Value <span>=</span> ListBox1<span>.</span>Value
		<span>Me</span><span>.</span>ListBox1<span>.</span>Clear
		<span>Me</span><span>.</span>TextBox1 <span>=</span> <span>""</span>
		<span>Me</span><span>.</span>ListBox1<span>.</span>Visible <span>=</span> <span>False</span>
		<span>Me</span><span>.</span>TextBox1<span>.</span>Visible <span>=</span> <span>False</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>代码解析：</p>
<p>列表框的 KeyDown 事件，当用户在列表框中按下回车后将列表框选中的条目写入到活动工作表的单元格中，同时清空文本框和列表框内容后隐藏，准备下一次录入。</p>
<div><pre><code><span>Private</span> <span>Sub</span> ListBox1_DblClick<span>(</span><span>ByVal</span> Cancel <span>As</span> MSForms<span>.</span>ReturnBoolean<span>)</span>
	ActiveCell<span>.</span>Value <span>=</span> ListBox1<span>.</span>Value
	<span>Me</span><span>.</span>ListBox1<span>.</span>Clear
	<span>Me</span><span>.</span>TextBox1 <span>=</span> <span>""</span>
	<span>Me</span><span>.</span>ListBox1<span>.</span>Visible <span>=</span> <span>False</span>
	<span>Me</span><span>.</span>TextBox1<span>.</span>Visible <span>=</span> <span>False</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>列表框的 DblClick 事件，当用户双击列表框的列表项时，把列表框数据赋给活动单元格，同时清空文本框和列表框内容后隐藏，准备下一次录入。</p>
<p>以上设置完成后，在“录入”工作表的A列选定单元格后，显示一个文本框和一个列表框，在文本框中输入查询条件后列表框显示符合查询条件的所有内容供用户选择，如图 114-2 所示。</p>
<div>
<p><img src="./assets/114-2.png" alt="" loading="lazy"></p>
<p><u>图 114-2</u>	输入时逐步提示信息</p>
</div>
<h2 id="_115、二级组合框"> 115、二级组合框</h2>
<p>在使用多个组合框输入数据时，往往希望后一个组合框中的条目能根据前一个组合框的内容有所不同，如示例中第二个选择城市的组合框根据第一个选择省份的组合框所选择的不同省份加载不同的县市名称，示例代码如下：</p>
<div><pre><code><span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	<span>Dim</span> col <span>As</span> <span>New</span> Collection
	<span>Dim</span> arr <span>As</span> <span>Variant</span>
	<span>Dim</span> rng <span>As</span> Range
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	<span>For</span> <span>Each</span> rng <span>In</span> Range<span>(</span><span>"A2:A"</span> <span>&amp;</span> Sheet1<span>.</span>Range<span>(</span><span>"A65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Row<span>)</span>
		<span>If</span> rng <span>&lt;</span><span>></span> <span>""</span> <span>Then</span> col<span>.</span>Add rng<span>,</span> <span>CStr</span><span>(</span>rng<span>)</span>
	<span>Next</span>
	<span>ReDim</span> arr<span>(</span><span>1</span> <span>To</span> col<span>.</span>Count<span>)</span>
	<span>For</span> i <span>=</span> <span>1</span> <span>To</span> col<span>.</span>Count
		arr<span>(</span>i<span>)</span> <span>=</span> col<span>(</span>i<span>)</span>
	<span>Next</span>
	ComboBox1<span>.</span>List <span>=</span> arr
	ComboBox1<span>.</span>ListIndex <span>=</span> <span>0</span>
	CommandButton1<span>.</span>Accelerator <span>=</span> <span>"D"</span>
<span>End</span> <span>Sub</span>
<span>Private</span> <span>Sub</span> ComboBox1_Change<span>(</span><span>)</span>
	<span>Dim</span> myAddress <span>As</span> <span>String</span>
	<span>Dim</span> rng <span>As</span> Range
	<span>Dim</span> mymsg <span>As</span> <span>Integer</span>
	ComboBox2<span>.</span>Clear
	<span>With</span> Sheet1<span>.</span>Range<span>(</span><span>"A:A"</span><span>)</span>
		<span>Set</span> rng <span>=</span> <span>.</span>Find<span>(</span>What<span>:</span><span>=</span>ComboBox1<span>.</span>Text<span>)</span>
			<span>If</span> <span>Not</span> rng <span>Is</span> <span>Nothing</span> <span>Then</span>
				myAddress <span>=</span> rng<span>.</span>Address
				<span>Do</span>
					ComboBox2<span>.</span>AddItem rng<span>.</span>Offset<span>(</span><span>,</span> <span>1</span><span>)</span>
					<span>Set</span> rng <span>=</span> <span>.</span>FindNext<span>(</span>rng<span>)</span>
				<span>Loop</span> <span>While</span> <span>Not</span> rng <span>Is</span> <span>Nothing</span> <span>And</span> rng<span>.</span>Address <span>&lt;</span><span>></span> myAddress
			<span>End</span> <span>If</span>
		<span>End</span> <span>With</span>
		ComboBox2<span>.</span>ListIndex <span>=</span> <span>0</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><p>代码解析：</p>
<p>第 1 行到第 17 行代码窗体的 Initialize 事件过程，在窗体显示时将工作表 A 列中的省份名称去除重复后加载到组合框中。</p>
<p>其中第 7 行到第 13 行代码把工作表 A 列中的省份名称使用 Add 方法去除重复后加载到组合框中，应用于 Collection 对象的 Add 方法添加一个成员对象，请参阅 110 。</p>
<p>第 15 行代码设置组合框的 ListIndex 属性为 0，选中组合框的第一行条目。ListIndex 属性指定当前选中的列表框或组合框条目，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>ListIndex [<span>=</span> <span>Variant</span>]

参数<span>Variant</span>是可选的，控件中当前被选的条目。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>ListIndex 属性包含列表中被选行的索引，取值范围为 -1 到列表总行数减 1（即ListCount - 1）之间的数值。当用户没有选中行时，ListIndex 返回 -1。列表中第一行的 ListIndex 值是 0，第二行的 ListIndex 值是 1，依此类推。</p>
<p>第 16 行代码设置窗体中按钮的 Accelerator 属性值。Accelerator 属性设置或检索控件的加速键，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>Accelerator [<span>=</span> <span>String</span>]

参数<span>String</span>是可选的，用作加速键的字符。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>先按住 Alt 再紧接着按加速键，会将焦点定位到该对象上，并初始化与该对象关联的一个或多个事件，也就是说窗体显示后按 Alt+D 组合键将会执行“关闭”按钮中的代码关闭窗体。</p>
<p>第 18 行到第 34 行代码 ComboBox1 的 Change 事件过程，使用 Find 方法将所有属于 ComboBox1 所选择的省份的县市加载到 ComboBox2 中。关于 Find 方法请参阅 5-1。</p>
<p>窗体运行后效果如图 115-1 所示。</p>
<div>
<p><img src="./assets/115-1.png" alt="" loading="lazy"></p>
<p><u>图 115-1</u>	二级组合框</p>
</div>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-07-02T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
  <entry>
    <title type="html">VBA 之 控件与用户窗体3</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/blog/project/Excel/12.VBA_controls_form_3/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/blog/project/Excel/12.VBA_controls_form_3/"/>
    <updated>2022-01-26T06:11:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="_134、使用-treeview-控件显示层次"> 134、使用 TreeView 控件显示层次</h2>
<p>TreeView 控件是一个树形结构的控件，该控件用于显示分层数据，如目录或文件目录，使程序的表现更为灵活，用户的操作更加方便，示例代码如下：</p>
<div><pre><code><span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	<span>Dim</span> c <span>As</span> <span>Integer</span>
	<span>Dim</span> r <span>As</span> <span>Integer</span>
	<span>Dim</span> rng <span>As</span> <span>Variant</span>
	rng <span>=</span> Sheet1<span>.</span>UsedRange
	<span>With</span> <span>Me</span><span>.</span>TreeView1
		<span>.</span>Style <span>=</span> tvwTreelinesPlusMinusPictureText
		<span>.</span>LineStyle <span>=</span> tvwRootLines
		<span>.</span>CheckBoxes <span>=</span> <span>False</span>
		<span>With</span> <span>.</span>Nodes
			<span>.</span>Clear
			<span>.</span>Add Key<span>:</span><span>=</span><span>"科目"</span><span>,</span> Text<span>:</span><span>=</span><span>"科目名称"</span>
			<span>For</span> c <span>=</span> <span>1</span> <span>To</span> Sheet1<span>.</span>UsedRange<span>.</span>Columns<span>.</span>Count
				<span>For</span> r <span>=</span> <span>2</span> <span>To</span> Sheet1<span>.</span>UsedRange<span>.</span>Rows<span>.</span>Count
					<span>If</span> <span>Not</span> IsEmpty<span>(</span>rng<span>(</span>r<span>,</span> c<span>)</span><span>)</span> <span>Then</span>
						<span>If</span> c <span>=</span> <span>1</span> <span>Then</span>
							<span>.</span>Add relative<span>:</span><span>=</span><span>"科目"</span><span>,</span> relationship<span>:</span><span>=</span>tvwChild<span>,</span> Key<span>:</span><span>=</span>rng<span>(</span>r<span>,</span> c<span>)</span><span>,</span> Text<span>:</span><span>=</span>rng<span>(</span>r<span>,</span> c<span>)</span>
						<span>ElseIf</span> <span>Not</span> IsEmpty<span>(</span>rng<span>(</span>r<span>,</span> c <span>-</span> <span>1</span><span>)</span><span>)</span> <span>Then</span>
							<span>.</span>Add relative<span>:</span><span>=</span>rng<span>(</span>r<span>,</span> c <span>-</span> <span>1</span><span>)</span><span>,</span> relationship<span>:</span><span>=</span>tvwChild<span>,</span> Key<span>:</span><span>=</span>rng<span>(</span>r<span>,</span> c<span>)</span><span>,</span> Text<span>:</span><span>=</span>rng<span>(</span>r<span>,</span> c<span>)</span>
						<span>Else</span>
							<span>.</span>Add relative<span>:</span><span>=</span><span>CStr</span><span>(</span>Sheet1<span>.</span>Cells<span>(</span>r<span>,</span> c <span>-</span> <span>1</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>)</span><span>,</span> relationship<span>:</span><span>=</span>tvwChild<span>,</span> Key<span>:</span><span>=</span>rng<span>(</span>r<span>,</span> c<span>)</span><span>,</span> Text<span>:</span><span>=</span>rng<span>(</span>r<span>,</span> c<span>)</span>
						<span>End</span> <span>If</span>
					<span>End</span> <span>If</span>
				<span>Next</span>
			<span>Next</span>
		<span>End</span> <span>With</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>代码解析：</p>
<p>在窗体初始化时将工作表中的科目名称填充 TreeView 控件。</p>
<p>第 7 行代码，设置 TreeView 控件每个列表的组成方式。Style 属性设置值如表格 131-2 所示。</p>
<p><u>表格 134-1</u>	Style 属性设置值</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>tvwTextOnly</td>
<td>0</td>
<td>文本</td>
</tr>
<tr>
<td>tvwPictureText</td>
<td>1</td>
<td>图像文本</td>
</tr>
<tr>
<td>tvwPlusMinusText</td>
<td>2</td>
<td>符号文本</td>
</tr>
<tr>
<td>tvwTreelinesText</td>
<td>4</td>
<td>直线文本</td>
</tr>
<tr>
<td>tvwTreelinesPlusMinusPictureText</td>
<td>7</td>
<td>正常显示</td>
</tr>
</tbody>
</table>
<p>第 8 行代码，设置 TreeView 控件显示根节点连线。TreeView 控件的 LineStyle 属性设置为 tvwRootLines 显示根节点连线，设置为 tvwTreeLines 则隐藏根节点连线。</p>
<p>第 9 行代码，设置 TreeView 控件不显示复选框。</p>
<p>第 10 行代码使用 Nodes 属性返回对 TreeView 控件的 Node 对象的集合的引用。</p>
<p>第 11 行代码，清除 TreeView 控件所有的节点。</p>
<p>第 12 行代码，使用 Add 方法在 Treeview 控件的 Nodes 集合中添加一个 Node 对象。Add 方法语法如下：</p>
<div><pre><code><span>object</span><span>.</span>Add<span>(</span>relative<span>,</span> relationship<span>,</span> key<span>,</span> text<span>,</span> image<span>,</span> selectedimage<span>)</span>

参数<span>Object</span>是必需的，一个有效的对象。
参数Relative是可选的，代表已存在的Node对象的索引号或键值。
参数relationship是可选的，代表新节点与已存在的节点间的关系，指定的Node对象的相对位置。relationship的设置值如表格 <span>134</span><span>-</span><span>2</span>所示。
参数key是可选的，唯一的字符串，可用于用Item方法检索Node。
参数text 是必需的，在Node中出现的字符串。
参数image是可选的，代表一个图像或在ImageList控件中图象的索引。
参数selectedimage是可选的，代表一个图像或在ImageList控件中图象的索引，在 Node被选中时显示。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><u>表格 134-2</u>	relationship 的设置值</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>tvwFirst</td>
<td>0</td>
<td>首节点，该Node和在relative中被命名的节点位于同一层，并位于所有同层节点之前。</td>
</tr>
<tr>
<td>tvwLast</td>
<td>1</td>
<td>最后的节点，该Node和在relative中被命名的节点位于同一层，并位于所有同层节点之后。任何连续地添加的节点可能位于最后添加的节点之后。</td>
</tr>
<tr>
<td>tvwNext</td>
<td>2</td>
<td>下一个节点，该Node位于在relative中被命名的节点之后。</td>
</tr>
<tr>
<td>tvwPrevious</td>
<td>3</td>
<td>前一个节点，该Node位于在relative中被命名的节点之前。</td>
</tr>
<tr>
<td>tvwChild</td>
<td>4</td>
<td>子节点。该Node 为在relative中被命名的节点的子节点。</td>
</tr>
</tbody>
</table>
<p>第 13 行到第 25 行代码代，在根节点下添加子节点。添加子节点仍然使用 Add 方法，需要一个唯一的 Key 值，必须提供根节点的 Key 值（参数 relative）和参数 relationship 值（tvwChild）。要将子节点链接到根节点的下面，参数 relative 必须与根节点的 Key 值一致，参数 relationship 必须设置为 tvwchild。要使子节点有效，子节点必须也有自已唯一的 Key 值。</p>
<p>获得双击 TreeView 控件后的返回值的代码如下：</p>
<div><pre><code><span>Private</span> <span>Sub</span> TreeView1_DblClick<span>(</span><span>)</span>
	<span>If</span> TreeView1<span>.</span>SelectedItem<span>.</span>Children <span>=</span> <span>0</span> <span>Then</span>
		Sheet1<span>.</span>Range<span>(</span><span>"A65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Offset<span>(</span><span>1</span><span>)</span> <span>=</span> TreeView1<span>.</span>SelectedItem<span>.</span>Text
	<span>Else</span>
		MsgBox <span>"所选择的不是末级科目,请重新选择科目!"</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>TreeView1_ DblClick过程是 TreeView 控件的双击事件，将所选的科目名称写入到工作表中。</p>
<p>第 2 行代码判断所选节点是否是末级科目。TreeView 控件的 SelectedItem 属性返回当前所选择的节点，而 Children 属性检查所选节点是否还有子节点，如没有子节点则返回 0。</p>
<p>运行窗体效果如图 134-1 所示。</p>
<div>
<p><img src="./assets/134-1.png" alt="" loading="lazy"></p>
<p><u>图 134-1</u>	使用 TreeView 控件显示层次</p>
</div>
<h2 id="_135、用户窗体添加图标"> 135、用户窗体添加图标</h2>
<p>窗体在显示时标题栏上是没有图标的，如果希望在窗体上添加图标，可以借助 API 函数在窗体显示时添加自定义的图标。</p>
<p>在 VBE 窗口中单击菜单“插入”→“用户窗体”，插入一个窗体，在窗体中添加一个 Image 控件，设置 Image 控件 Picture 属性为自定义图标的位图，并将 Image 控件的 Visible 属性设置为 False，使窗体运行时隐藏 Image 控件，如图 135-1 所示。</p>
<div>
<p><img src="./assets/135-1.png" alt="" loading="lazy"></p>
<p><u>图 135-1</u>	窗体中添加 Image 控件</p>
</div>
<p>在 VBE 中双击窗体，写入下面的代码。</p>
<div><pre><code><span>Private</span> <span>Declare</span> <span>Function</span> SendMessage <span>Lib</span> <span>"user32"</span> <span>Alias</span> <span>"SendMessageA"</span> <span>(</span><span>ByVal</span> hWnd <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> wMsg <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> wParam <span>As</span> <span>Long</span><span>,</span> lParam <span>As</span> Any<span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Declare</span> <span>Function</span> DrawMenuBar <span>Lib</span> <span>"user32"</span> <span>(</span><span>ByVal</span> hWnd <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Declare</span> <span>Function</span> FindWindow <span>Lib</span> <span>"user32"</span> <span>Alias</span> <span>"FindWindowA"</span> <span>(</span><span>ByVal</span> lpClassName <span>As</span> <span>String</span><span>,</span> <span>ByVal</span> lpWindowName <span>As</span> <span>String</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Const</span> WM_SETICON <span>=</span> <span>&amp;H80</span>
<span>Private</span> <span>Const</span> ICON_SMALL <span>=</span> <span>0</span><span>&amp;</span>
<span>Private</span> <span>Const</span> ICON_BIG <span>=</span> <span>1</span><span>&amp;</span>
<span>Sub</span> ChangeIcon<span>(</span><span>ByVal</span> hWnd <span>As</span> <span>Long</span><span>,</span> <span>Optional</span> <span>ByVal</span> hicon <span>As</span> <span>Long</span> <span>=</span> <span>0</span><span>&amp;</span><span>)</span>
	SendMessage hWnd<span>,</span> WM_SETICON<span>,</span> ICON_SMALL<span>,</span> <span>ByVal</span> hicon
	SendMessage hWnd<span>,</span> WM_SETICON<span>,</span> ICON_BIG<span>,</span> <span>ByVal</span> hicon
	DrawMenuBar hWnd
<span>End</span> <span>Sub</span>
<span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	<span>Dim</span> hWnd <span>As</span> <span>Long</span>
	hWnd <span>=</span> FindWindow<span>(</span>vbNullString<span>,</span> <span>Me</span><span>.</span>Caption<span>)</span>
	<span>Call</span> ChangeIcon<span>(</span>hWnd<span>,</span> Image1<span>.</span>Picture<span>.</span>Handle<span>)</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>代码解析：</p>
<p>窗体的初始化事件，窗体在显示时运行 ChangeIcon 函数，在标题栏中添加图标。</p>
<p>第 1 行到第 6 行代码， API 函数声明。</p>
<p>第 7 行到第 11 行代码，ChangeIcon 过程，用于转换图标。</p>
<p>第 14 行代码，获得窗口句柄。</p>
<p>第 15 行代码，运行 ChangeIcon 过程，将 Image 控件中的位图显示在窗体的标题栏上。</p>
<p>运行窗体后，在窗体标题栏上添加图标，如图 135-2 所示。</p>
<div>
<p><img src="./assets/135-2.png" alt="" loading="lazy"></p>
<p><u>图 135-2</u>	在窗体标题栏中添加图标</p>
</div>
<h2 id="_136、用户窗体添加最大最小化按纽"> 136、用户窗体添加最大最小化按纽</h2>
<p>VBA 中的窗体标题栏上只有关闭按纽，没有最大最小化按纽的，可以使用 API 函数在窗体的标题栏上添加最大最小化按纽，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Declare</span> <span>Function</span> FindWindow <span>Lib</span> <span>"user32"</span> <span>Alias</span> <span>"FindWindowA"</span> <span>(</span><span>ByVal</span> lpClassName <span>As</span> <span>String</span><span>,</span> <span>ByVal</span> lpWindowName <span>As</span> <span>String</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Declare</span> <span>Function</span> GetWindowLong <span>Lib</span> <span>"user32"</span> <span>Alias</span> <span>"GetWindowLongA"</span> <span>(</span><span>ByVal</span> hWnd <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> nIndex <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Declare</span> <span>Function</span> SetWindowLong <span>Lib</span> <span>"user32"</span> <span>Alias</span> <span>"SetWindowLongA"</span> <span>(</span><span>ByVal</span> hWnd <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> nIndex <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> dwNewLong <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Const</span> WS_MAXIMIZEBOX <span>=</span> <span>&amp;H10000</span>
<span>Private</span> <span>Const</span> WS_MINIMIZEBOX <span>=</span> <span>&amp;H20000</span>
<span>Private</span> <span>Const</span> GWL_STYLE <span>=</span> <span>(</span><span>-</span><span>16</span><span>)</span>
<span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	<span>Dim</span> hWndForm <span>As</span> <span>Long</span>
	<span>Dim</span> iStyle <span>As</span> <span>Long</span>
	hWndForm <span>=</span> FindWindow<span>(</span><span>"ThunderDFrame"</span><span>,</span> <span>Me</span><span>.</span>Caption<span>)</span>
	iStyle <span>=</span> GetWindowLong<span>(</span>hWndForm<span>,</span> GWL_STYLE<span>)</span>
	iStyle <span>=</span> iStyle <span>Or</span> WS_MINIMIZEBOX
	iStyle <span>=</span> iStyle <span>Or</span> WS_MAXIMIZEBOX
	SetWindowLong hWndForm<span>,</span> GWL_STYLE<span>,</span> iStyle
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>代码解析：</p>
<p>窗体初始化时使用 API 函数在标题栏上添加最大最小化按纽。</p>
<p>第 1 行到第 6 行代码，API 函数声明。</p>
<p>第 10 行代码，获取窗口句柄。</p>
<p>第 11 行到第 14 行代码，在标题栏上添加最大最小化按纽。</p>
<p>运行窗体后效果如图 136-1 所示。</p>
<div>
<p><img src="./assets/136-1.png" alt="" loading="lazy"></p>
<p><u>图 136-1</u>	标题栏上添加最大最小化按纽</p>
</div>
<h2 id="_137、禁用窗体标题栏的关闭按钮"> 137、禁用窗体标题栏的关闭按钮</h2>
<p>如果不希望用户通过窗体标题栏的关闭命令来关闭窗体，可以禁用窗体标题栏上的关闭按钮，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> UserForm_QueryClose<span>(</span>Cancel <span>As</span> <span>Integer</span><span>,</span> CloseMode <span>As</span> <span>Integer</span><span>)</span>
	<span>If</span> CloseMode <span>&lt;</span><span>></span> <span>1</span> <span>Then</span>
		Cancel <span>=</span> <span>True</span>
		MsgBox <span>"请点击按钮关闭窗体!"</span>
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>代码解析：</p>
<p>窗体的 QueryClose 事件，禁用窗体标题栏上的关闭按钮。</p>
<p>窗体的 QueryClose 事件发生在窗体关闭之前，语法如下：</p>
<div><pre><code><span>Private</span> <span>Sub</span> UserForm_QueryClose<span>(</span>cancel <span>As</span> <span>Integer</span><span>,</span> closemode <span>As</span> <span>Integer</span><span>)</span>

参数Cance是可选的，整数。将此[参数]<span>(</span>JavaScript<span>:</span>hhobj_5<span>.</span>Click<span>(</span><span>)</span><span>)</span>设置成 <span>0</span> 以外的任意值，在所有加载的用户窗体中停止QueryClose事件，并防止关闭窗体与应用程序。
参数closemode是可选的，一个值或常数，用来指示引起QueryClose事件的原因。
closemode参数的设置值如表格 <span>137</span><span>-</span><span>1</span>所示。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><u>表格 137-1</u>	closemode 参数</p>
<table>
<thead>
<tr>
<th>常数</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>vbFormControlMenu</td>
<td>0</td>
<td>用户在 UserForm上选择“控制”菜单中的“关闭”命令</td>
</tr>
<tr>
<td>VbFormCode</td>
<td>1</td>
<td>由代码调用 Unload 语句</td>
</tr>
<tr>
<td>vbAppWindows</td>
<td>2</td>
<td>正在结束当前 Windows 操作环境的过程。(仅用于Visual Basic 5.0 )</td>
</tr>
<tr>
<td>vbAppTaskManager</td>
<td>3</td>
<td>Windows 的“任务管理器”正在关闭这个应用。(仅用于Visual Basic 5.0 )</td>
</tr>
</tbody>
</table>
<p>第 2、3 行代码，如果窗体不是由代码调用 Unload 语句关闭，则停止关闭过程，从而禁用窗体标题栏的关闭按钮。</p>
<p>需要注意的是，一定要在窗体上设置关闭窗体的途径，否则会使窗体无法关闭。</p>
<p>窗体运行后，禁用窗体上的关闭按钮关闭窗体，只能使用按钮关闭窗体，如图 137-1 所示。</p>
<div>
<p><img src="./assets/137-1.png" alt="" loading="lazy"></p>
<p><u>图 137-1</u>	禁用窗体标题栏的关闭命令</p>
</div>
<h2 id="_138、屏蔽窗体标题栏的关闭按钮"> 138、屏蔽窗体标题栏的关闭按钮</h2>
<p>使用 API 函数可以屏蔽窗体标题栏的关闭按钮，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Declare</span> <span>Function</span> FindWindow <span>Lib</span> <span>"user32"</span> <span>Alias</span> <span>"FindWindowA"</span> <span>(</span><span>ByVal</span> lpClassName <span>As</span> <span>String</span><span>,</span> <span>ByVal</span> lpWindowName <span>As</span> <span>String</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Declare</span> <span>Function</span> GetWindowLong <span>Lib</span> <span>"user32"</span> <span>Alias</span> <span>"GetWindowLongA"</span> <span>(</span><span>ByVal</span> Hwnd <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> nIndex <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Declare</span> <span>Function</span> SetWindowLong <span>Lib</span> <span>"user32"</span> <span>Alias</span> <span>"SetWindowLongA"</span> <span>(</span><span>ByVal</span> Hwnd <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> nIndex <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> dwNewLong <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Declare</span> <span>Function</span> DrawMenuBar <span>Lib</span> <span>"user32"</span> <span>(</span><span>ByVal</span> Hwnd <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Const</span> GWL_STYLE <span>=</span> <span>(</span><span>-</span><span>16</span><span>)</span>
<span>Private</span> <span>Const</span> WS_SYSMENU <span>=</span> <span>&amp;H80000</span>
<span>Private</span> Hwnd <span>As</span> <span>Long</span>
<span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	<span>Dim</span> Istype <span>As</span> <span>Long</span>
	Hwnd <span>=</span> FindWindow<span>(</span><span>"ThunderDFrame"</span><span>,</span> <span>Me</span><span>.</span>Caption<span>)</span>
	Istype <span>=</span> GetWindowLong<span>(</span>Hwnd<span>,</span> GWL_STYLE<span>)</span>
	Istype <span>=</span> Istype <span>And</span> <span>Not</span> WS_SYSMENU
	SetWindowLong Hwnd<span>,</span> GWL_STYLE<span>,</span> Istype
	DrawMenuBar Hwnd
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>代码解析：</p>
<p>第 1 行到第 7 行代码是 API 函数声明。</p>
<p>第 8 行到第 15 行代码是窗体的 Initialize 事件，当窗体显示时屏蔽窗体标题栏的关闭按钮。</p>
<p>窗体运行后，屏蔽窗体上的关闭按钮，只能使用按钮关闭窗体，如图 138-1 所示。</p>
<div>
<p><img src="./assets/138-1.png" alt="" loading="lazy"></p>
<p><u>图 138-1</u>	屏蔽窗体标题栏的关闭按钮</p>
</div>
<h2 id="_139、无标题栏和边框的窗体"> 139、无标题栏和边框的窗体</h2>
<p>如果希望制作无标题栏和边框的窗体，那么可以使用 API 函数。</p>
<p>在 VBE 窗口中单击菜单“插入”→“用户窗体”，双击窗体，在其代码窗口中输入下面的代码：</p>
<div><pre><code><span>Private</span> <span>Declare</span> <span>Function</span> DrawMenuBar <span>Lib</span> <span>"user32"</span> <span>(</span><span>ByVal</span> Hwnd <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Declare</span> <span>Function</span> GetWindowLong <span>Lib</span> <span>"user32"</span> <span>Alias</span> <span>"GetWindowLongA"</span> <span>(</span><span>ByVal</span> Hwnd <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> nIndex <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Declare</span> <span>Function</span> SetWindowLong <span>Lib</span> <span>"user32"</span> <span>Alias</span> <span>"SetWindowLongA"</span> <span>(</span><span>ByVal</span> Hwnd <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> nIndex <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> dwNewLong <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Declare</span> <span>Function</span> FindWindow <span>Lib</span> <span>"user32"</span> <span>Alias</span> <span>"FindWindowA"</span> <span>(</span><span>ByVal</span> lpClassName <span>As</span> <span>String</span><span>,</span> <span>ByVal</span> lpWindowName <span>As</span> <span>String</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Const</span> GWL_STYLE <span>As</span> <span>Long</span> <span>=</span> <span>(</span><span>-</span><span>16</span><span>)</span>
<span>Private</span> <span>Const</span> GWL_EXSTYLE <span>=</span> <span>(</span><span>-</span><span>20</span><span>)</span>
<span>Private</span> <span>Const</span> WS_CAPTION <span>As</span> <span>Long</span> <span>=</span> <span>&amp;HC00000</span>
<span>Private</span> <span>Const</span> WS_EX_DLGMODALFRAME <span>=</span> <span>&amp;H1</span><span>&amp;</span>
<span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	<span>Dim</span> IStyle <span>As</span> <span>Long</span>
	<span>Dim</span> Hwnd <span>As</span> <span>Long</span>
	<span>If</span> Val<span>(</span>Application<span>.</span>Version<span>)</span> <span>&lt;</span> <span>9</span> <span>Then</span>
		Hwnd <span>=</span> FindWindow<span>(</span><span>"ThunderXFrame"</span><span>,</span> <span>Me</span><span>.</span>Caption<span>)</span>
	<span>Else</span>
		Hwnd <span>=</span> FindWindow<span>(</span><span>"ThunderDFrame"</span><span>,</span> <span>Me</span><span>.</span>Caption<span>)</span>
	<span>End</span> <span>If</span>
	IStyle <span>=</span> GetWindowLong<span>(</span>Hwnd<span>,</span> GWL_STYLE<span>)</span>
	IStyle <span>=</span> IStyle <span>And</span> <span>Not</span> WS_CAPTION
	SetWindowLong Hwnd<span>,</span> GWL_STYLE<span>,</span> IStyle
	DrawMenuBar Hwnd
	IStyle <span>=</span> GetWindowLong<span>(</span>Hwnd<span>,</span> GWL_EXSTYLE<span>)</span> <span>And</span> <span>Not</span> WS_EX_DLGMODALFRAME
	SetWindowLong Hwnd<span>,</span> GWL_EXSTYLE<span>,</span> IStyle
<span>End</span> <span>Sub</span>
<span>Private</span> <span>Sub</span> UserForm_Click<span>(</span><span>)</span>
	Unload <span>Me</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>代码解析：</p>
<p>窗体初始化时使用 API 函数去除其标题栏和边框。</p>
<p>第 1 行到第 8 行代码，API 函数的声明。</p>
<p>第 12 行到第 16 行代码，获取窗口句柄。</p>
<p>第 17 行到第 20 行代码，去除窗体标题栏。</p>
<p>第 21、22 行代码，去除窗体边框。</p>
<p>第 24 行到第 26 行代码，窗体的单击事件，单击窗体后关闭该窗体。</p>
<p>窗体运行后如图 139-1 所示，单击后关闭该窗体。</p>
<div>
<p><img src="./assets/139-1.png" alt="" loading="lazy"></p>
<p><u>图 139-1</u>	无标题栏和边框的窗体</p>
</div>
<h2 id="_140、制作年月选择窗体"> 140、制作年月选择窗体</h2>
<p>在工作表中需要输入日期时，可以使用日期时间控件（Microsoft Date and Time Picker Control 6.0，简称 DTP 控件），请参阅 116 。但有时只需要输入年份和月份，使用 DTP 控件选择月份并不方便，此时可以使用文本框结合微调框做一个年月选择窗体供用户输入年份和月份。</p>
<ul>
<li>
<p>步骤 1，在 VBE 窗口中单击菜单“插入”→“用户窗体”，将窗体的 Caption 属性设置为“请选择年月”。</p>
</li>
<li>
<p>步骤 2，在窗体上添加一个框架控件和两个命令按纽控件。在框架控件中添加两个文本框控件和两个 SpinButton 控件，并把命令按纽的 Caption 属性分别设置为“确定”和“取消”。</p>
</li>
<li>
<p>步骤 3，调整好控件位置，双击窗体写入下面的代码。</p>
</li>
</ul>
<div><pre><code><span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	SpinButton1<span>.</span>Value <span>=</span> Year<span>(</span><span>Date</span><span>)</span>
	SpinButton2<span>.</span>Value <span>=</span> Month<span>(</span><span>Date</span><span>)</span>
	TextBox1<span>.</span>Text <span>=</span> Year<span>(</span><span>Date</span><span>)</span> <span>&amp;</span> <span>"年"</span>
	TextBox2<span>.</span>Text <span>=</span> Month<span>(</span><span>Date</span><span>)</span> <span>&amp;</span> <span>"月份"</span>
<span>End</span> <span>Sub</span>
<span>Private</span> <span>Sub</span> SpinButton1_Change<span>(</span><span>)</span>
	TextBox1<span>.</span>Text <span>=</span> SpinButton1<span>.</span>Value <span>&amp;</span> <span>"年"</span>
<span>End</span> <span>Sub</span>
<span>Private</span> <span>Sub</span> SpinButton2_Change<span>(</span><span>)</span>
	<span>With</span> SpinButton2
		<span>Select</span> <span>Case</span> <span>.</span>Value
			<span>Case</span> <span>1</span> <span>To</span> <span>12</span>
				TextBox2<span>.</span>Text <span>=</span> <span>.</span>Value <span>&amp;</span> <span>"月份"</span>
			<span>Case</span> <span>Is</span> <span>></span> <span>12</span>
				TextBox1<span>.</span>Text <span>=</span> Left<span>(</span>TextBox1<span>.</span>Text<span>,</span> <span>4</span><span>)</span> <span>+</span> <span>1</span> <span>&amp;</span> <span>"年"</span>
				<span>.</span>Value <span>=</span> <span>1</span>
			<span>Case</span> <span>Is</span> <span>&lt;</span> <span>1</span>
				TextBox1<span>.</span>Text <span>=</span> Left<span>(</span>TextBox1<span>.</span>Text<span>,</span> <span>4</span><span>)</span> <span>-</span> <span>1</span> <span>&amp;</span> <span>"年"</span>
				<span>.</span>Value <span>=</span> <span>12</span>
		<span>End</span> <span>Select</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
<span>Private</span> <span>Sub</span> CommandButton1_Click<span>(</span><span>)</span>
	Sheet1<span>.</span>Range<span>(</span><span>"A65536"</span><span>)</span><span>.</span><span>End</span><span>(</span>xlUp<span>)</span><span>.</span>Offset<span>(</span><span>1</span><span>)</span> <span>=</span> TextBox1<span>.</span>Text <span>&amp;</span> TextBox2<span>.</span>Text
<span>End</span> <span>Sub</span>
<span>Private</span> <span>Sub</span> CommandButton2_Click<span>(</span><span>)</span>
	Unload <span>Me</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>代码解析：</p>
<p>第 1 行到第 6 行代码，窗体的初始化事件，在窗体加载时设置文本框和微调框的初始值。</p>
<p>第 2 行代码，设置微调框1 的初始值为当前年份。Year 函数返回年份的整数，语法如下：</p>
<div><pre><code>Year<span>(</span><span>date</span><span>)</span>

参数<span>date</span>是必需的，可以是任何能够表示日期的<span>Variant</span>、数值表达式、字符串表达式或它们的组合。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>第 3 行代码，设置微调框2 的初始值为当前月份。Mont 函数返回值为 1 到 12 之间的整数，表示一年中的某月，语法如下：</p>
<div><pre><code>Month<span>(</span><span>date</span><span>)</span>

参数<span>date</span>与Year函数的参数<span>date</span>相同。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>第 4 行代码，设置文本框1 显示的文本为当前年份。</p>
<p>第 5 行代码，设置文本框2 显示的文本为当前月份。</p>
<p>第 7 行到第 9 行代码，微调框1 的 Change 事件过程。当单击微调框1 数值调节钮的向上键或向下键调节年份时，文本框1 显示的年份等于调节后的年份。</p>
<p>第 10 行到第 23 行代码，微调框2 的 Change 事件过程。当单击微调框2 数值调节钮的向上键或向下键调节月份时，文本框2 显示的月份等于调节后的月份。如果是一年以内的调节，只调节文本框2 显示的月份，否则还需要调节文本框1 显示的年份。</p>
<p>第 25 行代码，“确定”按钮的单击过程，将选择好的年月写入工作表中。</p>
<p>第 28 行代码，使用 Unload 语句卸载窗体。</p>
<p>运行窗体后效果如图 140-1 所示。</p>
<div>
<p><img src="./assets/140-1.png" alt="" loading="lazy"></p>
<p><u>图 140-1</u>	年月选择窗体</p>
</div>
<h2 id="_141、自定义窗体中的鼠标指针类型"> 141、自定义窗体中的鼠标指针类型</h2>
<p>使用对象的 MousePointer 属性可以自定义鼠标掠过窗体控件时的指针类型，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	<span>With</span> <span>Me</span><span>.</span>TextBox1
		<span>.</span>MousePointer <span>=</span> <span>99</span>
		<span>.</span>MouseIcon <span>=</span> LoadPicture<span>(</span>ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\myMouse.ico"</span><span>)</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>代码解析：</p>
<p>当用户把鼠标放到窗体的文本框上时，所显示的鼠标指针的类型为自定义图标。</p>
<p>第3行代码设置文本框的 MousePointer 属性。MousePointer 属性指定当用户把鼠标放到特定对象上时，所显示鼠标指针的类型，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>MousePointer [<span>=</span> fmMousePointer]

参数<span>object</span>是必需的，一个有效对象。
参数fmMousePointer是可选的，所需鼠标指针的形状。fmMousePointer的设置值如表格 <span>141</span><span>-</span><span>1</span>所示。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><u>表格 141-1</u>	fmMousePointer 的设置值</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>fmMousePointerDefault</td>
<td>0</td>
<td>标准指针。根据对象来决定指针的图像（默认）</td>
</tr>
<tr>
<td>fmMousePointerArrow</td>
<td>1</td>
<td>箭头</td>
</tr>
<tr>
<td>fmMousePointerCross</td>
<td>2</td>
<td>十字线指针</td>
</tr>
<tr>
<td>fmMousePointerIBeam</td>
<td>3</td>
<td>I 形标</td>
</tr>
<tr>
<td>fmMousePointerSizeNESW</td>
<td>6</td>
<td>斜下的双箭头</td>
</tr>
<tr>
<td>fmMousePointerSizeNS</td>
<td>7</td>
<td>南北向的双箭头</td>
</tr>
<tr>
<td>mMousePointerSizeNWSE</td>
<td>8</td>
<td>斜上的双箭头</td>
</tr>
<tr>
<td>fmMousePointerSizeWE</td>
<td>9</td>
<td>东西向的双箭头</td>
</tr>
<tr>
<td>fmMousePointerUpArrow</td>
<td>10</td>
<td>向上键</td>
</tr>
<tr>
<td>fmMousePointerHourglass</td>
<td>11</td>
<td>沙漏</td>
</tr>
<tr>
<td>fmMousePointerNoDrop</td>
<td>12</td>
<td>在被拖动的对象上有 “Not”符号（有一条斜线的圆）。表示是无效的放置目标。</td>
</tr>
<tr>
<td>fmMousePointerAppStarting</td>
<td>13</td>
<td>带沙漏的箭头</td>
</tr>
<tr>
<td>fmMousePointerHelp</td>
<td>14</td>
<td>带问号的箭头</td>
</tr>
<tr>
<td>fmMousePointerSizeAll</td>
<td>15</td>
<td>调整所有尺寸的光标（四向箭头）</td>
</tr>
<tr>
<td>fmMousePointerCustom</td>
<td>99</td>
<td>使用由MouseIcon属性指定的图标</td>
</tr>
</tbody>
</table>
<p>第 3 行代码将文本框的 MousePointer 属性设置为 99，使用由 MouseIcon 属性指定的自定义图标。MouseIcon 属性为对象指定一个自定义的图标，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>MouseIcon <span>=</span> LoadPicture<span>(</span> pathname <span>)</span>

参数<span>object</span>是必需的，一个有效的对象。
参数pathname是必需的，指定包含自定义图标的文件的路径和文件名。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>设置后的鼠标指针的形状如图 141-1 所示。</p>
<div>
<p><img src="./assets/141-1.png" alt="" loading="lazy"></p>
<p><u>图 141-1</u>	自定义鼠标指针类型</p>
</div>
<h2 id="_142、调整窗体的显示位置"> 142、调整窗体的显示位置</h2>
<p>用户窗体显示时，默认的位置是窗体所在 Excel 文件的中央。如果需要调整，可以在窗体加载时对其进行设置，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	<span>With</span> <span>Me</span>
		<span>.</span>StartUpPosition <span>=</span> <span>0</span>
		<span>.</span>Left <span>=</span> <span>500</span>
		<span>.</span>Top <span>=</span> <span>300</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>窗体的初始化事件，在窗体加载时设置其显示位置。</p>
<p>第 3 行代码，将窗体的 StartUpPosition 属性设置成手动。</p>
<p>StartUpPosition 属性返回或设置一个值，用来指定窗体第一次出现时的位置，设置值如表格 142-1 所示。</p>
<p><u>表格 142-1</u>	StartUpPosition 属性设置值</p>
<table>
<thead>
<tr>
<th>设置</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>手动</td>
<td>0</td>
<td>没有初始设置指定</td>
</tr>
<tr>
<td>所有者中心</td>
<td>1</td>
<td>在 UserForm 所属项目的中央</td>
</tr>
<tr>
<td>屏幕中心</td>
<td>2</td>
<td>在整个屏幕的中央</td>
</tr>
<tr>
<td>窗口缺省</td>
<td>3</td>
<td>在屏幕的左上角</td>
</tr>
</tbody>
</table>
<p>StartUpPosition 属性可以在程序中设置，也可以在窗体的属性窗口中设置。</p>
<p>第 4、5 行代码，设置窗体的 Left 属性和 Top 属性，使其加载时显示在屏幕的右下角。</p>
<p>经过设置后的窗体加载时显示位置如图 142-1 所示。</p>
<div>
<p><img src="./assets/142-1.png" alt="" loading="lazy"></p>
<p><u>图 142-1</u>	调整窗体的显示位置</p>
</div>
<h2 id="_143、由鼠标确定窗体显示位置"> 143、由鼠标确定窗体显示位置</h2>
<p>窗体加载时其显示位置还可以由鼠标的坐标来确定，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> CommandButton1_Click<span>(</span><span>)</span>
	<span>Dim</span> ActiveCellX <span>As</span> <span>Integer</span>
	<span>Dim</span> ActiveCellY <span>As</span> <span>Integer</span>
	ActiveCellX <span>=</span> ExecuteExcel4Macro<span>(</span><span>"GET.CELL(44)"</span><span>)</span>
	ActiveCellY <span>=</span> ExecuteExcel4Macro<span>(</span><span>"GET.CELL(43)"</span><span>)</span>
	<span>With</span> UserForm1
		<span>.</span>Show <span>0</span>
		<span>.</span>Top <span>=</span> ActiveCellY
		<span>.</span>Left <span>=</span> ActiveCellX
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>代码解析：</p>
<p>使用 ExecuteExcel4Macro 方法执行 Microsoft Excel 4.0 宏函数取得鼠标的坐标，ExecuteExcel4Macro 方法的语法如下：</p>
<div><pre><code>expression<span>.</span>ExecuteExcel4Macro<span>(</span><span>String</span><span>)</span>

expression参数是可选的，返回一个Application对象。
<span>String</span>参数是必需的，一个不带等号的Microsoft Excel <span>4.0</span>宏语言函数。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第 4 行代码使用 GET.CELL(44) 宏函数取得鼠标的 X 坐标，第 5 行代码使用 GET.CELL(43) 宏函数取得鼠标的 Y 坐标。</p>
<p>第 6 行到第 10 行代码显示窗体并设置其 Top 属性和 Left 属性，调整其显示的位置。</p>
<p>还可以利用工作表 SelectionChange 事件的 Target 参数取得鼠标的坐标，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> Worksheet_SelectionChange<span>(</span><span>ByVal</span> Target <span>As</span> Range<span>)</span>
	<span>With</span> UserForm1
		<span>.</span>Show <span>0</span>
		<span>.</span>Top <span>=</span> Target<span>.</span>Top
		<span>.</span>Left <span>=</span> Target<span>.</span>Left
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解析：</p>
<p>工作表的 SelectionChange 事件过程，Target 参数代表新选定的区域，返回一个 Range 对象，在显示窗体时取得其 Top 和 Left 属性后设置窗体显示的 Top 和 Left 属性。</p>
<h2 id="_144、用户窗体的打印"> 144、用户窗体的打印</h2>
<p>在使用如图 144-1 所示的窗体录入数据时，如果需要把窗体打印出来，可以使用 PrintForm 方法，如下面的代码所示。</p>
<div>
<p><img src="./assets/144-1.png" alt="" loading="lazy"></p>
<p><u>图 144-1</u>	录入窗体</p>
</div>
<div><pre><code><span>Private</span> <span>Sub</span> CommandButton7_Click<span>(</span><span>)</span>
	<span>Dim</span> myHeight <span>As</span> <span>Integer</span>
	Application<span>.</span>ScreenUpdating <span>=</span> <span>False</span>
	<span>With</span> UserForm1
		myHeight <span>=</span> <span>.</span>Height
		<span>.</span>DTPicker1<span>.</span>Visible <span>=</span> <span>False</span>
		<span>.</span>Frame1<span>.</span>Visible <span>=</span> <span>False</span>
		<span>.</span>Height <span>=</span> myHeight <span>-</span> <span>30</span>
		<span>.</span>PrintForm
		<span>.</span>Height <span>=</span> myHeight
		<span>.</span>DTPicker1<span>.</span>Visible <span>=</span> <span>True</span>
		<span>.</span>Frame1<span>.</span>Visible <span>=</span> <span>True</span>
	<span>End</span> <span>With</span>
	Application<span>.</span>ScreenUpdating <span>=</span> <span>True</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>代码解析：</p>
<p>录入窗体中的“打印”按钮的单击代码，使用 PrintForm 方法打印窗体。</p>
<p>第 5 行代码使用变量 myHeight 记录窗体的 Height 属性值，以便在第 10 行代码中恢复窗体原有的高度。</p>
<p>第 6、7 行代码将窗体中的 DTP 日历控件和功能按钮的 Visible 属性设置为 False，使之隐藏，这样在打印时就不会被打印出来。</p>
<p>第 9 行代码使用 PrintForm 方法打印窗体，PrintForm 方法将 UserForm 对象的图象逐位发送到打印机，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>PrintForm

参数<span>object</span>代表对象表达式，其值为<span>“应用于”</span>列表中的对象。如果省略该参数，则把焦点所在的窗体当做<span>object</span>。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>第 11、12 行代码重新显示窗体中的 DTP 日历控件和功能按钮。</p>
<p>窗体打印后的效果如图 144-2 所示。</p>
<div>
<p><img src="./assets/144-2.png" alt="" loading="lazy"></p>
<p><u>图 144-2</u>	窗体打印效果</p>
</div>
<h2 id="_145、使用自定义颜色设置窗体颜色"> 145、使用自定义颜色设置窗体颜色</h2>
<p>在用 VBA 进行设计时，会发现控件与颜色相关的属性中系统提供可选择的颜色太少。比如窗体的 BackColor 属性，如果需要把窗体的背景颜色设置为淡蓝色 RGB(52,150,203)，可以在窗体初始化过程中对之进行设置，可以实现想要的效果，但是在设计时却不能看到最终效果。</p>
<p>其实窗体的 BackColor 属性（包括 ForeColor 以及 BorderColor 等等这些设置颜色的属性）允许输入一个以十六进制表示的长整型数值，这样在设计时就看到效果。</p>
<p>首先获取所需要的颜色值并以十六进制表示。还以上面的颜色为例，在立即窗口输入<code>“? Hex(RGB(52,150,203))”</code>可得到一个十六进制数据 CB9634，然后把光标定位在窗体属性窗口的 BackColor 属性值中，删除原来的数值后，输入<code>“&amp;HCB9634&amp;”</code>后按 <kbd>Enter</kbd> 键，窗体颜色效果立即就出现了，如图 145-1 所示。</p>
<div>
<p><img src="./assets/145-1.png" alt="" loading="lazy"></p>
<p><u>图 145-1</u>	在窗体设计时显示自定义颜色</p>
</div>
<h2 id="_146、在窗体中显示图表"> 146、在窗体中显示图表</h2>
<p>工作表中的图表是不能直接显示在窗体中的，如果需要在窗体上显示图表，除了使用 61 介绍的使用 ShowWindow 属性将工作表中嵌入的图表显示在独立的窗口中，还可以使用以下的方法。</p>
<h3 id="_1-使用-export-方法"> 1）使用 Export 方法</h3>
<p>可以把图表以图形格式从工作表中导出，再用窗体上的 Image 控件把图表显示出来，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	<span>Dim</span> Charts <span>As</span> Chart
	<span>Dim</span> cName <span>As</span> <span>String</span>
	<span>Set</span> Charts <span>=</span> Sheets<span>(</span><span>"Sheet2"</span><span>)</span><span>.</span>ChartObjects<span>(</span><span>1</span><span>)</span><span>.</span>Chart
	cName <span>=</span> ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\Temp.gif"</span>
	Charts<span>.</span>Export Filename<span>:</span><span>=</span>cName<span>,</span> FilterName<span>:</span><span>=</span><span>"GIF"</span>
	Image1<span>.</span>Picture <span>=</span> LoadPicture<span>(</span>cName<span>)</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>代码解析：</p>
<p>窗体的初始化事件过程，窗体加载时将工作表中的图表显示在窗体中。</p>
<p>第 4 行到第 6 行代码，使用 Export 方法把 Sheet2 表中的第一个图表导出到工作簿的同一目录下。</p>
<p>Export 方法以图形格式导出图表，语法如下：</p>
<div><pre><code>expression<span>.</span>Export<span>(</span>Filename<span>,</span> FilterName<span>,</span> Interactive<span>)</span>

参数expression是必需的，一个有效的对象。
参数Filename是必需的，导出的文件的名称。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>本例中设置 Filename 参数时加上了导出路径，将图形导出到同一文件夹下。</p>
<p>参数 FilterName 是可选的，导出文件的格式。</p>
<p>第 7 行代码，设置窗体中 Image 控件的 Picture 属性为导出文件的完整路径。</p>
<p>Picture 属性指定显示在对象上的位图，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>Picture <span>=</span> LoadPicture<span>(</span> pathname <span>)</span>

参数expression是必需的，一个有效的对象。
参数pathname是必需的，一个图片文件的完整路径。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>为了使窗体关闭时删除导出的图片文件，在窗体的 QueryClose 事件中写入下面的代码。</p>
<div><pre><code><span>Private</span> <span>Sub</span> UserForm_QueryClose<span>(</span>Cancel <span>As</span> <span>Integer</span><span>,</span> CloseMode <span>As</span> <span>Integer</span><span>)</span>
	Kill ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\Temp.gif"</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>窗体关闭时使用 Kill 方法删除导出的图片文件。Kill 方法的语法如下：</p>
<div><pre><code>Kill pathname

参数Pathname是必需的，用来指定一个文件名的字符串表达式。Pathname参数可以包含目录或文件夹、以及驱动器。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>运行窗体，将工作表的图表显示在窗体中，如图 146-1 所示。</p>
<div>
<p><img src="./assets/146-1.png" alt="" loading="lazy"></p>
<p><u>图 146-1</u>	在窗体上显示图表</p>
</div>
<h3 id="_2-使用-api-函数"> 2）使用 API 函数</h3>
<p>可以使用 API 函数把图表从工作表中导出，再用窗体上的 Image 控件把图表显示出来，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Declare</span> <span>Function</span> CreateStreamOnHGlobal <span>Lib</span> <span>"ole32"</span> <span>(</span><span>ByVal</span> hGlobal <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> fDeleteOnRelease <span>As</span> <span>Long</span><span>,</span> ppstm <span>As</span> Any<span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Declare</span> <span>Function</span> OleLoadPicture <span>Lib</span> <span>"olepro32"</span> <span>(</span>pStream <span>As</span> Any<span>,</span> <span>ByVal</span> lSize <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> fRunmode <span>As</span> <span>Long</span><span>,</span> riid <span>As</span> Any<span>,</span> ppvObj <span>As</span> Any<span>)</span> <span>As</span> <span>Long</span>
………代码略详见附件
<span>Private</span> <span>Declare</span> <span>Function</span> GetClipboardFormatName <span>Lib</span> <span>"user32"</span> <span>Alias</span> <span>"GetClipboardFormatNameA"</span> <span>(</span><span>ByVal</span> wFormat <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> lpString <span>As</span> <span>String</span><span>,</span> <span>ByVal</span> nMaxCount <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
<span>Public</span> <span>Function</span> LoadShapePicture<span>(</span>shp <span>As</span> <span>Object</span><span>)</span> <span>As</span> IPictureDisp
	<span>Dim</span> nClipsize <span>As</span> <span>Long</span>
	<span>Dim</span> hMem <span>As</span> <span>Long</span>
	<span>Dim</span> lpData <span>As</span> <span>Long</span>
	<span>Dim</span> sdata<span>(</span><span>)</span> <span>As</span> <span>Byte</span>
	<span>Dim</span> fmt <span>As</span> <span>Long</span>
	<span>Dim</span> fmtName <span>As</span> <span>String</span>
	<span>Dim</span> iClipBoardFormatNumber <span>As</span> <span>Long</span>
	<span>Dim</span> IID_IPicture<span>(</span><span>15</span><span>)</span>
……代码略详见附件
	EmptyClipboard
	CloseClipboard
<span>End</span> <span>Function</span>
 <span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	Image1<span>.</span>Picture <span>=</span> LoadShapePicture<span>(</span>Sheet1<span>.</span>ChartObjects<span>(</span><span>1</span><span>)</span><span>)</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>代码解析：</p>
<p>第 1 行到第 12 行代码 API 函数声明。</p>
<p>第 13 行到第 60 行代码 LoadShapePicture 函数，导出工作表中的图表。</p>
<p>第 61 行到第 63 行代码窗体的初始化事件过程，窗体加载时将工作表中的图表显示在窗体中，如图 146-2 所示。关于 Image 控件的 Picture 属性请参阅 146-1。</p>
<div>
<p><img src="./assets/146-2.png" alt="" loading="lazy"></p>
<p><u>图 146-2</u>	在窗体上显示图表</p>
</div>
<h2 id="_147、窗体运行时调整控件大小"> 147、窗体运行时调整控件大小</h2>
<p>用户窗体中的控件在运行时是不能调整大小的，而在某些情况下需要在窗体运行时调整控件的大小，此时可以利用控件的 MouseMove 事件。</p>
<ul>
<li>步骤 1，在 VBE 窗口中单击菜单“插入”→“用户窗体”，在窗体中添加两个框架控件，在框架控件中间添加一个 Image 控件，如图 147-1 所示。</li>
</ul>
<div>
<p><img src="./assets/147-1.png" alt="" loading="lazy"></p>
<p><u>图 147-1</u>	添加控件</p>
</div>
<ul>
<li>
<p>步骤 2，Image 控件是用来在窗体运行时拖动调整框架控件大小的，所以需要在 Image 控件的属性窗口将 BackStyle 属性设置为 fmBackStyleTransparent，使控件的背景为透明；将 BorderStyle 属性设置为 fmBorderStyleNone，使控件无可见的边框线；MousePointer 属性设置为 fmMousePointerSizeWE，当用户把鼠标放到 Image 控件上时，鼠标指针的类型为东西向的双箭头。关于控件的 MousePointer 属性请参阅 141 中的表格 141-1。</p>
</li>
<li>
<p>步骤 3，在窗体中调整好控件的位置后双击 Image 控件写入下面的代码：</p>
</li>
</ul>
<div><pre><code><span>Dim</span> Abscissa <span>As</span> <span>Single</span>
<span>Private</span> <span>Sub</span> Image1_MouseDown<span>(</span><span>ByVal</span> Button <span>As</span> <span>Integer</span><span>,</span> <span>ByVal</span> Shift <span>As</span> <span>Integer</span><span>,</span> <span>ByVal</span> x <span>As</span> <span>Single</span><span>,</span> <span>ByVal</span> y <span>As</span> <span>Single</span><span>)</span>
	Abscissa <span>=</span> x
<span>End</span> <span>Sub</span>
<span>Private</span> <span>Sub</span> Image1_MouseMove<span>(</span><span>ByVal</span> Button <span>As</span> <span>Integer</span><span>,</span> <span>ByVal</span> Shift <span>As</span> <span>Integer</span><span>,</span> <span>ByVal</span> x <span>As</span> <span>Single</span><span>,</span> <span>ByVal</span> y <span>As</span> <span>Single</span><span>)</span>
	<span>If</span> Button <span>=</span> <span>1</span> <span>Then</span>
		<span>If</span> Abscissa <span>-</span> x <span>></span> Frame1<span>.</span>Width <span>Or</span> x <span>></span> Frame2<span>.</span>Width <span>Then</span> <span>Exit</span> <span>Sub</span>
		Frame1<span>.</span>Width <span>=</span> Frame1<span>.</span>Width <span>-</span> Abscissa <span>+</span> x
		Image1<span>.</span>Left <span>=</span> Image1<span>.</span>Left <span>-</span> Abscissa <span>+</span> x
		Frame2<span>.</span>Left <span>=</span> Frame2<span>.</span>Left <span>-</span> Abscissa <span>+</span> x
		Frame2<span>.</span>Width <span>=</span> Frame2<span>.</span>Width <span>+</span> Abscissa <span>-</span> x
	<span>End</span> <span>If</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>代码解析：</p>
<p>第 2 行到第 4 行代码，Image 控件的 MouseDown 事件过程，用户按下鼠标按键时发生，语法如下：</p>
<div><pre><code><span>Private</span> <span>Sub</span> object_MouseDown<span>(</span> <span>ByVal</span> Button <span>As</span> fmButton<span>,</span> <span>ByVal</span> Shift <span>As</span> fmShiftState<span>,</span> <span>ByVal</span> X <span>As</span> <span>Single</span><span>,</span> <span>ByVal</span> Y <span>As</span> <span>Single</span><span>)</span>

其中参数x是可选的，控件位置的横坐标，以磅为单位，从左边开始测量。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>第 3 行代码将控件的横坐标赋给变量 Abscissa。</p>
<p>第 5 行到第 12 行代码，Image 控件的 MouseMove 事件过程，用户移动鼠标时该事件发生，语法如下：</p>
<div><pre><code><span>Private</span> <span>Sub</span> object_MouseMove<span>(</span> <span>ByVal</span> Button <span>As</span> fmButton<span>,</span> <span>ByVal</span> Shift <span>As</span> fmShiftState<span>,</span> <span>ByVal</span> X <span>As</span> <span>Single</span><span>,</span> <span>ByVal</span> Y <span>As</span> <span>Single</span><span>)</span>

其中参数Button是必需的，标识鼠标按键状态的整数值，其设置值如表格 <span>147</span><span>-</span><span>1</span>所示。
参数x是可选的，控件位置的水平坐标，以磅为单位，从左边开始测量。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><u>表格 147-1</u>	Button 参数的设置值</p>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>按键未被按下</td>
<td>4</td>
<td>按下中键</td>
</tr>
<tr>
<td>1</td>
<td>按下左键</td>
<td>5</td>
<td>同时按下左键和中键</td>
</tr>
<tr>
<td>2</td>
<td>按下右键</td>
<td>6</td>
<td>同时按下中键和右键</td>
</tr>
<tr>
<td>3</td>
<td>同时按下左键和右键</td>
<td>7</td>
<td>三个按键全都按下</td>
</tr>
</tbody>
</table>
<p>在 MouseMove 事件过程中，当用户在窗体上按下左键移动鼠标时，调整两个框架控件的 Width属性和框架 2 的 Left 属性，使其达到窗体运行时可以进行拖动调整大小的效果。</p>
<p>当鼠标指针在对象上移动时，MouseMove 事件是连续发生的，只要鼠标位于对象的边界之内，对象就会不断的识别 MouseMove 事件，所以框架控件可以连续的进行拖动调整大小。</p>
<p>运行窗体的，选择两个框架控件的中间位置，当鼠标指针变成东西向的双箭头时按下鼠标左键拖动可以进行拖动调整框架控件的大小，如图 147-2 所示。</p>
<div>
<p><img src="./assets/147-2.png" alt="" loading="lazy"></p>
<p><u>图 147-2</u>	窗体运行时调整控件大小</p>
</div>
<h2 id="_148、在用户窗体上添加菜单"> 148、在用户窗体上添加菜单</h2>
<p>在 VBA 中，用户窗体上是没有菜单的，为了使用方便，我们可以使用 API 函数在用户窗体上添加菜单，示例代码如下：</p>
<div><pre><code><span>Private</span> <span>Declare</span> <span>Function</span> FindWindow <span>Lib</span> <span>"user32"</span> <span>Alias</span> <span>"FindWindowA"</span> <span>(</span><span>ByVal</span> lpClassName <span>As</span> <span>String</span><span>,</span> <span>ByVal</span> lpWindowName <span>As</span> <span>String</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Declare</span> <span>Function</span> SetMenu <span>Lib</span> <span>"user32"</span> <span>(</span><span>ByVal</span> hwnd <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> hMenu <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Declare</span> <span>Function</span> CreateMenu <span>Lib</span> <span>"user32"</span> <span>(</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Declare</span> <span>Function</span> AppendMenu <span>Lib</span> <span>"user32"</span> <span>Alias</span> <span>"AppendMenuA"</span> <span>(</span><span>ByVal</span> hMenu <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> wFlags <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> wIDNewItem <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> lpNewItem <span>As</span> Any<span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Declare</span> <span>Function</span> DestroyMenu <span>Lib</span> <span>"user32"</span> <span>(</span><span>ByVal</span> hMenu <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Declare</span> <span>Function</span> CreatePopupMenu <span>Lib</span> <span>"user32"</span> <span>(</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Declare</span> <span>Function</span> SetWindowLong <span>Lib</span> <span>"user32"</span> <span>Alias</span> <span>"SetWindowLongA"</span> <span>(</span><span>ByVal</span> hwnd <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> nIndex <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> dwNewLong <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Declare</span> <span>Function</span> GetWindowLong <span>Lib</span> <span>"user32"</span> <span>Alias</span> <span>"GetWindowLongA"</span> <span>(</span><span>ByVal</span> hwnd <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> nIndex <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Const</span> GWL_WNDPROC <span>=</span> <span>(</span><span>-</span><span>4</span><span>)</span>
<span>Private</span> <span>Const</span> MF_STRING <span>=</span> <span>&amp;H0</span><span>&amp;</span>
<span>Private</span> <span>Const</span> MF_POPUP <span>=</span> <span>&amp;H10</span><span>&amp;</span>
<span>Private</span> <span>Const</span> MF_SEPARATOR <span>=</span> <span>&amp;H800</span><span>&amp;</span>
<span>Dim</span> MenuWnd <span>As</span> <span>Long</span><span>,</span> Dump <span>As</span> <span>Long</span><span>,</span> PopupMenuID <span>As</span> <span>Long</span><span>,</span> PopupMenuWnd <span>As</span> <span>Long</span><span>,</span> MenuID <span>As</span> <span>Long</span>
<span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	<span>If</span> Val<span>(</span>Application<span>.</span>Version<span>)</span> <span>&lt;</span> <span>9</span> <span>Then</span>
		hwnd <span>=</span> FindWindow<span>(</span><span>"ThunderXFrame"</span><span>,</span> <span>Me</span><span>.</span>Caption<span>)</span>
	<span>Else</span>
		hwnd <span>=</span> FindWindow<span>(</span><span>"ThunderDFrame"</span><span>,</span> <span>Me</span><span>.</span>Caption<span>)</span>
	<span>End</span> <span>If</span>
	MenuWnd <span>=</span> CreateMenu<span>(</span><span>)</span>
	PopupMenuID <span>=</span> CreatePopupMenu<span>(</span><span>)</span>
	Dump <span>=</span> AppendMenu<span>(</span>MenuWnd<span>,</span> MF_STRING <span>+</span> MF_POPUP<span>,</span> PopupMenuID<span>,</span> <span>"系统设置(&amp;X)"</span><span>)</span>
	Dump <span>=</span> AppendMenu<span>(</span>PopupMenuID<span>,</span> MF_STRING<span>,</span> <span>100</span><span>,</span> <span>"保存(&amp;S)..."</span><span>)</span>
	Dump <span>=</span> AppendMenu<span>(</span>PopupMenuID<span>,</span> MF_STRING<span>,</span> <span>101</span><span>,</span> <span>"备份(&amp;E)"</span><span>)</span>
	Dump <span>=</span> AppendMenu<span>(</span>PopupMenuID<span>,</span> MF_STRING<span>,</span> <span>102</span><span>,</span> <span>"退出(&amp;X)"</span><span>)</span>
	PopupMenuID <span>=</span> CreatePopupMenu<span>(</span><span>)</span>
	Dump <span>=</span> AppendMenu<span>(</span>MenuWnd<span>,</span> MF_STRING <span>+</span> MF_POPUP<span>,</span> PopupMenuID<span>,</span> <span>"会计凭证(&amp;P)"</span><span>)</span>
	Dump <span>=</span> AppendMenu<span>(</span>PopupMenuID<span>,</span> MF_STRING<span>,</span> <span>110</span><span>,</span> <span>"录入(&amp;L)"</span><span>)</span>
	Dump <span>=</span> AppendMenu<span>(</span>PopupMenuID<span>,</span> MF_STRING<span>,</span> <span>111</span><span>,</span> <span>"审核(&amp;C)"</span><span>)</span>
	PopupMenuID <span>=</span> CreatePopupMenu<span>(</span><span>)</span>
	Dump <span>=</span> AppendMenu<span>(</span>MenuWnd<span>,</span> MF_STRING <span>+</span> MF_POPUP<span>,</span> PopupMenuID<span>,</span> <span>"会计账簿(&amp;Z)"</span><span>)</span>
	Dump <span>=</span> AppendMenu<span>(</span>PopupMenuID<span>,</span> MF_STRING<span>,</span> <span>112</span><span>,</span> <span>"记账(&amp;T)"</span><span>)</span>
	Dump <span>=</span> AppendMenu<span>(</span>PopupMenuID<span>,</span> MF_STRING<span>,</span> <span>113</span><span>,</span> <span>"结账(&amp;J)"</span><span>)</span>
	PopupMenuID <span>=</span> CreatePopupMenu<span>(</span><span>)</span>
	Dump <span>=</span> AppendMenu<span>(</span>MenuWnd<span>,</span> MF_STRING <span>+</span> MF_POPUP<span>,</span> PopupMenuID<span>,</span> <span>"会计报表(&amp;B)"</span><span>)</span>
	Dump <span>=</span> AppendMenu<span>(</span>PopupMenuID<span>,</span> MF_STRING<span>,</span> <span>114</span><span>,</span> <span>"资产负债表(&amp;F)"</span><span>)</span>
	Dump <span>=</span> AppendMenu<span>(</span>PopupMenuID<span>,</span> MF_STRING<span>,</span> <span>115</span><span>,</span> <span>"损益表(&amp;Y)"</span><span>)</span>
	Dump <span>=</span> SetMenu<span>(</span>hwnd<span>,</span> MenuWnd<span>)</span>
	PreWinProc <span>=</span> GetWindowLong<span>(</span>hwnd<span>,</span> GWL_WNDPROC<span>)</span>
	SetWindowLong hwnd<span>,</span> GWL_WNDPROC<span>,</span> <span>AddressOf</span> MsgProcess
<span>End</span> <span>Sub</span>
<span>Private</span> <span>Sub</span> UserForm_Terminate<span>(</span><span>)</span>
	DestroyMenu MenuWnd
	DestroyMenu PopupMenuID
	DestroyMenu PopupMenuWnd
	SetWindowLong hwnd<span>,</span> GWL_WNDPROC<span>,</span> PreWinProc
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><p>代码解析：</p>
<p>第 1 行到第 13 行代码，API 函数声明。</p>
<p>第 14 行到第 41 代码，用户窗体的 Initialize 事件过程，在窗体显示时使用 API 函数在窗体上添加菜单。其中第 22 行代码添加第一个“系统设置”菜单，第 23、24、25 行代码在“系统设置”菜单中添加三个子菜单，第 26 行代码往下继续添加其他菜单。</p>
<p>第 40 行代码，为窗体中添加的菜单指定所执行的过程名称为“MsgProcess”函数过程。</p>
<p>第 42 行到第 47 行代码，用户窗体的 Terminate 事件过程，将所有引用对象的变量设置成 Nothing，从而删除对象的所有引用。</p>
<p>为了能够使用窗体中添加的菜单，需要在模块中写入下面的代码：</p>
<div><pre><code><span>Public</span> PreWinProc <span>As</span> <span>Long</span><span>,</span> hwnd <span>As</span> <span>Long</span>
<span>Public</span> <span>Declare</span> <span>Function</span> CheckMenuRadioItem <span>Lib</span> <span>"user32"</span> <span>(</span><span>ByVal</span> hMenu <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> un1 <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> un2 <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> un3 <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> un4 <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
<span>Public</span> <span>Declare</span> <span>Function</span> CheckMenuItem <span>Lib</span> <span>"user32"</span> <span>(</span><span>ByVal</span> hMenu <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> wIDCheckItem <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> wCheck <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
<span>Public</span> <span>Declare</span> <span>Function</span> EnableMenuItem <span>Lib</span> <span>"user32"</span> <span>(</span><span>ByVal</span> hMenu <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> wIDEnableItem <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> wEnable <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
<span>Public</span> <span>Const</span> MF_UNCHECKED <span>=</span> <span>&amp;H0</span><span>&amp;</span>
<span>Public</span> <span>Const</span> MF_CHECKED <span>=</span> <span>&amp;H8</span><span>&amp;</span>
<span>Public</span> <span>Const</span> MF_DISABLED <span>=</span> <span>&amp;H2</span><span>&amp;</span>
<span>Public</span> <span>Const</span> MF_GRAYED <span>=</span> <span>&amp;H1</span><span>&amp;</span>
<span>Public</span> <span>Const</span> MF_ENABLED <span>=</span> <span>&amp;H0</span><span>&amp;</span>
<span>Private</span> <span>Declare</span> <span>Function</span> CallWindowProc <span>Lib</span> <span>"user32"</span> <span>Alias</span> <span>"CallWindowProcA"</span> <span>(</span><span>ByVal</span> lpPrevWndFunc <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> hwnd <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> Msg <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> wParam <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> lParam <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Declare</span> <span>Function</span> GetMenu <span>Lib</span> <span>"user32"</span> <span>(</span><span>ByVal</span> hwnd <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Declare</span> <span>Function</span> GetSubMenu <span>Lib</span> <span>"user32"</span> <span>(</span><span>ByVal</span> hMenu <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> nPos <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
<span>Private</span> <span>Const</span> MF_BYCOMMAND <span>=</span> <span>&amp;H0</span><span>&amp;</span>
<span>Public</span> <span>Function</span> MsgProcess<span>(</span><span>ByVal</span> hwnd <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> Msg <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> wParam <span>As</span> <span>Long</span><span>,</span> <span>ByVal</span> lParam <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
	<span>Dim</span> SubMenu_hWnd <span>As</span> <span>Long</span>
	<span>Select</span> <span>Case</span> wParam
		<span>Case</span> <span>100</span>
			MsgBox <span>"你选择的是""保存""按钮!"</span>
		<span>Case</span> <span>101</span>
			MsgBox <span>"你选择的是""备份""按钮!"</span>
		<span>Case</span> <span>102</span>
			Unload UserForm1
		<span>Case</span> <span>110</span>
			MsgBox <span>"你选择的是""录入""按钮!"</span>
		<span>Case</span> <span>111</span>
			MsgBox <span>"你选择的是""审核""按钮!"</span>
		<span>Case</span> <span>112</span>
			MsgBox <span>"你选择的是""记账""按钮!"</span>
		<span>Case</span> <span>113</span>
			MsgBox <span>"你选择的是""结账""按钮!"</span>
		<span>Case</span> <span>114</span>
			MsgBox <span>"你选择的是""资产负债表""按钮!"</span>
		<span>Case</span> <span>115</span>
			MsgBox <span>"你选择的是""损益表""按钮!"</span>
		<span>Case</span> <span>Else</span>
			MsgProcess <span>=</span> CallWindowProc<span>(</span>PreWinProc<span>,</span> hwnd<span>,</span> Msg<span>,</span> wParam<span>,</span> lParam<span>)</span>
	<span>End</span> <span>Select</span>
<span>End</span> <span>Function</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><p>代码解析：</p>
<p>第 1 行到第 13 行代码，API 函数声明。</p>
<p>第 14 行到第 36 行代码，MsgProcess 函数过程，根据参数 wParam 的值为窗体中的菜单指定所执行的操作，为了演示方便只使用 MsgBox 函数显示一个消息框，在实际应用中可以为菜单写入代码或指定过程名称。</p>
<p>运行窗体后在窗体上添加菜单，如图 148-1 所示。</p>
<div>
<p><img src="./assets/148-1.png" alt="" loading="lazy"></p>
<p><u>图 148-1</u>	用户窗体上添加菜单</p>
</div>
<h2 id="_149、在用户窗体上添加工具栏"> 149、在用户窗体上添加工具栏</h2>
<p>在 148 中我们在用户窗体上使用 API 函数添加了菜单，还可以在用户窗体上继续添加工具栏用以显示一列下拉菜单的位图按钮，单击一个工具栏按钮等于选择一个菜单命令，以提供对常用功能和命令的快速访问。</p>
<p>在用户窗体上添加工具栏可以使用 Toolbar 控件，在设计模式下右键单击“工具箱”，在显示的右键菜单中选择“附加控件”，在显示的对话框中选择“Microsoft Toolbar Control， veision 6.0”控件，在用户窗体上添加一个 Toolbar 控件。如图 149-1 所示。</p>
<div>
<p><img src="./assets/149-1.png" alt="" loading="lazy"></p>
<p><u>图 149-1</u>	选择 Toolbar 控件</p>
</div>
<p>因为需要在 Toolbar 控件按钮中使用图标，所以还需要在用户窗体中添加一个 ImageList 控件保存所需要的图像文件，在 ImageList 控件的属性页中插入 6 张图片，如图 149-2 所示。</p>
<div>
<p><img src="./assets/149-2.png" alt="" loading="lazy"></p>
<p><u>图 149-2</u>	ImageList 控件插入图片</p>
</div>
<p>用户窗体上添加了 Toolbar 控件后还需要设置其属性和添加按钮控件，可以在 Toolbar 控件的属性页中进行设置和添加，如图 149-3 所示。</p>
<div>
<p><img src="./assets/149-3.png" alt="" loading="lazy"></p>
<p><u>图 149-3</u>	设置 Toolbar 控件属性</p>
</div>
<p>还可以在代码运行时对其进行设置和添加按钮，双击用户窗体写入下面的代码：</p>
<div><pre><code><span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	……使用API函数添加菜单代码略，详见附件
	<span>Dim</span> arr <span>As</span> <span>Variant</span>
	<span>Dim</span> i <span>As</span> <span>Byte</span>
	arr <span>=</span> Array<span>(</span><span>" 录入 "</span><span>,</span> <span>" 审核"</span><span>,</span> <span>" 记账 "</span><span>,</span> <span>" 结账 "</span><span>,</span> <span>"负债表"</span><span>,</span> <span>"损益表"</span><span>)</span>
	<span>With</span> Toolbar1
		<span>.</span>ImageList <span>=</span> ImageList1
		<span>.</span>Appearance <span>=</span> ccFlat
		<span>.</span>BorderStyle <span>=</span> ccNone
		<span>.</span>TextAlignment <span>=</span> tbrTextAlignBottom
		<span>With</span> <span>.</span>Buttons
			<span>.</span>Add<span>(</span><span>1</span><span>,</span> <span>,</span> <span>""</span><span>)</span><span>.</span>Style <span>=</span> tbrPlaceholder
			<span>For</span> i <span>=</span> <span>0</span> <span>To</span> UBound<span>(</span>arr<span>)</span>
				<span>.</span>Add<span>(</span>i <span>+</span> <span>2</span><span>,</span> <span>,</span> <span>,</span> <span>,</span> i <span>+</span> <span>1</span><span>)</span><span>.</span>Caption <span>=</span> arr<span>(</span>i<span>)</span>
			<span>Next</span>
		<span>End</span> <span>With</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>代码解析：</p>
<p>第 5 行代码数组 arr 用来保存按钮的标题文字。</p>
<p>第 7 行代码建立 Toolbar 控件和 ImageList 控件的关联。</p>
<p>第 8 行代码设置 Toolbar 控件的外观效果，Appearance 属性获得或设置控件的外观效果，设置值如表格 149-1 所示。</p>
<p><u>表格 149-1</u>	Appearance 属性值</p>
<table>
<thead>
<tr>
<th>设置值</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ccFlat</td>
<td>0</td>
<td>平面</td>
</tr>
<tr>
<td>cc3D</td>
<td>1</td>
<td>立体</td>
</tr>
</tbody>
</table>
<p>第 9 行代码设置 Toolbar 控件的边界样式，BorderStyle 属性获得或设置边界样式，设置值如表格 149-2 所示。</p>
<p><u>表格 149-2</u>	BorderStyle 属性值</p>
<table>
<thead>
<tr>
<th>设置值</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ccNone</td>
<td>0</td>
<td>无边界线</td>
</tr>
<tr>
<td>ccFixedSingle</td>
<td>1</td>
<td>固定单线框</td>
</tr>
</tbody>
</table>
<p>第 10 行代码设置按钮文本显示在按钮图像下方，TextAlignment 属性获得或设置一个值，决定按钮文本显示在按钮图像下方还是右侧，设置值如表格 149-3 所示。</p>
<p><u>表格 149-3</u>	TextAlignment 属性值</p>
<table>
<thead>
<tr>
<th>设置值</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>tbrTextAlignBottom</td>
<td>0</td>
<td>下方</td>
</tr>
<tr>
<td>tbrTextAlignRight</td>
<td>1</td>
<td>右侧</td>
</tr>
</tbody>
</table>
<p>第 11 行到第 15 行代码在 Toolbar 控件中添加按钮，添加按钮需要在 Buttons 的集合对象中使用 Add 方法，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>Buttons<span>.</span>Add<span>(</span>index<span>,</span> key<span>,</span> caption<span>,</span> style<span>,</span> image<span>)</span>

参数<span>object</span>是必需的，代表Toolbar对象。
参数index是可选的，指定新增按钮的索引值，该索引值决定了按钮在Toolbar控件中的位置。如果省略index参数新增按钮添加到Butons集合的最后。
参数key是可选的，指定新增按钮的关键字。
参数caption是可选的，指定新增按钮的标题文本。
参数style是可选的，指定新增按钮的样式，设置值如表格 <span>149</span><span>-</span><span>1</span>所示。
参数image是可选的，指定新增按钮载入的图像，图像必须是与该Toolbar控件相关联的ImageList控件图像库中的一个。image参数可以是一个整数，对应ImageList图像库中某个图片的Index值也可以是一个字符串，对应图片的关键字Key。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><u>表格 149-4</u>	Style 参数值</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>tbrDefault</td>
<td>0</td>
<td>一般按钮</td>
</tr>
<tr>
<td>tbrCheck</td>
<td>1</td>
<td>开关按钮</td>
</tr>
<tr>
<td>tbrButtonGroup</td>
<td>2</td>
<td>编组按钮</td>
</tr>
<tr>
<td>tbrSeparator</td>
<td>3</td>
<td>分隔按钮</td>
</tr>
<tr>
<td>tbrPlaceholder</td>
<td>4</td>
<td>占位按钮</td>
</tr>
</tbody>
</table>
<p>第 12 行代码代码首先在 Toolbar 控件中添加占位按钮，设置其 style 属性为 tbrPlaceholder，添加的就是占位按钮，在 Toolbar 控件中是不显示的，仅仅起到占位的作用。</p>
<p>第 14 行代码在占位按钮后继续添加 6 个按钮，设置其标题文本和图像在 ImageList 控件中的编号。</p>
<p>为了响应 Toolbar 控件，双击 Toolbar 控件写入下面的代码：</p>
<div><pre><code><span>Private</span> <span>Sub</span> Toolbar1_ButtonClick<span>(</span><span>ByVal</span> Button <span>As</span> MSComctlLib<span>.</span>Button<span>)</span>
	<span>Select</span> <span>Case</span> Button<span>.</span>Index
		<span>Case</span> <span>2</span>
			MsgBox <span>"录入"</span>
		<span>Case</span> <span>3</span>
			MsgBox <span>"审核"</span>
		<span>Case</span> <span>4</span>
			MsgBox <span>"记账"</span>
		<span>Case</span> <span>5</span>
			MsgBox <span>"结账"</span>
		<span>Case</span> <span>6</span>
			MsgBox <span>"资产负债表"</span>
		<span>Case</span> <span>7</span>
			MsgBox <span>"损益表"</span>
	<span>End</span> <span>Select</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>代码解析：</p>
<p>Toolbar 控件的 ButtonClick 事件，在单击 Toolbar 控件的按钮时发生，参数 Button 代表单击的按钮。为了演示方便，根据其 Index 属性值使用消息框显示按钮标题文本，在实际应用中可以为菜单写入代码或指定过程名称。</p>
<p>运行窗体后在窗体上添加工具栏，如图 149-4 所示。</p>
<div>
<p><img src="./assets/149-4.png" alt="" loading="lazy"></p>
<p><u>图 149-4</u>	在用户窗体上添加工具栏</p>
</div>
<h2 id="_150、使用代码添加窗体及控件"> 150、使用代码添加窗体及控件</h2>
<p>VBA 中的用户窗体为用户提供了可视化的操作界面，在用户窗体中一般都包含控件以便与用户进行交互。我们通常是在 VBE 中使用菜单“插入”→“用户窗体”来创建用户窗体，然后拖动工具箱中的控件到用户窗体中，也可以使用代码来添加用户窗体及其控件，代码如下：</p>
<div><pre><code><span>Private</span> <span>Sub</span> CommandButton1_Click<span>(</span><span>)</span>
	<span>Dim</span> myForm <span>As</span> VBComponent
	<span>Dim</span> myTextBox <span>As</span> Control
	<span>Dim</span> myButton <span>As</span> Control
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>Set</span> myForm <span>=</span> ThisWorkbook<span>.</span>VBProject<span>.</span>VBComponents<span>.</span>Add<span>(</span>vbext_ct_MSForm<span>)</span>
	<span>With</span> myForm
		<span>.</span>Properties<span>(</span><span>"Name"</span><span>)</span> <span>=</span> <span>"Formtest"</span>
		<span>.</span>Properties<span>(</span><span>"Caption"</span><span>)</span> <span>=</span> <span>"演示窗体"</span>
		<span>.</span>Properties<span>(</span><span>"Height"</span><span>)</span> <span>=</span> <span>"180"</span>
		<span>.</span>Properties<span>(</span><span>"Width"</span><span>)</span> <span>=</span> <span>"240"</span>
		<span>Set</span> myTextBox <span>=</span> <span>.</span>Designer<span>.</span>Controls<span>.</span>Add<span>(</span><span>"Forms.CommandButton.1"</span><span>)</span>
		<span>With</span> myTextBox
			<span>.</span>Name <span>=</span> <span>"myTextBox"</span>
			<span>.</span>Caption <span>=</span> <span>"新建文本框"</span>
			<span>.</span>Top <span>=</span> <span>40</span>
			<span>.</span>Left <span>=</span> <span>138</span>
			<span>.</span>Height <span>=</span> <span>20</span>
			<span>.</span>Width <span>=</span> <span>70</span>
		<span>End</span> <span>With</span>
		<span>Set</span> myButton <span>=</span> <span>.</span>Designer<span>.</span>Controls<span>.</span>Add<span>(</span><span>"Forms.CommandButton.1"</span><span>)</span>
		<span>With</span> myButton
			<span>.</span>Name <span>=</span> <span>"myButton"</span>
			<span>.</span>Caption <span>=</span> <span>"删除文本框"</span>
			<span>.</span>Top <span>=</span> <span>70</span>
			<span>.</span>Left <span>=</span> <span>138</span>
			<span>.</span>Height <span>=</span> <span>20</span>
			<span>.</span>Width <span>=</span> <span>70</span>
		<span>End</span> <span>With</span>
		<span>With</span> <span>.</span>CodeModule
			i <span>=</span> <span>.</span>CreateEventProc<span>(</span><span>"Click"</span><span>,</span> <span>"myTextBox"</span><span>)</span>
			<span>.</span>ReplaceLine i <span>+</span> <span>1</span><span>,</span> Space<span>(</span><span>4</span><span>)</span> <span>&amp;</span> <span>"Dim myTextBox As Control"</span> <span>&amp;</span> Chr<span>(</span><span>10</span><span>)</span> <span>&amp;</span> Space<span>(</span><span>4</span><span>)</span> <span>&amp;</span> <span>"Dim i As Integer"</span> <span>&amp;</span> Chr<span>(</span><span>10</span><span>)</span> <span>&amp;</span> Space<span>(</span><span>4</span><span>)</span> <span>&amp;</span> <span>"Dim k As Integer"</span> <span>_</span>
				<span>&amp;</span> Chr<span>(</span><span>10</span><span>)</span> <span>&amp;</span> Space<span>(</span><span>4</span><span>)</span> <span>&amp;</span> <span>"k = 10"</span> <span>&amp;</span> Chr<span>(</span><span>10</span><span>)</span> <span>&amp;</span> Space<span>(</span><span>4</span><span>)</span> <span>&amp;</span> <span>"For i = 1 To 5"</span> <span>&amp;</span> Chr<span>(</span><span>10</span><span>)</span> <span>&amp;</span> Space<span>(</span><span>8</span><span>)</span> <span>&amp;</span> <span>"Set myTextBox = Me.Controls.Add(bstrprogid:=""Forms.TextBox.1"")"</span> <span>_</span>
				<span>&amp;</span> Chr<span>(</span><span>10</span><span>)</span> <span>&amp;</span> Space<span>(</span><span>8</span><span>)</span> <span>&amp;</span> <span>"With myTextBox"</span> <span>&amp;</span> Chr<span>(</span><span>10</span><span>)</span> <span>&amp;</span> Space<span>(</span><span>12</span><span>)</span> <span>&amp;</span> <span>".Name = ""myTextBox"" &amp; i"</span> <span>&amp;</span> Chr<span>(</span><span>10</span><span>)</span> <span>&amp;</span> Space<span>(</span><span>12</span><span>)</span> <span>&amp;</span> <span>".Left = 20"</span> <span>_</span>
				<span>&amp;</span> Chr<span>(</span><span>10</span><span>)</span> <span>&amp;</span> Space<span>(</span><span>12</span><span>)</span> <span>&amp;</span> <span>".Top = k"</span> <span>&amp;</span> Chr<span>(</span><span>10</span><span>)</span> <span>&amp;</span> Space<span>(</span><span>12</span><span>)</span> <span>&amp;</span> <span>".Height = 18"</span> <span>&amp;</span> Chr<span>(</span><span>10</span><span>)</span> <span>&amp;</span> Space<span>(</span><span>12</span><span>)</span> <span>&amp;</span> <span>".Width = 80"</span> <span>_</span>
				<span>&amp;</span> Chr<span>(</span><span>10</span><span>)</span> <span>&amp;</span> Space<span>(</span><span>12</span><span>)</span> <span>&amp;</span> <span>"k = .Top + 28"</span> <span>&amp;</span> Chr<span>(</span><span>10</span><span>)</span> <span>&amp;</span> Space<span>(</span><span>8</span><span>)</span> <span>&amp;</span> <span>"End With"</span> <span>&amp;</span> Chr<span>(</span><span>10</span><span>)</span> <span>&amp;</span> Space<span>(</span><span>4</span><span>)</span> <span>&amp;</span> <span>"Next"</span>
			i <span>=</span> <span>.</span>CreateEventProc<span>(</span><span>"Click"</span><span>,</span> <span>"myButton"</span><span>)</span>
			<span>.</span>ReplaceLine i <span>+</span> <span>1</span><span>,</span> Space<span>(</span><span>4</span><span>)</span> <span>&amp;</span> <span>"Dim i As Integer"</span> <span>&amp;</span> Chr<span>(</span><span>10</span><span>)</span> <span>&amp;</span> Space<span>(</span><span>4</span><span>)</span> <span>&amp;</span> <span>"On Error Resume Next"</span> <span>&amp;</span> Chr<span>(</span><span>10</span><span>)</span> <span>&amp;</span> Space<span>(</span><span>4</span><span>)</span> <span>&amp;</span> <span>"For i = 1 To 5"</span> <span>&amp;</span> Chr<span>(</span><span>10</span><span>)</span> <span>&amp;</span> Space<span>(</span><span>8</span><span>)</span> <span>&amp;</span> <span>"Formtest.Controls.Remove ""myTextBox"" &amp; i"</span> <span>&amp;</span> Chr<span>(</span><span>10</span><span>)</span> <span>&amp;</span> Space<span>(</span><span>4</span><span>)</span> <span>&amp;</span> <span>"Next"</span>
		<span>End</span> <span>With</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><p>代码解析：</p>
<p>使用代码添加一个用户窗体及其两个按钮控件，并为按钮控件添加单击事件及其相应的代码。</p>
<p>第 2 行到第 5 行代码声明变量类型，如果发生错误请在菜单“工具”→“引用”中引用“Microsoft Visual Basic for Applications Extensibility 5.3”，如图 150-1 所示。</p>
<div>
<p><img src="./assets/150-1.png" alt="" loading="lazy"></p>
<p><u>图 150-1</u>	引用</p>
</div>
<p>第 6 行代码，使用 Add 方法添加用户窗体，应用于 VBComponents 集合的 Add 方法将一个对象添加到集合，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>Add<span>(</span>component<span>)</span>

参数<span>object</span>是必需的，一个有效的对象名。
参数component是必需的，对于VBComponents集合，则为表示类模块、窗体、标准模块的列举常数，可以为表格 <span>150</span><span>1</span>所示的常量之一。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><u>表格 150-1</u>	component 参数值</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>vbext_ct_ClassModule</td>
<td>2</td>
<td>将一个类模块添加到集合</td>
</tr>
<tr>
<td>Vbext_ct_MSForm</td>
<td>3</td>
<td>将窗体添加到集合</td>
</tr>
<tr>
<td>vbext_ct_StdModule</td>
<td>1</td>
<td>将标准模块添加到集合</td>
</tr>
</tbody>
</table>
<p>第 8 行到第 11 行代码，使用 VBComponent 对象的 Properties 属性设置用户窗体的相关属性。</p>
<p>第 12 行代码，使用 Add 方法添加在用户窗体上添加一个按钮控件。VBComponent 对象的 Designer 属性返回一个设计器对象，其 Controls 属性返回 Controls 集合，代表用户窗体中所有的控件。应用于 Controls 集合对象的 Add 方法在用户窗体中添加控件，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>Add<span>(</span> ProgID [<span>,</span> Name [<span>,</span> Visible]]<span>)</span>

参数<span>object</span>是必需的，一个有效的对象名。
参数ProgID是必需的，程序设计标识符。是用于标识对象类的、没有空格的文本串。关于程序设计标识符请参阅技巧<span>119</span><span>-</span><span>3</span>中的表格 <span>119</span><span>1</span>。
参数Name是可选的，指定被添加的对象的名称。
参数Visible是可选的，若对象为可见的为<span>True</span>，若对象为隐藏的则为<span>False</span>。默认值为<span>True</span>。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>第 13 行到第 20 行代码设置添加的按钮控件的相关属性。</p>
<p>第 21 行到第 29 行代码继续添加一个按钮控件并设置其相关属性。</p>
<p>第 30 行到第 40 行代码为添加的按钮控件创建单击事件过程并在其单击事件中添加代码。</p>
<p>其中第 30、39 行代码使用 CreateEventProc 方法为按钮控件创建单击事件过程，应用于 CodeModule 对象的 CreateEventProc 方法创建一个事件过程，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>CreateEventProc<span>(</span>eventname<span>,</span> objectname<span>)</span> <span>As</span> <span>Long</span>

参数<span>object</span>是必需的，一个有效的对象名。
参数eventname是必需的，字符串表达式，用来指定欲添加到模块的事件名称。
参数objectname是必需的，字符串表达式，用来指定事件源的对象名称。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>CreateEventProc 方法可返回事件过程的开始行，所以使用变量i保存开始行。</p>
<p>第 32 行代码使用 ReplaceLine 方法在按钮控件的单击事件过程中添加代码，应用于CodeModule对象的 ReplaceLine 方法用特定的代码代替原代码，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>ReplaceLine<span>(</span>line<span>,</span> code<span>)</span>

参数<span>object</span>是必需的，一个有效的对象名。
参数line是必需的，用来指定所要代替的行。
参数code是必需的，用来指定要插入的代码。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>在使用 ReplaceLine 方法时将 line 参数设置为变量i加 1，也就是在单击事件过程的第 2 行开始添加代码，在添加代码时使用 Space 函数插入空格，使用 Chr 函数进行换行。</p>
<p>运行 CommandButton1_Click 过程，添加一个用户窗体及两个按钮控件，并在用户窗体中添加以下的代码：</p>
<div><pre><code><span>Private</span> <span>Sub</span> myTextBox_Click<span>(</span><span>)</span>
	<span>Dim</span> myTextBox <span>As</span> Control
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>Dim</span> k <span>As</span> <span>Integer</span>
	k <span>=</span> <span>10</span>
	<span>For</span> i <span>=</span> <span>1</span> <span>To</span> <span>5</span>
		<span>Set</span> myTextBox <span>=</span> <span>Me</span><span>.</span>Controls<span>.</span>Add<span>(</span><span>"Forms.TextBox.1"</span><span>)</span>
		<span>With</span> myTextBox
			<span>.</span>Name <span>=</span> <span>"myTextBox"</span> <span>&amp;</span> i
			<span>.</span>Left <span>=</span> <span>20</span>
			<span>.</span>Top <span>=</span> k
			<span>.</span>Height <span>=</span> <span>18</span>
			<span>.</span>Width <span>=</span> <span>80</span>
			k <span>=</span> <span>.</span>Top <span>+</span> <span>28</span>
		<span>End</span> <span>With</span>
	<span>Next</span>
<span>End</span> <span>Sub</span>
<span>Private</span> <span>Sub</span> myButton_Click<span>(</span><span>)</span>
	<span>Dim</span> i <span>As</span> <span>Integer</span>
	<span>On</span> <span>Error</span> <span>Resume</span> <span>Next</span>
	<span>For</span> i <span>=</span> <span>1</span> <span>To</span> <span>5</span>
		Formtest<span>.</span>Controls<span>.</span>Remove <span>"myTextBox"</span> <span>&amp;</span> i
	<span>Next</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>代码解析：</p>
<p>第 1 行到第 17 行代码，用户窗体中“添加文本框”按钮的单击事件，在用户窗体运行时使用 Add 方法在用户窗体中添加5个文本框控件并设置其相关属性。</p>
<p>第 18 行到第 24 行代码，用户窗体中“删除文本框”按钮的单击事件，在用户窗体运行时使用 Remove 方法删除文本框控件。应用于 Controls 集合的 Remove 方法从集合中删除一个成员，或者从框架、页面或窗体中删除一个控件，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>Remove<span>(</span> collectionindex<span>)</span>

参数<span>object</span>是必需的，一个有效的对象名。
参数collectionindex是必需的，成员在集合内的位置或索引。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><p>注意</p>
<p>Remove 方法只能删除在运行时间添加的控件，如果想删除在设计时间添加的控件则会出错。</p>
</div>
<p>运行 CommandButton1_Click 过程添加的用户窗体如图 150-2 所示。</p>
<div>
<p><img src="./assets/150-2.png" alt="" loading="lazy"></p>
<p><u>图 150-2</u>	添加的用户窗体</p>
</div>
<p>单击“新建文本框”按钮在用户窗体中添加5个文本框控件，如图 150-3 所示，而单击“删除文本框”按钮则删除用户窗体中添加的文本框控件。</p>
<div>
<p><img src="./assets/150-3.png" alt="" loading="lazy"></p>
<p><u>图 150-3</u>	在用户窗体上添加文本框</p>
</div>
<h2 id="_151、用户窗体的全屏显示"> 151、用户窗体的全屏显示</h2>
<p>在需要用户窗体全屏显示时，可以将窗体的 Height 属性和 Width 属性设置为一定的数值，使之显示时和显示器一样大小。</p>
<p>使用这种方法虽然可以达到全屏显示的要求，但是如果换台显示器不一样的电脑时，此种方法便会失效。为了使用户窗体达到真正的全屏显示，可以使用以下的方法。</p>
<h3 id="_1-设置用户窗体为应用程序的大小"> 1）设置用户窗体为应用程序的大小</h3>
<p>将用户窗体的高度和宽度设置为应用程序的高度和宽度，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	Application<span>.</span>WindowState <span>=</span> xlMaximized
	<span>With</span> <span>Me</span>
		<span>.</span>Width <span>=</span> Application<span>.</span>Width
		<span>.</span>Height <span>=</span> Application<span>.</span>Height
		<span>.</span>Left <span>=</span> Application<span>.</span>Left
		<span>.</span>Top <span>=</span> Application<span>.</span>Top
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>代码解析：</p>
<p>用户窗体初始化时，将高度和宽度设置成与 Excel 应用程序窗口一样。</p>
<p>第 2 行代码，将 Excel 应用程序的 WindowState 属性设置为 xlMaximized，使 Excel 应用程序最大化显示。</p>
<p>不使用对象识别符时 Application 属性返回一个 Application 对象，代表 Excel 应用程序。WindowState 属性返回或设置窗口的状态，可以为表格 151-1 所示的 XlWindowState 常量之一。</p>
<p><u>表格 151-1</u>	XlWindowState 常量</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>xlMaximized</td>
<td>-4137</td>
<td>最大化</td>
</tr>
<tr>
<td>xlNormal</td>
<td>-4143</td>
<td>不变化</td>
</tr>
<tr>
<td>xlMinimized</td>
<td>-4140</td>
<td>最小化</td>
</tr>
</tbody>
</table>
<p>第 3 行到第 8 行代码将用户窗体的 Width 属性、Height 属性设置为 Excel 应用程序的高度和宽度，Width 属性、Height 属性以磅为单位返回或设置对象的高度和宽度。将用户窗体的 Left 属性、Top 属性设置为和最大化后的 Excel 应用程序的一样。</p>
<h3 id="_2-根据屏幕分辨率进行设置"> 2）根据屏幕分辨率进行设置</h3>
<p>根据屏幕分辨率的大小自动调整用户窗体的高度和宽度，如下面的代码所示。</p>
<div><pre><code><span>Private</span> <span>Declare</span> <span>Function</span> GetSystemMetrics <span>Lib</span> <span>"user32"</span> <span>(</span><span>ByVal</span> nIndex <span>As</span> <span>Long</span><span>)</span> <span>As</span> <span>Long</span>
<span>Const</span> SM_CXSCREEN <span>As</span> <span>Long</span> <span>=</span> <span>0</span>
<span>Const</span> SM_CYSCREEN <span>As</span> <span>Long</span> <span>=</span> <span>1</span>
<span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	<span>With</span> <span>Me</span>
		<span>.</span>Height <span>=</span> GetSystemMetrics<span>(</span>SM_CYSCREEN<span>)</span> <span>*</span> <span>0.72</span> 
		<span>.</span>Width <span>=</span> GetSystemMetrics<span>(</span>SM_CXSCREEN<span>)</span> <span>*</span> <span>0.75</span>
		<span>.</span>Left <span>=</span> <span>0</span>
		<span>.</span>Top <span>=</span> <span>0</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>代码解析：</p>
<p>用户窗体初始化时根据屏幕分辨率的大小自动调整用户窗体的高度和宽度。</p>
<p>第 1 行到第 3 行代码，API 函数声明。</p>
<p>第 6 行代码设置用户窗体的高度，屏幕分辨率的Y坐标值乘以 0.72 将其换算成以磅为单位的数值。</p>
<p>第 7 行代码设置用户窗体的宽度，屏幕分辨率的X坐标值乘以 0.75 将其换算成以磅为单位的数值。</p>
<p>经过以上两种方法的设置，用户窗体显示时始终以全屏显示。</p>
<h2 id="_152、在用户窗体上添加状态栏"> 152、在用户窗体上添加状态栏</h2>
<p>在 148 、 149 中我们在用户窗体上添加了菜单和工具栏，为了使窗体更像正规的软件，还需要在用户窗体的底部添加一个状态栏，用于显示程序的各种状态信息。</p>
<p>在用户窗体上添加状态栏使用 StatusBar 控件，StatusBar 控件用于设计窗体状态栏，状态栏由一组连续的窗格（最多 16 个）对象组合而成，用于显示应用程序当前的工作状态，其位置通常在应用程序窗体的底部。在设计模式下右键单击“工具箱”，在显示的右键菜单中选择“附加控件”，在显示的对话框中选择“Microsoft StatusBar Control， veision 6.0”控件如图 152-1 所示，拖动后就可以在用户窗体上添加一个 StatusBar 控件。</p>
<div>
<p><img src="./assets/152-1.png" alt="" loading="lazy"></p>
<p><u>图 152-1</u>	选择 StatusBar 控件</p>
</div>
<p>在用户窗体上添加了 StatusBar 控件后还需要添加窗格，可以在 StatusBar 控件的属性页中进行设置和添加，在 StatusBar 控件的属性窗口中选择“自定义”按钮，在显示的属性页中设置属性和添加窗格，如图 152-2 所示。</p>
<div>
<p><img src="./assets/152-2.png" alt="" loading="lazy"></p>
<p><u>图 152-2</u>	添加 StatusBar 控件的窗格</p>
</div>
<p>也可以在代码运行时对其进行属性设置和添加窗格，双击用户窗体写入下面的代码：</p>
<div><pre><code><span>Private</span> <span>Sub</span> UserForm_Initialize<span>(</span><span>)</span>
	……使用API函数添加菜单代码略，详见附件。
	<span>Dim</span> arr <span>As</span> <span>Variant</span>
	<span>Dim</span> i <span>As</span> <span>Byte</span>
	……使用Toolbar控件添加工具栏代码略，详见附件。
	arr <span>=</span> Array<span>(</span><span>0</span><span>,</span> <span>6</span><span>,</span> <span>5</span><span>)</span>
	<span>With</span> StatusBar1
		<span>.</span>Width <span>=</span> <span>Me</span><span>.</span>Width <span>-</span> <span>10</span>
		<span>For</span> i <span>=</span> <span>1</span> <span>To</span> <span>3</span>
			<span>.</span>Panels<span>.</span>Add<span>(</span>i<span>,</span> <span>,</span> <span>""</span><span>)</span><span>.</span>Style <span>=</span> arr<span>(</span>i <span>-</span> <span>1</span><span>)</span>
		<span>Next</span>
		<span>.</span>Panels<span>(</span><span>1</span><span>)</span><span>.</span>Text <span>=</span> <span>"准备就绪!"</span>
		<span>.</span>Panels<span>(</span><span>2</span><span>)</span><span>.</span>Width <span>=</span> <span>60</span>
		<span>.</span>Panels<span>(</span><span>3</span><span>)</span><span>.</span>Width <span>=</span> <span>75</span>
		<span>.</span>Panels<span>(</span><span>1</span><span>)</span><span>.</span>Width <span>=</span> <span>Me</span><span>.</span>Width <span>-</span> <span>.</span>Panels<span>(</span><span>1</span><span>)</span><span>.</span>Width <span>-</span> <span>.</span>Panels<span>(</span><span>2</span><span>)</span><span>.</span>Width
		<span>.</span>Panels<span>(</span><span>3</span><span>)</span><span>.</span>Picture <span>=</span> LoadPicture<span>(</span>ThisWorkbook<span>.</span>Path <span>&amp;</span> <span>"\123.BMP"</span><span>)</span>
		<span>For</span> i <span>=</span> <span>0</span> <span>To</span> <span>2</span>
			<span>.</span>Panels<span>(</span>i <span>+</span> <span>1</span><span>)</span><span>.</span>Alignment <span>=</span> i
		<span>Next</span>
	<span>End</span> <span>With</span>
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>代码解析：</p>
<p>第 8 行代码设置 StatusBar 控件的宽度比用户窗体略小一点。</p>
<p>第 9 行到第 11 行代码在 StatusBar 控件中添加三个窗格并指定窗格的样式。添加窗格需要在 Panels 集合对象中使用 Add 方法，语法如下：</p>
<div><pre><code><span>object</span><span>.</span>Panels<span>.</span>Add<span>(</span>index<span>,</span> key<span>,</span> text<span>,</span> style<span>,</span> picture<span>)</span>

参数<span>object</span>是必需的，代表StatusBar对象。
参数index是可选的，指定新增窗格的索引值，该索引值决定了窗格在StatusBar控件中的位置。如果省略index参数新增窗格添加到Panels集合的最后。
参数key是可选的，指定新增窗格的关键字。
参数text是可选的，指定新增窗格中显示的文本。
参数style是可选的，指定新增窗格的样式，设置值如表格 <span>152</span><span>-</span><span>1</span>所示。
参数picture是可选的，指定新增窗格载入的图像。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><u>表格 152-1</u>	Style 参数值</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sbrText</td>
<td>0</td>
<td>显示文本与图形</td>
</tr>
<tr>
<td>sbrCaps</td>
<td>1</td>
<td>显示大小写状态</td>
</tr>
<tr>
<td>sbrNum</td>
<td>2</td>
<td>显示numlock键状态</td>
</tr>
<tr>
<td>sbrIns</td>
<td>3</td>
<td>显示Insert状态</td>
</tr>
<tr>
<td>sbrScrl</td>
<td>4</td>
<td>显示Scroll键状态</td>
</tr>
<tr>
<td>sbrtime</td>
<td>5</td>
<td>按系统格式显示时间</td>
</tr>
<tr>
<td>sbrDate</td>
<td>6</td>
<td>按系统格式显示日期</td>
</tr>
</tbody>
</table>
<p>第 12 行代码设置第一个窗格显示的文本。</p>
<p>第 13 行到第 15 行代码设置三个窗格的宽度。</p>
<p>第 16 行代码为第三个窗格加载指定的图像。</p>
<p>第 17 行到第 19 行代码设置三个窗格中文本的对齐方式。Panels 对象的 Alignment 属性返回或设置窗格中文本的对齐方式，设置值如表格 152-2 所示。</p>
<p><u>表格 152-2</u>	Alignment 属性值</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sbrLeft</td>
<td>0</td>
<td>文本左对齐</td>
</tr>
<tr>
<td>sbrCenter</td>
<td>1</td>
<td>文本居中对齐</td>
</tr>
<tr>
<td>sbrRight</td>
<td>3</td>
<td>文本右对齐</td>
</tr>
</tbody>
</table>
<p>在示例中使用 StatusBar 控件的第一个窗格在用户窗体的文本框输入时显示所输入的内容，需要在文本框中写入下面的代码。</p>
<div><pre><code><span>Private</span> <span>Sub</span> TextBox1_Change<span>(</span><span>)</span>
	StatusBar1<span>.</span>Panels<span>(</span><span>1</span><span>)</span><span>.</span>Text <span>=</span> <span>"正在录入:"</span> <span>&amp;</span> TextBox1<span>.</span>Text
<span>End</span> <span>Sub</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码解析：</p>
<p>文本框的 Change 事件过程，将文本框中输入的内容显示在 StatusBar 控件的第一个窗格中。</p>
<p>运行窗体后在窗体上添加状态栏，如图 152-3 所示。</p>
<div>
<p><img src="./assets/152-3.png" alt="" loading="lazy"></p>
<p><u>图 152-3</u>	在用户窗体上添加状态栏</p>
</div>
]]></content>
    <author>
      <name>karin</name>
    </author>
    <contributor>
      <name>karin</name>
    </contributor>
    <published>2021-07-02T00:00:00.000Z</published>
    <rights>Copyright by karin</rights>
  </entry>
</feed>